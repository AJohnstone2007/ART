(* gcdReductionOutput.art - gcd reduction rules extended to support output *)

!traceLevel 2

!configuration -> _sig::__map, _alpha::__list

-assign  _n |> __int32(_)      --- assign(_X,_n),_sig, _alpha -> __done,__put(_sig,_X,_n), _alpha
-assignR _E,_sig, _alpha -> _I, _sigP, _alphaP --- assign(_X,_E),_sig, _alpha -> assign(_X,_I),_sigP, _alphaP

-deref --- deref(_R), _sig, _alpha -> __get(_sig, _R), _sig, _alpha

-sequenceDone                      --- seq(__done, _C), _sig, _alpha -> _C,_sig, _alpha
-sequence _C1,_sig, _alpha -> _C1P, _sigP, _alphaP --- seq(_C1,_C2),_sig, _alpha -> seq(_C1P,_C2), _sigP, _alphaP

-ifTrue                          --- if(true,_C1,_C2), _sig, _alpha -> _C1, _sig, _alpha
-ifFalse                         --- if(false,_C1,_C2), _sig, _alpha -> _C2, _sig, _alpha
-ifResolve _E,_sig, _alpha ->_EP,_sigP, _alphaP --- if(_E,_C1,_C2),_sig, _alpha -> if(_EP,_C1,_C2),_sigP, _alphaP

-while --- while(_E,_C), _sig, _alpha -> if(_E,seq(_C,while(_E,_C)),__done), _sig, _alpha

-gt  _n1 |> __int32(_)  _n2 |> __int32(_)     --- gt(_n1,_n2), _sig, _alpha  ->  __gt(_n1,_n2),_sig, _alpha 
-gtR _n |> __int32(_)  _E2,_sig, _alpha -> _I2,_sigP, _alphaP --- gt(_n,_E2), _sig, _alpha   -> gt(_n,_I2),_sigP, _alphaP
-gtL _E1,_sig, _alpha -> _I1,_sigP, _alphaP                   --- gt(_E1,_E2),_sig, _alpha  -> gt(_I1,_E2),_sigP, _alphaP

-ne  _n1 |> __int32(_) _n2 |> __int32(_)      --- ne(_n1,_n2),_sig, _alpha  -> __ne(_n1,_n2),_sig, _alpha
-neR _n |> __int32(_)  _E2, _sig, _alpha -> _I2,_sigP, _alphaP --- ne(_n,_E2), _sig, _alpha  -> ne(_n,_I2), _sigP, _alphaP
-neL _E1,_sig, _alpha -> _I1, _sigP, _alphaP                    --- ne(_E1,_E2), _sig, _alpha  -> ne(_I1,_E2), _sigP, _alphaP

-sub  _n1 |> __int32(_) _n2 |> __int32(_)     --- sub(_n1,_n2), _sig, _alpha -> __sub(_n1,_n2), _sig, _alpha
-subR _n |> __int32(_) _E2,_sig, _alpha -> _I2,_sigP, _alphaP --- sub(_n,_E2),_sig, _alpha  -> sub(_n,_I2),_sigP, _alphaP
-subL _E1, _sig, _alpha -> _I1,_sigP, _alphaP                  --- sub(_E1,_E2),_sig, _alpha -> sub(_I1,_E2),_sigP, _alphaP

-print _n |> __int32(_)  --- print(_n), _sig, _alpha -> __done, _sig, __put(_alpha, _n)
-printR _E, _sig, _alpha -> _I, _sigP, _alphaP --- print(_E), _sig, _alpha -> print(_I), _sigP, _alphaP
  

seq ::= statement^^ | statement seq 
statement ::= assign^^ | while^^ | if^^ | print^^
assign ::= &ID ':='^ expression ';'^
while ::= 'while'^ expression 'do'^ statement
if ::= 'if'^ expression 'then'^ statement | 'if'^ expression 'then'^ statement 'else'^ statement
print ::= 'print'^ expression ';'^
expression ::= rels^^
rels ::= adds^^ | gt^^ | ne^^
  gt ::= adds '>'^ adds
  ne ::= adds '!='^ adds 
adds  ::= operand^^ | sub^^ | add^^
  add ::= adds '+'^ operand
  sub ::= adds '-'^ operand
operand ::= __int32^^ | deref^^
__int32 ::= &INTEGER
deref ::= &ID

!print "Try with internal syntax term"
!try seq(assign(a, 6), seq(assign(b, 9), seq(while(ne(deref(a), deref(b)), if(gt(deref(a), deref(b)), assign(a, sub(deref(a), deref(b))), assign(b, sub(deref(b), deref(a))))), print(deref(b))))), __map, __list
!print "Try with external syntax"
!try "a := 6; b := 9; while a != b do if a > b then a := a - b; else b := b - a; print b;"
