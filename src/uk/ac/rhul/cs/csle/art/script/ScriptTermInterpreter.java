package uk.ac.rhul.cs.csle.art.script;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.PrintStream;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Scanner;

import uk.ac.rhul.cs.csle.art.cfg.ParserBase;
import uk.ac.rhul.cs.csle.art.cfg.cfgRules.CFGKind;
import uk.ac.rhul.cs.csle.art.cfg.cfgRules.CFGRules;
import uk.ac.rhul.cs.csle.art.cfg.cfgRules.GIFTKind;
import uk.ac.rhul.cs.csle.art.cfg.chart.AlgX;
import uk.ac.rhul.cs.csle.art.cfg.chart.CYK;
import uk.ac.rhul.cs.csle.art.cfg.gll.GLLBaseLine;
import uk.ac.rhul.cs.csle.art.cfg.gll.GLLHashPool;
import uk.ac.rhul.cs.csle.art.cfg.lexer.LexemeKind;
import uk.ac.rhul.cs.csle.art.cfg.lexer.LexerSingletonLongestMatch;
import uk.ac.rhul.cs.csle.art.cfg.rdsob.RDSOBExplicitStack;
import uk.ac.rhul.cs.csle.art.cfg.rdsob.RDSOBFunction;
import uk.ac.rhul.cs.csle.art.cfg.rdsob.RDSOBGenerator;
import uk.ac.rhul.cs.csle.art.choose.ChooseRules;
import uk.ac.rhul.cs.csle.art.term.AttributeActionInterpreter;
import uk.ac.rhul.cs.csle.art.term.AttributeGrammarInterpreter;
import uk.ac.rhul.cs.csle.art.term.ITerms;
import uk.ac.rhul.cs.csle.art.term.InterpreterBase;
import uk.ac.rhul.cs.csle.art.term.Rewriter;
import uk.ac.rhul.cs.csle.art.term.TRRules;
import uk.ac.rhul.cs.csle.art.term.TermTraverser;
import uk.ac.rhul.cs.csle.art.term.TermTraverserText;
import uk.ac.rhul.cs.csle.art.term.eSOSInterpreter;
import uk.ac.rhul.cs.csle.art.util.Util;

public class ScriptTermInterpreter {
  public final ITerms iTerms;

  // Bootstrap parser term generated by parsing ATScriptSpecification.art: when grammar changes, paste new term here
//@formatter:off
//  private final String scriptParserTermString = "rules(directive(whitespace(cfgBuiltinTerminal(SIMPLE\\_WHITESPACE), cfgBuiltinTerminal(COMMENT\\_NEST\\_ART), cfgBuiltinTerminal(COMMENT\\_LINE\\_C))), cfgRule(cfgLHS(rules), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(rule), cfgSlot, cfgFoldUnder(cfgNonterminal(rules)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(rule), cfgSlot))), cfgRule(cfgLHS(rule), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgRule)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(trRule)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(chooseRule)), cfgSlot), cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(!)), cfgSlot, cfgFoldOver(cfgNonterminal(directive)), cfgSlot))), cfgRule(cfgLHS(cfgRule), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgLHS), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\:\\:=)), cfgSlot, cfgNonterminal(cfgAlts), cfgSlot))), cfgRule(cfgLHS(cfgLHS), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(ID), cfgSlot))), cfgRule(cfgLHS(cfgAlts), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgAlt), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(|)), cfgSlot, cfgFoldUnder(cfgNonterminal(cfgAlts)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgAlt), cfgSlot))), cfgRule(cfgLHS(cfgAlt), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgSeq)), cfgSlot, cfgNonterminal(cfgActions), cfgSlot, cfgNonterminal(cfgEpsilonCarrier), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgSeq)), cfgSlot, cfgNonterminal(cfgActions), cfgSlot, cfgNonterminal(cfgEpsilon), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgSeq)), cfgSlot, cfgFoldUnder(cfgNonterminal(cfgElems)), cfgSlot, cfgNonterminal(cfgActions), cfgSlot))), cfgRule(cfgLHS(cfgEpsilonCarrier), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgEpsilon), cfgSlot, cfgFoldOver(cfgNonterminal(cfgAnnotation)), cfgSlot))), cfgRule(cfgLHS(cfgEpsilon), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(#)), cfgSlot))), cfgRule(cfgLHS(cfgAltNoAction), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgSeq)), cfgSlot, cfgNonterminal(cfgSlot), cfgSlot, cfgNonterminal(cfgName), cfgSlot, cfgNonterminal(cfgSlot), cfgSlot))), cfgRule(cfgLHS(cfgElems), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgActions), cfgSlot, cfgNonterminal(cfgExtended), cfgSlot, cfgFoldUnder(cfgNonterminal(cfgElems)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgActions), cfgSlot, cfgNonterminal(cfgExtended), cfgSlot))), cfgRule(cfgLHS(cfgExtended), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgName), cfgSlot, cfgFoldOver(cfgNonterminal(cfgAnnotation)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgName)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgOptional)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgKleene)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgPositive)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgDoFirst)), cfgSlot))), cfgRule(cfgLHS(cfgAnnotation), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgFoldUnder)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgFoldOver)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgFoldTear)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgFoldTearNamed)), cfgSlot))), cfgRule(cfgLHS(cfgFoldUnder), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(^)), cfgSlot))), cfgRule(cfgLHS(cfgFoldOver), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(^^)), cfgSlot))), cfgRule(cfgLHS(cfgFoldTear), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(^^^)), cfgSlot))), cfgRule(cfgLHS(cfgFoldTearNamed), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(^^^)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\:)), cfgSlot, cfgNonterminal(ID), cfgSlot))), cfgRule(cfgLHS(cfgDoFirst), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\()), cfgSlot, cfgNonterminal(cfgAlts), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\))), cfgSlot))), cfgRule(cfgLHS(cfgOptional), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\()), cfgSlot, cfgNonterminal(cfgAlts), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\))), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(?)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgAltNoAction), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(?)), cfgSlot))), cfgRule(cfgLHS(cfgPositive), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\()), cfgSlot, cfgNonterminal(cfgAlts), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\))), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(+)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgAltNoAction), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(+)), cfgSlot))), cfgRule(cfgLHS(cfgKleene), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\()), cfgSlot, cfgNonterminal(cfgAlts), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\))), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\*)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgAltNoAction), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\*)), cfgSlot))), cfgRule(cfgLHS(cfgName), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgPrim)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgPrim), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\:)), cfgSlot, cfgNonterminal(ID), cfgSlot))), cfgRule(cfgLHS(cfgPrim), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgNonterminal)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgCaseSensitiveTerminal)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgCaseInsensitiveTerminal)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgBuiltinTerminal)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgCharacterTerminal)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgCharacterRangeTerminal)), cfgSlot))), cfgRule(cfgLHS(cfgNonterminal), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(ID), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(STRING\\_DOLLAR), cfgSlot))), cfgRule(cfgLHS(cfgCaseSensitiveTerminal), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(STRING\\_PLAIN\\_SQ), cfgSlot))), cfgRule(cfgLHS(cfgCaseInsensitiveTerminal), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(STRING\\_DQ), cfgSlot))), cfgRule(cfgLHS(cfgBuiltinTerminal), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(&)), cfgSlot, cfgNonterminal(ID), cfgSlot))), cfgRule(cfgLHS(cfgCharacterTerminal), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(CHAR\\_BQ), cfgSlot))), cfgRule(cfgLHS(cfgCharacterRangeTerminal), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgRange), cfgSlot))), cfgRule(cfgLHS(cfgRange), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(CHAR\\_BQ), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(..)), cfgSlot, cfgNonterminal(CHAR\\_BQ), cfgSlot))), cfgRule(cfgLHS(cfgActions), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgSlot)), cfgSlot, cfgFoldUnder(cfgNonterminal(cfgActionSeq)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgSlot)), cfgSlot))), cfgRule(cfgLHS(cfgActionSeq), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgAction), cfgSlot, cfgFoldUnder(cfgNonterminal(cfgActionSeq)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgAction), cfgSlot))), cfgRule(cfgLHS(cfgAction), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgEquation)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgAssignment)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgInsert)), cfgSlot))), cfgRule(cfgLHS(cfgEquation), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgAttribute), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(=)), cfgSlot, cfgNonterminal(cfgExpression), cfgSlot))), cfgRule(cfgLHS(cfgAssignment), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgAttribute), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\:=)), cfgSlot, cfgNonterminal(cfgExpression), cfgSlot))), cfgRule(cfgLHS(cfgInsert), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(^+\\:)), cfgSlot, cfgNonterminal(ID), cfgSlot))), cfgRule(cfgLHS(cfgAttribute), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(ID), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(ID), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(.)), cfgSlot, cfgNonterminal(ID), cfgSlot))), cfgRule(cfgLHS(cfgExpression), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(\\_\\_bool)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(\\_\\_int32)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(\\_\\_real64)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(\\_\\_string)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(\\_\\_char)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgAttribute)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(ID)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(ID)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\()), cfgSlot, cfgFoldUnder(cfgNonterminal(cfgExpressionList)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\))), cfgSlot))), cfgRule(cfgLHS(cfgExpressionList), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgExpression), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgExpression), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\,)), cfgSlot, cfgFoldUnder(cfgNonterminal(cfgExpressionList)), cfgSlot))), cfgRule(cfgLHS(cfgSeq), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgEpsilon)))), cfgRule(cfgLHS(cfgSlot), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgEpsilon)))), cfgRule(cfgLHS(trRule), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(trLabel), cfgSlot, cfgNonterminal(tr), cfgSlot))), cfgRule(cfgLHS(trLabel), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgEpsilon)), cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(-)), cfgSlot, cfgNonterminal(ID), cfgSlot))), cfgRule(cfgLHS(tr), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(trPremises), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(---)), cfgSlot, cfgNonterminal(trTransition), cfgSlot))), cfgRule(cfgLHS(trPremises), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgEpsilon)), cfgSeq(cfgSlot, cfgNonterminal(trMatch), cfgSlot, cfgFoldUnder(cfgNonterminal(trPremises)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(trTransition), cfgSlot, cfgFoldUnder(cfgNonterminal(trPremises)), cfgSlot))), cfgRule(cfgLHS(trMatch), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(trTopTuple), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(|>)), cfgSlot, cfgNonterminal(trTopTuple), cfgSlot))), cfgRule(cfgLHS(trTransition), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(trTopTuple), cfgSlot, cfgFoldUnder(cfgNonterminal(trRelation)), cfgSlot, cfgNonterminal(trTopTuple), cfgSlot))), cfgRule(cfgLHS(trTopTuple), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(trTerm), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(trTuple)), cfgSlot, cfgFoldUnder(cfgNonterminal(terms)), cfgSlot))), cfgRule(cfgLHS(trTuple), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgEpsilon)))), cfgRule(cfgLHS(terms), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(trTerm), cfgSlot, cfgFoldUnder(cfgNonterminal(termsTail)), cfgSlot))), cfgRule(cfgLHS(termsTail), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\,)), cfgSlot, cfgNonterminal(trTerm), cfgSlot), cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\,)), cfgSlot, cfgNonterminal(trTerm), cfgSlot, cfgFoldUnder(cfgNonterminal(termsTail)), cfgSlot))), cfgRule(cfgLHS(trTerm), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(\\_\\_bool)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(\\_\\_int32)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(\\_\\_real64)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(\\_\\_string)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(\\_\\_char)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(list)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(\\_\\_map)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(ID)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(IDSTAR)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(ID)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\()), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\))), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(ID)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\()), cfgSlot, cfgNonterminal(trTerm), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\))), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(ID)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\()), cfgSlot, cfgFoldUnder(cfgNonterminal(terms)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\))), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(trTuple)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(<)), cfgSlot, cfgFoldUnder(cfgNonterminal(terms)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(>)), cfgSlot))), cfgRule(cfgLHS(list), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal([)), cfgSlot, cfgFoldOver(cfgNonterminal(listElements)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(])), cfgSlot))), cfgRule(cfgLHS(listElements), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(emptyList)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(\\_\\_list)), cfgSlot, cfgNonterminal(trTerm), cfgSlot, cfgNonterminal(emptyList), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(\\_\\_list)), cfgSlot, cfgNonterminal(trTerm), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\,)), cfgSlot, cfgNonterminal(listElements), cfgSlot))), cfgRule(cfgLHS(emptyList), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(\\_\\_list)), cfgSlot, cfgNonterminal(\\_\\_empty), cfgSlot))), cfgRule(cfgLHS(\\_\\_list), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgEpsilon)))), cfgRule(cfgLHS(\\_\\_empty), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgEpsilon)))), cfgRule(cfgLHS(trRelation), cfgAlts(cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(->), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(=>), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(/>), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(\\\\>), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(~>), cfgSlot))), cfgRule(cfgLHS(chooseRule), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(chooseElementRule)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(chooseSlotRule)), cfgSlot))), cfgRule(cfgLHS(chooseElementRule), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(chooseElementExpr), cfgSlot, cfgFoldOver(cfgNonterminal(chooserOp)), cfgSlot, cfgNonterminal(chooseElementExpr), cfgSlot))), cfgRule(cfgLHS(chooseSlotRule), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(chooseSlotExpr), cfgSlot, cfgFoldOver(cfgNonterminal(chooserOp)), cfgSlot, cfgNonterminal(chooseSlotExpr), cfgSlot))), cfgRule(cfgLHS(chooseElementExpr), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(chooseElement)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(chooseElementExpr), cfgSlot, cfgFoldOver(cfgNonterminal(chooseSetOp)), cfgSlot, cfgNonterminal(chooseElement), cfgSlot))), cfgRule(cfgLHS(chooseSlotExpr), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(chooseSlot)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(chooseSlotExpr), cfgSlot, cfgFoldOver(cfgNonterminal(chooseSetOp)), cfgSlot, cfgNonterminal(chooseSlot), cfgSlot))), cfgRule(cfgLHS(chooseElement), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgNonterminal), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgCharacterTerminal), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgBuiltinTerminal), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgCaseInsensitiveTerminal), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgCaseSensitiveTerminal), cfgSlot), cfgSeq(cfgSlot, cfgFoldUnder(cfgNonterminal(choosePredefinedElementSet)), cfgSlot), cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\()), cfgSlot, cfgNonterminal(chooseElementExpr), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\))), cfgSlot))), cfgRule(cfgLHS(chooseSlot), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgLHS), cfgSlot, cfgCaseSensitiveTerminal(\\:\\:=), cfgSlot, cfgNonterminal(cfgAlt), cfgSlot), cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\()), cfgSlot, cfgNonterminal(chooseSlotExpr), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\))), cfgSlot))), cfgRule(cfgLHS(choosePredefinedElementSet), cfgAlts(cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(anyCharacterTerminal), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(anyBuiltinTerminal), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(anyCaseSensitiveTerminal), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(anyCaseInsensitiveTerminal), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(anyParaterminal), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(anyLiteralTerminal), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(anyTerminal), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(anyNonterminal), cfgSlot))), cfgRule(cfgLHS(choosePredefinedSlotSet), cfgAlts(cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(anySlot), cfgSlot))), cfgRule(cfgLHS(chooserOp), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(chooseHigher)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(chooseLower)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(chooseLonger)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(chooseShorter)), cfgSlot))), cfgRule(cfgLHS(chooseHigher), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(>)), cfgSlot))), cfgRule(cfgLHS(chooseLower), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(<)), cfgSlot))), cfgRule(cfgLHS(chooseLonger), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(>>)), cfgSlot))), cfgRule(cfgLHS(chooseShorter), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(<<)), cfgSlot))), cfgRule(cfgLHS(chooseSetOp), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(chooseUnion), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(chooseDifference), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(chooseIntersection), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(chooseSymmetricDifference), cfgSlot))), cfgRule(cfgLHS(chooseUnion), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(+)), cfgSlot))), cfgRule(cfgLHS(chooseDifference), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(-)), cfgSlot))), cfgRule(cfgLHS(chooseIntersection), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\*)), cfgSlot))), cfgRule(cfgLHS(chooseSymmetricDifference), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(/)), cfgSlot))), cfgRule(cfgLHS(directive), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(directiveElement), cfgSlot))), cfgRule(cfgLHS(directiveElement), cfgAlts(cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(include), cfgSlot, cfgNonterminal(file), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(whitespace)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(#)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(whitespace)), cfgSlot, cfgFoldUnder(cfgNonterminal(whiteSpaceElements)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(whitespace)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\()), cfgSlot, cfgFoldUnder(cfgNonterminal(whiteSpaceElements)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\))), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(paraterminal)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(#)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(paraterminal)), cfgSlot, cfgFoldUnder(cfgNonterminal(paraterminalElements)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(lexer)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(#)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(lexer)), cfgSlot, cfgNonterminal(ID), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(parser)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(#)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(parser)), cfgSlot, cfgNonterminal(ID), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(interpreter)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(#)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(interpreter)), cfgSlot, cfgNonterminal(ID), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(start)), cfgSlot, cfgNonterminal(cfgNonterminal), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(start)), cfgSlot, cfgNonterminal(trRelation), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(configuration)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(#)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(configuration)), cfgSlot, cfgNonterminal(trRelation), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\,)), cfgSlot, cfgNonterminal(trTerm), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(clear)), cfgSlot, cfgCaseSensitiveTerminal(allRules), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(clear)), cfgSlot, cfgCaseSensitiveTerminal(cfgRules), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(clear)), cfgSlot, cfgCaseSensitiveTerminal(chooseRules), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(clear)), cfgSlot, cfgCaseSensitiveTerminal(trRules), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(trace)), cfgSlot, cfgNonterminal(\\_\\_int32), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(print)), cfgSlot, cfgFoldUnder(cfgNonterminal(displayElements)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(show)), cfgSlot, cfgFoldUnder(cfgNonterminal(displayElements)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(prompt)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(prompt)), cfgSlot, cfgBuiltinTerminal(STRING\\_DQ), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(try)), cfgSlot, cfgNonterminal(file), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(try)), cfgSlot, cfgNonterminal(file), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(=)), cfgSlot, cfgNonterminal(trTopTuple), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(try)), cfgSlot, cfgNonterminal(trTopTuple), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(try)), cfgSlot, cfgNonterminal(trTopTuple), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(=)), cfgSlot, cfgNonterminal(trTopTuple), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(breakSPPFcycles)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(breakSPPFcycles)), cfgSlot, cfgFoldUnder(cfgNonterminal(cycleModes)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(breakSPPFcyclesRelation)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(nop)), cfgSlot))), cfgRule(cfgLHS(cycleModes), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgNonterminal(cycleMode)), cfgSlot), cfgSeq(cfgSlot, cfgFoldUnder(cfgNonterminal(cycleMode)), cfgSlot, cfgFoldUnder(cfgNonterminal(cycleModes)), cfgSlot))), cfgRule(cfgLHS(cycleMode), cfgAlts(cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(preorder), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(postorder), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(lone), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(sibling), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(trace), cfgSlot))), cfgRule(cfgLHS(file), cfgAlts(cfgSeq(cfgSlot, cfgBuiltinTerminal(STRING\\_PLAIN\\_SQ), cfgSlot))), cfgRule(cfgLHS(whiteSpaceElements), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(whiteSpaceElement), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(whiteSpaceElement), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\,)), cfgSlot, cfgFoldUnder(cfgNonterminal(whiteSpaceElements)), cfgSlot))), cfgRule(cfgLHS(whiteSpaceElement), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgNonterminal)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgBuiltinTerminal)), cfgSlot))), cfgRule(cfgLHS(paraterminalElements), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(paraterminalElement), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(paraterminalElement), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\,)), cfgSlot, cfgFoldUnder(cfgNonterminal(paraterminalElements)), cfgSlot))), cfgRule(cfgLHS(paraterminalElement), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgNonterminal)), cfgSlot))), cfgRule(cfgLHS(displayElements), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgNonterminal(displayElement)), cfgSlot), cfgSeq(cfgSlot, cfgFoldUnder(cfgNonterminal(displayElement)), cfgSlot, cfgFoldUnder(cfgNonterminal(displayElements)), cfgSlot))), cfgRule(cfgLHS(displayElement), cfgAlts(cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(latex), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(file), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(script), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(scriptDerivation), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(allRules), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(cfgRules), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(chooseRules), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(trRules), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(lexer), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(parser), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(interpreter), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(input), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(twe), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(lexicalisation), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(gss), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(sppf), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(bsr), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(derivation), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(interpretation), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(statistics), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(\\_\\_string), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(cycles), cfgSlot))), cfgRule(cfgLHS(\\_\\_bool), cfgAlts(cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(true), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(false), cfgSlot))), cfgRule(cfgLHS(\\_\\_char), cfgAlts(cfgSeq(cfgSlot, cfgBuiltinTerminal(CHAR\\_BQ), cfgSlot))), cfgRule(cfgLHS(\\_\\_int32), cfgAlts(cfgSeq(cfgSlot, cfgBuiltinTerminal(SIGNED\\_INTEGER), cfgSlot))), cfgRule(cfgLHS(\\_\\_real64), cfgAlts(cfgSeq(cfgSlot, cfgBuiltinTerminal(SIGNED\\_REAL), cfgSlot))), cfgRule(cfgLHS(\\_\\_string), cfgAlts(cfgSeq(cfgSlot, cfgBuiltinTerminal(STRING\\_DQ), cfgSlot))), cfgRule(cfgLHS(\\_\\_map), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal({)), cfgSlot, cfgNonterminal(elements), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(})), cfgSlot), cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal({)), cfgSlot, cfgNonterminal(elements), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(})), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\:)), cfgSlot, cfgNonterminal(trTerm), cfgSlot))), cfgRule(cfgLHS(elements), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgEpsilon)), cfgSeq(cfgSlot, cfgFoldUnder(cfgNonterminal(trTopTuple)), cfgSlot))), cfgRule(cfgLHS(ID), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgBuiltinTerminal(ID)), cfgSlot))), cfgRule(cfgLHS(IDSTAR), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(ID), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\*)), cfgSlot))), cfgRule(cfgLHS(ID\\_ATTRIBUTE), cfgAlts(cfgSeq(cfgSlot, cfgBuiltinTerminal(ID), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(.)), cfgSlot, cfgBuiltinTerminal(ID), cfgSlot))), cfgRule(cfgLHS(STRING\\_DQ), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgBuiltinTerminal(STRING\\_DQ)), cfgSlot))), cfgRule(cfgLHS(STRING\\_DOLLAR), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgBuiltinTerminal(STRING\\_DOLLAR)), cfgSlot))), cfgRule(cfgLHS(STRING\\_PLAIN\\_SQ), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgBuiltinTerminal(STRING\\_PLAIN\\_SQ)), cfgSlot))), cfgRule(cfgLHS(CHAR\\_BQ), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgBuiltinTerminal(CHAR\\_BQ)), cfgSlot))))";
  private final String scriptParserTermString = "rules(directive(whitespace(cfgBuiltinTerminal(SIMPLE\\_WHITESPACE), cfgBuiltinTerminal(COMMENT\\_NEST\\_ART), cfgBuiltinTerminal(COMMENT\\_LINE\\_C))), cfgRule(cfgLHS(rules), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(rule), cfgSlot, cfgFoldUnder(cfgNonterminal(rules)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(rule), cfgSlot))), cfgRule(cfgLHS(rule), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgRule)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(trRule)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(chooseRule)), cfgSlot), cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(!)), cfgSlot, cfgFoldOver(cfgNonterminal(directive)), cfgSlot))), cfgRule(cfgLHS(cfgRule), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgLHS), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\:\\:=)), cfgSlot, cfgNonterminal(cfgAlts), cfgSlot))), cfgRule(cfgLHS(cfgLHS), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(ID), cfgSlot))), cfgRule(cfgLHS(cfgAlts), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgAlt), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(|)), cfgSlot, cfgFoldUnder(cfgNonterminal(cfgAlts)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgAlt), cfgSlot))), cfgRule(cfgLHS(cfgAlt), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgSeq)), cfgSlot, cfgNonterminal(cfgActions), cfgSlot, cfgNonterminal(cfgEpsilonCarrier), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgSeq)), cfgSlot, cfgNonterminal(cfgActions), cfgSlot, cfgNonterminal(cfgEpsilon), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgSeq)), cfgSlot, cfgFoldUnder(cfgNonterminal(cfgElems)), cfgSlot, cfgNonterminal(cfgActions), cfgSlot))), cfgRule(cfgLHS(cfgEpsilonCarrier), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgEpsilon), cfgSlot, cfgFoldOver(cfgNonterminal(cfgAnnotation)), cfgSlot))), cfgRule(cfgLHS(cfgEpsilon), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(#)), cfgSlot))), cfgRule(cfgLHS(cfgAltNoAction), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgSeq)), cfgSlot, cfgNonterminal(cfgSlot), cfgSlot, cfgNonterminal(cfgName), cfgSlot, cfgNonterminal(cfgSlot), cfgSlot))), cfgRule(cfgLHS(cfgElems), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgActions), cfgSlot, cfgNonterminal(cfgExtended), cfgSlot, cfgFoldUnder(cfgNonterminal(cfgElems)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgActions), cfgSlot, cfgNonterminal(cfgExtended), cfgSlot))), cfgRule(cfgLHS(cfgExtended), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgName), cfgSlot, cfgFoldOver(cfgNonterminal(cfgAnnotation)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgName)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgOptional)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgKleene)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgPositive)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgDoFirst)), cfgSlot))), cfgRule(cfgLHS(cfgAnnotation), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgFoldUnder)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgFoldOver)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgFoldTear)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgFoldTearNamed)), cfgSlot))), cfgRule(cfgLHS(cfgFoldUnder), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(^)), cfgSlot))), cfgRule(cfgLHS(cfgFoldOver), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(^^)), cfgSlot))), cfgRule(cfgLHS(cfgFoldTear), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(^^^)), cfgSlot))), cfgRule(cfgLHS(cfgFoldTearNamed), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(^^^)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\:)), cfgSlot, cfgNonterminal(ID), cfgSlot))), cfgRule(cfgLHS(cfgDoFirst), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\()), cfgSlot, cfgNonterminal(cfgAlts), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\))), cfgSlot))), cfgRule(cfgLHS(cfgOptional), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\()), cfgSlot, cfgNonterminal(cfgAlts), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\))), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(?)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgAltNoAction), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(?)), cfgSlot))), cfgRule(cfgLHS(cfgPositive), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\()), cfgSlot, cfgNonterminal(cfgAlts), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\))), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(+)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgAltNoAction), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(+)), cfgSlot))), cfgRule(cfgLHS(cfgKleene), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\()), cfgSlot, cfgNonterminal(cfgAlts), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\))), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\*)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgAltNoAction), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\*)), cfgSlot))), cfgRule(cfgLHS(cfgName), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgPrim)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgPrim), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\:)), cfgSlot, cfgNonterminal(ID), cfgSlot))), cfgRule(cfgLHS(cfgPrim), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgNonterminal)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgCaseSensitiveTerminal)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgCaseInsensitiveTerminal)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgBuiltinTerminal)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgCharacterTerminal)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgCharacterRangeTerminal)), cfgSlot))), cfgRule(cfgLHS(cfgNonterminal), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(ID), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(STRING\\_DOLLAR), cfgSlot))), cfgRule(cfgLHS(cfgCaseSensitiveTerminal), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(STRING\\_PLAIN\\_SQ), cfgSlot))), cfgRule(cfgLHS(cfgCaseInsensitiveTerminal), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(STRING\\_DQ), cfgSlot))), cfgRule(cfgLHS(cfgBuiltinTerminal), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(&)), cfgSlot, cfgNonterminal(ID), cfgSlot))), cfgRule(cfgLHS(cfgCharacterTerminal), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(CHAR\\_BQ), cfgSlot))), cfgRule(cfgLHS(cfgCharacterRangeTerminal), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgRange), cfgSlot))), cfgRule(cfgLHS(cfgRange), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(CHAR\\_BQ), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(..)), cfgSlot, cfgNonterminal(CHAR\\_BQ), cfgSlot))), cfgRule(cfgLHS(cfgActions), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgSlot)), cfgSlot, cfgFoldUnder(cfgNonterminal(cfgActionSeq)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgSlot)), cfgSlot))), cfgRule(cfgLHS(cfgActionSeq), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgAction), cfgSlot, cfgFoldUnder(cfgNonterminal(cfgActionSeq)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgAction), cfgSlot))), cfgRule(cfgLHS(cfgAction), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgEquation)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgAssignment)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgInsert)), cfgSlot))), cfgRule(cfgLHS(cfgEquation), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgAttribute), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(=)), cfgSlot, cfgNonterminal(cfgExpression), cfgSlot))), cfgRule(cfgLHS(cfgAssignment), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgAttribute), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\:=)), cfgSlot, cfgNonterminal(cfgExpression), cfgSlot))), cfgRule(cfgLHS(cfgInsert), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(^+\\:)), cfgSlot, cfgNonterminal(ID), cfgSlot))), cfgRule(cfgLHS(cfgAttribute), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(ID), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(ID), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(.)), cfgSlot, cfgNonterminal(ID), cfgSlot))), cfgRule(cfgLHS(cfgExpression), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(\\_\\_bool)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(\\_\\_int32)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(\\_\\_real64)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(\\_\\_string)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(\\_\\_char)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgAttribute)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(ID)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(ID)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\()), cfgSlot, cfgFoldUnder(cfgNonterminal(cfgExpressionList)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\))), cfgSlot))), cfgRule(cfgLHS(cfgExpressionList), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgExpression), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgExpression), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\,)), cfgSlot, cfgFoldUnder(cfgNonterminal(cfgExpressionList)), cfgSlot))), cfgRule(cfgLHS(cfgSeq), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgEpsilon)))), cfgRule(cfgLHS(cfgSlot), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgEpsilon)))), cfgRule(cfgLHS(trRule), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(trLabel), cfgSlot, cfgNonterminal(tr), cfgSlot))), cfgRule(cfgLHS(trLabel), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgEpsilon)), cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(-)), cfgSlot, cfgNonterminal(ID), cfgSlot))), cfgRule(cfgLHS(tr), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(trPremises), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(---)), cfgSlot, cfgNonterminal(trTransition), cfgSlot))), cfgRule(cfgLHS(trPremises), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgEpsilon)), cfgSeq(cfgSlot, cfgNonterminal(trMatch), cfgSlot, cfgFoldUnder(cfgNonterminal(trPremises)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(trTransition), cfgSlot, cfgFoldUnder(cfgNonterminal(trPremises)), cfgSlot))), cfgRule(cfgLHS(trMatch), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(trTopTuple), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(|>)), cfgSlot, cfgNonterminal(trTopTuple), cfgSlot))), cfgRule(cfgLHS(trTransition), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(trTopTuple), cfgSlot, cfgFoldUnder(cfgNonterminal(trRelation)), cfgSlot, cfgNonterminal(trTopTuple), cfgSlot))), cfgRule(cfgLHS(trTopTuple), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(trTerm), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(trTuple)), cfgSlot, cfgFoldUnder(cfgNonterminal(terms)), cfgSlot))), cfgRule(cfgLHS(trTuple), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgEpsilon)))), cfgRule(cfgLHS(terms), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(trTerm), cfgSlot, cfgFoldUnder(cfgNonterminal(termsTail)), cfgSlot))), cfgRule(cfgLHS(termsTail), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\,)), cfgSlot, cfgNonterminal(trTerm), cfgSlot), cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\,)), cfgSlot, cfgNonterminal(trTerm), cfgSlot, cfgFoldUnder(cfgNonterminal(termsTail)), cfgSlot))), cfgRule(cfgLHS(trTerm), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(\\_\\_bool)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(\\_\\_char)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(\\_\\_int32)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(\\_\\_real64)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(\\_\\_string)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(\\_\\_keyval)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(\\_\\_list)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(\\_\\_set)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(ID)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(IDSTAR)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(ID)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\()), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\))), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(ID)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\()), cfgSlot, cfgNonterminal(trTerm), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\))), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(ID)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\()), cfgSlot, cfgFoldUnder(cfgNonterminal(terms)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\))), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(trTuple)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(<)), cfgSlot, cfgFoldUnder(cfgNonterminal(terms)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(>)), cfgSlot))), cfgRule(cfgLHS(\\_\\_keyval), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(trTerm), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(->)), cfgSlot, cfgNonterminal(trTerm), cfgSlot))), cfgRule(cfgLHS(\\_\\_list), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal([)), cfgSlot, cfgNonterminal(listParent), cfgSlot, cfgNonterminal(elements), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(])), cfgSlot))), cfgRule(cfgLHS(listParent), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgEpsilon)), cfgSeq(cfgSlot, cfgNonterminal(\\_\\_list), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(|)), cfgSlot))), cfgRule(cfgLHS(\\_\\_set), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal({)), cfgSlot, cfgNonterminal(setParent), cfgSlot, cfgNonterminal(elements), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(})), cfgSlot))), cfgRule(cfgLHS(setParent), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgEpsilon)), cfgSeq(cfgSlot, cfgNonterminal(\\_\\_set), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(|)), cfgSlot))), cfgRule(cfgLHS(elements), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgEpsilon)), cfgSeq(cfgSlot, cfgFoldUnder(cfgNonterminal(terms)), cfgSlot))), cfgRule(cfgLHS(trRelation), cfgAlts(cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(->), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(=>), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(/>), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(\\\\>), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(~>), cfgSlot))), cfgRule(cfgLHS(chooseRule), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(chooseElementRule)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(chooseSlotRule)), cfgSlot))), cfgRule(cfgLHS(chooseElementRule), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(chooseElementExpr), cfgSlot, cfgFoldOver(cfgNonterminal(chooserOp)), cfgSlot, cfgNonterminal(chooseElementExpr), cfgSlot))), cfgRule(cfgLHS(chooseSlotRule), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(chooseSlotExpr), cfgSlot, cfgFoldOver(cfgNonterminal(chooserOp)), cfgSlot, cfgNonterminal(chooseSlotExpr), cfgSlot))), cfgRule(cfgLHS(chooseElementExpr), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(chooseElement)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(chooseElementExpr), cfgSlot, cfgFoldOver(cfgNonterminal(chooseSetOp)), cfgSlot, cfgNonterminal(chooseElement), cfgSlot))), cfgRule(cfgLHS(chooseSlotExpr), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(chooseSlot)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(chooseSlotExpr), cfgSlot, cfgFoldOver(cfgNonterminal(chooseSetOp)), cfgSlot, cfgNonterminal(chooseSlot), cfgSlot))), cfgRule(cfgLHS(chooseElement), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgNonterminal), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgCharacterTerminal), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgBuiltinTerminal), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgCaseInsensitiveTerminal), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgCaseSensitiveTerminal), cfgSlot), cfgSeq(cfgSlot, cfgFoldUnder(cfgNonterminal(choosePredefinedElementSet)), cfgSlot), cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\()), cfgSlot, cfgNonterminal(chooseElementExpr), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\))), cfgSlot))), cfgRule(cfgLHS(chooseSlot), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgLHS), cfgSlot, cfgCaseSensitiveTerminal(\\:\\:=), cfgSlot, cfgNonterminal(cfgAlt), cfgSlot), cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\()), cfgSlot, cfgNonterminal(chooseSlotExpr), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\))), cfgSlot))), cfgRule(cfgLHS(choosePredefinedElementSet), cfgAlts(cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(anyCharacterTerminal), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(anyBuiltinTerminal), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(anyCaseSensitiveTerminal), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(anyCaseInsensitiveTerminal), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(anyParaterminal), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(anyLiteralTerminal), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(anyTerminal), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(anyNonterminal), cfgSlot))), cfgRule(cfgLHS(choosePredefinedSlotSet), cfgAlts(cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(anySlot), cfgSlot))), cfgRule(cfgLHS(chooserOp), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(chooseHigher)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(chooseLower)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(chooseLonger)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(chooseShorter)), cfgSlot))), cfgRule(cfgLHS(chooseHigher), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(>)), cfgSlot))), cfgRule(cfgLHS(chooseLower), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(<)), cfgSlot))), cfgRule(cfgLHS(chooseLonger), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(>>)), cfgSlot))), cfgRule(cfgLHS(chooseShorter), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(<<)), cfgSlot))), cfgRule(cfgLHS(chooseSetOp), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(chooseUnion), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(chooseDifference), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(chooseIntersection), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(chooseSymmetricDifference), cfgSlot))), cfgRule(cfgLHS(chooseUnion), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(+)), cfgSlot))), cfgRule(cfgLHS(chooseDifference), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(-)), cfgSlot))), cfgRule(cfgLHS(chooseIntersection), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\*)), cfgSlot))), cfgRule(cfgLHS(chooseSymmetricDifference), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(/)), cfgSlot))), cfgRule(cfgLHS(directive), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(directiveElement), cfgSlot))), cfgRule(cfgLHS(directiveElement), cfgAlts(cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(include), cfgSlot, cfgNonterminal(file), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(whitespace)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(#)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(whitespace)), cfgSlot, cfgFoldUnder(cfgNonterminal(whiteSpaceElements)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(whitespace)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\()), cfgSlot, cfgFoldUnder(cfgNonterminal(whiteSpaceElements)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\))), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(paraterminal)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(#)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(paraterminal)), cfgSlot, cfgFoldUnder(cfgNonterminal(paraterminalElements)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(lexer)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(#)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(lexer)), cfgSlot, cfgNonterminal(ID), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(parser)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(#)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(parser)), cfgSlot, cfgNonterminal(ID), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(interpreter)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(#)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(interpreter)), cfgSlot, cfgNonterminal(ID), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(start)), cfgSlot, cfgNonterminal(cfgNonterminal), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(start)), cfgSlot, cfgNonterminal(trRelation), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(configuration)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(#)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(configuration)), cfgSlot, cfgNonterminal(trRelation), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\,)), cfgSlot, cfgNonterminal(trTerm), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(clear)), cfgSlot, cfgCaseSensitiveTerminal(allRules), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(clear)), cfgSlot, cfgCaseSensitiveTerminal(cfgRules), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(clear)), cfgSlot, cfgCaseSensitiveTerminal(chooseRules), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(clear)), cfgSlot, cfgCaseSensitiveTerminal(trRules), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(trace)), cfgSlot, cfgNonterminal(\\_\\_int32), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(print)), cfgSlot, cfgFoldUnder(cfgNonterminal(displayElements)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(show)), cfgSlot, cfgFoldUnder(cfgNonterminal(displayElements)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(prompt)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(prompt)), cfgSlot, cfgBuiltinTerminal(STRING\\_DQ), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(try)), cfgSlot, cfgNonterminal(file), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(try)), cfgSlot, cfgNonterminal(file), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(=)), cfgSlot, cfgNonterminal(trTopTuple), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(try)), cfgSlot, cfgNonterminal(trTopTuple), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(try)), cfgSlot, cfgNonterminal(trTopTuple), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(=)), cfgSlot, cfgNonterminal(trTopTuple), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(breakSPPFcycles)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(breakSPPFcycles)), cfgSlot, cfgFoldUnder(cfgNonterminal(cycleModes)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(breakSPPFcyclesRelation)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(nop)), cfgSlot))), cfgRule(cfgLHS(cycleModes), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgNonterminal(cycleMode)), cfgSlot), cfgSeq(cfgSlot, cfgFoldUnder(cfgNonterminal(cycleMode)), cfgSlot, cfgFoldUnder(cfgNonterminal(cycleModes)), cfgSlot))), cfgRule(cfgLHS(cycleMode), cfgAlts(cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(preorder), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(postorder), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(lone), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(sibling), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(trace), cfgSlot))), cfgRule(cfgLHS(file), cfgAlts(cfgSeq(cfgSlot, cfgBuiltinTerminal(STRING\\_PLAIN\\_SQ), cfgSlot))), cfgRule(cfgLHS(whiteSpaceElements), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(whiteSpaceElement), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(whiteSpaceElement), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\,)), cfgSlot, cfgFoldUnder(cfgNonterminal(whiteSpaceElements)), cfgSlot))), cfgRule(cfgLHS(whiteSpaceElement), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgNonterminal)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgBuiltinTerminal)), cfgSlot))), cfgRule(cfgLHS(paraterminalElements), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(paraterminalElement), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(paraterminalElement), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\,)), cfgSlot, cfgFoldUnder(cfgNonterminal(paraterminalElements)), cfgSlot))), cfgRule(cfgLHS(paraterminalElement), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgNonterminal)), cfgSlot))), cfgRule(cfgLHS(displayElements), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgNonterminal(displayElement)), cfgSlot), cfgSeq(cfgSlot, cfgFoldUnder(cfgNonterminal(displayElement)), cfgSlot, cfgFoldUnder(cfgNonterminal(displayElements)), cfgSlot))), cfgRule(cfgLHS(displayElement), cfgAlts(cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(latex), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(file), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(script), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(scriptDerivation), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(allRules), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(cfgRules), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(chooseRules), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(trRules), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(lexer), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(parser), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(interpreter), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(input), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(twe), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(lexicalisation), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(gss), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(sppf), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(bsr), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(derivation), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(interpretation), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(statistics), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(\\_\\_string), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(cycles), cfgSlot))), cfgRule(cfgLHS(\\_\\_bool), cfgAlts(cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(true), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(false), cfgSlot))), cfgRule(cfgLHS(\\_\\_char), cfgAlts(cfgSeq(cfgSlot, cfgBuiltinTerminal(CHAR\\_BQ), cfgSlot))), cfgRule(cfgLHS(\\_\\_int32), cfgAlts(cfgSeq(cfgSlot, cfgBuiltinTerminal(SIGNED\\_INTEGER), cfgSlot))), cfgRule(cfgLHS(\\_\\_real64), cfgAlts(cfgSeq(cfgSlot, cfgBuiltinTerminal(SIGNED\\_REAL), cfgSlot))), cfgRule(cfgLHS(\\_\\_string), cfgAlts(cfgSeq(cfgSlot, cfgBuiltinTerminal(STRING\\_DQ), cfgSlot))), cfgRule(cfgLHS(ID), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgBuiltinTerminal(ID)), cfgSlot))), cfgRule(cfgLHS(IDSTAR), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(ID), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\*)), cfgSlot))), cfgRule(cfgLHS(ID\\_ATTRIBUTE), cfgAlts(cfgSeq(cfgSlot, cfgBuiltinTerminal(ID), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(.)), cfgSlot, cfgBuiltinTerminal(ID), cfgSlot))), cfgRule(cfgLHS(STRING\\_DQ), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgBuiltinTerminal(STRING\\_DQ)), cfgSlot))), cfgRule(cfgLHS(STRING\\_DOLLAR), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgBuiltinTerminal(STRING\\_DOLLAR)), cfgSlot))), cfgRule(cfgLHS(STRING\\_PLAIN\\_SQ), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgBuiltinTerminal(STRING\\_PLAIN\\_SQ)), cfgSlot))), cfgRule(cfgLHS(CHAR\\_BQ), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgBuiltinTerminal(CHAR\\_BQ)), cfgSlot))))";
  //@formatter:on

  private final GLLBaseLine scriptParser = new GLLBaseLine();
  private final LexerSingletonLongestMatch scriptLexer = new LexerSingletonLongestMatch();
  private final int scriptParserTerm; // This received the derivation from scriptParser

  private int scriptDerivationTerm;
  private final TermTraverser scriptTraverser;

  private final LexerSingletonLongestMatch currentLexer = new LexerSingletonLongestMatch(); // default current lexer is longest match - change to TWE set lexer
  private ParserBase currentParser = new GLLBaseLine(); // default current parser is GLL base line - change to MGLL when available
  private InterpreterBase currentInterpreter = new eSOSInterpreter(); // when available
  public CFGRules currentCFGRules; // scriptTraverser builds CFG rules into this grammar
  private int currentDerivationTerm;
  private int currentRewriteTerm;
  private int currentConfiguration;

  private ChooseRules currentChooser;

  private TRRules currentTRRules;
  private final Rewriter currentRewriter;

  String consoleInputLine = "";
  Scanner console = new Scanner(System.in);

  int successfulTests = 0;
  int failedTests = 0;

  public ScriptTermInterpreter(ITerms iTerms) {
    this.iTerms = iTerms;
    iTerms.plainTextTraverser = initialisePlainTextTraverser(); // Set up plain pretty printer actions
    iTerms.latexTraverser = initialiseLaTeXTraverser(); // Set up LaTeX pretty printer actions
    scriptTraverser = initialiseScriptTraverser(); // Set up script interpetation actions
    scriptParserTerm = iTerms.findTerm(scriptParserTermString); // Construct a term from the script grammar's text term

    // Bootstrap in action: build the script parser's grammar by traversing the scriptParserTerm and normalising, then making the result the script parser
    currentCFGRules = new CFGRules("Script grammar", iTerms);
    scriptTraverser.traverse(scriptParserTerm); // Construct the script parser grammar by walking the script parser term from the last bootstrap
    currentCFGRules.normalise();
    scriptParser.cfgRules = currentCFGRules; // Now we have a usable script parser
    // System.out.println("script grammar" + currentGrammar.toString());

    currentChooser = new ChooseRules(iTerms);
    currentChooser.normalise(currentCFGRules);

    // Initialise rewriter
    currentTRRules = new TRRules(iTerms);
    currentRewriter = new Rewriter(iTerms);
  }

  private TermTraverserText initialiseScriptTraverser() {
    TermTraverserText ret = new TermTraverserText(iTerms);

    ret.addActionBreak("directive", (Integer t) -> directiveAction(t), null, null);

    ret.addActionBreak("cfgLHS", (Integer t) -> currentCFGRules.lhsAction(childSymbolString(t)), null, null);
    ret.addAction("cfgSeq", (Integer t) -> currentCFGRules.altAction(), null, (Integer t) -> currentCFGRules.endAction(""));

    ret.addAction("cfgEpsilon", (Integer t) -> currentCFGRules.updateWorkingNode(CFGKind.EPS, "#"), null, null);
    ret.addActionBreak("cfgNonterminal", (Integer t) -> currentCFGRules.updateWorkingNode(CFGKind.N, childSymbolString(t)), null, null);
    ret.addActionBreak("cfgCaseSensitiveTerminal", (Integer t) -> currentCFGRules.updateWorkingNode(CFGKind.T, childSymbolString(t)), null, null);
    ret.addActionBreak("cfgBuiltinTerminal", (Integer t) -> currentCFGRules.updateWorkingNode(CFGKind.B, childSymbolString(t)), null, null);

    ret.addActionBreak("cfgCharacterTerminal", (Integer t) -> currentCFGRules.updateWorkingNode(CFGKind.C, childSymbolString(t)), null, null);
    ret.addActionBreak("cfgCharacterRangeTerminal", (Integer t) -> currentCFGRules.updateWorkingNode(CFGKind.C, childSymbolString(t)), null, null); // Not
                                                                                                                                                    // implemeneted
                                                                                                                                                    // yet

    ret.addAction("cfgDoFirst", (Integer t) -> currentCFGRules.updateWorkingNode(CFGKind.DO, null), null, null);
    ret.addAction("cfgOptional", (Integer t) -> currentCFGRules.updateWorkingNode(CFGKind.OPT, null), null, null);
    ret.addAction("cfgKleene", (Integer t) -> currentCFGRules.updateWorkingNode(CFGKind.KLN, null), null, null);
    ret.addAction("cfgPositive", (Integer t) -> currentCFGRules.updateWorkingNode(CFGKind.POS, null), null, null);

    ret.addAction("cfgFoldNone", (Integer t) -> currentCFGRules.workingFold = GIFTKind.NONE, null, null);
    ret.addAction("cfgFoldUnder", (Integer t) -> currentCFGRules.workingFold = GIFTKind.UNDER, null, null);
    ret.addAction("cfgFoldOver", (Integer t) -> currentCFGRules.workingFold = GIFTKind.OVER, null, null);
    ret.addAction("cfgFoldTear", (Integer t) -> currentCFGRules.workingFold = GIFTKind.TEAR, null, null);

    // ret.addAction("cfgSlot", (Integer t) -> currentGrammar.workingAction = t, null, null);
    ret.addAction("chooseRule", (Integer t) -> currentChooser.buildChooseRule(t), null, null);

    ret.addAction("trRule", (Integer t) -> currentTRRules.buildTRRule(t), null, null);
    return ret;
  }

  private void directiveAction(int term) {
    Util.trace(5, 0, "*** !" + iTerms.toString(iTerms.subterm(term, 0)) + "\n");
    switch (iTerms.termSymbolString(iTerms.subterm(term, 0))) {
    case "trace":
      Util.traceLevel = iTerms.termToJavaInteger(iTerms.subterm(term, 0, 0));
      System.out.println("Trace level set to " + Util.traceLevel);
      break;
    case "configuration":
      currentConfiguration = iTerms.subterm(term, 0);
      break;
    case "whitespace":
      currentCFGRules.whitespaces.clear();
      for (int i = 0; i < iTerms.termArity(iTerms.subterm(term, 0)); i++)
        if (iTerms.termSymbolString(iTerms.subterm(term, 0, i)).equals("cfgBuiltinTerminal")) switch (iTerms.termSymbolString(iTerms.subterm(term, 0, i, 0))) {
        case "SIMPLE_WHITESPACE":
          currentCFGRules.whitespaces.add(LexemeKind.SIMPLE_WHITESPACE);
          break;
        case "COMMENT_NEST_ART":
          currentCFGRules.whitespaces.add(LexemeKind.COMMENT_NEST_ART);
          break;
        case "COMMENT_LINE_C":
          currentCFGRules.whitespaces.add(LexemeKind.COMMENT_LINE_C);
          break;
        case "COMMENT_BLOCK_C":
          currentCFGRules.whitespaces.add(LexemeKind.COMMENT_BLOCK_C);
          break;
        default:
          Util.fatal("Unexpected !whitespace element " + iTerms.toString(iTerms.subterm(term, 0, i, 0)));
        }
      break;

    case "clear":
      switch (iTerms.termSymbolString(iTerms.subterm(term, 0, 0))) {
      case "all":
        currentCFGRules = new CFGRules("", iTerms);
        currentChooser = new ChooseRules(iTerms);
        currentTRRules = new TRRules(iTerms);
        break;
      case "cfgRules":
        currentCFGRules = new CFGRules("", iTerms);
        break;
      case "chooseRules":
        currentChooser = new ChooseRules(iTerms);
        break;
      case "rewriteRules":
        currentTRRules = new TRRules(iTerms);
        break;
      }
      break;
    case "lexer":
      break;
    case "parser":
      for (int i = 0; i < iTerms.termArity(iTerms.subterm(term, 0)); i++)
        switch (iTerms.termSymbolString(iTerms.subterm(term, 0, i)).toLowerCase()) {
        case "algx":
          currentParser = new AlgX(iTerms);
          break;
        case "cyk":
          currentParser = new CYK(iTerms);
          break;
        case "gllhashpool":
          currentParser = new GLLHashPool();
          break;
        case "gllbaseline":
          currentParser = new GLLBaseLine();
          break;
        case "rdsobgenerator":
          new RDSOBGenerator(currentCFGRules, "OSBRDG");
          return;
        case "rdsobfunction":
          currentParser = new RDSOBFunction();
          break;
        case "rdsobexplicitstack":
          currentParser = new RDSOBExplicitStack();
          break;
        default:
          Util.fatal("Unexpected !parser argument " + iTerms.toString(iTerms.subterm(term, 0, i)));
        }
      break;

    case "interpreter":
      for (int i = 0; i < iTerms.termArity(iTerms.subterm(term, 0)); i++)
        switch (iTerms.termSymbolString(iTerms.subterm(term, 0, i)).toLowerCase()) {
        case "eSOS":
          currentInterpreter = new eSOSInterpreter();
          break;
        case "attributeAction":
          currentInterpreter = new AttributeActionInterpreter();
          break;
        case "attributeGrammar":
          currentInterpreter = new AttributeGrammarInterpreter();
          break;
        default:
          Util.fatal("Unexpected !interpreter argument " + iTerms.toString(iTerms.subterm(term, 0, i)));
        }
      break;
    case "print":
      for (int i = 0; i < iTerms.termArity(iTerms.subterm(term, 0)); i++)
        printDisplayElement(term, i);
      break;

    case "show":
      for (int i = 0; i < iTerms.termArity(iTerms.subterm(term, 0)); i++)
        showDisplayElement(term, i);
      break;
    case "try":
      // System.out.println("try at " + iTerms.toString(term));
      if (iTerms.termSymbolString(iTerms.subterm(term, 0, 0)).equals("file"))
        try {
          String filename = iTerms.termSymbolString(iTerms.subterm(term, 0, 0, 0));
          // System.out.println("Attempting to open file " + filename);
          tryParse(filename, Files.readString(Paths.get(filename)));
        } catch (IOException e) {
          Util.fatal("Unable to open try file; skipping " + iTerms.toString(term));
        }
      else if (iTerms.termSymbolString(iTerms.subterm(term, 0, 0, 0)).equals("__string")) {
        tryParse("", iTerms.termSymbolString(iTerms.subterm(term, 0, 0, 0, 0)));
        currentDerivationTerm = iTerms.findTerm("trTopTuple", currentDerivationTerm); // augment to tuple
      } else
        currentDerivationTerm = iTerms.subterm(term, 0, 0); // Go straight to the rewrite stage

      currentRewriteTerm = currentRewriter.rewrite(currentDerivationTerm, currentTRRules);

      if (iTerms.termArity(iTerms.subterm(term, 0)) == 2) // There was a test term
        if (currentRewriteTerm == iTerms.subterm(term, 0, 1)) {
          System.out.println("*** Successful test");
          successfulTests++;
        } else {
          System.out.println("*** Failed test: expected " + iTerms.plainTextTraverser.toString(iTerms.subterm(term, 0, 1)));
          failedTests++;
        }
      break;
    case "prompt":
      if (iTerms.termArity(iTerms.subterm(term, 0)) == 0)
        System.out.print("\n*** Press return to continue");
      else
        System.out.print("\n" + iTerms.termSymbolString(iTerms.subterm(term, 0, 0)));
      consoleInputLine = console.nextLine();
      break;
    case "nop": // No operation
      break;

    case "breakSPPFcycles":
      boolean trace = false;
      TraversalKind traversalKind = TraversalKind.arbitrary;
      boolean lone = false;
      boolean sibling = false;

      for (int i = 0; i < iTerms.termArity(iTerms.subterm(term, 0)); i++)
        switch (iTerms.termSymbolString(iTerms.subterm(term, 0, i))) {
        case "trace":
          trace = true;
          break;
        case "preorder":
          traversalKind = TraversalKind.preorder;
          break;
        case "postorder":
          traversalKind = TraversalKind.postorder;
          break;
        case "lone":
          lone = true;
          break;
        case "sibling":
          sibling = true;
          break;
        default:
          Util.fatal("Unknown !breakSPPFcycles argument " + iTerms.termSymbolString(iTerms.subterm(term, 0, i)));
        }
      currentParser.sppfBreakCycles(trace, traversalKind, lone, sibling);
      break;

    case "breakSPPFcyclesRelation":
      currentParser.sppfBreakCyclesRelation();
      break;

    default:
      Util.fatal("Unimplemented directive !" + iTerms.toString(iTerms.subterm(term, 0, 0)));
    }

  }

  private void printDisplayElement(int term, int i) {
    boolean isLatex = false;
    String directive = iTerms.termSymbolString(iTerms.subterm(term, 0));
    String displayElement = iTerms.termSymbolString(iTerms.subterm(term, 0, i));
    TermTraverserText rtt = directive.equals("latex") ? iTerms.latexTraverser : iTerms.plainTextTraverser;
    PrintStream ps = null;

    switch (displayElement) {
    case "file":
      try {
        ps = new PrintStream(new File(iTerms.termSymbolString(iTerms.subterm(term, 0, i, 0))));
      } catch (FileNotFoundException e) {
        Util.fatal("Unable to open LaTeX output 'arttypeset.tex'");
      }
      break;

    case "latex":
      isLatex = true;
      break;

    case "script":
      ps.println(rtt.toString(scriptDerivationTerm, null));
      break;

    case "scriptExpansion":
      // currentRewriter.normalise();
      currentCFGRules.normalise();
      System.out.println(currentCFGRules);
      break;

    case "scriptDerivation":
      // Switch comments if you wanted one line or indented derivations
      // System.out.println("script derivation term: [" + scriptDerivationTerm + "]\n" + iTerms.toString(scriptDerivationTerm, false, -1, null));
      System.out.println("Script derivation term: [" + scriptDerivationTerm + "]\n" + iTerms.toString(scriptDerivationTerm, true, -1, null));
      break;

    case "cfgRules":
      currentCFGRules.normalise();
      System.out.println(currentCFGRules);
      break;

    case "outcome":
      System.out.println(currentParser.inLanguage ? "Accept" : "Reject");

      break;
    case "derivation":
      // Switch comments if you wanted one line or indented derivations
      System.out.println("Current derivation term = " + currentDerivationTerm + " " + iTerms.toString(currentDerivationTerm, false, -1, null));
      // System.out.println("current derivation term: [" + currentDerivationTerm + "]\n" + iTerms.toString(currentDerivationTerm, true, -1, null));
      if (scriptParserTerm == currentDerivationTerm) System.out.println("Bootstrap achieved: script parser term and current derivation term identical");
      break;

    case "interpretation":
      // Switch comments if you wanted one line or indented derivations
      System.out.println("Current rewrite term: [" + currentRewriteTerm + "]\n" + iTerms.toString(currentRewriteTerm, false, -1, null));
      // System.out.println("current derivation term: [" + currentRewriteTerm + "]\n" + iTerms.toString(currentRewriteTerm, true, -1, null));
      break;

    case "statistics":
      System.out.println(currentParser.statisticsToString());
      break;

    case "__string":
      System.out.println(iTerms.termSymbolString(iTerms.subterm(term, 0, i, 0)));
      break;

    case "gss":
      currentParser.gssPrint();
      break;

    case "sppf":
      currentParser.sppfPrint();
      break;

    case "cycles":
      currentParser.sppfPrintCycles();
      break;

    default:
      Util.fatal("No implementation for !" + directive + " " + displayElement);
    }
  }

  private void showDisplayElement(int term, int i) {
    String directive = iTerms.termSymbolString(iTerms.subterm(term, 0));
    String displayElement = iTerms.termSymbolString(iTerms.subterm(term, 0, i));
    TermTraverserText rtt = iTerms.plainTextTraverser;
    PrintStream ps = null;

    switch (displayElement) {
    case "file":
      try {
        ps = new PrintStream(new File(iTerms.termSymbolString(iTerms.subterm(term, 0, i, 0))));
      } catch (FileNotFoundException e) {
        Util.fatal("Unable to open LaTeX output 'arttypeset.tex'");
      }
      break;

    case "scriptDerivation":
      // Switch comments if you wanted one line or indented derivations
      // System.out.println("script derivation term: [" + scriptDerivationTerm + "]\n" + iTerms.toString(scriptDerivationTerm, false, -1, null));
      System.out.println("Script derivation term: [" + scriptDerivationTerm + "]\n" + iTerms.toString(scriptDerivationTerm, true, -1, null));
      break;

    case "grammar":
      currentCFGRules.normalise();
      System.out.println(currentCFGRules);
      break;

    case "derivation":
      // Switch comments if you wanted one line or indented derivations
      System.out.println("Current derivation term = " + currentDerivationTerm + " " + iTerms.toString(currentDerivationTerm, false, -1, null));
      // System.out.println("current derivation term: [" + currentDerivationTerm + "]\n" + iTerms.toString(currentDerivationTerm, true, -1, null));
      if (scriptParserTerm == currentDerivationTerm) System.out.println("Bootstrap achieved: script parser term and current derivation term identical");
      break;

    case "gss":
      // currentParser.gssPrint();
      currentParser.gss2Dot();
      break;

    case "sppf":
      // currentParser.sppfPrint();
      currentParser.sppf2Dot();
      break;

    default:
      Util.fatal("No visualisation available for !" + directive + " " + displayElement);
    }
  }

  private String childSymbolString(int t) {
    return iTerms.termSymbolString(iTerms.subterm(t, 0));
  }

  private void tryParse(String inputStringName, String inputString) {
    // System.out.println("tryParse on " + inputString);
    currentParser.resetStatistics();
    currentParser.loadStartMemory();
    currentCFGRules.normalise();
    if (currentCFGRules.isEmpty()) {
      System.out.println("Try failed: grammar has no rules");
      return;
    }
    currentChooser.normalise(currentCFGRules);

    currentParser.traceLevel = Util.traceLevel;
    currentParser.inputStringName = inputStringName;
    currentParser.inputString = inputString;
    currentParser.cfgRules = currentCFGRules;
    currentDerivationTerm = 0;
    currentParser.inLanguage = false;
    currentParser.loadSetupTime();
    currentLexer.lex(inputString, currentCFGRules.lexicalKindsArray(), currentCFGRules.lexicalStringsArray(), currentCFGRules.whitespacesArray());
    // currentLexer.report();
    currentParser.input = currentLexer.tokens;
    currentParser.positions = currentLexer.positions;
    currentParser.loadLexTime();
    if (currentParser.input != null) currentParser.parse();
    currentParser.loadParseTime();
    if (currentParser.inLanguage) {
      currentParser.chooseLongestMatch();
      currentParser.loadParseChooseTime();
      currentDerivationTerm = currentParser.derivationAsTerm();
      currentParser.loadTermGenerateTime();
    } else {
      currentDerivationTerm = 0;
      System.out.println("Try failed: syntax error");
    }
    currentParser.loadEndMemory();
  }

  // This version interprets the string with no tricks
  public void interpretARTScript(String scriptString) {
    currentCFGRules = new CFGRules("currentGrammar", iTerms);
    // Lex the script string
    scriptParser.inputString = scriptString;
    scriptParser.inLanguage = false;
    scriptLexer.lex(scriptParser.inputString, scriptParser.cfgRules.lexicalKindsArray(), scriptParser.cfgRules.lexicalStringsArray(),
        scriptParser.cfgRules.whitespacesArray());
    // scriptLexer.report();
    if (scriptLexer.tokens == null) Util.fatal("Lexical error in script");
    scriptParser.input = scriptLexer.tokens;
    scriptParser.positions = scriptLexer.positions;
    scriptParser.parse();
    if (!scriptParser.inLanguage) Util.fatal("Syntax error in script");
    scriptDerivationTerm = scriptParser.derivationAsTerm();
    // System.out.println("Script term:\n" + iTerms.toString(scriptDerivationTerm, true, -1, null));
    scriptTraverser.traverse(scriptDerivationTerm);
    if (successfulTests != 0 || failedTests != 0) System.out.print("Successful tests: " + successfulTests + "; failed tests " + failedTests);
  }

  private TermTraverserText initialisePlainTextTraverser() {
    TermTraverserText ret = new TermTraverserText(iTerms);
    // -1: uncomment these to have shorthand type renditions rather than plain terms
    // ret.addEmptyAction("__bool", "__char", "__int32", "__real64");
    // ret.addAction("__string", "\"", "", "\"");
    // ret.addAction("__map", "{", ", ", "}");
    // ret.addAction("__list", "[", ", ", "]");

    ret.addEmptyAction("rules");

    // 1. Context Free Grammar pretty print controls
    ret.addEmptyAction("cfgSlot");

    ret.addActionBreak("cfgLHS", (Integer t) -> {
      ret.appendAlias(iTerms.termSymbolStringIndex(iTerms.subterm(t, 0)));
      ret.append(" ::=");
    }, null, null);

    ret.addAction("cfgRule", null, null, "\n");
    ret.addAction("cfgAlts", null, "|", null);
    ret.addAction("cfgSeq", null, " ", null);
    ret.addAction("cfgName", null, ":", null);
    ret.addActionBreak("cfgNonterminal", (Integer t) -> ret.append(texEscape(iTerms.getString(iTerms.termSymbolStringIndex(iTerms.subterm(t, 0))))), null,
        null);
    ret.addActionBreak("cfgCaseInsensitiveTerminal",
        (Integer t) -> ret.append("\"" + texEscape(iTerms.getString(iTerms.termSymbolStringIndex(iTerms.subterm(t, 0)))) + "\""), null, null);
    ret.addActionBreak("cfgCaseSensitiveTerminal", (Integer t) -> ret.appendAlias("'", iTerms.termSymbolStringIndex(iTerms.subterm(t, 0)), "'"), null, null);
    ret.addActionBreak("cfgCharacterTerminal", (Integer t) -> ret.appendAlias("`", iTerms.termSymbolStringIndex(iTerms.subterm(t, 0)), ""), null, null);
    ret.addActionBreak("cfgCharacterRangeTerminal",
        (Integer t) -> ret.append("`" + iTerms.termSymbolString(iTerms.subterm(t, 0, 0)) + "..`" + iTerms.termSymbolString(iTerms.subterm(t, 0, 1))), null,
        null);
    ret.addActionBreak("cfgBuiltinTerminal", (Integer t) -> ret.appendAlias("&", iTerms.termSymbolStringIndex(iTerms.subterm(t, 0)), ""), null, null);
    ret.addAction("cfgOptional", "(", null, ")?");
    ret.addAction("cfgKleene", "(", null, ")*");
    ret.addAction("cfgPositive", "(", null, ")+");
    ret.addAction("cfgDoFirst", "(", null, ")");
    ret.addAction("cfgEpsilon", "#", null, null);

    ret.addAction("cfgFoldUnder", null, null, "^");
    ret.addAction("cfgFoldOver", null, null, "^^");
    ret.addAction("cfgTear", null, null, "^^^");
    ret.addAction("cfgTearNamed", null, "^^^:", null);
    ret.addAction("cfgInsert", " ^+:", null, null);

    ret.addAction("cfgAttribute", null, ".", null);
    ret.addAction("cfgEquation", null, " = ", null);
    ret.addAction("cfgAssignment", null, " := ", null);

    // 2. Chooser pretty print controls
    ret.addEmptyAction("chooseElement");
    ret.addAction("chooseRule", null, null, "\n");
    ret.addAction("chooseHigher", " > ", null, null);
    ret.addAction("chooseLower", " < ", null, null);
    ret.addAction("chooseLonger", " >> ", null, null);
    ret.addAction("chooseShorter", " << ", null, null);
    ret.addAction("chooseDiff", "(", " \\ ", ")");
    ret.addAction("chooseUnion", "(", " | ", ")");
    ret.addAction("chooseIntersection", "(", " / ", ")");
    ret.addActionBreak("choosePredefinedSet", (Integer t) -> ret.append(ret.childSymbolString(t, 0)), null, null);

    // 3. Term rewrite pretty print controls
    ret.addAction("trRule", null, null, "\n");
    ret.addAction("tr", null, " --- ", null);
    ret.addAction("trPremises", null, "  ", null);
    ret.addActionBreak("trLabel", (Integer t) -> ret.append(iTerms.termArity(t) > 0 ? ("-" + ret.childSymbolString(t, 0) + " ") : " "), null, null);
    ret.addAction("trMatch", null, (Integer t) -> ret.append(" |> "), null);
    ret.addEmptyAction("trTransition");
    ret.addActionBreak("TRRELATION", (Integer t) -> ret.append(" " + ret.childSymbolString(t, 0) + " "), null, null);
    ret.addActionBreak("trTerm", (Integer t) -> ret.append(iTerms.toString(iTerms.subterm(t, 0))), null, null);
    ret.addEmptyAction("trTopTuple");
    ret.addAction("trTuple", "<", ", ", ">");

    // 4. Default actions
    // Debug - load text traverser default action to print message if we encounter an unknown constructor
    // ret.addAction(-1, (Integer t) -> ret.append("??" + iTerms.toString(t) + "?? "), null, null);
    ret.addAction(-1, (Integer t) -> {
      ret.appendAlias(iTerms.termSymbolStringIndex(t));
      if (iTerms.termArity(t) > 0) ret.append("(");
    }, (Integer t) -> ret.append(", "), (Integer t) -> {
      if (iTerms.termArity(t) > 0) ret.append(")");
    });

    // Debug - print keys from text traverser tables
    // System.out.println("text traverser: " + pp.tt);

    return ret;
  }

  private String texEscape(String s) {
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < s.length(); i++) {
      switch (s.charAt(i)) {
      case '_', '$', '^', '%', '\\':
        sb.append('\\');
      }
      sb.append(s.charAt(i));
    }
    return sb.toString();
  }

  private String typesetConstant(int t) {
    String label = iTerms.termSymbolString(t);
    String argument = "";
    if (iTerms.termArity(t) > 0) argument = iTerms.termSymbolString(iTerms.subterm(t, 0));
    if (!argument.equals("_")) switch (label) {
    case "__bool":
      return "\\artBoolean{" + argument + "}";
    case "__char":
      return "\\artCharacter{" + iTerms.termSymbolString(iTerms.subterm(t, 0)) + "}";
    case "__int32":
      return "\\artInteger{" + iTerms.termSymbolString(iTerms.subterm(t, 0)) + "}";
    case "__real64":
      return "\\artReal{" + iTerms.termSymbolString(iTerms.subterm(t, 0)) + "}";
    case "__string":
      return "\\artString{" + iTerms.termSymbolString(iTerms.subterm(t, 0)) + "}";
    }
    return texEscape(label);
  }

  private TermTraverserText initialiseLaTeXTraverser() {
    TermTraverserText ret = new TermTraverserText(iTerms);
    // -1: uncomment these to have shorthand type renditions rather than plain terms
    ret.addActionBreak("__bool", (Integer t) -> ret.append(typesetConstant(t)), null, null);
    ret.addActionBreak("__char", (Integer t) -> ret.append(typesetConstant(t)), null, null);
    ret.addActionBreak("__int32", (Integer t) -> ret.append(typesetConstant(t)), null, null);
    ret.addActionBreak("__real64", (Integer t) -> ret.append(typesetConstant(t)), null, null);
    ret.addActionBreak("__string", (Integer t) -> ret.append(typesetConstant(t)), null, null);
    ret.addAction("__map", "\\artMap{", ", ", "}");
    ret.addAction("__list", "\\artList{", ", ", "}");

    // -1B: load global aliases
    ret.addGlobalAlias("->", "\\artRelation{\\rightarrow}");
    ret.addGlobalAlias("=>", "\\artRelation{\\Rightarrow}");
    ret.addGlobalAlias("-\\", "\\artRelation{\\rightharpoonup}");
    ret.addGlobalAlias("-/", "\\artRelation{\\rightharpoondown}");
    ret.addGlobalAlias("~>", "\\artRelation{\\leadsto}");

    // 0. Top level pretty print controls
    ret.addAction("rules", "%!TEX root = typeset.tex\n", "", "");

    // 1. Context Free Grammar pretty print controls
    ret.addEmptyAction("cfgSlot");

    ret.addAction("cfgRule", "\\artCFGRule{", "", "}\n");
    ret.addActionBreak("cfgLHS", (Integer t) -> ret.append("\\artLHS{" + texEscape(iTerms.termSymbolString(iTerms.subterm(t, 0))) + "}\\artExpandsTo"), null,
        null);

    ret.addAction("cfgAlts", null, "\\artSequenceSeperator", null);
    ret.addAction("cfgSeq", null, "\\artSequenceSpace", null);
    ret.addAction("cfgName", null, ":", null);
    ret.addActionBreak("cfgNonterminal",
        (Integer t) -> ret.append("\\artNonterminal{" + texEscape(iTerms.getString(iTerms.termSymbolStringIndex(iTerms.subterm(t, 0)))) + "}"), null, null);
    ret.addActionBreak("cfgCaseInsensitiveTerminal",
        (Integer t) -> ret.append("\\artCaseInsensitiveTerminal{" + texEscape(iTerms.getString(iTerms.termSymbolStringIndex(iTerms.subterm(t, 0)))) + "}"),
        null, null);
    ret.addActionBreak("cfgCaseSensitiveTerminal",
        (Integer t) -> ret.append("\\artCaseSensitiveTerminal{" + texEscape(iTerms.getString(iTerms.termSymbolStringIndex(iTerms.subterm(t, 0)))) + "}"), null,
        null);
    ret.addActionBreak("cfgCharacterTerminal",
        (Integer t) -> ret.append("\\artCharacterTerminal{" + texEscape(iTerms.getString(iTerms.termSymbolStringIndex(iTerms.subterm(t, 0)))) + "}"), null,
        null);

    ret.addActionBreak("cfgCharacterRangeTerminal",
        (Integer t) -> ret.append("\\artCharacterRangeTerminal{" + texEscape(iTerms.getString(iTerms.termSymbolStringIndex(iTerms.subterm(t, 0, 0)))) + "}{"
            + texEscape(iTerms.getString(iTerms.termSymbolStringIndex(iTerms.subterm(t, 0, 1)))) + "}"),
        null, null);

    ret.addActionBreak("cfgBuiltinTerminal",
        (Integer t) -> ret.append("\\artBuiltinTerminal{" + texEscape(iTerms.getString(iTerms.termSymbolStringIndex(iTerms.subterm(t, 0)))) + "}"), null, null);

    ret.addAction("cfgEpsilon", "\\artEpsilon", null, null);

    ret.addAction("cfgDoFirst", "\\artDoFirst{", "}{", "}\n");
    ret.addAction("cfgPositive", "\\artPositive{", "}{", "}\n");
    ret.addAction("cfgOptional", "\\artOptional{", "}{", "}\n");
    ret.addAction("cfgKleene", "\\artKleene{", "}{", "}\n");

    ret.addAction("cfgFoldUnder", null, null, "\\artFoldUnder");
    ret.addAction("cfgFoldOver", null, null, "\\artFoldOver");
    ret.addAction("cfgTear", null, null, "\\artTear");
    ret.addAction("cfgTearNamed", "\\artFoldUnder{", "}{", "}");
    ret.addAction("cfgInsert", "\\artInsert{", null, "}");

    ret.addAction("cfgAttribute", "\\artAttribute{", ".", "}");
    ret.addAction("cfgEquation", "\\artEquation{", "}{", "}");
    ret.addAction("cfgAssignment", "\\artAssignment{", "}{", "}");

    // 2. Chooser pretty print controls
    ret.addEmptyAction("chooseElement");
    ret.addAction("chooseRule", "\\artChooseRule{", "}{", "}\n");
    ret.addAction("chooseHigher", "\\artChooseHigher{", "}{", "}\n");
    ret.addAction("chooseLower", "\\artChooseLower{", "}{", "}\n");
    ret.addAction("chooseLonger", "\\artChooseLonger{", "}{", "}\n");
    ret.addAction("chooseShorter", "\\artChooseShorter{", "}{", "}\n");
    ret.addAction("chooseDiff", "(", " \\ ", ")");
    ret.addAction("chooseUnion", "(", " | ", ")");
    ret.addAction("chooseIntersection", "(", " / ", ")");
    ret.addActionBreak("choosePredefinedSet", (Integer t) -> ret.append(ret.childSymbolString(t, 0)), null, null);

    // 3. Term rewrite pretty print controls
    ret.addAction("trRule", "\\artTRRule{", "", "}\n");
    ret.addAction("tr", "\\artTR{", "}{", "}");
    ret.addAction("trPremises", null, "\\artPremiseSpace", null);
    ret.addActionBreak("trLabel", (Integer t) -> {
      if (iTerms.termArity(t) > 0) {
        ret.append("\\artTRLabel{");
        ret.appendAlias(iTerms.termSymbolStringIndex(iTerms.subterm(t, 0)));
        ret.append("}");
      }
    }, null, null);
    ret.addAction("trMatch", " ", "\\triangleright ", " ");
    ret.addAction("trTransition", "\\artTransition{", "", "}\n");
    ret.addEmptyAction("trTopTuple");
    ret.addAction("trTuple", "\\artTuple{", ", ", "}\n");

    // 4. Directives
    ret.addActionBreak("directive", (Integer t) -> {
      ret.append("\\artDirective{!" + iTerms.termSymbolString(iTerms.subterm(t, 0)));
      for (int i = 0; i < iTerms.termArity(iTerms.subterm(t, 0)); i++) {
        ret.append(" " + typesetConstant(iTerms.subterm(t, 0, 0)));
      }
    }, null, (Integer t) -> ret.append("}\n"));

    // 5. Default action
    // Debug - load text traverser default action to print message if we encounter an unknown constructor
    // ret.addAction(-1, (Integer t) -> ret.append("??" + iTerms.toString(t) + "?? "), null, null);
    ret.addAction(-1, (Integer t) -> {
      ret.append(typesetID(iTerms.getString(ret.aliasLookup(iTerms.termSymbolStringIndex(t)))));

      if (iTerms.termArity(t) > 0) ret.append("(");
    }, (Integer t) -> ret.append(", "), (Integer t) -> {
      if (iTerms.termArity(t) > 0) ret.append(")");
    });

    // Debug - print keys from text traverser tables
    // System.out.println("text traverser: " + pp.tt);

    return ret;
  }

  public String typesetID(String s) {
    // System.out.print("typesetID() formatting " + s);

    boolean hasIndex = false;
    int underscores = 0, index = 0, primes = 0, digits = 0, cc = 0;
    // Prefix processing
    while (cc < s.length() && s.charAt(cc) == '_')
      cc++;
    underscores = cc;

    // Suffix processing
    cc = s.length() - 1;
    while (cc >= 0 && s.charAt(cc) == 'P') {
      cc--;
      primes++;
    }
    if (cc >= 0 && Character.isDigit(s.charAt(cc))) {
      hasIndex = true;
      cc--;
      digits++;
    }

    for (int i = 0; i < digits; i++)
      index = index * 10 + (s.charAt(cc + 1 + i) - '0');

    // Extract core
    String ret = s.substring(underscores, cc + 1);

    // Add suffix
    if (hasIndex) ret += "$_{" + index + "}$";
    for (int i = 0; i < primes; i++)
      ret += "^\\prime";

    // Classify
    switch (underscores) {
    case 0:
      ret = "\\artConstructor{" + ret + "}";
      break;
    case 1:
      ret = "\\artVariable{" + ret + "}";
      break;
    case 2:
      ret = "\\artValue{" + ret + "}";
      break;
    default:
      Util.fatal("identifier " + s + " begins with three or more underscores");
    }

    // System.out.println(" to yield " + ret);
    return ret;
  }
}
