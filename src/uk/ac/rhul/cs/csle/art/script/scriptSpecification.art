(* ART` script grammar rules - mostly suitable for RDSOB parsers: No left recursive rules; Alterates in decreasing length order;   directive at end of each rule *)
!clear chooseRules  // remove default lexical choice
//!parser rdsobFunction // Uncomment this line to try bootstrapping with Recursive Descent Singleton Ordered Backtracking parser instead of default GLL parser
!whitespace &SIMPLE_WHITESPACE, &COMMENT_NEST_ART, &COMMENT_LINE_C 

// We want to let MGLL resolve ambiguities at derivation level, butthe boolean literals might best be handled at lexical level,and our depth rule also needs priority
//'__bool' > &ID
'true' > &ID
'false' > &ID
// > &ID

trTermFiles ::= artDepth trTermFiles . > trTermFiles ::= trTerm trTermFiles .

rules ::= rule rules^ | rule
rule  ::= cfgRule^^ | trRule^^ | chooseRule^^ | directive^^   

(* Context Free Grammar rules ************************************************)
cfgRule  ::= cfgLHS '::='^ cfgAlts
  cfgLHS ::= ID | ID '<'^ cfgAttributeDeclarations '>'^
  cfgAttributeDeclarations ::=  cfgAttributeDeclaration | cfgAttributeDeclaration cfgAttributeDeclarations^  
  cfgAttributeDeclaration  ::= ID ':'^ ID | ID ':'^ ID STRING_ANGLE_NEST 

cfgAlts ::= cfgAlt '|'^ cfgAlts^ | cfgAlt  
cfgAlt  ::= cfgSeq^^ cfgActions cfgEpsilonCarrier | cfgSeq^^ cfgActions cfgEpsilon | cfgSeq^^ cfgElems^ cfgActions (* final actions in sequence *)  
  cfgEpsilonCarrier ::= cfgEpsilon cfgAnnotation^^ 
cfgEpsilon ::= '#'^

cfgAltNoAction ::= cfgSeq^^ cfgSlot cfgName cfgSlot   // This matches a single element with no actions allowed for use in abbreviated Kleene operations
cfgElems ::= cfgActions cfgExtended cfgElems^ | cfgActions cfgExtended  

cfgExtended ::= cfgName cfgAnnotation^^ | cfgName^^ | cfgOptional^^ | cfgKleene^^ | cfgPositive^^ | cfgDoFirst^^  
cfgAnnotation ::= cfgFoldUnder^^ | cfgFoldOver^^  | cfgFoldTear^^ | cfgFoldTearNamed^^ | cfgDelay^^
  cfgFoldUnder ::= '^'^  
  cfgFoldOver ::= '^^'^  
  cfgFoldTear ::= '^^^'^
  cfgFoldTearNamed ::= '^^^'^ ':'^ ID 
  cfgDelay ::= '!<'
cfgDoFirst  ::= '('^ cfgAlts ')'^  
cfgOptional ::= '('^ cfgAlts ')'^ '?'^ | cfgAltNoAction '?'^  
cfgPositive ::= '('^ cfgAlts ')'^ '+'^ | cfgAltNoAction '+'^  
cfgKleene   ::= '('^ cfgAlts ')'^ '*'^ | cfgAltNoAction '*'^  

cfgName ::= cfgPrim^^ | cfgPrim ':'^ ID           // second child (if present) is a local name
cfgPrim ::= 
  cfgNonterminal^^ | cfgCaseSensitiveTerminal^^| cfgCaseInsensitiveTerminal^^ | cfgBuiltinTerminal^^ | cfgBuiltinNoWSTerminal^^ 
| cfgCharacterTerminal^^ | cfgCharacterSetTerminal^^| cfgCharacterAntiSetTerminal^^ | cfgCharacterOutOfBand^^ | cfgStartOfString^^
  
  cfgNonterminal ::= ID | STRING_DOLLAR
  cfgCaseSensitiveTerminal ::= STRING_SQ
  cfgCaseInsensitiveTerminal ::= STRING_DQ
  cfgBuiltinTerminal ::= '&'^ ID
  cfgBuiltinNoWSTerminal ::= '&&'^ ID
  cfgCharacterTerminal ::= CHAR_BQ
  cfgCharacterSetTerminal ::= STRING_BRACE
  cfgCharacterAntiSetTerminal ::= '~'^ STRING_BRACE
  cfgCharacterOutOfBand ::= '~!{}'
  cfgStartOfString ::= '!$$'
cfgPrims ::= cfgPrim | cfgPrim ','^ cfgPrims^ 


cfgActions ::= cfgSlot^^ cfgActionSeq^ | cfgSlot^^   
  cfgActionSeq ::= cfgAction cfgActionSeq^ | cfgAction  
  cfgAction  ::= cfgEquation^^ | cfgAssignment^^ | cfgNative^^ | cfgInsert^^  
cfgEquation ::= cfgAttribute '='^ cfgExpression  
cfgAssignment ::= cfgAttribute ':='^ cfgExpression
cfgNative ::= STRING_SHRIEK_SHRIEK
cfgInsert ::= '^+:'^ ID  
cfgAttribute ::= ID | ID '.'^ ID   

cfgExpressionList ::= cfgExpression | cfgExpression cfgExpressionList^
cfgExpression ::= __bool^^ | __intAP^^ | __int32^^ | __realAP^^ | __real64^^ | __string^^ | __char^^ | cfgAttribute^^ | ID^^ | ID^^ '('^  cfgExpressionList^ ')'^

cfgSeq ::= #^   // Dirty trick: both cfgAlt and cfgAltNoAction promote cfgSeq to achieve gather operation
cfgSlot ::= #^  

(* Term rewrite rules ********************************************************)
trRule ::= trLabel tr
trLabel ::= #^ | '-'^ ID  
tr ::= trPremises '---'^ trTransition
trPremises ::= #^ | trMatch trPremises^ | trTransition trPremises^
trMatch ::= trTopTuple '|>'^ trTopTuple

trTransition ::= trTopTuple trRelation^ trTopTuple
trTopTuple ::= trTerm | trTuple^^ trTerm ','^ trTerms^
trTuple ::= #^  
trTerms ::= trTerm | trTerm ','^ trTerms^ | trTerm trTerms^ // comma is optional
trTermFiles ::= trTerm | trTerm trTermFiles^ | artFile | artFile trTermFiles^ | artDepth | artDepth trTermFiles^

artDepth ::= 'depth'^ __int32

trTerm ::= 
  __bool^^ | __char^^ | __intAP^^ | __int32^^ | __realAP^^ | __real64^^ | __string^^  // lexical from builtins - see below  
| __array^^ | __list^^ | __set^^ | __map^^ 
| ID^^ | IDSTAR^^ | ID^^ '('^ ')'^ | ID^^ '('^ trTerms^ ')'^ | trTuple^^ '<'^ trTerms^ '>'^

__array ::= '['^  __int32 '|'^ ']'^ | '['^ __int32 '|'^ __a ']'^
__a ::= trTerm | trTerm ','^ __a | trTerm __a // comma is optional

__list ::= '['^ ']'^ | '['^ __l ']'^
__l ::= trTerm | trTerm ','^ __l | trTerm __l // comma is optional

__set  ::= '{'^ '}'^ | '{'^ __s '}'^ 
__s ::= trTerm | trTerm ','^ __s | trTerm __s // comma is optional

__map  ::= '{'^ '='^ '}'^  |'{'^ __m '}'^  // Note ugly empty map syntax
__m ::= trTerm '='^ trTerm | trTerm '='^ trTerm ','^ __m | trTerm '='^ trTerm __m // comma is optional

trRelation ::= '->' | '=>' | '~>' | ':->' | ':=>' | ':~>'  

(* Choose rules ***************************************************************)
chooseRule ::= chooseDerivation^^ | chooseLexical^^ 

chooseDerivation ::= chooseDerivationProduction chooserOp chooseDerivationProduction
chooseDerivationProduction ::= 
  cfgNonterminal '::='^ chooseEpsilonRHS^
| cfgNonterminal '::='^ chooseDerivationProductionRHS^

chooseEpsilonRHS ::= cfgEpsilon | '.' cfgEpsilon | cfgEpsilon '.'

chooseDerivationProductionRHS ::= 
   cfgPrim | '.' | cfgPrim chooseDerivationProductionRHS^ | '.' chooseDerivationProductionRHS^

chooseLexical ::= chooseExpr chooserOp chooseExpr

chooseExpr ::= 
  chooseElement^ | chooseElement^ chooseExprTail^
| chooseSet      | chooseSet chooseExprTail^

chooseExprTail ::= chooseCarrier | chooseCarrier chooseExprTail^

chooseCarrier ::= chooseAdd^^ chooseElement^ | chooseRemove^^ chooseElement^  

chooseElement ::= 
  cfgNonterminal | cfgCharacterTerminal | cfgBuiltinTerminal | cfgCaseInsensitiveTerminal | cfgCaseSensitiveTerminal

chooseSet ::=
  'anyCharacterTerminal' | 'anyBuiltinTerminal' | 'anyCaseSensitiveTerminal' | 'anyCaseInsensitiveTerminal'
| 'anyTerminal' | 'anyParaterminal' | 'anyNonterminal' | 'anySlot'

chooserOp ::= chooseHigher^^ | chooseLower^^ | chooseLonger^^ | chooseShorter^^
chooseHigher ::= '>'^
chooseLower ::= '<'^
chooseLonger ::= '>>'^
chooseShorter ::= '<<'^
chooseAdd ::= '+'^
chooseRemove ::= '-'^

(* Directives ****************************************************************)
directive ::= directiveCarrier

directiveCarrier ::=  
  '!prompt'^^ | '!prompt'^^ &STRING_DQ
| '!traceLevel'^^ __int32
| '!errorLevel'^^ __int32

| '!print'^^ trTermFiles^
| '!show'^^ trTermFiles^

| '!clear'^^ IDs^ | '!save'^^ ID ID | '!recall'^^ ID | '!convert'^^ IDs^

| '!characterSet'^^ cfgCharacterSetTerminal
| '!token'^^ cfgPrims^
| '!whitespace'^^ cfgPrims^
| '!paraterminal'^^ paraterminalElements^

| '!configuration'^^ trRelation typedIDs
| '!signature'^^ signatures
| '!terminal'^^ trRelation trTerms

| '!lexer'^^ ID | '!parser'^^ ID | '!interpreter'^^ ID 
| '!generate'^^ __int32 ID | '!generate'^^ ID  
| '!support'^^ cfgNative cfgNative 
| '!mode'^^ modes^  

| '!start'^^ cfgNonterminal | '!start'^^ trRelation // Set parser start nonterminal or rewriter start relation

| '!try'^^ artFile       | '!try'^^ artFile '='^ trTopTuple 
| '!try'^^ trTopTuple | '!try'^^ trTopTuple '='^ trTopTuple

(* Research features *)
| '!deleteTokens'^^ __int32 | '!swapTokens'^^ __int32 
| '!sppfBreakCycles'^^ | '!sppfBreakCyclesRelation'^^

artFile ::= &STRING_SQ

signatures ::= signature | signature signatures
signature ::= ID '('^ typedIDs ')'^ '::'^ type

IDs ::= ID | ID ','^ IDs^
typedIDs ::= typedID | typedID ','^ typedIDs
typedID ::= ID '::'^ type
type ::= 
  'any' | 'cmd' | 'expr' 
| '__bool' |'__char' | '__intAP' | '__int32' | '__realAP' | '__real64' | '__string' 
| typeCollection^
typeCollection ::= '__array' | '__list' | '__set' | '__map'

modes ::= mode^ | mode^ ','^ modes^ 

mode ::= modeSimpleAdd | modeSimpleRemove | modeNumeric

modeSimpleAdd ::= ID
modeSimpleRemove ::= 'not'^ ID
modeNumeric ::= ID  __int32

paraterminalElements ::= paraterminalElement | paraterminalElement ','^ paraterminalElements^
paraterminalElement  ::= cfgNonterminal^^

(* Lexical elements **********************************************************)
__bool ::= 'true' | 'false'
__char ::= &CHAR_BQ
__intAP ::= &AP_INTEGER
__int32 ::= &SIGNED_INTEGER
__realAP ::= &AP_REAL
__real64 ::= &SIGNED_REAL 
__string ::= &STRING_DQ

ID ::= &ID^^
IDSTAR ::= ID '*'^
STRING_SQ ::= &STRING_SQ^^ 
STRING_DQ ::= &STRING_DQ^^ 
STRING_DOLLAR ::= &STRING_DOLLAR^^
STRING_SHRIEK_SHRIEK ::= &STRING_SHRIEK_SHRIEK^^
STRING_BRACE ::= &STRING_BRACE^^
STRING_ANGLE_NEST ::= &STRING_ANGLE_NEST^^
CHAR_BQ ::= &CHAR_BQ^^


