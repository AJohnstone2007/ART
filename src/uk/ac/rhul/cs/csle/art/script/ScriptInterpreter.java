package uk.ac.rhul.cs.csle.art.script;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.PrintStream;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;

import uk.ac.rhul.cs.csle.art.cfg.AbstractParser;
import uk.ac.rhul.cs.csle.art.cfg.cfgRules.CFGElement;
import uk.ac.rhul.cs.csle.art.cfg.cfgRules.CFGElementKind;
import uk.ac.rhul.cs.csle.art.cfg.cfgRules.CFGRules;
import uk.ac.rhul.cs.csle.art.cfg.cfgRules.CFGRulesKind;
import uk.ac.rhul.cs.csle.art.cfg.cfgRules.GIFTKind;
import uk.ac.rhul.cs.csle.art.cfg.chart.AlgX;
import uk.ac.rhul.cs.csle.art.cfg.chart.CYK;
import uk.ac.rhul.cs.csle.art.cfg.gll.GLLBaseLine;
import uk.ac.rhul.cs.csle.art.cfg.gll.GLLHashPool;
import uk.ac.rhul.cs.csle.art.cfg.gll.GLLModal;
import uk.ac.rhul.cs.csle.art.cfg.lexer.AbstractLexer;
import uk.ac.rhul.cs.csle.art.cfg.lexer.LexerBaseLine;
import uk.ac.rhul.cs.csle.art.cfg.lexer.LexerGLLRecogniser;
import uk.ac.rhul.cs.csle.art.cfg.rdsob.RDSOBExplicitStack;
import uk.ac.rhul.cs.csle.art.cfg.rdsob.RDSOBFunction;
import uk.ac.rhul.cs.csle.art.cfg.rdsob.RDSOBGenerator;
import uk.ac.rhul.cs.csle.art.cfg.rdsob.RDSOBOracleGenerator;
import uk.ac.rhul.cs.csle.art.choose.ChooseRules;
import uk.ac.rhul.cs.csle.art.interpret.AbstractInterpreter;
import uk.ac.rhul.cs.csle.art.interpret.ActionsGenerator;
import uk.ac.rhul.cs.csle.art.interpret.AttributeActionInterpreter;
import uk.ac.rhul.cs.csle.art.term.ITerms;
import uk.ac.rhul.cs.csle.art.term.Rewriter;
import uk.ac.rhul.cs.csle.art.term.TRRules;
import uk.ac.rhul.cs.csle.art.term.TermTraverser;
import uk.ac.rhul.cs.csle.art.term.TermTraverserLaTeX;
import uk.ac.rhul.cs.csle.art.term.TermTraverserText;
import uk.ac.rhul.cs.csle.art.util.Util;
import uk.ac.rhul.cs.csle.art.util.Version;
import uk.ac.rhul.cs.csle.art.util.statistics.Statistics;

public final class ScriptInterpreter {
  public static final ITerms iTerms = new ITerms();

  // Bootstrap parser term generated by parsing ATScriptSpecification.art: when grammar changes, paste new term here
  //@formatter:off
//  private final String scriptParserTermString = "rules(directive(!clear(chooseRules)), directive(!parser(gll)), directive(!whitespace(cfgBuiltinTerminal(SIMPLE_WHITESPACE), cfgBuiltinTerminal(COMMENT_NEST_ART), cfgBuiltinTerminal(COMMENT_LINE_C))), cfgRule(cfgLHS(rules), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(rule), cfgSlot, cfgFoldUnder(cfgNonterminal(rules)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(rule), cfgSlot))), cfgRule(cfgLHS(rule), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgRule)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(trRule)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(chooseRule)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(directive)), cfgSlot))), cfgRule(cfgLHS(cfgRule), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgLHS), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\:\\:=)), cfgSlot, cfgNonterminal(cfgAlts), cfgSlot))), cfgRule(cfgLHS(cfgLHS), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(ID), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(ID), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(<)), cfgSlot, cfgNonterminal(cfgAttributeDeclarations), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(>)), cfgSlot))), cfgRule(cfgLHS(cfgAttributeDeclarations), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgAttributeDeclaration), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgAttributeDeclaration), cfgSlot, cfgFoldUnder(cfgNonterminal(cfgAttributeDeclarations)), cfgSlot))), cfgRule(cfgLHS(cfgAttributeDeclaration), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(ID), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\:)), cfgSlot, cfgNonterminal(ID), cfgSlot))), cfgRule(cfgLHS(cfgAlts), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgAlt), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(|)), cfgSlot, cfgFoldUnder(cfgNonterminal(cfgAlts)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgAlt), cfgSlot))), cfgRule(cfgLHS(cfgAlt), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgSeq)), cfgSlot, cfgNonterminal(cfgActions), cfgSlot, cfgNonterminal(cfgEpsilonCarrier), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgSeq)), cfgSlot, cfgNonterminal(cfgActions), cfgSlot, cfgNonterminal(cfgEpsilon), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgSeq)), cfgSlot, cfgFoldUnder(cfgNonterminal(cfgElems)), cfgSlot, cfgNonterminal(cfgActions), cfgSlot))), cfgRule(cfgLHS(cfgEpsilonCarrier), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgEpsilon), cfgSlot, cfgFoldOver(cfgNonterminal(cfgAnnotation)), cfgSlot))), cfgRule(cfgLHS(cfgEpsilon), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(#)), cfgSlot))), cfgRule(cfgLHS(cfgAltNoAction), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgSeq)), cfgSlot, cfgNonterminal(cfgSlot), cfgSlot, cfgNonterminal(cfgName), cfgSlot, cfgNonterminal(cfgSlot), cfgSlot))), cfgRule(cfgLHS(cfgElems), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgActions), cfgSlot, cfgNonterminal(cfgExtended), cfgSlot, cfgFoldUnder(cfgNonterminal(cfgElems)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgActions), cfgSlot, cfgNonterminal(cfgExtended), cfgSlot))), cfgRule(cfgLHS(cfgExtended), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgName), cfgSlot, cfgFoldOver(cfgNonterminal(cfgAnnotation)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgName)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgOptional)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgKleene)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgPositive)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgDoFirst)), cfgSlot))), cfgRule(cfgLHS(cfgAnnotation), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgFoldUnder)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgFoldOver)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgFoldTear)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgFoldTearNamed)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgDelay)), cfgSlot))), cfgRule(cfgLHS(cfgFoldUnder), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(^)), cfgSlot))), cfgRule(cfgLHS(cfgFoldOver), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(^^)), cfgSlot))), cfgRule(cfgLHS(cfgFoldTear), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(^^^)), cfgSlot))), cfgRule(cfgLHS(cfgFoldTearNamed), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(^^^)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\:)), cfgSlot, cfgNonterminal(ID), cfgSlot))), cfgRule(cfgLHS(cfgDelay), cfgAlts(cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(!<), cfgSlot))), cfgRule(cfgLHS(cfgDoFirst), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\()), cfgSlot, cfgNonterminal(cfgAlts), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\))), cfgSlot))), cfgRule(cfgLHS(cfgOptional), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\()), cfgSlot, cfgNonterminal(cfgAlts), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\))), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(?)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgAltNoAction), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(?)), cfgSlot))), cfgRule(cfgLHS(cfgPositive), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\()), cfgSlot, cfgNonterminal(cfgAlts), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\))), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(+)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgAltNoAction), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(+)), cfgSlot))), cfgRule(cfgLHS(cfgKleene), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\()), cfgSlot, cfgNonterminal(cfgAlts), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\))), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(*)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgAltNoAction), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(*)), cfgSlot))), cfgRule(cfgLHS(cfgName), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgPrim)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgPrim), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\:)), cfgSlot, cfgNonterminal(ID), cfgSlot))), cfgRule(cfgLHS(cfgPrim), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgNonterminal)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgCaseSensitiveTerminal)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgCaseInsensitiveTerminal)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgBuiltinTerminal)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgBuiltinNoWSTerminal)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgCharacterTerminal)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgCharacterSetTerminal)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgCharacterAntiSetTerminal)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgCharacterOutOfBand)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgStartOfString)), cfgSlot))), cfgRule(cfgLHS(cfgNonterminal), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(ID), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(STRING_DOLLAR), cfgSlot))), cfgRule(cfgLHS(cfgCaseSensitiveTerminal), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(STRING_SQ), cfgSlot))), cfgRule(cfgLHS(cfgCaseInsensitiveTerminal), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(STRING_DQ), cfgSlot))), cfgRule(cfgLHS(cfgBuiltinTerminal), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(&)), cfgSlot, cfgNonterminal(ID), cfgSlot))), cfgRule(cfgLHS(cfgBuiltinNoWSTerminal), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(&&)), cfgSlot, cfgNonterminal(ID), cfgSlot))), cfgRule(cfgLHS(cfgCharacterTerminal), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(CHAR_BQ), cfgSlot))), cfgRule(cfgLHS(cfgCharacterSetTerminal), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(STRING_BRACE), cfgSlot))), cfgRule(cfgLHS(cfgCharacterAntiSetTerminal), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(~)), cfgSlot, cfgNonterminal(STRING_BRACE), cfgSlot))), cfgRule(cfgLHS(cfgCharacterOutOfBand), cfgAlts(cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(~!{}), cfgSlot))), cfgRule(cfgLHS(cfgStartOfString), cfgAlts(cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(!$$), cfgSlot))), cfgRule(cfgLHS(cfgPrims), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgPrim), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgPrim), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\,)), cfgSlot, cfgFoldUnder(cfgNonterminal(cfgPrims)), cfgSlot))), cfgRule(cfgLHS(cfgActions), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgSlot)), cfgSlot, cfgFoldUnder(cfgNonterminal(cfgActionSeq)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgSlot)), cfgSlot))), cfgRule(cfgLHS(cfgActionSeq), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgAction), cfgSlot, cfgFoldUnder(cfgNonterminal(cfgActionSeq)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgAction), cfgSlot))), cfgRule(cfgLHS(cfgAction), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgEquation)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgAssignment)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgNative)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgInsert)), cfgSlot))), cfgRule(cfgLHS(cfgEquation), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgAttribute), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(=)), cfgSlot, cfgNonterminal(cfgExpression), cfgSlot))), cfgRule(cfgLHS(cfgAssignment), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgAttribute), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\:=)), cfgSlot, cfgNonterminal(cfgExpression), cfgSlot))), cfgRule(cfgLHS(cfgNative), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(STRING_SHRIEK_SHRIEK), cfgSlot))), cfgRule(cfgLHS(cfgInsert), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(^+\\:)), cfgSlot, cfgNonterminal(ID), cfgSlot))), cfgRule(cfgLHS(cfgAttribute), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(ID), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(ID), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(.)), cfgSlot, cfgNonterminal(ID), cfgSlot))), cfgRule(cfgLHS(cfgExpressionList), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgExpression), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgExpression), cfgSlot, cfgFoldUnder(cfgNonterminal(cfgExpressionList)), cfgSlot))), cfgRule(cfgLHS(cfgExpression), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(__bool)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(__intAP)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(__int32)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(__realAP)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(__real64)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(__string)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(__char)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgAttribute)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(ID)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(ID)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\()), cfgSlot, cfgFoldUnder(cfgNonterminal(cfgExpressionList)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\))), cfgSlot))), cfgRule(cfgLHS(cfgSeq), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgEpsilon)))), cfgRule(cfgLHS(cfgSlot), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgEpsilon)))), cfgRule(cfgLHS(trRule), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(trLabel), cfgSlot, cfgNonterminal(tr), cfgSlot))), cfgRule(cfgLHS(trLabel), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgEpsilon)), cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(-)), cfgSlot, cfgNonterminal(ID), cfgSlot))), cfgRule(cfgLHS(tr), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(trPremises), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(---)), cfgSlot, cfgNonterminal(trTransition), cfgSlot))), cfgRule(cfgLHS(trPremises), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgEpsilon)), cfgSeq(cfgSlot, cfgNonterminal(trMatch), cfgSlot, cfgFoldUnder(cfgNonterminal(trPremises)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(trTransition), cfgSlot, cfgFoldUnder(cfgNonterminal(trPremises)), cfgSlot))), cfgRule(cfgLHS(trMatch), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(trTopTuple), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(|>)), cfgSlot, cfgNonterminal(trTopTuple), cfgSlot))), cfgRule(cfgLHS(trTransition), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(trTopTuple), cfgSlot, cfgFoldUnder(cfgNonterminal(trRelation)), cfgSlot, cfgNonterminal(trTopTuple), cfgSlot))), cfgRule(cfgLHS(trTopTuple), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(trTerm), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(trTuple)), cfgSlot, cfgNonterminal(trTerm), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\,)), cfgSlot, cfgFoldUnder(cfgNonterminal(trTerms)), cfgSlot))), cfgRule(cfgLHS(trTuple), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgEpsilon)))), cfgRule(cfgLHS(trTerms), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(trTerm), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(trTerm), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\,)), cfgSlot, cfgFoldUnder(cfgNonterminal(trTerms)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(trTerm), cfgSlot, cfgFoldUnder(cfgNonterminal(trTerms)), cfgSlot))), cfgRule(cfgLHS(trTerm), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(__bool)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(__char)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(__intAP)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(__int32)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(__realAP)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(__real64)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(__string)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(__array)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(__list)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(__set)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(__map)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(ID)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(IDSTAR)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(ID)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\()), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\))), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(ID)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\()), cfgSlot, cfgFoldUnder(cfgNonterminal(trTerms)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\))), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(trTuple)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(<)), cfgSlot, cfgFoldUnder(cfgNonterminal(trTerms)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(>)), cfgSlot))), cfgRule(cfgLHS(__array), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal([)), cfgSlot, cfgNonterminal(__int32), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(|)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(])), cfgSlot), cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal([)), cfgSlot, cfgNonterminal(__int32), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(|)), cfgSlot, cfgNonterminal(__a), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(])), cfgSlot))), cfgRule(cfgLHS(__a), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(trTerm), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(trTerm), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\,)), cfgSlot, cfgNonterminal(__a), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(trTerm), cfgSlot, cfgNonterminal(__a), cfgSlot))), cfgRule(cfgLHS(__list), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal([)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(])), cfgSlot), cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal([)), cfgSlot, cfgNonterminal(__l), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(])), cfgSlot))), cfgRule(cfgLHS(__l), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(trTerm), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(trTerm), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\,)), cfgSlot, cfgNonterminal(__l), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(trTerm), cfgSlot, cfgNonterminal(__l), cfgSlot))), cfgRule(cfgLHS(__set), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal({)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(})), cfgSlot), cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal({)), cfgSlot, cfgNonterminal(__s), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(})), cfgSlot))), cfgRule(cfgLHS(__s), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(trTerm), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(trTerm), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\,)), cfgSlot, cfgNonterminal(__s), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(trTerm), cfgSlot, cfgNonterminal(__s), cfgSlot))), cfgRule(cfgLHS(__map), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal({)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(=)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(})), cfgSlot), cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal({)), cfgSlot, cfgNonterminal(__m), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(})), cfgSlot))), cfgRule(cfgLHS(__m), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(trTerm), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(=)), cfgSlot, cfgNonterminal(trTerm), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(trTerm), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(=)), cfgSlot, cfgNonterminal(trTerm), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\,)), cfgSlot, cfgNonterminal(__m), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(trTerm), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(=)), cfgSlot, cfgNonterminal(trTerm), cfgSlot, cfgNonterminal(__m), cfgSlot))), cfgRule(cfgLHS(trRelation), cfgAlts(cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(->), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(=>), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(~>), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(\\:->), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(\\:=>), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(\\:~>), cfgSlot))), cfgRule(cfgLHS(chooseRule), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(chooseDerivation)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(chooseLexical)), cfgSlot))), cfgRule(cfgLHS(chooseDerivation), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(chooseDerivationProduction), cfgSlot, cfgNonterminal(chooserOp), cfgSlot, cfgNonterminal(chooseDerivationProduction), cfgSlot))), cfgRule(cfgLHS(chooseDerivationProduction), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgNonterminal), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\:\\:=)), cfgSlot, cfgFoldUnder(cfgNonterminal(chooseEpsilonRHS)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgNonterminal), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\:\\:=)), cfgSlot, cfgFoldUnder(cfgNonterminal(chooseDerivationProductionRHS)), cfgSlot))), cfgRule(cfgLHS(chooseEpsilonRHS), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgEpsilon), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(.), cfgSlot, cfgNonterminal(cfgEpsilon), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgEpsilon), cfgSlot, cfgCaseSensitiveTerminal(.), cfgSlot))), cfgRule(cfgLHS(chooseDerivationProductionRHS), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgPrim), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(.), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgPrim), cfgSlot, cfgFoldUnder(cfgNonterminal(chooseDerivationProductionRHS)), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(.), cfgSlot, cfgFoldUnder(cfgNonterminal(chooseDerivationProductionRHS)), cfgSlot))), cfgRule(cfgLHS(chooseLexical), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(chooseExpr), cfgSlot, cfgNonterminal(chooserOp), cfgSlot, cfgNonterminal(chooseExpr), cfgSlot))), cfgRule(cfgLHS(chooseExpr), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgNonterminal(chooseElement)), cfgSlot), cfgSeq(cfgSlot, cfgFoldUnder(cfgNonterminal(chooseElement)), cfgSlot, cfgFoldUnder(cfgNonterminal(chooseExprTail)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(chooseSet), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(chooseSet), cfgSlot, cfgFoldUnder(cfgNonterminal(chooseExprTail)), cfgSlot))), cfgRule(cfgLHS(chooseExprTail), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(chooseCarrier), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(chooseCarrier), cfgSlot, cfgFoldUnder(cfgNonterminal(chooseExprTail)), cfgSlot))), cfgRule(cfgLHS(chooseCarrier), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(chooseAdd)), cfgSlot, cfgFoldUnder(cfgNonterminal(chooseElement)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(chooseRemove)), cfgSlot, cfgFoldUnder(cfgNonterminal(chooseElement)), cfgSlot))), cfgRule(cfgLHS(chooseElement), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgNonterminal), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgCharacterTerminal), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgBuiltinTerminal), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgCaseInsensitiveTerminal), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgCaseSensitiveTerminal), cfgSlot))), cfgRule(cfgLHS(chooseSet), cfgAlts(cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(anyCharacterTerminal), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(anyBuiltinTerminal), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(anyCaseSensitiveTerminal), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(anyCaseInsensitiveTerminal), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(anyTerminal), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(anyParaterminal), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(anyNonterminal), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(anySlot), cfgSlot))), cfgRule(cfgLHS(chooserOp), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(chooseHigher)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(chooseLower)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(chooseLonger)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(chooseShorter)), cfgSlot))), cfgRule(cfgLHS(chooseHigher), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(>)), cfgSlot))), cfgRule(cfgLHS(chooseLower), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(<)), cfgSlot))), cfgRule(cfgLHS(chooseLonger), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(>>)), cfgSlot))), cfgRule(cfgLHS(chooseShorter), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(<<)), cfgSlot))), cfgRule(cfgLHS(chooseAdd), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(+)), cfgSlot))), cfgRule(cfgLHS(chooseRemove), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(-)), cfgSlot))), cfgRule(cfgLHS(directive), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(directiveCarrier), cfgSlot))), cfgRule(cfgLHS(directiveCarrier), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!prompt)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!prompt)), cfgSlot, cfgBuiltinTerminal(STRING_DQ), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!traceLevel)), cfgSlot, cfgNonterminal(__int32), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!errorLevel)), cfgSlot, cfgNonterminal(__int32), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!print)), cfgSlot, cfgFoldUnder(cfgNonterminal(trTerms)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!show)), cfgSlot, cfgFoldUnder(cfgNonterminal(trTerms)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!clear)), cfgSlot, cfgFoldUnder(cfgNonterminal(IDs)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!save)), cfgSlot, cfgNonterminal(ID), cfgSlot, cfgNonterminal(ID), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!recall)), cfgSlot, cfgNonterminal(ID), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!convert)), cfgSlot, cfgFoldUnder(cfgNonterminal(IDs)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!characterSet)), cfgSlot, cfgNonterminal(cfgCharacterSetTerminal), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!token)), cfgSlot, cfgFoldUnder(cfgNonterminal(cfgPrims)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!whitespace)), cfgSlot, cfgFoldUnder(cfgNonterminal(cfgPrims)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!paraterminal)), cfgSlot, cfgFoldUnder(cfgNonterminal(paraterminalElements)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!configuration)), cfgSlot, cfgNonterminal(trRelation), cfgSlot, cfgNonterminal(configurationElements), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!final)), cfgSlot, cfgNonterminal(trRelation), cfgSlot, cfgNonterminal(trTerms), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!lexer)), cfgSlot, cfgNonterminal(ID), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!parser)), cfgSlot, cfgNonterminal(ID), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!interpreter)), cfgSlot, cfgNonterminal(ID), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!generate)), cfgSlot, cfgNonterminal(__int32), cfgSlot, cfgNonterminal(ID), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!generate)), cfgSlot, cfgNonterminal(ID), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!support)), cfgSlot, cfgNonterminal(cfgNative), cfgSlot, cfgNonterminal(cfgNative), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!mode)), cfgSlot, cfgFoldUnder(cfgNonterminal(modes)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!start)), cfgSlot, cfgNonterminal(cfgNonterminal), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!start)), cfgSlot, cfgNonterminal(trRelation), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!try)), cfgSlot, cfgNonterminal(file), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!try)), cfgSlot, cfgNonterminal(file), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(=)), cfgSlot, cfgNonterminal(trTopTuple), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!try)), cfgSlot, cfgNonterminal(trTopTuple), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!try)), cfgSlot, cfgNonterminal(trTopTuple), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(=)), cfgSlot, cfgNonterminal(trTopTuple), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!deleteTokens)), cfgSlot, cfgNonterminal(__int32), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!swapTokens)), cfgSlot, cfgNonterminal(__int32), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!sppfBreakCycles)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!sppfBreakCyclesRelation)), cfgSlot))), cfgRule(cfgLHS(file), cfgAlts(cfgSeq(cfgSlot, cfgBuiltinTerminal(STRING_SQ), cfgSlot))), cfgRule(cfgLHS(IDs), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(ID), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(ID), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\,)), cfgSlot, cfgFoldUnder(cfgNonterminal(IDs)), cfgSlot))), cfgRule(cfgLHS(modes), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(ID), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(ID), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\,)), cfgSlot, cfgFoldUnder(cfgNonterminal(modes)), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(not), cfgSlot, cfgNonterminal(ID), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(not), cfgSlot, cfgNonterminal(ID), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\,)), cfgSlot, cfgFoldUnder(cfgNonterminal(modes)), cfgSlot))), cfgRule(cfgLHS(configurationElements), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(configurationElement), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(configurationElement), cfgSlot, cfgFoldUnder(cfgNonterminal(configurationElements)), cfgSlot))), cfgRule(cfgLHS(configurationElement), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(ID), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\:\\:)), cfgSlot, cfgNonterminal(ID), cfgSlot))), cfgRule(cfgLHS(paraterminalElements), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(paraterminalElement), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(paraterminalElement), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\,)), cfgSlot, cfgFoldUnder(cfgNonterminal(paraterminalElements)), cfgSlot))), cfgRule(cfgLHS(paraterminalElement), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgNonterminal)), cfgSlot))), cfgRule(cfgLHS(__bool), cfgAlts(cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(true), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(false), cfgSlot))), cfgRule(cfgLHS(__char), cfgAlts(cfgSeq(cfgSlot, cfgBuiltinTerminal(CHAR_BQ), cfgSlot))), cfgRule(cfgLHS(__intAP), cfgAlts(cfgSeq(cfgSlot, cfgBuiltinTerminal(AP_INTEGER), cfgSlot))), cfgRule(cfgLHS(__int32), cfgAlts(cfgSeq(cfgSlot, cfgBuiltinTerminal(SIGNED_INTEGER), cfgSlot))), cfgRule(cfgLHS(__realAP), cfgAlts(cfgSeq(cfgSlot, cfgBuiltinTerminal(AP_REAL), cfgSlot))), cfgRule(cfgLHS(__real64), cfgAlts(cfgSeq(cfgSlot, cfgBuiltinTerminal(SIGNED_REAL), cfgSlot))), cfgRule(cfgLHS(__string), cfgAlts(cfgSeq(cfgSlot, cfgBuiltinTerminal(STRING_DQ), cfgSlot))), cfgRule(cfgLHS(ID), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgBuiltinTerminal(ID)), cfgSlot))), cfgRule(cfgLHS(IDSTAR), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(ID), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(*)), cfgSlot))), cfgRule(cfgLHS(STRING_SQ), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgBuiltinTerminal(STRING_SQ)), cfgSlot))), cfgRule(cfgLHS(STRING_DQ), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgBuiltinTerminal(STRING_DQ)), cfgSlot))), cfgRule(cfgLHS(STRING_DOLLAR), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgBuiltinTerminal(STRING_DOLLAR)), cfgSlot))), cfgRule(cfgLHS(STRING_SHRIEK_SHRIEK), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgBuiltinTerminal(STRING_SHRIEK_SHRIEK)), cfgSlot))), cfgRule(cfgLHS(STRING_BRACE), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgBuiltinTerminal(STRING_BRACE)), cfgSlot))), cfgRule(cfgLHS(CHAR_BQ), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgBuiltinTerminal(CHAR_BQ)), cfgSlot))))";
  private final String scriptParserTermString = "rules(directive(!clear(chooseRules)), directive(!parser(gll)), directive(!whitespace(cfgBuiltinTerminal(SIMPLE_WHITESPACE), cfgBuiltinTerminal(COMMENT_NEST_ART), cfgBuiltinTerminal(COMMENT_LINE_C))), chooseLexical(chooseExpr(cfgCaseSensitiveTerminal(true)), chooseHigher, chooseExpr(cfgBuiltinTerminal(ID))), chooseLexical(chooseExpr(cfgCaseSensitiveTerminal(false)), chooseHigher, chooseExpr(cfgBuiltinTerminal(ID))), cfgRule(cfgLHS(rules), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(rule), cfgSlot, cfgFoldUnder(cfgNonterminal(rules)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(rule), cfgSlot))), cfgRule(cfgLHS(rule), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgRule)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(trRule)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(chooseRule)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(directive)), cfgSlot))), cfgRule(cfgLHS(cfgRule), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgLHS), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\:\\:=)), cfgSlot, cfgNonterminal(cfgAlts), cfgSlot))), cfgRule(cfgLHS(cfgLHS), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(ID), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(ID), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(<)), cfgSlot, cfgNonterminal(cfgAttributeDeclarations), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(>)), cfgSlot))), cfgRule(cfgLHS(cfgAttributeDeclarations), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgAttributeDeclaration), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgAttributeDeclaration), cfgSlot, cfgFoldUnder(cfgNonterminal(cfgAttributeDeclarations)), cfgSlot))), cfgRule(cfgLHS(cfgAttributeDeclaration), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(ID), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\:)), cfgSlot, cfgNonterminal(ID), cfgSlot))), cfgRule(cfgLHS(cfgAlts), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgAlt), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(|)), cfgSlot, cfgFoldUnder(cfgNonterminal(cfgAlts)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgAlt), cfgSlot))), cfgRule(cfgLHS(cfgAlt), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgSeq)), cfgSlot, cfgNonterminal(cfgActions), cfgSlot, cfgNonterminal(cfgEpsilonCarrier), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgSeq)), cfgSlot, cfgNonterminal(cfgActions), cfgSlot, cfgNonterminal(cfgEpsilon), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgSeq)), cfgSlot, cfgFoldUnder(cfgNonterminal(cfgElems)), cfgSlot, cfgNonterminal(cfgActions), cfgSlot))), cfgRule(cfgLHS(cfgEpsilonCarrier), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgEpsilon), cfgSlot, cfgFoldOver(cfgNonterminal(cfgAnnotation)), cfgSlot))), cfgRule(cfgLHS(cfgEpsilon), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(#)), cfgSlot))), cfgRule(cfgLHS(cfgAltNoAction), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgSeq)), cfgSlot, cfgNonterminal(cfgSlot), cfgSlot, cfgNonterminal(cfgName), cfgSlot, cfgNonterminal(cfgSlot), cfgSlot))), cfgRule(cfgLHS(cfgElems), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgActions), cfgSlot, cfgNonterminal(cfgExtended), cfgSlot, cfgFoldUnder(cfgNonterminal(cfgElems)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgActions), cfgSlot, cfgNonterminal(cfgExtended), cfgSlot))), cfgRule(cfgLHS(cfgExtended), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgName), cfgSlot, cfgFoldOver(cfgNonterminal(cfgAnnotation)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgName)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgOptional)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgKleene)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgPositive)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgDoFirst)), cfgSlot))), cfgRule(cfgLHS(cfgAnnotation), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgFoldUnder)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgFoldOver)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgFoldTear)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgFoldTearNamed)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgDelay)), cfgSlot))), cfgRule(cfgLHS(cfgFoldUnder), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(^)), cfgSlot))), cfgRule(cfgLHS(cfgFoldOver), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(^^)), cfgSlot))), cfgRule(cfgLHS(cfgFoldTear), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(^^^)), cfgSlot))), cfgRule(cfgLHS(cfgFoldTearNamed), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(^^^)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\:)), cfgSlot, cfgNonterminal(ID), cfgSlot))), cfgRule(cfgLHS(cfgDelay), cfgAlts(cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(!<), cfgSlot))), cfgRule(cfgLHS(cfgDoFirst), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\()), cfgSlot, cfgNonterminal(cfgAlts), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\))), cfgSlot))), cfgRule(cfgLHS(cfgOptional), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\()), cfgSlot, cfgNonterminal(cfgAlts), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\))), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(?)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgAltNoAction), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(?)), cfgSlot))), cfgRule(cfgLHS(cfgPositive), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\()), cfgSlot, cfgNonterminal(cfgAlts), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\))), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(+)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgAltNoAction), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(+)), cfgSlot))), cfgRule(cfgLHS(cfgKleene), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\()), cfgSlot, cfgNonterminal(cfgAlts), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\))), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(*)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgAltNoAction), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(*)), cfgSlot))), cfgRule(cfgLHS(cfgName), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgPrim)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgPrim), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\:)), cfgSlot, cfgNonterminal(ID), cfgSlot))), cfgRule(cfgLHS(cfgPrim), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgNonterminal)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgCaseSensitiveTerminal)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgCaseInsensitiveTerminal)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgBuiltinTerminal)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgBuiltinNoWSTerminal)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgCharacterTerminal)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgCharacterSetTerminal)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgCharacterAntiSetTerminal)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgCharacterOutOfBand)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgStartOfString)), cfgSlot))), cfgRule(cfgLHS(cfgNonterminal), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(ID), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(STRING_DOLLAR), cfgSlot))), cfgRule(cfgLHS(cfgCaseSensitiveTerminal), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(STRING_SQ), cfgSlot))), cfgRule(cfgLHS(cfgCaseInsensitiveTerminal), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(STRING_DQ), cfgSlot))), cfgRule(cfgLHS(cfgBuiltinTerminal), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(&)), cfgSlot, cfgNonterminal(ID), cfgSlot))), cfgRule(cfgLHS(cfgBuiltinNoWSTerminal), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(&&)), cfgSlot, cfgNonterminal(ID), cfgSlot))), cfgRule(cfgLHS(cfgCharacterTerminal), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(CHAR_BQ), cfgSlot))), cfgRule(cfgLHS(cfgCharacterSetTerminal), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(STRING_BRACE), cfgSlot))), cfgRule(cfgLHS(cfgCharacterAntiSetTerminal), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(~)), cfgSlot, cfgNonterminal(STRING_BRACE), cfgSlot))), cfgRule(cfgLHS(cfgCharacterOutOfBand), cfgAlts(cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(~!{}), cfgSlot))), cfgRule(cfgLHS(cfgStartOfString), cfgAlts(cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(!$$), cfgSlot))), cfgRule(cfgLHS(cfgPrims), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgPrim), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgPrim), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\,)), cfgSlot, cfgFoldUnder(cfgNonterminal(cfgPrims)), cfgSlot))), cfgRule(cfgLHS(cfgActions), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgSlot)), cfgSlot, cfgFoldUnder(cfgNonterminal(cfgActionSeq)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgSlot)), cfgSlot))), cfgRule(cfgLHS(cfgActionSeq), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgAction), cfgSlot, cfgFoldUnder(cfgNonterminal(cfgActionSeq)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgAction), cfgSlot))), cfgRule(cfgLHS(cfgAction), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgEquation)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgAssignment)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgNative)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgInsert)), cfgSlot))), cfgRule(cfgLHS(cfgEquation), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgAttribute), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(=)), cfgSlot, cfgNonterminal(cfgExpression), cfgSlot))), cfgRule(cfgLHS(cfgAssignment), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgAttribute), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\:=)), cfgSlot, cfgNonterminal(cfgExpression), cfgSlot))), cfgRule(cfgLHS(cfgNative), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(STRING_SHRIEK_SHRIEK), cfgSlot))), cfgRule(cfgLHS(cfgInsert), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(^+\\:)), cfgSlot, cfgNonterminal(ID), cfgSlot))), cfgRule(cfgLHS(cfgAttribute), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(ID), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(ID), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(.)), cfgSlot, cfgNonterminal(ID), cfgSlot))), cfgRule(cfgLHS(cfgExpressionList), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgExpression), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgExpression), cfgSlot, cfgFoldUnder(cfgNonterminal(cfgExpressionList)), cfgSlot))), cfgRule(cfgLHS(cfgExpression), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(__bool)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(__intAP)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(__int32)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(__realAP)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(__real64)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(__string)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(__char)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgAttribute)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(ID)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(ID)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\()), cfgSlot, cfgFoldUnder(cfgNonterminal(cfgExpressionList)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\))), cfgSlot))), cfgRule(cfgLHS(cfgSeq), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgEpsilon)))), cfgRule(cfgLHS(cfgSlot), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgEpsilon)))), cfgRule(cfgLHS(trRule), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(trLabel), cfgSlot, cfgNonterminal(tr), cfgSlot))), cfgRule(cfgLHS(trLabel), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgEpsilon)), cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(-)), cfgSlot, cfgNonterminal(ID), cfgSlot))), cfgRule(cfgLHS(tr), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(trPremises), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(---)), cfgSlot, cfgNonterminal(trTransition), cfgSlot))), cfgRule(cfgLHS(trPremises), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgEpsilon)), cfgSeq(cfgSlot, cfgNonterminal(trMatch), cfgSlot, cfgFoldUnder(cfgNonterminal(trPremises)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(trTransition), cfgSlot, cfgFoldUnder(cfgNonterminal(trPremises)), cfgSlot))), cfgRule(cfgLHS(trMatch), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(trTopTuple), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(|>)), cfgSlot, cfgNonterminal(trTopTuple), cfgSlot))), cfgRule(cfgLHS(trTransition), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(trTopTuple), cfgSlot, cfgFoldUnder(cfgNonterminal(trRelation)), cfgSlot, cfgNonterminal(trTopTuple), cfgSlot))), cfgRule(cfgLHS(trTopTuple), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(trTerm), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(trTuple)), cfgSlot, cfgNonterminal(trTerm), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\,)), cfgSlot, cfgFoldUnder(cfgNonterminal(trTerms)), cfgSlot))), cfgRule(cfgLHS(trTuple), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgEpsilon)))), cfgRule(cfgLHS(trTerms), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(trTerm), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(trTerm), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\,)), cfgSlot, cfgFoldUnder(cfgNonterminal(trTerms)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(trTerm), cfgSlot, cfgFoldUnder(cfgNonterminal(trTerms)), cfgSlot))), cfgRule(cfgLHS(trTerm), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(__bool)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(__char)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(__intAP)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(__int32)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(__realAP)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(__real64)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(__string)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(__array)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(__list)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(__set)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(__map)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(ID)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(IDSTAR)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(ID)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\()), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\))), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(ID)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\()), cfgSlot, cfgFoldUnder(cfgNonterminal(trTerms)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\))), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(trTuple)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(<)), cfgSlot, cfgFoldUnder(cfgNonterminal(trTerms)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(>)), cfgSlot))), cfgRule(cfgLHS(__array), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal([)), cfgSlot, cfgNonterminal(__int32), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(|)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(])), cfgSlot), cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal([)), cfgSlot, cfgNonterminal(__int32), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(|)), cfgSlot, cfgNonterminal(__a), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(])), cfgSlot))), cfgRule(cfgLHS(__a), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(trTerm), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(trTerm), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\,)), cfgSlot, cfgNonterminal(__a), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(trTerm), cfgSlot, cfgNonterminal(__a), cfgSlot))), cfgRule(cfgLHS(__list), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal([)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(])), cfgSlot), cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal([)), cfgSlot, cfgNonterminal(__l), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(])), cfgSlot))), cfgRule(cfgLHS(__l), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(trTerm), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(trTerm), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\,)), cfgSlot, cfgNonterminal(__l), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(trTerm), cfgSlot, cfgNonterminal(__l), cfgSlot))), cfgRule(cfgLHS(__set), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal({)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(})), cfgSlot), cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal({)), cfgSlot, cfgNonterminal(__s), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(})), cfgSlot))), cfgRule(cfgLHS(__s), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(trTerm), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(trTerm), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\,)), cfgSlot, cfgNonterminal(__s), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(trTerm), cfgSlot, cfgNonterminal(__s), cfgSlot))), cfgRule(cfgLHS(__map), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal({)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(=)), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(})), cfgSlot), cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal({)), cfgSlot, cfgNonterminal(__m), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(})), cfgSlot))), cfgRule(cfgLHS(__m), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(trTerm), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(=)), cfgSlot, cfgNonterminal(trTerm), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(trTerm), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(=)), cfgSlot, cfgNonterminal(trTerm), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\,)), cfgSlot, cfgNonterminal(__m), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(trTerm), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(=)), cfgSlot, cfgNonterminal(trTerm), cfgSlot, cfgNonterminal(__m), cfgSlot))), cfgRule(cfgLHS(trRelation), cfgAlts(cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(->), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(=>), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(~>), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(\\:->), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(\\:=>), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(\\:~>), cfgSlot))), cfgRule(cfgLHS(chooseRule), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(chooseDerivation)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(chooseLexical)), cfgSlot))), cfgRule(cfgLHS(chooseDerivation), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(chooseDerivationProduction), cfgSlot, cfgNonterminal(chooserOp), cfgSlot, cfgNonterminal(chooseDerivationProduction), cfgSlot))), cfgRule(cfgLHS(chooseDerivationProduction), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgNonterminal), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\:\\:=)), cfgSlot, cfgFoldUnder(cfgNonterminal(chooseEpsilonRHS)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgNonterminal), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\:\\:=)), cfgSlot, cfgFoldUnder(cfgNonterminal(chooseDerivationProductionRHS)), cfgSlot))), cfgRule(cfgLHS(chooseEpsilonRHS), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgEpsilon), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(.), cfgSlot, cfgNonterminal(cfgEpsilon), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgEpsilon), cfgSlot, cfgCaseSensitiveTerminal(.), cfgSlot))), cfgRule(cfgLHS(chooseDerivationProductionRHS), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgPrim), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(.), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgPrim), cfgSlot, cfgFoldUnder(cfgNonterminal(chooseDerivationProductionRHS)), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(.), cfgSlot, cfgFoldUnder(cfgNonterminal(chooseDerivationProductionRHS)), cfgSlot))), cfgRule(cfgLHS(chooseLexical), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(chooseExpr), cfgSlot, cfgNonterminal(chooserOp), cfgSlot, cfgNonterminal(chooseExpr), cfgSlot))), cfgRule(cfgLHS(chooseExpr), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgNonterminal(chooseElement)), cfgSlot), cfgSeq(cfgSlot, cfgFoldUnder(cfgNonterminal(chooseElement)), cfgSlot, cfgFoldUnder(cfgNonterminal(chooseExprTail)), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(chooseSet), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(chooseSet), cfgSlot, cfgFoldUnder(cfgNonterminal(chooseExprTail)), cfgSlot))), cfgRule(cfgLHS(chooseExprTail), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(chooseCarrier), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(chooseCarrier), cfgSlot, cfgFoldUnder(cfgNonterminal(chooseExprTail)), cfgSlot))), cfgRule(cfgLHS(chooseCarrier), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(chooseAdd)), cfgSlot, cfgFoldUnder(cfgNonterminal(chooseElement)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(chooseRemove)), cfgSlot, cfgFoldUnder(cfgNonterminal(chooseElement)), cfgSlot))), cfgRule(cfgLHS(chooseElement), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(cfgNonterminal), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgCharacterTerminal), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgBuiltinTerminal), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgCaseInsensitiveTerminal), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(cfgCaseSensitiveTerminal), cfgSlot))), cfgRule(cfgLHS(chooseSet), cfgAlts(cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(anyCharacterTerminal), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(anyBuiltinTerminal), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(anyCaseSensitiveTerminal), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(anyCaseInsensitiveTerminal), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(anyTerminal), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(anyParaterminal), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(anyNonterminal), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(anySlot), cfgSlot))), cfgRule(cfgLHS(chooserOp), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(chooseHigher)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(chooseLower)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(chooseLonger)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(chooseShorter)), cfgSlot))), cfgRule(cfgLHS(chooseHigher), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(>)), cfgSlot))), cfgRule(cfgLHS(chooseLower), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(<)), cfgSlot))), cfgRule(cfgLHS(chooseLonger), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(>>)), cfgSlot))), cfgRule(cfgLHS(chooseShorter), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(<<)), cfgSlot))), cfgRule(cfgLHS(chooseAdd), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(+)), cfgSlot))), cfgRule(cfgLHS(chooseRemove), cfgAlts(cfgSeq(cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(-)), cfgSlot))), cfgRule(cfgLHS(directive), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(directiveCarrier), cfgSlot))), cfgRule(cfgLHS(directiveCarrier), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!prompt)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!prompt)), cfgSlot, cfgBuiltinTerminal(STRING_DQ), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!traceLevel)), cfgSlot, cfgNonterminal(__int32), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!errorLevel)), cfgSlot, cfgNonterminal(__int32), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!print)), cfgSlot, cfgFoldUnder(cfgNonterminal(trTerms)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!show)), cfgSlot, cfgFoldUnder(cfgNonterminal(trTerms)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!clear)), cfgSlot, cfgFoldUnder(cfgNonterminal(IDs)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!save)), cfgSlot, cfgNonterminal(ID), cfgSlot, cfgNonterminal(ID), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!recall)), cfgSlot, cfgNonterminal(ID), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!convert)), cfgSlot, cfgFoldUnder(cfgNonterminal(IDs)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!characterSet)), cfgSlot, cfgNonterminal(cfgCharacterSetTerminal), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!token)), cfgSlot, cfgFoldUnder(cfgNonterminal(cfgPrims)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!whitespace)), cfgSlot, cfgFoldUnder(cfgNonterminal(cfgPrims)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!paraterminal)), cfgSlot, cfgFoldUnder(cfgNonterminal(paraterminalElements)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!configuration)), cfgSlot, cfgNonterminal(trRelation), cfgSlot, cfgNonterminal(configurationElements), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!final)), cfgSlot, cfgNonterminal(trRelation), cfgSlot, cfgNonterminal(trTerms), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!lexer)), cfgSlot, cfgNonterminal(ID), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!parser)), cfgSlot, cfgNonterminal(ID), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!interpreter)), cfgSlot, cfgNonterminal(ID), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!generate)), cfgSlot, cfgNonterminal(__int32), cfgSlot, cfgNonterminal(ID), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!generate)), cfgSlot, cfgNonterminal(ID), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!support)), cfgSlot, cfgNonterminal(cfgNative), cfgSlot, cfgNonterminal(cfgNative), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!mode)), cfgSlot, cfgFoldUnder(cfgNonterminal(modes)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!start)), cfgSlot, cfgNonterminal(cfgNonterminal), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!start)), cfgSlot, cfgNonterminal(trRelation), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!try)), cfgSlot, cfgNonterminal(file), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!try)), cfgSlot, cfgNonterminal(file), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(=)), cfgSlot, cfgNonterminal(trTopTuple), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!try)), cfgSlot, cfgNonterminal(trTopTuple), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!try)), cfgSlot, cfgNonterminal(trTopTuple), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(=)), cfgSlot, cfgNonterminal(trTopTuple), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!deleteTokens)), cfgSlot, cfgNonterminal(__int32), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!swapTokens)), cfgSlot, cfgNonterminal(__int32), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!sppfBreakCycles)), cfgSlot), cfgSeq(cfgSlot, cfgFoldOver(cfgCaseSensitiveTerminal(!sppfBreakCyclesRelation)), cfgSlot))), cfgRule(cfgLHS(file), cfgAlts(cfgSeq(cfgSlot, cfgBuiltinTerminal(STRING_SQ), cfgSlot))), cfgRule(cfgLHS(IDs), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(ID), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(ID), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\,)), cfgSlot, cfgFoldUnder(cfgNonterminal(IDs)), cfgSlot))), cfgRule(cfgLHS(modes), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(ID), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(ID), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\,)), cfgSlot, cfgFoldUnder(cfgNonterminal(modes)), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(not), cfgSlot, cfgNonterminal(ID), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(not), cfgSlot, cfgNonterminal(ID), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\,)), cfgSlot, cfgFoldUnder(cfgNonterminal(modes)), cfgSlot))), cfgRule(cfgLHS(configurationElements), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(configurationElement), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(configurationElement), cfgSlot, cfgFoldUnder(cfgNonterminal(configurationElements)), cfgSlot))), cfgRule(cfgLHS(configurationElement), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(ID), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\:\\:)), cfgSlot, cfgNonterminal(ID), cfgSlot))), cfgRule(cfgLHS(paraterminalElements), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(paraterminalElement), cfgSlot), cfgSeq(cfgSlot, cfgNonterminal(paraterminalElement), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(\\,)), cfgSlot, cfgFoldUnder(cfgNonterminal(paraterminalElements)), cfgSlot))), cfgRule(cfgLHS(paraterminalElement), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgNonterminal(cfgNonterminal)), cfgSlot))), cfgRule(cfgLHS(__bool), cfgAlts(cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(true), cfgSlot), cfgSeq(cfgSlot, cfgCaseSensitiveTerminal(false), cfgSlot))), cfgRule(cfgLHS(__char), cfgAlts(cfgSeq(cfgSlot, cfgBuiltinTerminal(CHAR_BQ), cfgSlot))), cfgRule(cfgLHS(__intAP), cfgAlts(cfgSeq(cfgSlot, cfgBuiltinTerminal(AP_INTEGER), cfgSlot))), cfgRule(cfgLHS(__int32), cfgAlts(cfgSeq(cfgSlot, cfgBuiltinTerminal(SIGNED_INTEGER), cfgSlot))), cfgRule(cfgLHS(__realAP), cfgAlts(cfgSeq(cfgSlot, cfgBuiltinTerminal(AP_REAL), cfgSlot))), cfgRule(cfgLHS(__real64), cfgAlts(cfgSeq(cfgSlot, cfgBuiltinTerminal(SIGNED_REAL), cfgSlot))), cfgRule(cfgLHS(__string), cfgAlts(cfgSeq(cfgSlot, cfgBuiltinTerminal(STRING_DQ), cfgSlot))), cfgRule(cfgLHS(ID), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgBuiltinTerminal(ID)), cfgSlot))), cfgRule(cfgLHS(IDSTAR), cfgAlts(cfgSeq(cfgSlot, cfgNonterminal(ID), cfgSlot, cfgFoldUnder(cfgCaseSensitiveTerminal(*)), cfgSlot))), cfgRule(cfgLHS(STRING_SQ), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgBuiltinTerminal(STRING_SQ)), cfgSlot))), cfgRule(cfgLHS(STRING_DQ), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgBuiltinTerminal(STRING_DQ)), cfgSlot))), cfgRule(cfgLHS(STRING_DOLLAR), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgBuiltinTerminal(STRING_DOLLAR)), cfgSlot))), cfgRule(cfgLHS(STRING_SHRIEK_SHRIEK), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgBuiltinTerminal(STRING_SHRIEK_SHRIEK)), cfgSlot))), cfgRule(cfgLHS(STRING_BRACE), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgBuiltinTerminal(STRING_BRACE)), cfgSlot))), cfgRule(cfgLHS(CHAR_BQ), cfgAlts(cfgSeq(cfgSlot, cfgFoldOver(cfgBuiltinTerminal(CHAR_BQ)), cfgSlot))))";
  //@formatter:on

  private final AbstractParser scriptParser = new GLLBaseLine(true);
  private final AbstractLexer scriptLexer = new LexerBaseLine();
  private final int scriptParserTerm; // This received the derivation from scriptParser
  private final Map<String, ScriptValue> scriptVariables = new HashMap<>();
  private final int scriptDerivationTerm;
  private final TermTraverser scriptTraverser;

  private final Set<String> validModes = Set.of("recogniser", "hashpool", "mgll", "tasklifo", "taskfifo", "productionlookahead", "mglllookahead",
      "returnlookahead", "derivationtrim");
  public final static Set<String> currentModes = new HashSet<>();
  private AbstractLexer currentLexer = new LexerBaseLine();
  private AbstractParser currentParser = new GLLModal();
  private final Rewriter currentRewriter = new Rewriter();
  private AbstractInterpreter currentInterpreter = null;

  public static CFGRules scriptCFGRules;
  public static CFGRules currentCFGRules; // scriptTraverser builds CFG rules into this grammar
  public static ChooseRules currentChooseRules = new ChooseRules();
  public static TRRules currentTRRules = new TRRules();

  private int currentTryTerm = 0;
  private int currentIndexedTryTerm = 0;
  private int currentRewriteTerm = 0;

  private int currentConfiguration;
  public static boolean seenChooseRule = false;
  public static Statistics currentStatistics = new Statistics();

  Scanner keyboard = new Scanner(System.in);

  int successfulTests = 0;
  int failedTests = 0;

  public ScriptInterpreter(String scriptString) {
    iTerms.plainTextTraverser = initialisePlainTextTraverser(); // Set up plain pretty printer actions
    iTerms.latexTraverser = initialiseLaTeXTraverser(); // Set up LaTeX pretty printer actions
    scriptTraverser = initialiseScriptTraverser(); // Set up script interpetation actions
    scriptParserTerm = iTerms.findTerm(scriptParserTermString); // Construct a term from the script grammar's text term

    // Bootstrap in action: build the script parser's grammar by traversing the scriptParserTerm and normalising, then making the result the script parser
    currentCFGRules = new CFGRules(CFGRulesKind.SCRIPT);
    scriptTraverser.traverse(scriptParserTerm); // Construct the script parser grammar by walking the script parser term from the last bootstrap
    normalise();
    scriptCFGRules = currentCFGRules; // Now we have a usable script parser

    currentCFGRules = new CFGRules(CFGRulesKind.USER);
    Util.traceLevel = 0;
    Util.errorLevel = 1;
    scriptParser.parse(scriptString, scriptCFGRules, scriptLexer, null);
    // Util.debug("Script lexicalisation:\n");
    // scriptParser.lexer.print(System.out, iTerms.rawTextTraverser, false, false, false);
    // Util.debug("Script derivations:\n");
    // scriptParser.derivations.print(System.out, iTerms.rawTextTraverser, false, false, true);
    scriptParser.outcomeReport();
    scriptParser.derivations.numberNodes();
    if (scriptParser.derivations.ambiguityCheck()) {
      Util.errorLevel = 10;
      Util.error("Script ambiguity");
      scriptParser.derivations.ambiguityCheck(); // Run again to show actual ambiguities
      Util.fatal("Internal error");
    }
    scriptDerivationTerm = scriptParser.derivations.derivationAsTerm();
    if (!scriptParser.inLanguage) return;
    // Util.debug("Script term:\n" + iTerms.toRawString(scriptDerivationTerm));
    Util.traceLevel = Util.errorLevel = 3;
    scriptTraverser.traverse(scriptDerivationTerm);
    if (successfulTests != 0 || failedTests != 0) Util.info("Successful tests: " + successfulTests + "; failed tests " + failedTests);
  }

  private void normalise() {
    currentCFGRules.normalise();
    currentChooseRules.normalise();
    currentTRRules.normalise();
  }

  private TermTraverserText initialiseScriptTraverser() {
    TermTraverserText ret = new TermTraverserText(iTerms, "ART Script traverser");

    ret.addActionBreak("directive", (Integer t) -> directiveAction(t), null, null);

    ret.addActionBreak("cfgLHS", (Integer t) -> currentCFGRules.actionLHS(childSymbolString(t)), null, null);
    ret.addAction("cfgAttributeDeclaration", (Integer t) -> currentCFGRules.actionAttribute(childSymbolString(t), childSymbolString1(t)), null, null);
    ret.addAction("cfgSeq", (Integer t) -> currentCFGRules.actionALT(), null, (Integer t) -> currentCFGRules.actionEND(""));

    ret.addAction("cfgEpsilon", (Integer t) -> currentCFGRules.actionSEQ(CFGElementKind.EPSILON, "#", t), null, null);
    ret.addActionBreak("cfgNonterminal", (Integer t) -> currentCFGRules.actionSEQ(CFGElementKind.NONTERMINAL, childSymbolString(t), t), null, null);
    ret.addActionBreak("cfgCaseSensitiveTerminal", (Integer t) -> currentCFGRules.actionSEQ(CFGElementKind.TRM_CS, childSymbolString(t), t), null, null);
    ret.addActionBreak("cfgBuiltinTerminal", (Integer t) -> currentCFGRules.actionSEQ(CFGElementKind.TRM_BI, childSymbolString(t), t), null, null);

    ret.addActionBreak("cfgCharacterTerminal", (Integer t) -> currentCFGRules.actionSEQ(CFGElementKind.TRM_CH, childSymbolString(t), t), null, null);
    ret.addActionBreak("cfgCharacterSetTerminal", (Integer t) -> currentCFGRules.actionSEQ(CFGElementKind.TRM_CH_SET, childSymbolString(t), t), null, null);
    ret.addActionBreak("cfgCharacterAntiSetTerminal", (Integer t) -> currentCFGRules.actionSEQ(CFGElementKind.TRM_CH_ANTI_SET, childSymbolString(t), t), null,
        null);
    ret.addActionBreak("cfgCharacterOutOfBand", (Integer t) -> currentCFGRules.actionSEQ(CFGElementKind.TRM_CH_UOB, "!{}", t), null, null);
    ret.addActionBreak("cfgStartOfString", (Integer t) -> currentCFGRules.actionSEQ(CFGElementKind.SOS, "$$", t), null, null);

    ret.addAction("cfgDoFirst", (Integer t) -> currentCFGRules.actionSEQ(CFGElementKind.PAR, currentCFGRules.nextUniqueLabel(), t), null, null);
    ret.addAction("cfgOptional", (Integer t) -> currentCFGRules.actionSEQ(CFGElementKind.OPT, currentCFGRules.nextUniqueLabel(), t), null, null);
    ret.addAction("cfgKleene", (Integer t) -> currentCFGRules.actionSEQ(CFGElementKind.KLN, currentCFGRules.nextUniqueLabel(), t), null, null);
    ret.addAction("cfgPositive", (Integer t) -> currentCFGRules.actionSEQ(CFGElementKind.POS, currentCFGRules.nextUniqueLabel(), t), null, null);

    // Note - folds can only be applied to primitives, so why not ditch the working fold and just apply directly postorder - see delay below for model
    ret.addAction("cfgFoldNone", (Integer t) -> currentCFGRules.workingFold = GIFTKind.NONE, null, null);
    ret.addAction("cfgFoldUnder", (Integer t) -> currentCFGRules.workingFold = GIFTKind.UNDER, null, null);
    ret.addAction("cfgFoldOver", (Integer t) -> currentCFGRules.workingFold = GIFTKind.OVER, null, null);
    ret.addAction("cfgFoldTear", (Integer t) -> currentCFGRules.workingFold = GIFTKind.TEAR, null, null);

    ret.addAction("cfgDelay", null, null, (Integer t) -> currentCFGRules.workingNode.delayed = true); // On the way out - can only be applied to primitives

    ret.addAction("cfgSlot", (Integer t) -> currentCFGRules.workingNode.actionAsTerm = t, null, null);

    ret.addActionBreak("chooseDerivation", (Integer t) -> currentChooseRules.addDerivationChooseRule(t), null, null);
    ret.addActionBreak("chooseLexical", (Integer t) -> currentChooseRules.addLexicalChooseRule(t), null, null);

    ret.addAction("trRule", (Integer t) -> currentTRRules.buildTRRule(t), null, null);
    return ret;
  }

  private String childSymbolString(int t) {
    return Util.unescapeString(iTerms.termSymbolString(iTerms.subterm(t, 0)));
  }

  private String childSymbolString1(int t) {
    return Util.unescapeString(iTerms.termSymbolString(iTerms.subterm(t, 1)));
  }

  private void directiveAction(int term) {
    // Util.debug("Evaluating directive !" + iTerms.toString(iTerms.subterm(term, 0)));
    int operationTerm = iTerms.subterm(term, 0);
    switch (iTerms.termSymbolString(operationTerm)) {

    case "!prompt":
      if (iTerms.termArity(iTerms.subterm(term, 0)) == 0)
        System.out.print("\n*** Press return to continue");
      else
        System.out.print("\n" + iTerms.termSymbolString(iTerms.subterm(term, 0, 0)));
      keyboard.nextLine();
      break;

    case "!print", "!show":
      normalise();
      processDisplayElements(operationTerm);
      break;

    case "!traceLevel":
      Util.traceLevel = iTerms.termToJavaInteger(iTerms.subterm(term, 0, 0));
      // Util.debug("Trace level set to " + Util.traceLevel);
      break;

    case "!errorLevel":
      Util.errorLevel = iTerms.termToJavaInteger(iTerms.subterm(term, 0, 0));
      // Util.debug("Error level set to " + Util.traceLevel);
      break;

    case "!clear":
      for (int i = 0; i < iTerms.termArity(iTerms.subterm(term, 0)); i++) {
        String argument = iTerms.termSymbolString(iTerms.subterm(term, 0, i)).toLowerCase();
        // Util.debug("Processing !clear " + argument);
        switch (argument) {
        case "allrules":
          currentCFGRules = new CFGRules(CFGRulesKind.USER);
          currentChooseRules = new ChooseRules();
          currentTRRules = new TRRules();
          break;
        case "cfgrules":
          currentCFGRules = new CFGRules(CFGRulesKind.USER);
          break;
        case "chooserules":
          seenChooseRule = true;
          currentChooseRules = new ChooseRules();
          break;
        case "trrules":
          currentTRRules = new TRRules();
          break;
        case "statistics":
          currentStatistics = new Statistics();
          break;
        case "whitespace":
          currentCFGRules.seenWhitespaceDirective = true;
          currentCFGRules.whitespaces.clear();
          break;
        default:
          Util.fatal("Unknown !clear argument " + argument + "\nmust be one of (case insensitive): allRules cfgRules choseRulesrewriteRules whitespace mode");
        }
      }
      normalise();
      break;

    case "!lexer":
      switch (iTerms.termSymbolString(iTerms.subterm(term, 0, 0)).toLowerCase()) {
      case "baseline":
        currentLexer = new LexerBaseLine();
        break;
      case "gllrecogniser":
        currentLexer = new LexerGLLRecogniser();
        break;
      default:
        Util.fatal(
            "Unexpected !lexer argument " + iTerms.toString(iTerms.subterm(term, 0, 0)) + "\nmust be one of (case insensitive): baseline  gllRecogniser\n");
      }
      break;

    case "!parser":
      switch (iTerms.termSymbolString(iTerms.subterm(term, 0, 0)).toLowerCase()) {
      case "algx":
        currentParser = new AlgX();
        break;
      case "cyk":
        currentParser = new CYK();
        break;
      case "rdsobfunction":
        currentParser = new RDSOBFunction();
        break;
      case "rdsobexplicitstack":
        currentParser = new RDSOBExplicitStack();
        break;

      case "gllhashpool":
        currentParser = new GLLHashPool();
        break;
      case "gllBaseline":
        currentParser = new GLLBaseLine(false);
        break;
      case "mgllBaseline":
        currentParser = new GLLBaseLine(true);
        break;
      case "gllmodal":
        currentParser = new GLLModal();
        break;
      case "gll":
        currentModes.remove("mgll");
        currentModes.remove("recogniser");
        currentParser = new GLLModal();
        break;
      case "mgll":
        currentModes.add("mgll");
        currentModes.remove("recogniser");
        currentParser = new GLLModal();
        break;
      case "gllrecogniser":
        currentModes.remove("mgll");
        currentModes.add("recogniser");
        currentParser = new GLLModal();
        break;
      case "mgllrecogniser":
        currentModes.add("mgll");
        currentModes.add("recogniser");
        currentParser = new GLLModal();
        break;

      default:
        Util.fatal("Unexpected !parser argument " + iTerms.toString(iTerms.subterm(term, 0, 0))
            + "\nmust be one of (case insensitive): algx cyk gll mgll rdsobfunction rdsobexplicitstack");
      }
      break;

    case "!interpreter":
      switch (iTerms.termSymbolString(iTerms.subterm(term, 0, 0)).toLowerCase()) {
      case "attributeaction":
        currentInterpreter = new AttributeActionInterpreter();
        break;
      default:
        Util.fatal(
            "Unexpected !interpreter argument " + iTerms.toString(iTerms.subterm(term, 0, 0)) + "\nmust be one of (case insensitive): attributeAction esos\n");
      }
      break;

    case "!mode":
      boolean removeMode = false;
      for (int i = 0; i < iTerms.termArity(iTerms.subterm(term, 0)); i++) {
        String modeArgument = iTerms.termSymbolString(iTerms.subterm(term, 0, i)).toLowerCase();
        if (modeArgument.equals("not")) {
          removeMode = true;
          continue;
        }
        if (!validModes.contains(modeArgument))
          Util.fatal("Unexpected !mode argument " + iTerms.toString(iTerms.subterm(term, 0, 0)) + "; must be one of (case insensitive):\n" + validModes);

        if (removeMode)
          currentModes.remove(modeArgument);
        else
          currentModes.add(modeArgument);

        removeMode = false;
      }
      break;

    case "!convert":
      normalise();
      switch (iTerms.termSymbolString(iTerms.subterm(term, 0, 0)).toLowerCase()) {
      case "cfgcharacterinline":
        currentCFGRules = new CFGRules(currentCFGRules, CFGRulesKind.USER, true, false, false, false);
        break;
      case "cfgcharacter":
        currentCFGRules = new CFGRules(currentCFGRules, CFGRulesKind.USER, true, true, false, false);
        break;
      case "cfgbnfleft":
        currentCFGRules = new CFGRules(currentCFGRules, CFGRulesKind.USER, false, false, true, false);
        break;
      case "cfgbnfright":
        currentCFGRules = new CFGRules(currentCFGRules, CFGRulesKind.USER, false, false, false, true);
        break;
      default:
        Util.fatal("Unexpected !convert argument " + iTerms.toString(iTerms.subterm(term, 0, 0))
            + "\nmust be one of (case insensitive): cfgCharacter cfgCharacterInline cfgbnfLeft cfgbnfRight\n");
      }
      break;

    case "!characters":
      for (var c : iTerms.termSymbolString(iTerms.subterm(term, 0, 0, 0)).toCharArray())
        currentCFGRules.characterSet.add(c);
      break;

    case "!whitespace":
      currentCFGRules.whitespaces.clear();
      currentCFGRules.seenWhitespaceDirective = true;
      for (int i = 0; i < iTerms.termArity(iTerms.subterm(term, 0)); i++)
        currentCFGRules.whitespaces.add(findCFGElement(iTerms.subterm(term, 0, i)));
      break;

    case "!token":
      for (int i = 0; i < iTerms.termArity(iTerms.subterm(term, 0)); i++)
        currentCFGRules.declaredAsTokens.add(findCFGElement(iTerms.subterm(term, 0, i)));
      break;

    case "!paraterminal":
      for (int i = 0; i < iTerms.termArity(iTerms.subterm(term, 0)); i++)
        currentCFGRules.paraterminals.add(findCFGElement(iTerms.subterm(term, 0, i)));
      break;

    case "!generate":
      normalise();
      switch (iTerms.termSymbolString(iTerms.subterm(term, 0, 0)).toLowerCase()) {
      case "rdsob":
        new RDSOBGenerator(currentCFGRules, "ARTGeneratedRDSOB");
        break;
      case "rdsoboracle":
        normalise();
        new RDSOBOracleGenerator(currentCFGRules);
        break;
      case "actions":
        normalise();
        if (iTerms.termArity(iTerms.subterm(term, 0)) == 1) new ActionsGenerator(currentCFGRules, currentCFGRules.filePrelude, currentCFGRules.classPrelude);
        break;
      case "__int32": { // sentence and sentential forms generator
        int count = iTerms.termToJavaInteger(iTerms.subterm(term, 0, 0));
        switch (iTerms.termSymbolString(iTerms.subterm(term, 0, 1)).toLowerCase()) {
        case "sentences":
          currentCFGRules.generate(count, true);
          break;
        case "sententialforms":
          currentCFGRules.generate(count, false);
          break;
        default:
          Util.fatal("Unexpected !generate <n> argument " + iTerms.toString(iTerms.subterm(term, 0, 0))
              + "\nmust be one of (case insensitive)\nsentences\nsententialforms");
          break;
        }
        break;
      }
      default:
        Util.fatal("Unexpected !generate argument " + iTerms.toString(iTerms.subterm(term, 0, 0))
            + "\nmust be one of (case insensitive)\nrdsob\nactions\n<count> sentences\n<count< sententialforms");
        break;
      }
      break;
    case "!support":
      currentCFGRules.filePrelude = iTerms.termSymbolString(iTerms.subterm(term, 0, 0, 0));
      currentCFGRules.classPrelude = iTerms.termSymbolString(iTerms.subterm(term, 0, 1, 0));
      break;

    case "!start":
      break;

    case "!configuration":
      currentTRRules.modifyConfiguration(iTerms.subterm(term, 0));
      break;

    case "!terminal":
      for (int i = 1; i < iTerms.termArity(iTerms.subterm(term, 0)); i++)
        currentTRRules.addTerminal(iTerms.subterm(term, 0, 0, 0), iTerms.termSymbolStringIndex(iTerms.subterm(term, 0, i)));
      break;

    case "!try":
      // Util.debug("processing try " + iTerms.toString(term));
      normalise();
      if (iTerms.termSymbolString(iTerms.subterm(term, 0, 0)).equals("file")) // Parse contents of file
        try {
          String filename = iTerms.termSymbolString(iTerms.subterm(term, 0, 0, 0));
          // Util.info("Attempting to open file " + filename);
          tryParse(filename, Files.readString(Paths.get(filename)));
        } catch (IOException e) {
          Util.fatal("Unable to open try file; skipping " + iTerms.toString(term));
        }
      else if (iTerms.termSymbolString(iTerms.subterm(term, 0, 0, 0)).equals("__string")) // Parse literal string
        tryParse("", Util.unescapeString(iTerms.termSymbolString(iTerms.subterm(term, 0, 0, 0, 0))));
      else
        currentTryTerm = iTerms.subterm(term, 0, 0); // No parsing - process term directly

      if (currentTryTerm != 0 && currentTRRules.defaultStartRelation != 0) {// if there is a term and some rules
        // if (!iTerms.hasSymbol(currentDerivationTerm, "trTopTuple")) currentDerivationTerm = iTerms.findTerm("trTopTuple", currentDerivationTerm); // augment
        currentTryTerm = currentTRRules.unelideConfiguration(currentTryTerm, currentTRRules.defaultStartRelation, true);

        currentRewriteTerm = currentRewriter.rewrite(currentTryTerm, currentTRRules); // Run the rewriter
        if (iTerms.termArity(iTerms.subterm(term, 0)) == 2) // There was a test term
          if (currentRewriteTerm == iTerms.subterm(term, 0, 1)) {
            Util.info("*** Successful test");
            successfulTests++;
          } else {
            Util.info("*** Failed test: expected " + iTerms.plainTextTraverser.toString(iTerms.subterm(term, 0, 1)));
            failedTests++;
          }
      }

      if (currentTryTerm != 0 && currentInterpreter != null) currentInterpreter.interpret(currentParser);
      break;

    case "!save": {
      normalise();
      String id = iTerms.termSymbolString(iTerms.subterm(term, 0, 1));
      switch (iTerms.termSymbolString(iTerms.subterm(term, 0, 0)).toLowerCase()) {
      case "cfgrules":
        scriptVariables.put(id, new ScriptValueCFGRules(currentCFGRules));
        break;
      case "trrules":
        scriptVariables.put(id, new ScriptValueTRRules(currentTRRules));
        break;
      case "chooserules":
        scriptVariables.put(id, new ScriptValueChooseRules(currentChooseRules));
        break;
      case "term":
        scriptVariables.put(id, new ScriptValueTerm(currentRewriteTerm));
        break;
      default:
        Util.fatal("Unknown !save argument " + iTerms.termSymbolString(iTerms.subterm(term, 0, 0))
            + "\nmust be one of (case insensitive): cfgRules trRules  chooseRules  term");
      }
    }
      break;

    case "!recall": {
      String id = iTerms.termSymbolString(iTerms.subterm(term, 0, 0));
      switch (scriptVariables.get(id)) {
      case null -> Util.error("unknown script variable " + id);

      case ScriptValueCFGRules v -> currentCFGRules = v.payload;
      case ScriptValueTRRules v -> currentTRRules = v.payload;
      case ScriptValueChooseRules v -> currentChooseRules = v.payload;

      default -> Util.fatal("Unexpected !recall value type: " + scriptVariables.get(id).getClass().getSimpleName());
      }
      normalise();
    }
      break;

    /* Undocumented research features */
    case "!deletetokens":
      currentLexer.deleteTokenCount = iTerms.termToJavaInteger(iTerms.subterm(term, 0, 0));
      break;

    case "!swaptokens":
      currentLexer.swapTokenCount = iTerms.termToJavaInteger(iTerms.subterm(term, 0, 0));
      break;

    case "!sppfBreakCycles": {
      boolean trace = false;
      boolean statistics = false;
      boolean counts = false;
      for (int i = 0; i < iTerms.termArity(iTerms.subterm(term, 0)); i++)
        switch (iTerms.termSymbolString(iTerms.subterm(term, 0, i))) {
        case "trace":
          trace = true;
          break;
        case "counts":
          counts = true;
          break;
        case "statistics":
          statistics = true;
          break;
        default:
          Util.fatal("Unknown !sppfBreakCycles argument " + iTerms.termSymbolString(iTerms.subterm(term, 0, i)));
        }
      currentParser.derivations.breakCycles(trace, counts, statistics);
    }
      break;

    case "!sppfBreakCyclesRelation":
      currentParser.derivations.breakCyclesRelation();
      break;

    default:
      Util.error("Unimplemented directive " + iTerms.toString(iTerms.subterm(term, 0)));
    }

  }

  private void processDisplayElements(int term) {
    boolean isShow = iTerms.hasSymbol(term, "!show");
    PrintStream outputStream = Util.console;
    TermTraverserText outputTraverser = iTerms.plainTextTraverser;
    boolean full = false, indented = false, indexed = false;
    int depthLimit = -1;

    // Util.debug("Processing display term [" + term + "] " + iTerms.toRawString(term));

    for (int i = 0; i < iTerms.termArity(iTerms.subterm(term)); i++) {
      int displayTerm = iTerms.subterm(term, i);
      String displayElement = iTerms.termSymbolString(displayTerm);

      if (iTerms.termArity(displayTerm) > 0) {
        if (displayElement.equals("__string")) // special case
          outputStream.println(iTerms.termSymbolString(iTerms.subterm(displayTerm, 0)));
        else
          outputStream.println(iTerms.toString(displayTerm, outputTraverser, indented, depthLimit));
      } else {
        // Util.debug("Processing display element " + displayElement);

        switch (displayElement) {
        case "__array", "__list", "__set", "__map": // This is to handle empty collections
          outputStream.println(iTerms.toString(displayTerm, outputTraverser, indented, depthLimit));
          break;
        case "file":
          String filename = iTerms.termSymbolString(iTerms.subterm(term, i, 0));
          Util.info("Redirecting output to file " + filename);
          try {
            outputStream = new PrintStream(filename);
          } catch (FileNotFoundException e) {
            Util.error("Unable to open file " + filename + " for output");
          }
          break;

        case "raw":
          outputTraverser = iTerms.rawTextTraverser;
          break;

        case "plain":
          outputTraverser = iTerms.plainTextTraverser;
          break;

        case "latex":
          outputTraverser = iTerms.latexTraverser;
          break;

        case "indented":
          indented = true;
          break;

        case "depth":
          // TODO: add argument processing
          break;

        case "full":
          full = true;
          break;

        case "indexed":
          indexed = true;
          break;

        case "scriptTerm":
          outputStream.println(
              "Script derivation term: [" + scriptDerivationTerm + "]\n" + iTerms.toString(scriptDerivationTerm, outputTraverser, indented, depthLimit));
          break;

        case "cfgRulesScript":
          if (isShow)
            scriptCFGRules.show(outputStream, outputTraverser, indexed, full, indented);
          else
            scriptCFGRules.print(outputStream, outputTraverser, indexed, full, indented);
          break;

        case "cfgRules":
          if (isShow)
            currentCFGRules.show(outputStream, outputTraverser, indexed, full, indented);
          else
            currentCFGRules.print(outputStream, outputTraverser, indexed, full, indented);
          break;

        case "cfgRulesLexer":
          if (isShow)
            currentCFGRules.cfgRulesLexer.show(outputStream, outputTraverser, indexed, full, indented);
          else
            currentCFGRules.cfgRulesLexer.print(outputStream, outputTraverser, indexed, full, indented);
          break;

        case "cfgRulesParser":
          if (isShow)
            currentCFGRules.cfgRulesParser.show(outputStream, outputTraverser, indexed, full, indented);
          else
            currentCFGRules.cfgRulesParser.print(outputStream, outputTraverser, indexed, full, indented);
          break;

        case "chooseRules":
          if (isShow)
            currentChooseRules.show(outputStream, outputTraverser, indexed, full, indented);
          else
            currentChooseRules.print(outputStream, outputTraverser, indexed, full, indented);
          break;

        case "trRules":
          if (isShow)
            currentTRRules.show(outputStream, outputTraverser, indexed, full, indented);
          else
            currentTRRules.print(outputStream, outputTraverser, indexed, full, indented);
          break;

        case "lexicalisations":
          if (isShow)
            currentLexer.show(outputStream, outputTraverser, indexed, full, indented);
          else
            currentLexer.print(outputStream, outputTraverser, indexed, full, indented);
          break;

        case "scriptLexicalisations":
          if (isShow)
            scriptParser.lexer.show(outputStream, outputTraverser, indexed, full, indented);
          else
            scriptParser.lexer.print(outputStream, outputTraverser, indexed, full, indented);
          break;

        case "tasks":
          if (currentParser.tasks == null)
            Util.error("no current tasks to print");
          else if (isShow)
            currentParser.tasks.show(outputStream, outputTraverser, indexed, full, indented);
          else
            currentParser.tasks.print(outputStream, outputTraverser, indexed, full, indented);
          break;

        case "stacks":
          if (isShow)
            currentParser.stacks.show(outputStream, outputTraverser, indexed, full, indented);
          else
            currentParser.stacks.print(outputStream, outputTraverser, indexed, full, indented);
          break;

        case "derivations":
          if (isShow)
            currentParser.derivations.show(outputStream, outputTraverser, indexed, full, indented);
          else
            currentParser.derivations.print(outputStream, outputTraverser, indexed, full, indented);
          break;

        case "scriptDerivations":
          if (isShow)
            scriptParser.derivations.show(outputStream, outputTraverser, indexed, full, indented);
          else
            scriptParser.derivations.print(outputStream, outputTraverser, indexed, full, indented);
          break;

        case "tryTerm":
          if (indexed) {
            currentIndexedTryTerm = currentParser.derivations.derivationAsInterpeterTerm();
            outputStream.println(iTerms.toString(currentIndexedTryTerm, outputTraverser, indented, depthLimit));
          } else {
            outputStream.println(iTerms.toString(currentTryTerm, outputTraverser, indented, depthLimit));
            if (scriptParserTerm == currentTryTerm) Util.info("Bootstrap achieved: script parser term and current derivation term identical");
          }
          break;

        case "version":
          outputStream.println("ART version " + Version.version());
          break;

        case "statistics":
          if (isShow)
            currentStatistics.show(outputStream, outputTraverser, indexed, full, indented);
          else
            currentStatistics.print(outputStream, outputTraverser, indexed, full, indented);
          break;

        case "cardinalities":
          currentParser.printCardinalities(outputStream);
          break;

        case "paraterminals":
          currentParser.derivations.printParaterminals(outputStream, outputTraverser, indexed, full, indented);
          break;

        case "parasentences":
          currentParser.derivations.printParasentences(outputStream, outputTraverser, indexed, full, indented);
          break;

        default:
          Util.error("Ignoring " + (isShow ? "!show" : "!print") + " argument: " + displayElement
              + "\n   Must be a double-quoted string, a term or one of (case insensitive):\n" + "     raw plain latex full indented depth <n>\n"
              + "     characterSet cfgRules cfgRulesLexer cfgRulesParser chooseRules trRules\n" + "     lexicalisations tasks stacks derivations tryTerm\n"
              + "     scriptLexicalisations scriptDerivations scriptTerm\n" + "     version statistics cardinalities paraterminals parasentences\n");
        }
      }
    }
  }

  public static CFGElement findCFGElement(int term) {
    // Util.debug("findCFGElement on " + iTerms.toRawString(term));
    switch (iTerms.termSymbolString(term)) {
    case "cfgEpsilon":
      return currentCFGRules.findElement(CFGElementKind.EPSILON, "#");
    case "cfgCaseSensitiveTerminal":
      return currentCFGRules.findElement(CFGElementKind.TRM_CS, iTerms.termSymbolString(iTerms.termChildren(term)[0]));
    case "cfgCaseInsensitiveTerminal":
      return currentCFGRules.findElement(CFGElementKind.TRM_CI, iTerms.termSymbolString(iTerms.termChildren(term)[0]));
    case "cfgBuiltinTerminal":
      return currentCFGRules.findElement(CFGElementKind.TRM_BI, iTerms.termSymbolString(iTerms.termChildren(term)[0]));
    case "cfgNonterminal":
      return currentCFGRules.findElement(CFGElementKind.NONTERMINAL, iTerms.termSymbolString(iTerms.termChildren(term)[0]));
    case "cfgCharacterTerminal":
      return currentCFGRules.findElement(CFGElementKind.TRM_CH, iTerms.termSymbolString(iTerms.termChildren(term)[0]));
    case "cfgCharacterSetTerminal":
      return currentCFGRules.findElement(CFGElementKind.TRM_CH_SET, iTerms.termSymbolString(iTerms.termChildren(term)[0]));
    case "cfgCharacterAntiSetTerminal":
      return currentCFGRules.findElement(CFGElementKind.TRM_CH_ANTI_SET, iTerms.termSymbolString(iTerms.termChildren(term)[0]));

    default:
      Util.fatal("Unknown CFG element type " + iTerms.termSymbolString(term));
      return null;
    }
  }

  private void tryParse(String inputStringName, String inputString) {
    Util.trace(8, "Parser trace using " + currentParser.getClass().getSimpleName());

    currentStatistics.putTime("SetupTime");
    currentParser.parse(inputString, currentCFGRules, currentLexer, currentChooseRules);
    currentStatistics.putTime("ParseTime");
    currentParser.outcomeReport();

    currentTryTerm = 0;
    if (currentParser.derivations != null) {
      currentParser.derivations.numberNodes();
      currentParser.derivations.choose(currentChooseRules);
      currentStatistics.putTime("ChooseTime");
      currentTryTerm = currentParser.derivations.derivationAsTerm();
      currentStatistics.putTime("TermGenerateTime");
    }
  }

  private TermTraverserText initialisePlainTextTraverser() {
    TermTraverserText ret = new TermTraverserText(iTerms, "iTerms default plain text traverser");

    // __map and __m require special treatment because they don't fit neatly pre/in/post string model, so we shall directly program the underlying actions
    // For __map, the preorder action tests the arity of the term, and appends {= instead of {
    ret.addAction("__map", (Integer t) -> ret.sb.append(iTerms.termArity(t) == 0 ? "{=" : "{"), null, (Integer t) -> ret.sb.append("}"));
    ret.addAction("__m", null, "=", null); // note that intext traverses, inorder always adds , after the second argument

    ret.addActionBreak("__bool", (Integer t) -> ret.appendAlias("", iTerms.termSymbolStringIndex(iTerms.subterm(t, 0)), ""), null, null);
    ret.addActionBreak("__int32", (Integer t) -> ret.appendAlias("", iTerms.termSymbolStringIndex(iTerms.subterm(t, 0)), ""), null, null);
    ret.addActionBreak("__real64", (Integer t) -> ret.appendAlias("", iTerms.termSymbolStringIndex(iTerms.subterm(t, 0)), ""), null, null);
    ret.addActionBreak("__char", (Integer t) -> ret.appendAlias("'", iTerms.termSymbolStringIndex(iTerms.subterm(t, 0)), ""), null, null);
    ret.addActionBreak("__string", (Integer t) -> ret.appendAlias("\"", iTerms.termSymbolStringIndex(iTerms.subterm(t, 0)), "\""), null, null);
    ret.addActionBreak("__intAP", (Integer t) -> ret.appendAlias("", iTerms.termSymbolStringIndex(iTerms.subterm(t, 0)), ""), null, null);
    ret.addActionBreak("__realAP", (Integer t) -> ret.appendAlias("", iTerms.termSymbolStringIndex(iTerms.subterm(t, 0)), ""), null, null);

    ret.addAction("__array", "[", " | ", "]");
    ret.addAction("__a", null, ", ", null);

    ret.addAction("__list", "[", ", ", "]");
    ret.addAction("__l", null, ", ", null);

    ret.addAction("__set", "{", ", ", "}");
    ret.addAction("__s", null, ", ", null);

    // 0. Line break after each rule
    ret.addAction("rules", null, "\n", null);

    // 1. Context Free Grammar pretty print controls
    ret.addEmptyAction("cfgSlot");

    ret.addActionBreak("cfgLHS", (Integer t) -> {
      ret.appendAlias(iTerms.termSymbolStringIndex(iTerms.subterm(t, 0)));
      ret.append(" ::=");
    }, null, null);

    ret.addEmptyAction("cfgRule");
    ret.addAction("cfgAlts", null, "|", null);
    ret.addAction("cfgSeq", null, " ", null);
    ret.addAction("cfgName", null, ":", null);
    ret.addActionBreak("cfgNonterminal", (Integer t) -> ret.append(iTerms.getString(iTerms.termSymbolStringIndex(iTerms.subterm(t, 0)))), null, null);
    ret.addActionBreak("cfgCaseInsensitiveTerminal",
        (Integer t) -> ret.append("\"" + iTerms.getString(iTerms.termSymbolStringIndex(iTerms.subterm(t, 0))) + "\""), null, null);
    ret.addActionBreak("cfgCaseSensitiveTerminal", (Integer t) -> ret.appendAlias("'", iTerms.termSymbolStringIndex(iTerms.subterm(t, 0)), "'"), null, null);
    ret.addActionBreak("cfgCharacterTerminal", (Integer t) -> ret.appendAlias("`", iTerms.termSymbolStringIndex(iTerms.subterm(t, 0)), ""), null, null);
    ret.addActionBreak("cfgCharacterRangeTerminal",
        (Integer t) -> ret.append("`" + iTerms.termSymbolString(iTerms.subterm(t, 0, 0)) + "..`" + iTerms.termSymbolString(iTerms.subterm(t, 0, 1))), null,
        null);
    ret.addActionBreak("cfgStartString", (Integer t) -> ret.append("$$"), null, null);
    ret.addActionBreak("cfgBuiltinTerminal", (Integer t) -> ret.appendAlias("&", iTerms.termSymbolStringIndex(iTerms.subterm(t, 0)), ""), null, null);
    ret.addAction("cfgOptional", "(", null, ")?");
    ret.addAction("cfgKleene", "(", null, ")*");
    ret.addAction("cfgPositive", "(", null, ")+");
    ret.addAction("cfgDoFirst", "(", null, ")");
    ret.addAction("cfgEpsilon", "#", null, null);

    ret.addAction("cfgFoldUnder", null, null, "^");
    ret.addAction("cfgFoldOver", null, null, "^^");
    ret.addAction("cfgTear", null, null, "^^^");
    ret.addAction("cfgTearNamed", null, "^^^:", null);
    ret.addAction("cfgInsert", " ^+:", null, null);

    ret.addAction("cfgAttribute", null, ".", null);
    ret.addAction("cfgEquation", "\n", " = ", null);
    ret.addAction("cfgAssignment", "\n", " := ", null);
    ret.addAction("cfgNative", "\n!!", null, "!!");

    // 2. Chooser pretty print controls
    ret.addEmptyAction("chooseElement");
    ret.addEmptyAction("chooseRule");
    ret.addAction("chooseHigher", " > ", null, null);
    ret.addAction("chooseLower", " < ", null, null);
    ret.addAction("chooseLonger", " >> ", null, null);
    ret.addAction("chooseShorter", " << ", null, null);
    ret.addAction("chooseDiff", "(", " \\ ", ")");
    ret.addAction("chooseUnion", "(", " | ", ")");
    ret.addAction("chooseIntersection", "(", " / ", ")");
    ret.addActionBreak("choosePredefinedSet", (Integer t) -> ret.append(ret.childSymbolString(t, 0)), null, null);

    // 3. Term rewrite pretty print controls
    ret.addEmptyAction("trRule");
    ret.addAction("tr", null, " --- ", null);
    ret.addAction("trPremises", null, "  ", null);
    ret.addActionBreak("trLabel", (Integer t) -> ret.append(iTerms.termArity(t) > 0 ? ("-" + ret.childSymbolString(t, 0) + " ") : " "), null, null);
    ret.addAction("trMatch", null, (Integer t) -> ret.append(" |> "), null);
    ret.addEmptyAction("trTransition");
    ret.addActionBreak("TRRELATION", (Integer t) -> ret.append(" " + ret.childSymbolString(t, 0) + " "), null, null);
    ret.addActionBreak("trTerm", (Integer t) -> ret.append(iTerms.toString(iTerms.subterm(t, 0))), null, null);
    ret.addEmptyAction("trTopTuple");
    ret.addAction("trTuple", "<", ", ", ">");

    // 4. Default actions
    // Debug - load text traverser default action to print message if we encounter an unknown constructor
    // ret.addAction(-1, (Integer t) -> ret.append("??" + iTerms.toString(t) + "?? "), null, null);
    ret.addAction(-1, (Integer t) -> {
      ret.appendAlias(iTerms.termSymbolStringIndex(t));
      if (iTerms.termArity(t) > 0) ret.append("(");
    }, (Integer t) -> ret.append(", "), (Integer t) -> {
      if (iTerms.termArity(t) > 0) ret.append(")");
    });

    // Debug - print keys from text traverser tables
    // Util.info("text traverser: " + ret);

    return ret;
  }

  private String texEscape(String s) {
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < s.length(); i++) {
      switch (s.charAt(i)) {
      case '_', '$', '^', '%', '\\':
        sb.append('\\');
      }
      sb.append(s.charAt(i));
    }
    return sb.toString();
  }

  private String typesetConstant(int t) {
    String label = iTerms.termSymbolString(t);
    String argument = "";
    if (iTerms.termArity(t) > 0) argument = iTerms.termSymbolString(iTerms.subterm(t, 0));
    if (!argument.equals("_")) switch (label) {
    case "__bool":
      return "\\artBoolean{" + argument + "}";
    case "__char":
      return "\\artCharacter{" + iTerms.termSymbolString(iTerms.subterm(t, 0)) + "}";
    case "__int32":
      return "\\artInteger{" + iTerms.termSymbolString(iTerms.subterm(t, 0)) + "}";
    case "__real64":
      return "\\artReal{" + iTerms.termSymbolString(iTerms.subterm(t, 0)) + "}";
    case "__string":
      return "\\artString{" + iTerms.termSymbolString(iTerms.subterm(t, 0)) + "}";
    }
    return texEscape(label);
  }

  private TermTraverserLaTeX initialiseLaTeXTraverser() {
    TermTraverserLaTeX ret = new TermTraverserLaTeX(iTerms, "iTerms default LaTeX traverser");
    // -1: uncomment these to have shorthand type renditions rather than plain terms
    ret.addActionBreak("__bool", (Integer t) -> ret.append(typesetConstant(t)), null, null);
    ret.addActionBreak("__char", (Integer t) -> ret.append(typesetConstant(t)), null, null);
    ret.addActionBreak("__int32", (Integer t) -> ret.append(typesetConstant(t)), null, null);
    ret.addActionBreak("__real64", (Integer t) -> ret.append(typesetConstant(t)), null, null);
    ret.addActionBreak("__string", (Integer t) -> ret.append(typesetConstant(t)), null, null);
    ret.addAction("file", "\\artFile{", null, "}");
    ret.addAction("__map", "\\artMap{", "}{", "}");
    ret.addAction("__list", "\\artList{", "}{", "}");

    // -1B: load global aliases
    ret.addGlobalAlias("->", "\\artRelation{$\\rightarrow$}");
    ret.addGlobalAlias("=>", "\\artRelation{$\\Rightarrow$}");
    ret.addGlobalAlias("-\\", "\\artRelation{$\\rightharpoonup$}");
    ret.addGlobalAlias("-/", "\\artRelation{$\\rightharpoondown$}");
    ret.addGlobalAlias("~>", "\\artRelation{$\\leadsto$}");

    // 0. Top level pretty print controls
    ret.addAction("rules", "%!TEX root = artRules.tex\n", "", "");

    // 1. Context Free Grammar pretty print controls
    ret.addEmptyAction("cfgSlot");

    ret.addAction("cfgRule", "\\artCFGRule{", "", "}\n");
    ret.addAction("cfgLHS", "\\artLHS{", null, "}\\artExpandsTo");
    ret.addAction("cfgAttributeDeclarations", "\\artAttributeDeclarations{", null, "}");

    ret.addAction("cfgAlts", null, "\\artSequenceSeperator", null);
    ret.addAction("cfgSeq", null, "\\artSequenceSpace", null);
    ret.addAction("cfgName", null, ":", null);
    ret.addActionBreak("cfgNonterminal",
        (Integer t) -> ret.append("\\artNonterminal{" + texEscape(iTerms.getString(iTerms.termSymbolStringIndex(iTerms.subterm(t, 0)))) + "}"), null, null);
    ret.addActionBreak("cfgCaseInsensitiveTerminal",
        (Integer t) -> ret.append("\\artCaseInsensitiveTerminal{" + texEscape(iTerms.getString(iTerms.termSymbolStringIndex(iTerms.subterm(t, 0)))) + "}"),
        null, null);
    ret.addActionBreak("cfgCaseSensitiveTerminal",
        (Integer t) -> ret.append("\\artCaseSensitiveTerminal{" + texEscape(iTerms.getString(iTerms.termSymbolStringIndex(iTerms.subterm(t, 0)))) + "}"), null,
        null);
    ret.addActionBreak("cfgCharacterTerminal",
        (Integer t) -> ret.append("\\artCharacterTerminal{" + texEscape(iTerms.getString(iTerms.termSymbolStringIndex(iTerms.subterm(t, 0)))) + "}"), null,
        null);

    ret.addActionBreak("cfgCharacterRangeTerminal",
        (Integer t) -> ret.append("\\artCharacterRangeTerminal{" + texEscape(iTerms.getString(iTerms.termSymbolStringIndex(iTerms.subterm(t, 0, 0)))) + "}{"
            + texEscape(iTerms.getString(iTerms.termSymbolStringIndex(iTerms.subterm(t, 0, 1)))) + "}"),
        null, null);

    ret.addActionBreak("cfgBuiltinTerminal",
        (Integer t) -> ret.append("\\artBuiltinTerminal{" + texEscape(iTerms.getString(iTerms.termSymbolStringIndex(iTerms.subterm(t, 0)))) + "}"), null, null);

    ret.addAction("cfgEpsilon", "\\artEpsilon", null, null);

    ret.addAction("cfgDoFirst", "\\artDoFirst{", "}{", "}\n");
    ret.addAction("cfgPositive", "\\artPositive{", "}{", "}\n");
    ret.addAction("cfgOptional", "\\artOptional{", "}{", "}\n");
    ret.addAction("cfgKleene", "\\artKleene{", "}{", "}\n");

    ret.addAction("cfgFoldUnder", null, null, "\\artFoldUnder");
    ret.addAction("cfgFoldOver", null, null, "\\artFoldOver");
    ret.addAction("cfgTear", null, null, "\\artTear");
    ret.addAction("cfgTearNamed", "\\artFoldUnder{", "}{", "}");
    ret.addAction("cfgInsert", "\\artInsert{", null, "}");

    ret.addAction("cfgAttributeDeclarations", "\\artAttributeDeclarations{", "}{", "}");
    ret.addAction("cfgAttributeDeclaration", "\\artAttributeDeclaration{", "}{", "}");
    ret.addAction("cfgAttribute", "\\artAttribute{", "}{", "}");
    ret.addAction("cfgEquation", "\\artEquation{", "}{", "}");
    ret.addAction("cfgNative", "\\artNative{", "}{", "}");
    ret.addAction("cfgAssignment", "\\artAssignment{", "}{", "}");

    // 2. Chooser pretty print controls
    ret.addEmptyAction("chooseElement");
    ret.addAction("chooseRule", "\\artChooseRule{", "}{", "}\n");
    ret.addAction("chooseHigher", "\\artChooseHigher{", "}{", "}\n");
    ret.addAction("chooseLower", "\\artChooseLower{", "}{", "}\n");
    ret.addAction("chooseLonger", "\\artChooseLonger{", "}{", "}\n");
    ret.addAction("chooseShorter", "\\artChooseShorter{", "}{", "}\n");
    ret.addAction("chooseDiff", "(", " \\ ", ")");
    ret.addAction("chooseUnion", "(", " | ", ")");
    ret.addAction("chooseIntersection", "(", " / ", ")");
    ret.addActionBreak("choosePredefinedSet", (Integer t) -> ret.append(ret.childSymbolString(t, 0)), null, null);

    // 3. Term rewrite pretty print controls
    ret.addAction("trRule", "\\artTRRule{", "}{", "}\n");
    ret.addAction("tr", "\\artTR{", "}{", "}");
    ret.addAction("trPremises", null, "\\artPremiseSpace", null);
    ret.addActionBreak("trLabel", (Integer t) -> {
      if (iTerms.termArity(t) > 0) {
        ret.append("\\artTRLabel{");
        ret.appendAlias(iTerms.termSymbolStringIndex(iTerms.subterm(t, 0)));
        ret.append("}");
      }
    }, null, null);
    ret.addAction("trMatch", " ", "\\triangleright ", " ");
    ret.addAction("trTransition", "\\artTransition{", "}{", "}\n");
    ret.addEmptyAction("trTopTuple");
    ret.addAction("trTuple", "\\artTuple{", ", ", "}\n");

    // 4. Directives
    ret.addAction("directive", "\\artDirective{", " ", "}\n");

    // 5. Default action
    // Debug - load text traverser default action to print message if we encounter an unknown constructor
    // ret.addAction(-1, (Integer t) -> ret.append("??" + iTerms.toString(t) + "?? "), null, null);
    ret.addAction(-1, (Integer t) -> {
      ret.append(typesetID(iTerms.getString(ret.aliasLookup(iTerms.termSymbolStringIndex(t)))));

      if (iTerms.termArity(t) > 0) ret.append("(");
    }, (Integer t) -> ret.append(", "), (Integer t) -> {
      if (iTerms.termArity(t) > 0) ret.append(")");
    });

    // Debug - print keys from text traverser tables
    // Util.info("text traverser: " + pp.tt);

    return ret;
  }

  public String typesetID(String s) {
    // System.out.print("typesetID() formatting " + s);

    boolean hasIndex = false;
    int underscores = 0, index = 0, primes = 0, digits = 0, cc = 0;
    // Prefix processing
    while (cc < s.length() && s.charAt(cc) == '_')
      cc++;
    underscores = cc;

    // Suffix processing
    cc = s.length() - 1;
    while (cc >= 0 && s.charAt(cc) == 'P') {
      cc--;
      primes++;
    }
    if (cc >= 0 && Character.isDigit(s.charAt(cc))) {
      hasIndex = true;
      cc--;
      digits++;
    }

    for (int i = 0; i < digits; i++)
      index = index * 10 + (s.charAt(cc + 1 + i) - '0');

    // Extract core
    String ret = s.substring(underscores, cc + 1);

    // Add suffix
    if (hasIndex) ret += "$_{" + index + "}$";
    for (int i = 0; i < primes; i++)
      ret += "$^\\prime$";

    // Classify
    switch (underscores) {
    case 0:
      ret = "\\artConstructor{" + ret + "}";
      break;
    case 1:
      ret = "\\artVariable{" + ret + "}";
      break;
    case 2:
      ret = "\\artValue{" + ret + "}";
      break;
    default:
      Util.fatal("identifier " + s + " begins with three or more underscores");
    }

    // Util.info(" to yield " + ret);
    return ret;
  }
}
