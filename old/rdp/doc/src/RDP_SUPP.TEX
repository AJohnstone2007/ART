\documentstyle[rhultechreport,epsf,11pt,bezier,twoside]{report}
\renewcommand{\today}{December 20, 1997}
\newcommand{\rdpsupp}{{\tt rdp\_\,supp}}
\newcommand{\rdp}{{\mediumseries\tt rdp}}
\title{{\tt \rdp\_supp} -- support routines for\\the {\tt\mediumseries rdp} compiler
compiler}
\author{Adrian Johnstone \and Elizabeth Scott}
\reportnumber{\csnum{97}{26}} %Uncomment this line only when
\begin{document}
\makecstitle %make Adrian's title page
\thispagestyle{empty}
\vspace*{1cm}
\begin{center}\bf Abstract\end{center}

%%%%% modified by EAS 18/8/98  %%%%%%%%%%%

\rdp\ is a system for implementing language processors. It accepts a
grammar written in an extended Backus-Naur Form annotated with inherited
and synthesized attributes and C-language semantic actions. \rdp\ checks
that the grammar is LL(1), providing detailed error messages pinpointing
the source of any problems. A parser written in ANSI C may then be
output. \rdp\ is particularly suited to student use because it
constructs ready to run parsers and interpreters and provides detailed
diagnostics. 

This report describes the user accessible parts of the \rdp\ support
library\dash \rdpsupp\ for short. \rdpsupp\ comprises seven packages to
manage memory ({\tt memalloc.c}), sets ({\tt set.c}), graphs ({\tt
graph.c}),  scanners ({\tt scan.c}), text buffers ({\tt textio.c}),
command line arguments ({\tt arg.c)} and symbol tables ({\tt symbol.c}).
These packages are designed to be useful for general purpose programming
and may be used independently of the \rdp\ system. The internal
operation of the packages is not documented here, but the \rdp\ distribution pack
does include commented source code for all parts of the system.

The \rdp\ source code is public domain and has been successfully built
using Borland C++ 3.1 and Microsoft C++ version 7 on MS-DOS, GNU {\tt
gcc} and {\tt g++} running on OSF/1, Ultrix, MS-DOS, Linux and SunOS,
and a variety of vendor's own compilers running on many flavours of
Unix. \rdp\ has also been built for the Macintosh using a console
support library, and a version modified to take account of the unusual
filenaming conventions on the Acorn Archimedes is available on request.

\vspace*{\fill}
\begin{center}
\fbox{\parbox{12cm}{This document is \copyright\,Adrian Johnstone and
Elizabeth Scott 1997.\\[1ex]
Permission is given to freely distribute this document
electronically and on paper. You may not change this document or
incorporate parts of it in other documents: it must be distributed intact.\\[1ex]
The \rdp\ system itself is \copyright\,Adrian Johnstone but may
be freely copied and modified on condition that details of the
modifications are sent to the copyright holder 
with permission to include
such modifications in future versions and to discuss them (with
acknowledgement) in future publications.\\[1ex]
The version of \rdp\ described here is version 1.50 dated 20 December 1997.\\[1ex] 
Please send bug reports and copies of modifications
to the author at the address on the title page or electronically
to {\tt A.Johnstone@rhbnc.ac.uk}.
}}
\end{center}
\clearpage
\pagenumbering{roman}
\tableofcontents
\setcounter{page}{0}
\chapter{Introduction}
\pagenumbering{arabic}

\rdp\ is a system for implementing language processors. Compilers,
assemblers and interpreters may all be written in the \rdp\ source
language (an extended Backus-Naur Form) and then processed by the
\rdp\ command to produce a program written in ANSI C which may then
be compiled and run.


\rdp\ generated parsers use a set of general purpose support
modules collectively known as \verb+rdp_supp+. There are seven parts to
\rdpsupp:
\begin{itemize}
\item a hash coded symbol table handler which allows multiple tables to
be managed with arbitrary user data fields ({\tt symbol.c}),
\item a set handler which supports dynamically resizable sets ({\tt
set.c}),
\item a set of routines for creating and manipulating general graph data
structures which can also output graphs in a form that may be displayed
on-screen by the VCG tool ({\tt graph.c}),
\item a memory manager which wraps fatal error handling around the
standard ANSI C heap allocation routines ({\tt memalloc.c}),
\item a text handler which provides line buffering and string management
without imposing arbitrary limits on input line length ({\tt textio.c}),
\item a set of routines for processing command line arguments and
automatically building help routines ({\tt arg.c}),
\item scanner support routines for testing tokens in recursive descent
parsers ({\tt scan.c}).
\end{itemize}

Writing effective language processors in \rdp\
requires a detailed understanding of these modules.
This report documents the user accessible functions in the \rdpsupp\
library. Implementation details are hidden except where a knowledge of
the underlying data structures is required for efficient exploitation of
the library. The full source code of the \rdpsupp\ library is available
in directory \verb+rdp_supp+ of the \rdp\ distribution, and the various \rdp\ tools
provide examples of the use of \rdpsupp\ routines.

This manual is part of a four manual series. In addition to this support library 
manual, the user manual~\cite{rdp:user:1.5}
describes the \rdp\ source language, command switches and
error messages. A third, tutorial, report
assumes no knowledge of parsing, grammars or language design and shows
how to use \rdp\ to develop a small calculator-like
language~\cite{rdp:tut:1.5}. The emphasis in the tutorial guide is on
learning to use the basic \rdp\ features and command line options. A
large case study is documented in~\cite{rdp:case:1.5} which extends the
language described in the tutorial guide with details of a syntax
checker, an interpreter and a compiler along with an assembler and
simulator for a synthetic architecture which is used as the compiler
target machine.

\chapter{{\tt arg} -- command line argument services}

The {\tt arg} library provides automatic processing for Unix style
command line arguments. The library is used to implement \rdp's
\verb+ARG_...+ directives in which command line switches are associated
with variables in the parser called {\em switch variables}. When the command line
is processed, the switch variables are loaded with values from the command line
switches supplied by the user.

The {\tt arg} library is set up at run time by calling one of a family
of routines to  declare command line switches. When all of the switches
have been set up, the command line can be processed by passing the
normal \verb+argc+ (argument count) and \verb+argv+ (argument vector)
parameters from the ANSI-C {\tt main()} function to the library. Each
command line switch has an associated {\em switch variable} which will
be updated during command line processing and a {\em
description string} which gives a short summary message describing the
switch's function. The library creates a {\em help message} by
concatenating these descriptions which may be issued along with a fatal
error message if an invalid command line is detected.

\section{Command line format}

The model supported by the library is that of a command line made up of
{\em file arguments} and {\em switches} separated by spaces made up of
space or tab characters. Switches are distinguished by a leading minus
sign ({\tt -}). Any space delimited field beginning with a {\tt -}
character is a switch and anything else is a file argument. 

Switches are distinguished one from another by their {\em key character}
which immediately follows the {\tt -} character. Switches are processed
in strict left-to-right order as they appear on the command line and may
be of three types.
\begin{enumerate} 

\item {\em Boolean switches} declared using the function
\verb+arg_boolean+ which take an integer switch variable that is
initialised to {\sc false} (integer 0). Each instance of the boolean
switch in the command line toggles the state of the switch variable by
exclusive {\sc or}-ing its value with logical {\sc true}. 

\item {\em Numeric switches} declared using the function
\verb+arg_numeric+ which take an unsigned long switch variable that is
initialised to zero. Each instance of the numeric switch in the command
line must be immediately followed by a decimal integer without any
intervening spaces. The ASCII coded number on the command line is
converted to binary and loaded into the switch variable, overwriting any
previous value.

\item {\em String switches\/} declared using the function
\verb+arg_string+ which take a string ({\tt char *}) switch variable
that is initialised to {\tt NULL}. Each instance of the numeric switch
in the command line must be followed by a string of characters which
will be collected and loaded into the switch variable, overwriting any
previous value. No intervening spaces are allowed between the switch key
and the actual string: a string switch key followed by a space will be
interpreted as an empty (zero length) string parameter.

\end{enumerate}

\section{The help message}

It is usual to provide a summary help message that can be issued by a
program if it receives invalid command parameters. The {\tt arg} library
automatically constructs such a message by concatenating the {\em
description lines} from the declared command line switches. The routine
\verb+arg_help()+ may be called to issue this message.

\section{{\protect\verb+arg\_boolean+}}
\begin{verbatim}
void arg_boolean(char key, char* description, int *intvalue)
\end{verbatim}
Declare a boolean switch with key character {\tt key}, help message {\tt description} and
switch variable {\tt intvalue}.

\section{\protect\verb+arg\_help+}
\begin{verbatim}
void arg_help(char *msg)
\end{verbatim}
Issue a fatal error message {\tt msg} followed by the help message
formed by concatenating the description lines from each declared 
command line switch. The program exits after calling this function with exit status
\verb+EXIT_FAILURE+.

\section{\protect\verb+arg\_message+}
\begin{verbatim}
void arg_message(char* description)
\end{verbatim}
Declare a line to be added to the help message without an associated command line switch.
This function is useful for adding blank spacing lines or titles and other general information
to the help message.

\section{\protect\verb+arg\_numeric+}
\begin{verbatim}
void arg_numeric(char key, char* description, unsigned long *unsignedvalue)
\end{verbatim}
Declare a numeric switch with key character {\tt key}, help message {\tt description} and
switch variable {\tt unsignedvalue}.

\section{\protect\verb+arg\_process+}
\begin{verbatim}
char ** arg_process(int argc, char *argv[])
\end{verbatim}
Process the command line parameters held in {\tt argv} according to the switches declared
using the switch definition functions. All the non-switch (filename) arguments are collected into
an array of pointers to strings (a {\tt char **} variable) which is returned by the function.
If no filename arguments are seen, then {\tt NULL} is returned.

\section{\protect\verb+arg\_string+}
\begin{verbatim}
void arg_string(char key, char* description, char **str)
\end{verbatim}
Declare a string switch with key character {\tt key}, help message {\tt description} and
switch variable {\tt str}.

\section{An example program}

The example shown in Figure~\ref{arg:example:in} is an extract from the
source of the \rdp\ tool which illustrates the use of most of the {\tt
arg} routines. The output produced by the \verb+arg_help()+ function when \rdp\ is called
with no source file is shown in Figure~\ref{arg:example:out}.

\begin{figure}
{
\footnotesize
\begin{verbatim}
arg_message("Recursive descent parser generator V1.50 (c) Adrian Johnstone 1997\n\n"
            "Usage: rdp [options] source[.bnf]");
arg_message("");  /* Add a blank line to the help message */
arg_boolean('f', "Filter mode (read from stdin and write to stdout)", &rdp_filter);
arg_boolean('l', "Make a listing", &rdp_line_echo);
arg_string ('o', "Write output to filename", &rdp_outputfilename);
arg_boolean('s', "Echo each scanner symbol as it is read", &rdp_symbol_echo);
arg_boolean('S', "Print summary symbol table statistics", &rdp_symbol_statistics);
arg_numeric('t', "Tab expansion width (default 8)", &rdp_tabwidth);
arg_numeric('T', "Text buffer size in bytes for scanner (default 20000)", &rdp_textsize);
arg_boolean('v', "Set verbose mode", &rdp_verbose);
arg_string ('V', "Write derivation tree to filename in VCG format", &rdp_vcg_filename);
arg_message("");
arg_boolean('e', "Write out expanded BNF along with first and follow sets", &rdp_expanded);
arg_boolean('E', "Add rule name to error messages in generated parser", &rdp_error_production_name);
arg_boolean('F', "Force creation of output files", &rdp_force);
arg_boolean('p', "Make parser only (omit semantic actions from generated code)", &rdp_parser_only);
arg_boolean('R', "Add rule entry and exit messages", &rdp_trace);
arg_message("");
arg_message("You can contact the author (Adrian Johnstone) at:");
arg_message("");
arg_message("Computer Science Department, Royal Holloway, University of London");
arg_message("Egham, Surrey, TW20 0EX UK. Email: A.Johnstone@rhbnc.ac.uk");

rdp_sourcefilename = *arg_process(argc, argv);

if (rdp_sourcefilename == NULL)
   arg_help("No source file specified");
\end{verbatim}
}
\caption{Example usage of the {\tt arg} library}
\label{arg:example:in}
\end{figure}
\begin{figure}
{\footnotesize
\begin{verbatim}
Fatal - No source file specified

Recursive descent parser generator V1.50 (c) Adrian Johnstone 1997
Generated on Dec 20 1997 12:04:45 and compiled on Dec 20 1997 at 12:02:49

Usage: rdp [options] source[.bnf]

-f     Filter mode (read from stdin and write to stdout)
-l     Make a listing
-o <s> Write output to filename
-s     Echo each scanner symbol as it is read
-S     Print summary symbol table statistics
-t <n> Tab expansion width (default 8)
-T <n> Text buffer size in bytes for scanner (default 20000)
-v     Set verbose mode
-V <s> Write derivation tree to filename in VCG format

-e     Write out expanded BNF along with first and follow sets
-E     Add rule name to error messages in generated parser
-F     Force creation of output files
-p     Make parser only (omit semantic actions from generated code)
-R     Add rule entry and exit messages

You can contact the author (Adrian Johnstone) at:

Computer Science Department, Royal Holloway, University of London
Egham, Surrey, TW20 0EX UK. Email: A.Johnstone@rhbnc.ac.uk
\end{verbatim}
}
\caption{Output from the {\tt arg\_\,help()} function}
\label{arg:example:out}
\end{figure}
\section{Limitations}
Unix commands use a wide variety of conventions for command line switches, not all of 
which are supported by the {\tt arg} library. Here is a list of such limitations.
\begin{enumerate}
\item Command line switches can only be of the three kinds
described above: there is no built-in facility for real number switches, for instance, although
a string switch could be used to collect the characters for later processing.
\item There is no straightforward way to allow embedded spaces in string switches. This is a
side-effect of the way in which the ANSI-C standard command line handler parses the fields in
a command line.
\item Command line switch keys can only be made up of a single character.
\item No spaces are allowed between a key and its argument.

\item There is no way to associate command line switches with particular
file parameters. Consider, for instance a switch {\tt -l} which is
intended to switch on the listing for a source file. It would be reasonable to interpret a 
command line of the form
\begin{quote}
\small
\begin{verbatim}
mytool first_file -l second_file third_file -l
\end{verbatim}
\end{quote}
as an instruction to process the three files
\verb+first_file+, \verb+second_file+ and \verb+third_file+
with the source listing being switched on for the first and third files but switched off for the
second file. However, the {\tt arg} library processes all command line switches in left to
right order and then returns the file parameters in a block, so the interleaving of command
line arguments and file parameters is not preserved.

\end{enumerate}

\chapter{{\tt graph} -- a graph data structure handler}

A {\em graph} is a collection of nodes and edges, often drawn
as a collection of round nodes and arrows representing the
edges. There may or may not be data associated with individual nodes and
edges. In a general graph, there is no limit to the number of edges leaving
or entering a node, and there is no limit of the number of nodes in a
graph.

Graphs are fundamental objects in computing, being used to represent
relationships between objects. Special cases of graphs, such as {\em
linked lists} or {\em trees} have restrictions on the number of edges that
may enter or leave nodes and the kinds of paths that may be traced
through the graph. A {\em singly linked list}, for instance is a
collection of nodes each with either one or zero edges entering and
one or zero edges leaving. Every node in the list has exactly one edge entering it
and one edge leaving it except for  one node (called the head) which has
no edge entering it and one node (called the tail) which has no edge
leaving it.

These special cases along with the properties of more general graphs are
described in most standard books on data structures. The {\tt graph}
library described in this chapter provides a completely general
mechanism for implementing unrestricted graphs in an efficient manner.
It is possible to provide more space (and time) efficient
implementations of some important special cases such as  trees of fixed
order, queues and circular buffers but the implementation used here is
the cheapest simple method we know of for handling completely unconstrained
graphs.

Graphs can be very complex, and debugging a program which is based on graph
structures can be hard because tracing through the edges using a
conventional ANSI-C debugger is confusing and time consuming. A major
advantage of the \rdp\ {\tt graph} library is that any graph can be
output as a text file written in the language of the {\tt VCG} graph
visualisation tool. VCG can display a graph at various resolutions, trace
graphically through the nodes and edges of a graph and format the graph
for printing on a wide variety of devices. The various tree diagrams
shown in the \rdp\ manuals were produced in this way: \rdp\ uses the
graph library to build parse trees and \rdp\ generated parsers provide a
{\tt -V} command line switch which is used to output the tree in VCG
compatible format. The VCG tool is not a part of the \rdp\ distribution
but the author of VCG has kindly given his permission for VCG to be
distributed alongside \rdp\dash you will find versions for Windows or
Unix in the \rdp\ FTP server as described in
Appendix~\ref{distribution}.

\section{Internal structure of a graph}

The {\tt graph} library uses a hierarchy of linked lists of {\em graph atoms} to represent
graphs that may be manipulated using a family of routines for inserting and deleting nodes and
edges. 
A graph atom may be used to represent
\begin{enumerate}
\item a graph header,
\item a graph node, or
\item a graph edge.
\end{enumerate}
Each atom has a predecessor and a successor pointer which are used to form doubly-linked
lists of atoms representing the same kind of atom and an ancillary pointer which is used
to point to atoms of another type. Each atom also has a unique number which may be displayed as 
part of a graph dump. The number is only present to aid debugging: it is not used by any
graph routine and may not be changed during a run.

The library maintains a single doubly-linked list of graph headers, one
header for each graph in use by the program. Graphs may be added or deleted
during program execution and the graph list may be empty. The ancillary
pointer of each graph header points to a doubly-linked list of graph
nodes, which may be empty. Each graph node represents a single, unique,
node in the graph represented by the parent header. The ancillary
pointer of each graph node points to a doubly-linked list of graph
edges, which may be empty. There will be one graph edge in the list for
each edge leaving that node. The ancillary pointer
for each edge points to the node that the edge is directed towards. In
this representation, edges are inherently unidirectional: an undirected
graph may be represented inserting both forward and reverse edges
between each related pair of nodes.

Figure~\ref{graph:example:in} shows an example of a small derivation tree generated by the
{\tt minitree} compiler and its internal representation using graph atoms is shown in 
Figure~\ref{graph:example:out}.
\begin{figure}
\hspace*{5cm}
\begin{minipage}{10cm}
\epsfbox{small.ps}
\end{minipage}
\caption{A small tree built using the {\tt graph library}}
\label{graph:example:in}
\end{figure}
\begin{figure}
\hspace*{3cm}
\begin{minipage}{10cm}
\epsfbox{smalla.ps}
\end{minipage}
\caption{A small tree showing the internal graph structure}
\label{graph:example:out}
\end{figure}
In these examples, no data is associated with the edges. For graph atoms without data, the
VCG representation shows the type of the atom followed by a colon and the unique
number of the atom. Hence, in Figure~\ref{graph:example:out} the graph header node is
labeled {\tt Graph:1} and the edges are labeled as {\tt Edge:5} and so on. The {\em nodes} in the
graph do have user supplied labels (in this case, the {\tt minitree} compiler that produced the
derivation tree has labeled the nodes with the scanner lexeme for terminals or the rule name
for non-terminals) and these are used as VCG node labels where they exist.

\section{Graph data and handles}

All graph atoms can carry data, be they graph headers, nodes or edges.
When a graph, node or edge atom is inserted into the current set, extra
space can be reserved for the user data in that atom. It is not possible
to change the size of the data space in a graph atom once it is created, so although
different graph nodes and edges can contain different amounts of data
each node must stay the same size throughout its life. 

The functions to insert atoms into graphs return a {\em handle} to the
atom that has been created. In detail, it turns out that the handle is a
{\tt void} pointer  to the start of the user data area in the atom, or
(equivalently) a {\tt void} pointer to the location one past the atom's
internal pointer data block. These handles may not be manipulated but
they are used to refer to individual atoms and can be passed into other
functions to cause atoms to be printed out, set as the target of an
edge, deleted and so on.
User data is accessed by {\em casting} the handle of an atom to a pointer
to the user datatype. The fields in the user data block can then be accessed using the
usual ANSI-C {\tt ->} operator.

\section{\protect\verb+graph\_compare\_double+}
\begin{verbatim}
int graph_compare_double(void *left, void *right)
\end{verbatim}
Compare double precision real fields for equality. The first element of
the user data structure must be a {\tt double}. Return 0 if they are
equal, $+1$ if {\tt left} $>$ {\tt right} or $-1$ if {\tt right} $<$
{\tt left}, just like the ANSI routine {\tt strcmp()}. 

\section{\protect\verb+graph\_compare\_long+}
\begin{verbatim}
int graph_compare_long(void *left, void *right)
\end{verbatim}
Compare long unsigned integer fields for equality. The first element of
the user data structure must be a {\tt long unsigned int}. Return 0 if they are
equal, $+1$ if {\tt left} $>$ {\tt right} or $-1$ if {\tt right} $<$
{\tt left}, just like the ANSI routine {\tt strcmp()}. 

\section{\protect\verb+graph\_compare\_mem+}
\begin{verbatim}
int graph_compare_mem(void *left, void *right, size_t size)
\end{verbatim}
Compare memory blocks for equality. The first element of
the user data structure must be a pointer and the two memory blocks are compared
for string equality over the first {\tt size} bytes. Return 0 if they are
equal, $+1$ if {\tt left} $>$ {\tt right} or $-1$ if {\tt right} $<$
{\tt left}, just like the ANSI routine {\tt strncmp()}. 

\section{\protect\verb+graph\_compare\_string+}
\begin{verbatim}
int graph_compare_string(void *left, void *right)
\end{verbatim}
Compare string fields for equality. The first element of
the user data structure must be a {\tt char *}. Return 0 if they are
equal, $+1$ if {\tt left} $>$ {\tt right} or $-1$ if {\tt right} $<$
{\tt left}, just like the ANSI routine {\tt strcmp()}. 

\section{\protect\verb+graph\_delete\_edge+}
\begin{verbatim}
void graph_delete_edge(void *edge)
\end{verbatim}
Remove {\tt edge} from its parent graph. The parent and target nodes for {\tt edge} are unchanged.

\section{\protect\verb+graph\_delete\_graph+}
\begin{verbatim}
void graph_delete_graph(void *graph)
\end{verbatim}
Remove {\tt graph} from the list of graphs. All of the nodes and edges in {\tt graph} are also
deleted and the memory returned to the free list.

\section{\protect\verb+graph\_delete\_node+}
\begin{verbatim}
void graph_delete_node(void *node)
\end{verbatim}
Remove {\tt node} from its parent graph. All of the edges emanating from {\tt node} are also
deleted and the memory returned to the free list. The nodes pointed to by those edges are
unchanged.

\section{\protect\verb+graph\_get\_atom\_number+}
\begin{verbatim}
unsigned long graph_get_atom_number(const void *graph_or_node_or_edge)
\end{verbatim}
Return the unique atom number for a graph atom. Atom numbers are allocated in an ascending sequence
starting from 1 in the order in which atoms are inserted. Atom numbers are never reused, even after
atoms have been deleted.

\section{\protect\verb+graph\_get\_next\_edge+}
\begin{verbatim}
void *graph_get_next_edge(const void* node_or_edge)
\end{verbatim}
Get the next member of the edge list emanating from a node or an edge.
If this routine is passed an atom that corresponds to a node, then the
returned edge will be the first edge in that node's list. If the routine
is passed an atom that corresponds to an edge, then the successor to
that edge will be returned. If there is no next edge, then {\tt NULL} is
returned.

\section{\protect\verb+graph\_get\_edge\_target+}
\begin{verbatim}
void * graph_get_edge_target(const void * edge)
\end{verbatim}
Return a handle to the node atom pointed to by the {\tt edge}, that is the value of the
ancillary pointer for atom {\tt edge}.

\section{\protect\verb+graph\_get\_final\_edge+}
\begin{verbatim}
void * graph_get_final_edge(const void * node_or_edge) 
\end{verbatim}
Get the final member of the edge list emanating from a node or an edge.
If this routine is passed an atom that corresponds to a node, then the
returned edge will be the last edge in that node's list. If the routine
is passed an atom that corresponds to an edge, then the last element of that
atoms's successor list will be returned. If the edge list is empty, then {\tt NULL} is
returned.

\section{\protect\verb+graph\_get\_final\_node+}
\begin{verbatim}
void * graph_get_final_node(const void * node_or_edge) 
\end{verbatim}
Get the final member of the node list emanating from a graph atom or a node atom.
If this routine is passed an atom that corresponds to a graph, then the
returned node will be the last node in that graph's list. If the routine
is passed an atom that corresponds to an node, then the last element of that
atoms's successor list will be returned. If the node list is empty, then {\tt NULL} is
returned.

\section{\protect\verb+graph\_hash\_double+}
\begin{verbatim}
unsigned graph_hash_double(unsigned hash_prime, void *data)
\end{verbatim}
Hash a double precision real number. See Chapter~\ref{symbol} on symbol tables for more
information on hashing.

\section{\protect\verb+graph\_hash\_long+}
\begin{verbatim}
unsigned graph_hash_long(unsigned hash_prime, void *data)
\end{verbatim}
Hash an unsigned long integer. See Chapter~\ref{symbol} on symbol tables for more
information on hashing.

\section{\protect\verb+graph\_hash\_mem+}
\begin{verbatim}
unsigned graph_hash_mem(unsigned hash_prime, void *data)
\end{verbatim}
Hash a length encoded block of memory. See Chapter~\ref{symbol} on symbol tables for more
information on hashing.

\section{\protect\verb+graph\_hash\_string+}
\begin{verbatim}
unsigned graph_hash_string(unsigned hash_prime, void *data)
\end{verbatim}
Hash a zero terminated string. See Chapter~\ref{symbol} on symbol tables for more
information on hashing.

\section{\protect\verb+graph\_insert\_edge+}
\begin{verbatim}
void *graph_insert_edge(size_t size, void* target_node, void* node_or_edge)
\end{verbatim}
Insert an edge into a graph, allocating {\tt size} bytes for user data
and setting \verb+target_node+ as the destination of the edge. If
parameter \verb+node_or_edge+ is passed a node atom then the new edge is
inserted at the first element of that node's edge list with the original
list as the successor to the new edge. If parameter \verb+node_or_edge+
is passed an edge atom then the new edge is inserted at the successor to
that edge.

\section{\protect\verb+graph\_insert\_graph+}
\begin{verbatim}
void *graph_insert_graph(char *id)
\end{verbatim}
Insert a new graph into the library's graph list, allocating space for a character
pointer which is set to {\tt id}.

\section{\protect\verb+graph\_insert\_node+}
\begin{verbatim}
void *graph_insert_node(size_t size, void* node_or_graph)
\end{verbatim}
Insert a node into a graph, allocating {\tt size} bytes for user data. If
parameter \verb+node_or_graph+ is passed a graph atom then the new node is
inserted at the first element of that graph's node list with the original
list as the successor to the new node. If parameter \verb+node_or_graph+
is passed a node atom then the new node is inserted at the successor to
that node.

\section{\protect\verb+graph\_insert\_node\_child+}
\begin{verbatim}
void *graph_insert_node_child(size_t node_size, size_t edge_size, 
                              void* parent_node)
\end{verbatim}
Insert a new node and an edge from \verb+parent_node+ to the new node, reserving
\verb+node_size+ bytes of space in the new node atom and \verb+edge_size+ bytes of space
in the new edge atom.

\section{\protect\verb+graph\_insert\_node\_parent+}
\begin{verbatim}
void *graph_insert_node_parent(size_t node_size, size_t edge_size, 
                               void* child_node)
\end{verbatim}
Insert a new node and an edge from it to \verb+child_node+, reserving
\verb+node_size+ bytes of space in the new node atom and \verb+edge_size+ bytes of space
in the new edge atom.


\section{\protect\verb+graph\_vcg+}
\begin{verbatim}
void graph_vcg(void *graph,
               void (*graph_action)(const void *graph), 
               void (*node_action) (const void *node),
               void (*edge_action) (const void *edge)
              )
\end{verbatim}
Output {\tt graph} in VCG format to the current {\tt textio} output
stream which by default is the screen. See Chapter~\ref{textio} for
information on how to redirect the textio output stream. The three
function pointers \verb+graph_action+, \verb+node_action+ and
\verb+edge_action+ are {\em callback} functions that will be called once
for each graph, node and edge atom respectively in the graph with the
handle of the graph atom as a parameter. These callback functions can be
used to output VCG specific tags so as to, for instance, change the
colour and shape of a node or the size of the arrowhead on an edge.
Figure~\ref{graph:example:in} was produced using this function.

\section{\protect\verb+graph\_vcg\_atoms+}
\begin{verbatim}
void graph_vcg_atoms(void *graph,
                     void(* graph_action)(const void * graph), 
                     void (*node_action) (const void *node),
                     void (*edge_action) (const void *edge)
                    )
\end{verbatim}
Output the atoms in {\tt graph} in VCG format to the current {\tt textio} output
stream which by default is the screen. See Chapter~\ref{textio} for
information on how to redirect the textio output stream. The three
function pointers \verb+graph_action+, \verb+node_action+ and
\verb+edge_action+ are {\em callback} functions that will be called once
for each graph, node and edge atom respectively in the graph with the
handle of the graph atom as a parameter. These callback functions can be
used to output VCG specific tags so as to, for instance, change the
colour and shape of a node or the size of the arrowhead on an edge.
Figure~\ref{graph:example:out} was produced using this function.


\chapter{{\tt memalloc} -- memory management routines}

The {\tt memalloc} routines replicate the ANSI standard memory
management routines but issue a fatal error message if an error occurs.
They all return a void pointer which in general will need to be cast to
the required pointer type. Several of these routines use parameters of
type \verb+size_t+: ANSI C translators provide an implementation
dependent definition of \verb+size_t+ which is guaranteed to be able to
represent the largest data object that may be created using that
translator. Most often it will be either an {\tt unsigned~int} or an
{\tt unsigned~long}.

\section{\protect\verb+mem\_calloc+}
\begin{verbatim}
void *mem_calloc(size_t nitems, size_t size)
\end{verbatim}
Allocate a block of memory large enough to hold {\tt nitems} of size
{\tt size} and then clear the contents to zero. Return a void pointer to the
first location in the block. Exit with a fatal error if insufficient
memory is available to allocate the requested block size.

\section{\protect\verb+mem\_free+}
\begin{verbatim}
void mem_free(void *block)
\end{verbatim}
Free a block previously allocated by a call to one of the other
\verb+mem_+ routines. Exit with a fatal error if {\tt block} is null.
Attempting to a free a pointer that is not referring to a previously
allocated block results in unpredictable behaviour.

\section{\protect\verb+mem\_malloc+}
\begin{verbatim}
void *mem_malloc(size_t size)
\end{verbatim}
Allocate a block of memory of size
{\tt size}. Return a void pointer to the
first location in the block. The memory block is not initialised.
Exit with a fatal error if insufficient
memory is available to allocate the requested block size.

\section{\protect\verb+mem\_print\_statistics+}
\begin{verbatim}
void mem_print_statistics(void)
\end{verbatim}
Print out the number of bytes of memory allocated using
\verb+mem_malloc+, \verb+mem_calloc+ and \verb+mem_realloc+ since the
program started running.

\section{\protect\verb+mem\_realloc+}
\begin{verbatim}
void *mem_realloc(void *block, size_t size)
\end{verbatim}
Change the size of a previously allocated memory block to {\tt size}. If
necessary, a completely new memory block will be created and the
necessary copying of data between old and new blocks performed
automatically. Return a void pointer to the first location in the block.
Any new memory area beyond the end of the old block  memory block is not
initialised, and will therefore contain unpredictable data immediately
after a call to {\tt mem\_realloc}. Exit with a fatal error if
insufficient memory is available to allocate the requested block size.

\chapter{{\tt scan} -- scanner support routines}

The scanner is such an integral part of the \rdp\ system that is
unlikely to ever be used as a general purpose package: all \rdp\
generated parsers automatically contain the necessary calls to these
routines. They are documented here for completeness.

\section{\protect\verb+scan\_column\_number+}
\begin{verbatim}
unsigned long scan_column_number(void)
\end{verbatim}
Return the start column number for the most recently scanned lexeme.

\section{\protect\verb+scan\_init+}
\begin{verbatim}
void scan_init(const int case_insensitive, 
               const int newline_visible, 
               const int show_skips, 
               const int symbol_echo, 
               char *token_names)
\end{verbatim}
Initialise the scanner subsystem. This routine {\em must} be called
before calling any other scanner routines. It is an error to call this
routine twice.
As well as creating a symbol table to hold the scanner keywords,
\begin{verbatim}
scan_init
\end{verbatim}
accepts parameters that control the overall behaviour of the scanner as
follows:
\begin{itemize}
\item \verb+case_insensitive+
If true, then convert uppercase alphabetic characters to lowercase
before lexical analysis except in extended tokens such as strings and
comments.

\item \verb+newline_visible+
If true, then pass newline characters to the parser as token
\verb+EOLN+, otherwise discard newlines in the scanner.
 
\item \verb+show_skips+
If true, issue a {\tt skipping to ...} message during error recovery.

\item \verb+symbol_echo+
If true, print the token value of each symbol as it is scanned.

\item \verb+token_names+
A string containing the token names in ASCII, each name terminated by a
null character (\verb+\0+). If null then error messages will only report
the token number in decimal. If there are fewer strings than tokens defined,
unexpected error messages will cause unpredictable behaviour.
\end{itemize}

\section{\protect\verb+scan\_line\_number+}
\begin{verbatim}
unsigned long scan_line_number(void)
\end{verbatim}
Return the current line number of the file being scanned. The line number
reported is the line number at the start of the most recently parsed token.
Visible comment tokens can be many lines long, so the line numbers reported
during a scan may not be contiguous.

\section{\protect\verb+scan\_load\_keyword+}
\begin{verbatim}
void scan_load_keyword(char *id1, const char *id2, const int token,
                       const int extended)
\end{verbatim}
Load the keyword {\tt id1} into the scanner's symbol table and mark it
as token number {\tt token}. Extended tokens such as \verb+STRING_ESC+
and \verb+COMMENT+ use the {\tt id2} parameter to specify a
supplementary token. The class of an extended token is specified using
the {\tt extended} parameter.

The scanner recognises keywords and punctuation symbols by comparing the
input with the contents of its own symbol table. It is sometimes useful
to add elements to the scanner table during program parsing. In
particular, the C language {\tt typedef} statement creates new names for
types which may be indistinguishable from variable names without
lookahead in certain contexts. Indeed, rather remarkably it is legal in
C to have a type name and a variable name which are identical, that is
the names must inhabit separate name space. In situations like these it
is sometimes useful to be able to {\em create} new keywords during
execution.


\section{\protect\verb+scan\_prune\_tree+}
\begin{verbatim}
void scan_prune_tree(scan_data * rdp_tree)
\end{verbatim}
Prune empty (epsilon) nodes from the derivation tree.

\section{\protect\verb+scan\_test+}
\begin{verbatim}
int scan_test(const char *production, const int valid,
              set_ * stop)
\end{verbatim}
Test to see if the current token number equals {\tt valid} and return a
1 if the test succeeds or else a 0 if the test fails. If the current
token is {\em not} equal to {\tt valid} and {\tt stop} is not {\tt NULL}
then generate an error message and skip until a token in {\tt stop} is
detected. If {\tt production} is not {\tt NULL}, then preface the error
message with the production name. RDP uses this parameter when the {\tt
-E} switch is used during parser generation.

\section{\protect\verb+scan\_test\_set+}
\begin{verbatim}
int scan_test_set(const char *production, set_ * valid,
                  set_ * stop)
\end{verbatim}
Test to see if the current token number is a member of set {\tt valid} 
and return a 1 if the test succeeds or else a 0 if the test fails. If
the current token is {\em not} in {\tt valid} and {\tt stop} is not {\tt
NULL} then generate an error message and skip until a token in {\tt
stop} is detected. If {\tt production} is not {\tt NULL}, then preface
the error message with the production name. RDP uses this parameter when
the {\tt -E} switch is used during parser generation.

\section{\protect\verb+scan\_vcg\_print\_node+}
\begin{verbatim}
void scan_vcg_print_node(const void* node)
\end{verbatim}
RDP generated parsers can automatically build derivation trees during a
parse which show how the productions in a grammar are activated:
essentially the derivation tree is a trace of the path taken by the
parser. These derivation trees can be written to a text file in a form
suitable for input to the VCG (Visualisation of Compiler Graphs)
tool~\cite{SANDER95}, which can then display the tree under MS-Windows,
Windows-95 or X-windows. The derivation trees are built using the {\tt
graph} library. This routine is called once for each node in the tree
during the last pass of the parser, and produces scanner specific labels
in the displayed tree.

\chapter{{\tt set} -- a dynamic set handler}

Set manipulation is central to many parsing algorithms, and a space
efficient set representation is an important part of the \rdpsupp\
library. Sets are represented as variable length bit strings, and the
common operations such as set union are implemented as bitwise logical
operations. 

The set handler can handle sets of integers or {\tt enum} elements
(which in C are really integers in disguise) in the range 0 to
(\verb+MAX_UNSIGNED+ $-$ 1) where \verb+MAX_UNSIGNED+ is the ANSI
standard C macro that expands to the largest encodable {\tt unsigned}
number. Each set is represented by a structure which contains an
unsigned integer called  {\tt size}, and a pointer to a block of memory
on the heap as shown in Figure~\ref{set:structure}. When initially
created a set contains a null pointer, that is its total memory
consumption is \verb|(sizeof(unsigned) + sizeof(void *))|.

\begin{figure}
\begin{center}
\input{set.pic}
\end{center}
\caption{Set data structure}
\label{set:structure}
\end{figure}

As elements are added to a set, the set package automatically grows the
set by allocating extra storage. Sets can only grow in multiples of a
 byte,
so set size is always rounded up to the nearest eight bits.

Simply clearing bits in a set is not enough to release the memory.
The only routines that can cause a set to shrink are \verb+set_free()+
which clears the set and returns allocated memory to the heap, and
\verb+set_normalise()+ which removes empty bytes from the end of a set.

To reduce the number of reallocation calls made to the memory manager it
is possible to define a minimum size for a set below which it will not
shrink. By default the minimum set size is zero bytes.

Set names are always passed by address since C passes structures by
value not name. 

The basic set operations such as union and intersection are implemented in three
 different forms\dash so-called {\em element}, {\em list} and {\em set\/}
forms. Each form takes the address of a set as the destination
parameter, but the source might be either a single integer (the element
form), a list of integers (the list form) or another set (the set form).
A list is terminated by the constant \verb+SET_END+ which is defined in
{\tt set.h} to be \verb+MAX_UNSIGNED+. This extract 
illustrates the use of the three different
forms:
\begin{quote}
\begin{verbatim}
  set_unite_element(&first, 5)
  set_unite_list(&first, 8, 1, 3, SET_END)
  set_unite_set(&first, &second)
\end{verbatim}
\end{quote}

\section{\protect\verb+set\_array+}
\begin{verbatim}
unsigned *set_array(const set_ * src)
\end{verbatim}
When iterating over the contents of a set it is inefficient to test each
bit individually. This routine takes a set and returns an array of {\tt
unsigned} integers, one for each element of the set. A final element is
set to \verb+SET_END+. Once this array has been created, set iterations
may be implemented by iterating over the elements of the array:
\begin{quote}
\begin{verbatim}
  set_ src
  unsigned *elements = set_array(src)

  while (*elements != SET_END)
  {
    ...

    elements++
  }

\end{verbatim}
\end{quote}

When you have finished using the array created by calling
\verb+set_array+, you can free the memory by simply calling
\verb+mem_free()+:
\begin{quote}
\begin{verbatim}
  mem_free(elements)
\end{verbatim}
\end{quote}

\section{\protect\verb+set\_cardinality+}
\begin{verbatim}
unsigned set_cardinality(const set_ * src)
\end{verbatim}
Return the number of elements in set {\tt src}.

\section{\protect\verb+set\_assign\_element+}
\begin{verbatim}
void set_assign_element(set_ * dst, const unsigned element)
\end{verbatim}
Clear {\tt dst} and then assign the single {\tt element} to it.

\section{\protect\verb+set\_assign\_list+}
\begin{verbatim}
void set_assign_list(set_ * dst,...)
\end{verbatim}
Clear {\tt dst} and then assign the list of elements to it.

\section{\protect\verb+set\_assign\_set+}
\begin{verbatim}
void set_assign_set(set_ * dst, const set_ * src)
\end{verbatim}
Copy {\tt src} to {\tt dst}.

\section{\protect\verb+set\_compare+}
\begin{verbatim}
int set_compare(set_ * dst, set_ * src)
\end{verbatim}
Return 0 if {\tt src} and {\tt dst} are each subsets of each other (i.e.
they contain exactly the same elements). It is not necessary for the
sets to be the same length for this test to succeed. The routine returns
$-1$ if {\tt src} is `less than' {\tt dst} and $+1$ if {\tt src} is
`greater than' {\tt dst}. The exact definition of greater than and less
than is not significant: the existence of a collation sequence allows
sets to be used as symbol table keys.

\section{\protect\verb+set\_difference\_element+}
\begin{verbatim}
void set_difference_element(set_ * dst, const unsigned element)
\end{verbatim}
Remove {\tt element} from {\tt dst}.  It is not an
error to remove an element that is not in a set.

\section{\protect\verb+set\_difference\_list+}
\begin{verbatim}
void set_difference_list(set_ * dst,...)
\end{verbatim}
Remove each member of the list of elements from {\tt dst}. It is not an
error to remove an element that is not in a set.

\section{\protect\verb+set\_difference\_set+}
\begin{verbatim}
void set_difference_set(const set_ * dst, const set_ * src)
\end{verbatim}
Remove every element in {\tt src} from {\tt dst}.  It is not an
error to remove an element that is not in a set.

\section{\protect\verb+set\_free+}
\begin{verbatim}
void set_free(set_ * dst)
\end{verbatim}
Clear {\tt dst} and return the bit vector storage to the heap.

\section{\protect\verb+set\_grow+}
\begin{verbatim}
void set_grow(set_ * dst, const unsigned length)
\end{verbatim}
Expand {\tt dst} so that it is {\tt length} bytes long and therefore
capable of holding elements in the range 0 \ldots ({\tt length}$\times8) -1$.

\section{\protect\verb+set\_includes\_element+}
\begin{verbatim}
int set_includes_element(set_ * dst, const unsigned element)
\end{verbatim}
Return 1 if set {\tt dst} contains {\tt element} otherwise 0.

\section{\protect\verb+set\_includes\_list+}
\begin{verbatim}
int set_includes_list(set_ * dst,...)
\end{verbatim}
Return 1 if set {\tt dst} contains every element in the list otherwise 0.

\section{\protect\verb+set\_includes\_set+}
\begin{verbatim}
int set_includes_set(const set_ * dst, const set_ * src)
\end{verbatim}
Return 1 if set {\tt dst} contains every element in {\tt src} otherwise 0.

\section{\protect\verb+set\_intersect\_element+}
\begin{verbatim}
void set_intersect_element(set_ * dst, const unsigned element)
\end{verbatim}
Remove every element in {\tt dst} apart from {\tt element}.

\section{\protect\verb+set\_intersect\_list+}
\begin{verbatim}
void set_intersect_list(set_ * dst,...)
\end{verbatim}
Remove every element in {\tt dst} that is not in the list.

\section{\protect\verb+set\_intersect\_set+}
\begin{verbatim}
void set_intersect_set(set_ * dst, const set_ * src)
\end{verbatim}
Remove every element in {\tt dst} that is not in {\tt src}.

\section{\protect\verb+set\_complement+}
\begin{verbatim}
void set_invert(set_ * dst, const unsigned universe)
\end{verbatim}
Form the complement of {\tt dst} in universe 0, \ldots, {\tt universe} by
complementing all bits in the vector and then clearing bits
corresponding to {\tt universe} and above.

\section{\protect\verb+set\_minimum\_size+}
\begin{verbatim}
unsigned set_minimum_size(const unsigned minimum_size)
\end{verbatim}
Set a minimum length below which \verb+set_normalise()+ will not shrink
any set.

\section{\protect\verb+set\_normalise+}
\begin{verbatim}
void set_normalise(set_ * dst)
\end{verbatim}
Delete zero bytes from the end of a bit vector and update the size
field, i.e. reduce a set to its minimum storage requirement. Do not
shrink to less than the value set by the last call to \verb+set_minimum_size+.


\section{\protect\verb+set\_print\_element+}
\begin{verbatim}
void set_print_element(const unsigned element, const char *element_names)
\end{verbatim}
Print a single set element. If \verb+element_names+ is {\tt NULL} then
simply print the decimal representation of the element number. If
\verb+element_names+ is non-null, it is assumed to be an ASCII string
made up of null delimited substrings, one per element. The routine
 counts substrings from the left until it finds the name of the set
element and prints that instead of the decimal number.

\section{\protect\verb+set\_print\_set+}
\begin{verbatim}
void set_print_set(const set_ * src, const char *element_names, 
                   unsigned line_length)
\end{verbatim}
Print all elements in {\tt src}. If \verb+element_names+ is {\tt NULL}
then simply print the decimal representation of the element numbers. If
\verb+element_names+ is non-null, it is assumed to be an ASCII string
made up of null delimited substrings, one per element. The routine finds
counts substrings from the left until it finds the name of the set
element and prints that instead of the decimal number.

Whenever the routine starts to print out a new set element, it checks to see
whether the length of the current output line exceeds \verb+line_length+. If
so, it prints a newline before proceeding. This parameter can be used to 
avoid printing very long lines by setting an upper bound on the start column
of a set element. Note that this does not have the effect of limiting line
length to the set value because the actual line lengths will depend on the 
length of the set element names.

This routine is used by \rdp\ to build the error messages when a parser
syntax error occurs. See the routine \verb+scan_test_set()+.

\section{\protect\verb+set\_unite\_element+}
\begin{verbatim}
void set_unite_element(set_ * dst, const unsigned element)
\end{verbatim}
Add {\tt element} to {\tt dst}.

\section{\protect\verb+set\_unite\_list+}
\begin{verbatim}
void set_unite_list(set_ * dst,...)
\end{verbatim}
Add a list of elements to {\tt dst}.

\section{\protect\verb+set\_unite\_set+}
\begin{verbatim}
void set_unite_set(set_ * dst, const set_ * src)
\end{verbatim}
Add each element in {\tt src} to {\tt dst}.

\chapter{{\tt symbol} -- a hash coded symbol table manager}
\label{symbol}
\section{Data structures}
An efficient symbol table manager is crucial to the performance of any translator.
Many languages require symbol table access during
scanning simply to resolve grammatical ambiguities, and semantic
analysis usually requires symbol table manipulation if the underlying grammar is to
remain context free. The \rdp\ symbol table manager is particularly
flexible, allowing multiple symbol tables to be managed. The user data
associated with each symbol can be defined with complete freedom, and
the internal links used to maintain the hash table are hidden.
There is no inherent reason why symbols in
a particular table should not carry different user data as long as the
key fields are in the same place in each record. The \rdp\ EBNF provides
a \verb+SYMBOL_TABLE+ directive which automatically creates and
initialises symbol tables. See the file \verb+rdp.bnf+ for a
particularly complicated example of its use.

\begin{figure}
\begin{center}
\input{symbol.pic}
\end{center}
\caption{Symbol table data structure}
\label{symbol:structure}
\end{figure}

\rdp\ maintains a linked list of symbol tables. Each symbol table is
described by a header record that contains pointers to a hash table, a
scope list, various maintenance functions and some book keeping data.
The basic layout is illustrated in Figure~\ref{symbol:structure}.

Whenever a symbol is to be inserted into the table, its key fields are
{\em hashed} generating a random number in the range 0 \ldots {\tt
size}. This hash number is then used to index into the hash table,
selecting one of the linked lists. The symbol is then added to the head
of the list. A lookup is performed by hashing the test symbol and then
searching down the list for a match. Since the most recent additions are
always examined first, the structure directly implements nested scope
rules in that a new symbol will hide any symbols with the same key
deeper in the table.

The hash lists are in fact doubly linked so that symbols can be quickly
unlinked from the chain.

Whenever a symbol is added to a hash list, it is also added to the head
of the current scope chain. New scope regions may be declared, in which case a
new scope record is created and added to the head of the scope list. The
scope pointers are represented in Figure~\ref{symbol:structure} by
curved arrows. Although not shown on the diagram, each symbol maintains
a back link to its scope record allowing efficient checking of the
scope level for a particular symbol. The current scope may be reset to
a previously declared scope.

Different kinds of user data record are allowed for by parameterising
the functions that hash, compare and print symbols. These are supplied
as function pointers when the symbol table is declared. Most symbol
tables (certainly all those in the distributed grammars) simply use a
single string as the key field.  The library provides standard hash and
compare functions for the special (although common) case of a symbol in
which the first field is a character string (i.e. a pointer to {\tt
char}) which acts as the key field. Functions are also provided for an
initial \verb+set_+ key field. If you need to do something more baroque,
such as hashing on both a string and a numeric name space, then you will
have to write your own functions. Try looking at the source code for
\verb+symbol_compare_string()+, \verb+symbol_hash_string()+ and
\verb+symbol_print_string()+ for ideas.


All of the pointers embedded in the symbols are hidden from the user,
and symbols are manipulated {\em via} {\tt void} pointers to the first
location in the user data block. \rdp\ defines casting macros for each
symbol table to make user data field access less verbose. See the file
\verb+miniplus.bnf+ for examples.

The {\tt symbol} table package was originally developed along the lines
described in the `Dragon Book' \cite{dragon}. The idea of hiding the
pointers and using function pointers in a sort of poor man's object
oriented programming was taken from Holub's book on compilers
\cite{holub} although things have implemented rather differently here and
a more complete set of routines is provided. We also took the idea of
storing a symbol's hash number within it to allow fast lookup from the
symbol table module that Terence Parr supplies with the PCCTS
\cite{PARR95} compiler-compiler suite.


\section{\protect\verb+symbol\_compare\_double+}
\begin{verbatim}
int symbol_compare_double(void *left, void *right)
\end{verbatim}
Compare double precision real keys for equality. The first element of
the user data structure must be a {\tt double}. Return 0 if they are
equal, $+1$ if {\tt left} $>$ {\tt right} or $-1$ if {\tt right} $<$
{\tt left}, just like the ANSI routine {\tt strcmp()}. For symbols that
are keyed on a single {\tt double}, this routine may be used as the {\tt\em
compare} parameter to \verb+symbol_init()+ and the \rdp\ directive
\verb+SYMBOL_TABLE+.

\section{\protect\verb+symbol\_compare\_double\_reverse+}
\begin{verbatim}
int symbol_compare_double_reverse(void *left, void *right)
\end{verbatim}
Compare double precision real keys for equality with reverse polarity.
The first element of the user data structure must be a {\tt double}.
Return 0 if they are equal, $+1$ if {\tt left} $<$ {\tt right} or $-1$
if {\tt right} $>$ {\tt left}. For symbols that are keyed on a single
{\tt double}, this routine may be used as the {\tt\em compare} parameter to
\verb+symbol_init()+ and the \rdp\ directive \verb+SYMBOL_TABLE+.

\section{\protect\verb+symbol\_compare\_long+}
\begin{verbatim}
int symbol_compare_long(void *left, void *right)
\end{verbatim}
Compare long integer keys for equality. The first element of the user data
structure must be a {\tt long int}. Return 0 if they are equal, $+1$ if
{\tt left} $>$ {\tt right} or $-1$ if {\tt right} $<$ {\tt left}, just
like the ANSI routine {\tt strcmp()}. For symbols that are keyed on a
single long integer, this routine may be used as the {\tt\em compare}
parameter to \verb+symbol_init()+ and the \rdp\ directive \verb+SYMBOL_TABLE+.

\section{\protect\verb+symbol\_compare\_long\_reverse+}
\begin{verbatim}
int symbol_compare_long_reverse(void *left, void *right)
\end{verbatim}
Compare long integer keys for equality with reverse polarity. The first element of the user data
structure must be a {\tt long int}. Return 0 if they are equal, $+1$ if
{\tt left} $<$ {\tt right} or $-1$ if {\tt right} $>$ {\tt left}, just
like the ANSI routine {\tt strcmp()}. For symbols that are keyed on a
single long integer, this routine may be used as the {\tt\em compare}
parameter to \verb+symbol_init()+ and the \rdp\ directive \verb+SYMBOL_TABLE+.

\section{\protect\verb+symbol\_compare\_string+}
\begin{verbatim}
int symbol_compare_string(void *left, void *right)
\end{verbatim}
Compare string keys for equality. The first element of the user data
structure must be a {\tt char*}. Return 0 if they are equal, $+1$ if
{\tt left} $>$ {\tt right} or $-1$ if {\tt right} $<$ {\tt left}, just
like the ANSI routine {\tt strcmp()}. For symbols that are keyed on a
single string, this routine may be used as the {\tt\em compare}
parameter to \verb+symbol_init()+ and the \rdp\ directive \verb+SYMBOL_TABLE+.

\section{\protect\verb+symbol\_compare\_string\_reverse+}
\begin{verbatim}
int symbol_compare_string_reverse(void *left, void *right)
\end{verbatim}
Compare string keys for equality with reverse polarity. The first element of the user data
structure must be a {\tt char*}. Return 0 if they are equal, $+1$ if
{\tt left} $<$ {\tt right} or $-1$ if {\tt right} $>$ {\tt left}, just
like the ANSI routine {\tt strcmp()}. For symbols that are keyed on a
single string, this routine may be used as the {\tt\em compare}
parameter to \verb+symbol_init()+ and the \rdp\ directive \verb+SYMBOL_TABLE+.

\section{\protect\verb+symbol\_find+}
\begin{verbatim}
void symbol_find(const void *table, void *key, size_t key_size, 
                size_t symbol_size, void* scope, 
                enum SYMBOL_FIND_OP op)
\end{verbatim}
\begin{verbatim}
enum SYMBOL_FIND_OP {SYMBOL_NEW, SYMBOL_OLD, SYMBOL_ANY}
\end{verbatim}
\section{\protect\verb+symbol\_free\_scope+}
\begin{verbatim}
void symbol_free_scope(const void *scope)
\end{verbatim}
Unlink all symbols in a scope chain and then free all memory associated
with them. Unlink the scope record from the scope chain and free the
memory associated with it.

\section{\protect\verb+symbol\_free\_symbol+}
\begin{verbatim}
void symbol_free_symbol(void *symbol)
\end{verbatim}
Free the memory associated with a symbol. Unpredictable behaviour will
occur if a symbol is freed before unlinking it from the symbol table.

\section{\protect\verb+symbol\_free\_table+}
\begin{verbatim}
void symbol_free_table(void *table)
\end{verbatim}
Free all memory associated with a table and all symbols and scope
records within it.

\section{\protect\verb+symbol\_get\_scope+}
\begin{verbatim}
void *symbol_get_scope(const void *table)
\end{verbatim}
Return a pointer to the scope record for the current scope level.

\section{\protect\verb+symbol\_hash\_double+}
\begin{verbatim}
unsigned symbol_hash_double(unsigned hash_prime, void *data)
\end{verbatim}
\section{\protect\verb+symbol\_hash\_long+}
\begin{verbatim}
unsigned symbol_hash_long(unsigned hash_prime, void *data)
\end{verbatim}
\section{\protect\verb+symbol\_hash\_mem+}
\begin{verbatim}
unsigned symbol_hash_mem(unsigned hash_prime, void *data)
\end{verbatim}
Hash a length encoded string.
For symbols that are keyed on a
single length encoded string, this routine may be used as the {\tt\em hash}
parameter to \verb+symbol_init()+ and the \rdp\ directive \verb+SYMBOL_TABLE+.


\section{\protect\verb+symbol\_hash\_string+}
\begin{verbatim}
unsigned symbol_hash_string(unsigned hash_prime, void *data) 
\end{verbatim}
Hash a zero terminated string.
For symbols that are keyed on a
single string, this routine may be used as the {\tt\em hash}
parameter to \verb+symbol_init()+ and the \rdp\ directive \verb+SYMBOL_TABLE+.

\section{\protect\verb+symbol\_insert\_key+}
\begin{verbatim}
void *symbol_insert_key(const void *table, char *str, size_t size)
\end{verbatim}
Make a new symbol with a user data area {\tt size} bytes long.
Put a pointer to {\tt str} in the user first user
data field. Hash the symbol and insert in the table. 

\section{\protect\verb+symbol\_insert\_symbol+}
\begin{verbatim}
void *symbol_insert_symbol(const void *table, void *symbol) 
\end{verbatim}
Hash an existing symbol and insert it in the table.

\section{\protect\verb+symbol\_lookup\_key+}
\begin{verbatim}
void * symbol_lookup_key(const void * table, void * key, void * scope)
\end{verbatim}
Hash the key and lookup up the symbol. Return {\tt NULL} if not found,
otherwise a pointer to the base of the user data in the found symbol.
Parameter {\tt scope} restricts the search to scope level {\tt scope}.
If {\tt scope} is {\tt NULL}, then all scopes are searched.

\section{\protect\verb+symbol\_new\_scope+}
\begin{verbatim}
void *symbol_new_scope(void *table, char *str) 
\end{verbatim}
Create a new named scope and add it to the head of the scope list. Make
the new scope current.

\section{\protect\verb+symbol\_new\_symbol+}
\begin{verbatim}
void *symbol_new_symbol(size_t size) 
\end{verbatim}
Allocate enough memory for the symbol table pointers plus {\tt size}
bytes of user data. Return a pointer to the base of the user data.

\section{\protect\verb+symbol\_new\_table+}
\begin{verbatim}
void *symbol_new_table(char *name,
                       const unsigned symbol_hashsize,
                       const unsigned symbol_hashprime,
                       int (*compare) (void *left_symbol, void *right_symbol),
                       unsigned (*hash) (unsigned hash_prime, void *data),
                       void (*print) (const void *symbol))
\end{verbatim}
Create a new symbol table and add it to the head of the linked list of
tables. Return a pointer to the table which may be used to name the
table in subsequent calls. The table will have {\tt size} hash buckets.
See {\tt rdp.c} for examples of use.

\section{\protect\verb+symbol\_next\_symbol+}
\begin{verbatim}
void *symbol_next_symbol(void *table, void *symbol)
\end{verbatim}
Sometimes it is necessary to look down a hash chain beyond a found
symbol, for instance to locate instances of symbols with the same key
that were inserted previously. This routine takes a pointer to a symbol
and then continues to search down the same chain until it finds another
match or reaches the end of the list. Return {\tt NULL} if no other
matching symbol is found, otherwise a pointer to the base of the user data.

\section{\protect\verb+symbol\_next\_symbol\_in\_scope+}
\begin{verbatim}
void *symbol_next_symbol_in_scope(void *symbol)
\end{verbatim}
This routine returns the next symbol in a scope chain. Prior to any
sorting, symbols will be returned in the reverse order to that in which
they were inserted.

\section{\protect\verb+symbol\_print\_all\_table+}
\begin{verbatim}
void symbol_print_all_table(void) 
\end{verbatim}
Print a diagnostic dump of all symbol tables currently active.

\section{\protect\verb+symbol\_print\_all\_table\_statistics+}
\begin{verbatim}
void symbol_print_all_table_statistics(const int histogram_size)
\end{verbatim}
Print summary statistics for all symbol tables currently active. \rdp\
generated parsers call this routine when the {\tt -S} command line
option is active.

\section{\protect\verb+symbol\_print\_double+}
\begin{verbatim}
void symbol_print_double(const void *symbol) 
\end{verbatim}
Print the first element in the user data as a double precision real.
For symbols that are keyed on a
single real, this routine may be used as the {\tt\em print}
parameter to \verb+symbol_init()+ and the \rdp\ directive \verb+SYMBOL_TABLE+.

\section{\protect\verb+symbol\_print\_long+}
\begin{verbatim}
void symbol_print_long(const void *symbol)
\end{verbatim}
Print the first element in the user data as a long integer.
For symbols that are keyed on a
single long integer, this routine may be used as the {\tt\em print}
parameter to \verb+symbol_init()+ and the \rdp\ directive \verb+SYMBOL_TABLE+.

\section{\protect\verb+symbol\_print\_string+}
\begin{verbatim}
void symbol_print_string(const void *symbol) 
\end{verbatim}
Print the first element in the user data as a pointer to string.
For symbols that are keyed on a
single string, this routine may be used as the {\tt\em print}
parameter to \verb+symbol_init()+ and the \rdp\ directive \verb+SYMBOL_TABLE+.


\section{\protect\verb+symbol\_print\_scope+}
\begin{verbatim}
void symbol_print_scope(const void *table, void *scope) 
\end{verbatim}
Print all symbols in the scope chain pointed to by {\tt scope}.

\section{\protect\verb+symbol\_print\_symbol+}
\begin{verbatim}
void symbol_print_symbol(const void *table, const void *symbol) 
\end{verbatim}
Print a single symbol.

\section{\protect\verb+symbol\_print\_table+}
\begin{verbatim}
void symbol_print_table(const void *table) 
\end{verbatim}
Print the entire contents of the symbol table pointed to by {\tt table}.

\section{\protect\verb+symbol\_print\_table\_statistics+}
\begin{verbatim}
void symbol_print_table_statistics(const void *table, 
                                   const int histogram_size)
\end{verbatim}
Print summary statistics for the symbol table pointed to by {\tt table}.

\section{\protect\verb+symbol\_set\_scope+}
\begin{verbatim}
void symbol_set_scope(void *table, void *scope)
\end{verbatim}
Set the current scope to {\tt scope}, which must be a pointer returned
by a previous call to \verb+symbol_new_scope()+ or \verb+symbol_get_scope()+.

\section{\protect\verb+symbol\_sort\_table+}
\begin{verbatim}
void symbol_sort_table(void *table)
\end{verbatim}
Sort all scope chains in a table using the ordering defined by {\tt compare} function.

\section{\protect\verb+symbol\_sort\_scope+}
\begin{verbatim}
void symbol_sort_scope(void *table, void *scope)
\end{verbatim}
Sort a scope chain using the ordering defined by {\tt compare} function.
\rdp\ uses this function to alphabetically sort token and production
names.

\section{\protect\verb+symbol\_unlink\_scope+}
\begin{verbatim}
void symbol_unlink_scope(void *data) 
\end{verbatim}
Unlink all symbols in a scope chain from their hash chains. 
The symbols themselves (and the scope chain data) are
preserved. This function is usually called at the exit from a scope block.

\section{\protect\verb+symbol\_unlink\_symbol+}
\begin{verbatim}
void symbol_unlink_symbol(void *data)
\end{verbatim}
Unlink a single symbol from its hash chain. 
The symbol itself (and the scope chain data) are
preserved. 
\section{\protect\verb+symbol\_unlink\_table+}
\begin{verbatim}
void symbol_unlink_table(void *table)
\end{verbatim}
Unlink all symbols in a table from their hash chains. 
The symbols themselves (and the scope chain data) are
preserved. 

\chapter{{\tt textio} -- text buffering and messaging services}
\label{textio}
Text buffering is a surprisingly troubling part of lexical analyser design.
Supporting nested include files, source echoing and synchronised error
messages requires careful design. The \rdp\ text buffer manager
maintains a single large area of memory. New strings can be inserted at
low addresses and grow upwards. 

The top of the region is used as a
pushdown stack of line buffers for the set of included files. As each
nested include file is opened, a record containing the previous state of
the text manager is pushed onto a linked list and a new line buffer
opened up. At the end of the included file, the buffer is released, the
record list popped and scanning continues where it left off. End of file
is not returned to the caller until the outermost file is completely consumed.

This arrangement allows arbitrary strings of arbitrary lengths to be
stored, and files with arbitrarily long lines to be read. As each new
line is read in, it is stored backwards at the top of the buffer. \rdp\
does not run out of memory until the strings meet the line buffers, so
memory can always be fully used.
This data arrangement is illustrated in Figure~\ref{text:structure}.

\begin{figure}
\begin{center}
\input{text.pic}
\end{center}
\caption{Text buffer structure}
\label{text:structure}
\end{figure}

As well as these text input routines, messaging routines are provided to
centralise the production of error messages. 

\section{Global variables}
\subsection{\tt *text\_bot}
A pointer to the first location in the text buffer.
\subsection{\tt *text\_top}
A pointer to the first free location above the string base.
\subsection{\tt int text\_char}
The last character read by {\em textio}.
\subsection{\tt void *text\_scan\_data}
A pointer to the last scanner symbol read by the scanner.

\section{\protect\verb+text\_capitalise\_string+}
\begin{verbatim}
char *text_capitalise_string(char *str)
\end{verbatim}
Capitalise the first character of each space delimited word in string {\tt str}.

\section{\protect\verb+text\_default\_filetype+}
\begin{verbatim}
char *text_default_filetype(char *fname, const char *ftype)
\end{verbatim}
If {\tt fname} has no filetype then add a period and the string {\tt
ftype} to it.

\section{\protect\verb+text\_dump+}
\begin{verbatim}
void text_dump(void)
\end{verbatim}
Print out (in order of creation time) all the inserted strings in the text buffer.

\section{\protect\verb+text\_echo+}
\begin{verbatim}
void text_echo(const int i)
\end{verbatim}
Enable listing for all lines.

\section{\protect\verb+text\_extract\_filename+}
\begin{verbatim}
char * text_extract_filename(char * fname)
\end{verbatim}
Return the file name part of a path, after stripping off leading directories
and the trailing file type.

\section{\protect\verb+text\_find\_ASCII\_element+}
\begin{verbatim}
char * text_find_ASCII_element(int c)
\end{verbatim}
Return a string representing the ASCII code for {\tt c}. Non-printing
character codes return a three digit mnemonic code.

\section{\protect\verb+text\_force\_filetype+}
\begin{verbatim}
char *text_force_filetype(char *fname, const char *ftype)
\end{verbatim}
Force {\tt fname} to have filetype {\tt ftype} even if it already has one.

\section{\protect\verb+text\_free+}
\begin{verbatim}
void text_free(void)
\end{verbatim}
Release all memory held by the {\tt textio} package. It is an error to access any
{\tt textio} functions after calling \verb+text_free+.

\section{\protect\verb+text\_get\_char+}
\begin{verbatim}
void text_get_char(void)
\end{verbatim}
Get a single character from the line buffer into \verb+text_char+.
\section{\protect\verb+text\_init+}

\begin{verbatim}
void text_init(const long max_text, 
               const unsigned max_errors, 
               const unsigned max_warnings, 
               const unsigned tab_width)
\end{verbatim}
Initialise the text subsystem with a buffer of \verb+max_text+ bytes.

\section{\protect\verb+text\_insert\_char+}

\begin{verbatim}
char *text_insert_char(const char c)
\end{verbatim}
Insert a single character into the string buffer.
Return a pointer to the inserted character.

\section{\protect\verb+text\_insert\_characters+}
\begin{verbatim}
char *text_insert_characters(const char *str)
\end{verbatim}
Insert the string {\tt str} into the string buffer, but omit the
terminating null character.
Return a pointer to the first character.

\section{\protect\verb+text\_insert\_integer+}

\begin{verbatim}
char *text_insert_integer(const unsigned n)
\end{verbatim}
Insert the ASCII decimal representation of an unsigned integer into the text buffer.
Return a pointer to the start of the string.

\section{\protect\verb+text\_insert\_string+}

\begin{verbatim}
char *text_insert_string(const char *str)
\end{verbatim}
Insert the string {\tt str} into the string buffer and include the
terminating null character. 
Return a pointer to the start of the string.

\section{\protect\verb+text\_insert\_substring+}
\begin{verbatim}
char *text_insert_substring(const char * prefix, const char *str, 
                            const unsigned n)
\end{verbatim}
Insert the string {\tt prefix} into th string buffer
followed by the string {\tt str} followed by an
underscore and then insert the ASCII decimal representation of unsigned
integer \verb+n+ with a terminating null character.  Return a pointer to
the start of the string. This routine is used to construct
sub-production names in the \rdp\ grammar checking routines.

\section{\protect\verb+long text\_is\_valid\_C\_id+}
\begin{verbatim}
int text_is_valid_C_id(char * s)
\end{verbatim}
Return {\sc true} (integer 1) if {\tt s} conforms to the rules for
valid ANSI-C identifiers, otherwise return {\sc false} (integer 0).

\section{\protect\verb+long text\_line\_number+}
\begin{verbatim}
unsigned long text_line_number(void)
\end{verbatim}
Return the current line number in the current file.

\section{\protect\verb+text\_lowercase\_string+}
\begin{verbatim}
char *text_lowercase_string(char *str)
\end{verbatim}
Go through string {\tt str}, converting all upper case letters to lower
case and return that string.

\section{\protect\verb+text\_make\_C\_identifier+}
\begin{verbatim}
char *text_make_C_identifier(char * str)
\end{verbatim}
Use \verb+text_find_ASCII_element+ to construct a valid C identifier from
the names of the characters in {\tt str}.

\section{\protect\verb+text\_message+}
\begin{verbatim}
int text_message(const enum text_message_type type, const char *fmt, ...)
\end{verbatim}
Generate an error message. {\tt type} is one of 

\begin{itemize}
\item \verb+TEXT_INFO+ print the current filename and the message.

\item \verb+TEXT_WARNING+ print {\tt Warning}, the current filename and the message.

\item \verb+TEXT_ERROR+ print {\tt Error}, the current filename and the message.

\item \verb+TEXT_FATAL+ print {\tt Fatal}, the current filename and the
message. Exit to the operating system after issuing the message.

\item \verb+TEXT_INFO_ECHO+ echo the current source line, print the current filename and the message.

\item \verb+TEXT_WARNING_ECHO+ echo the current source line, print {\tt Warning}, the current filename and the message.

\item \verb+TEXT_ERROR_ECHO+echo the current source line, print {\tt Warning}, the current filename and the message.

\item \verb+TEXT_FATAL_ECHO+ echo the current source line, print {\tt Warning}, the current filename and the
message. Exit to the operating system after issuing the message.
\end{itemize}

Any valid \verb+printf()+ parameters may be supplied after {\tt type}.
\section{\protect\verb+text\_open+}
\begin{verbatim}
FILE *text_open(char *s)
\end{verbatim}
Open a file. {\tt s} is an ASCII string containing the file name. An
error message will be issued if the file cannot be opened. There is no
corresponding close function because files are automatically closed by
the handler when an {\tt EOF} is encountered.

\section{\protect\verb+text\_print\_C\_char+}
\begin{verbatim}
int text_print_C_char(char * string)
\end{verbatim}
Print the contents of {\tt string} as an ANSI-C character literal, 
using escape sequences where necessary.

\section{\protect\verb+text\_print\_C\_char\_file+}
\begin{verbatim}
int text_print_C_char_file(FILE * file, char * string)
\end{verbatim}
Print the contents of {\tt string} as an ANSI-C character literal to file
stream {\tt file}, 
using escape sequences where necessary.

\section{\protect\verb+text\_print\_C\_string+}
\begin{verbatim}
int text_print_C_string(char * string)
\end{verbatim}
Print the contents of {\tt string} as an ANSI-C string literal, 
using escape sequences where necessary.

\section{\protect\verb+text\_print\_C\_string\_file+}
\begin{verbatim}
int text_print_C_string_file(FILE * file, char * string)
\end{verbatim}
Print the contents of {\tt string} as an ANSI-C string literal to file
stream {\tt file}, 
using escape sequences where necessary.

\section{\protect\verb+text\_print\_statistics+}
\begin{verbatim}
void text_print_statistics(void)
\end{verbatim}
Print summary text buffer statistics. Use this routine to find out how
much free space is left in the text buffer.

\section{\protect\verb+text\_print\_time+}
\begin{verbatim}
void text_print_time(void)
\end{verbatim}
Print the currently consumed CPU time for this run.

\section{\protect\verb+text\_printf+}
\begin{verbatim}
int text_printf(const char *fmt, ...)
\end{verbatim}
Send a formatted message to the message stream. Any valid {\tt printf()}
parameters are valid here.

\section{\protect\verb+text\_print\_total\_errors+}
\begin{verbatim}
int text_print_total_errors(void)
\end{verbatim}
Print the total number of errors across all input files.

\section{\protect\verb+text\_redirect+}
\begin{verbatim}
void text_redirect(FILE* file)
\end{verbatim}
At startup, messages are sent to the stream named in the
\verb+TEXT_MESSAGES+ macro defined in \verb+textio.h+, which is usually
{\tt stderr}. Output can be redirected to any other text file with this
routine. {\tt file} must be an initialised file variable pointer.

\section{\protect\verb+text\_total\_errors+}
\begin{verbatim}
unsigned text_total_errors(void)
\end{verbatim}
Return the total number of errors across all input files.

\section{\protect\verb+text\_total\_warnings+}
\begin{verbatim}
unsigned text_total_warnings(void)
\end{verbatim}
Return the total number of warnings across all input files.

\section{\protect\verb+text\_uppercase\_string+}
\begin{verbatim}
void text_uppercase_string(char *str)
\end{verbatim}
Go through string {\tt str}, converting all lower case letters to upper
case and return that string.

\input{rdp_inst.tex}

\bibliographystyle{alpha}
\bibliography{adrian}
\end{document}
