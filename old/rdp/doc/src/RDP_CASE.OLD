\documentstyle[rhultechreport,epsf,11pt,twoside]{report}
\renewcommand{\today}{December 20, 1997}
\newcommand{\quietsection}[1]{\subsubsection*{#1}\addcontentsline{toc}{subsection}{#1}}
\newcommand{\errorsection}[1]{\subsubsection*{#1}}
\newcommand{\rdpsupp}{{\mediumseries\tt rdp\_supp}}
\newcommand{\rdp}{{\mediumseries\tt rdp}}
\newcommand{\rdps}{{\mediumseries\tt rdp\ }}
\title{Designing and implementing language translators with \rdp\,--\,a case study}
\author{Adrian Johnstone \and Elizabeth Scott}
\reportnumber{\csnum{97}{27}} %Uncomment this line only when
\begin{document}
\makecstitle %make Adrian's title page
\thispagestyle{empty}
\vspace*{1cm}
\begin{center}\bf Abstract\end{center}

\rdp\ is a system for implementing language processors. It accepts a
specification, written in an extended Backus-Naur Form, of a source
language and produces as output a parser for the language, written in C.
It is possible for the user to specify, in C, actions which  should be
taken when fragments of the source language are recognised by the
generated parser. \rdp\
produces as output a program written in C, which parses fragments of the
specified language  and carries out the specified corresponding actions.
\rdp\ can produce, for example, compilers (the actions specify the
corresponding target code), interpreters (the actions evaluate the input
fragments) and pretty printers (the actions reformat the input
fragments).

This report describes the design and implementation of a family of
language translators based around a simple procedural programming
language called {\tt mini}. The tools covered include two different
interpreters, an assembler, a simulator  for an idealised processor, a
na\"\i ve single-pass compiler for that processor, and a multiple-pass
compiler. We also include a pretty printer for ANSI-C and a list of suggestions
for further project work. For each tool, we look at how
the tool is used before covering the design and implementation of the
translator. All of the tools are included in the \rdp\ standard
distribution pack and have been tested on MS-DOS, Windows-95 and Unix
systems.

\vspace*{3ex}

The \rdp\ source code is public domain and has been successfully built
using Borland C++ version 3.1 and Microsoft C++ version 7 on MS-DOS,
Borland C++ version 5.1 on Windows-95, GNU {\tt gcc} and {\tt g++}
running on OSF/1, Ultrix, MS-DOS, Linux and SunOS, and a variety of
vendor's own C compilers. Users have also reported straightforward ports
to the Amiga, Macintosh and Archimedes systems.

\vspace*{\fill}
\begin{center}
\fbox{\parbox{12cm}{This document is \copyright\,Adrian Johnstone and Elizabeth Scott
1997.\\[1ex]
Permission is given to freely distribute this document
electronically and on paper. You may not change this document or
incorporate parts of it in other documents: it must be distributed intact.\\[1ex]
The \rdp\ system itself is \copyright\,Adrian Johnstone but may
be freely copied and modified on condition that details of the
modifications are sent to the copyright holder 
with permission to include
such modifications in future versions and to discuss them (with
acknowledgement) in future publications.\\[1ex]
The version of \rdp\ described here is version 1.50 dated 20 December
1997.\\[1ex] 
Please send bug reports and copies of modifications
to the authors at the address on the title page or electronically
to {\tt A.Johnstone@rhbnc.ac.uk}.
}}
\end{center}
\clearpage
\pagenumbering{roman}
\tableofcontents
\clearpage
\setcounter{page}{0}
\chapter{Translation tools}
\pagenumbering{arabic}

\rdp\ is a system for implementing language processors. It accepts a
specification, written in an extended Backus-Naur Form, of a source
language and produces as output a parser for the language, written in C.
It is possible for the user to specify, in C, actions which  should be
taken when fragments of the source language are recognised by the
generated parser. \rdp\
produces as output a program written in C, which parses fragments of the
specified language  and carries out the specified corresponding actions.
\rdp\ can produce, for example, compilers (the actions specify the
corresponding target code), interpreters (the actions evaluate the input
fragments) and pretty printers (the actions reformat the input
fragments).

This report describes the design and implementation of a family of
language translators based around a simple procedural programming
language called {\tt mini}. The tools covered include two different
interpreters, an assembler, a simulator  for an idealised processor, a
na\"\i ve single-pass compiler for that processor, and a multiple-pass
compiler. We also include a pretty printer for ANSI-C and a list of suggestions
for further project work. For each tool, we look at how
the tool is used before covering the design and implementation of the
translator. All of the tools are included in the \rdp\ standard
distribution pack and have been tested on MS-DOS, Windows-95 and Unix
systems.

If you have not used \rdp\ before, we recommend that you read through
the accompanying report entitled {\em `A tutorial guide to \rdp\ for new
users'}~\cite{rdp:tut:1.5} which is a step by step guide to running
\rdp\ and which also describes some of the theoretical underpinnings to
parsing and translation of computer languages. There are also two
reference manuals for \rdp: the user guide~\cite{rdp:user:1.5} and the
support library manual~\cite{rdp:supp:1.5}. These reference guides
provide detailed information on \rdp's options, error messages and
support library functions. 

We begin by discussing the roles of interpreters and compilers,
with some historical background.

\section{The spectrum of language translators and the limitations of
single pass translators}

\rdp\ can be used to construct many kinds of translator. In the tutorial
guide~\cite{rdp:tut:1.5} we looked at a single pass {\em interpreter}
for a very simple language called {\tt mini}. These kinds of translators
are limited to reading the source file once and executing embedded
semantic actions on the fly. This makes it hard to implement loop
constructs, which of course require parts of the source file to be
executed over and over again. This is the reason why the mini language
interpreter described in the tutorial manual does not support looping
constructs.

One approach to handling loops within an interpreter might be to `trick'
the parser by resetting the input pointer to the start of the mini source code loop at
the beginning of each loop iteration: a {\em rewindable} interpreter. This
technique is feasible, but requires a detailed understanding of the
internals of \rdp. It also results in rather slow translation.
Experiments with the {\tt mini} interpreter show
that when interpreting arithmetic expressions, about 90\% of the time is
spent performing the parse and only 10\% of the time performing  useful
computation. 

In fact, even this discouraging ratio represents the best-case. The use
of comments and long variable names can significantly increase the
proportion of time spent on parsing. This is unfortunate as it militates
against use of meaningful names and embedded documentation, leading to
cryptic and hard to understand programs. Treating loops using the
rewinding trick would mean that the loop would be re-parsed over and
over again, and such an interpreter would be slow. Nevertheless, this
kind of trick is used in some real systems: in particular BASIC
interpreters (such as the Visual Basic engine built in to some Windows-95
tools) work this way. To improve the performance a little, it is normal
for such tools to store the program in a format that strips out
comments and white space, and replaces keywords with single characters. This
eases the job of the scanner and helps to improve performance.

A {\em compiler} does not attempt to execute a program in the way that
an interpreter does. Instead, it outputs a program in the machine
language of some {\em target processor} which can be directly executed
by that processor. The compiler's main task is to identify operations in
the source program and map them to code templates in the target
processor's language that have the same meaning, or {\em semantics}.

Full compilation undoubtedly provides the most efficient way of
executing most real programs, but a different target program will be
required for each kind of target processor, that is, the generated code
is not portable between architectures (or in extreme cases, not even
between different models of computer within the same architectural
family). One approach to providing a measure of portability is to
strictly separate the parsing stage (which is specified by the design of
the language to be translated) and the generation phase, which is keyed
to the architecture of the target processor. 

This is usually achieved by allowing the parser to make one or more
passes over the source program and by providing embedded semantic
actions that translate the program into some simple {\em intermediate
form} which captures the meaning of the program without requiring the
large syntactic overhead of keywords and English-like syntax that are
used in most human-readable programming languages. The compilers {\tt
miniloop} and {\tt minitree} (described in Chapters~\ref{miniloop} and
\ref{minitree} respectively) are examples of this approach.

\section{Intermediate forms, and translation to virtual machine code}

Intermediate forms used in real compilers fall into two basic types: a
tree like-structure closely related to the derivation trees described
in~\cite{rdp:user:1.5} or alternatively a list of instructions for a
paper architecture or {\em virtual machine\/\footnote{This use of the term
virtual machine to denote an architecture that is independent of any
physically implemented machine should not be confused with the use of
the term in operating systems and computer architecture contexts, where
it denotes the ability of an architecture to support multiple
simultaneously executing processes each of which appears to own the full
resources of the host machine.}}. The virtual machine approach is illustrated by the
{\tt miniloop} compiler in Chapter~\ref{miniloop} and the tree based approach by
the {\tt minitree} compiler described in Chapter~\ref{minitree}.
Virtual machines are
superficially similar to real processors, but they offer a level of
abstraction above that of a real processor. For instance, it is common
in intermediate forms to retain the variable names from the original
user's program rather than translating them into machine addresses as
would be required for a real machine level program. 

Both kinds of intermediate form allow a variety of {\em optimisations}
to be applied, such as the evaluation of constant expressions or the
replacement of multiplications by powers of two with shift operations.
In general, an optimiser is supposed to take a program in the
intermediate form and output another program written in the intermediate
form that has the same semantics, but is faster or more compact, or both.
Sometimes optimisers fail to make improvements, and in some cases they
may actually make things worse. In addition, some features of
programming languages (such as the unrestricted use of pointers) can
introduce subtle effects that make it hard for the optimiser to
guarantee that the semantics are preserved.

After the optimiser has finished, code must be generated for the target
processor. In general, there must be a different code generator for
each processor, but at least all of the parsing and many of the optimisation
components of the compiler can be common between target processors.

One way of providing the benefits of full portability whilst retaining
much of the efficiency of a fully compiled solution is to use an
intermediate form that can itself be efficiently interpreted. In this
case no final code generation phase is required. Instead, a software simulator
for the virtual machine which can read and execute the intermediate form
is supplied. This kind of approach was popularised by the UCSD P-system
in the 1970's which was a combined operating system and Pascal compiler
that was distributed as {\em P-code}. P-code~\cite{PEMBERTON82a,PEMBERTON82b} 
was in fact the machine
language for a mythical stack based computer that could be efficiently
simulated on real architectures. The system was so successful that a
microprocessor manufacturer subsequently designed and marketed a
hardware implementation of the P-code processor. On this processor, the
P-code {\em was} native machine code so no software based interpretation
was required. 

P-code was successful because its only real competitors on the very
small microprocessor based systems of the time were interpreters for
BASIC. These fully interpreted languages were slow compared to the
P-code simulator. As microprocessor systems matured, true compilers for
languages such as C and Turbo-Pascal that compiled to the host machine's
machine code became widely available and the UCSD P-system fell out of
favour because it was much slower than these so-called native-mode compilers.

Recently, virtual machine based approaches have become popular again
because of the need to distribute executable programs around the
Internet. Portability between different computer architectures must be
absolutely guaranteed even though there are a very wide variety of
systems connected to the net, and the programs must run in an identical
fashion wherever they are executed. In addition, the programs must be
run in such a way that any suspicious behaviour that might undermine the
host system's security can be caught. In practice, actually allowing
arbitrary machine language programs to execute is too dangerous.
Instead, languages like Java compile to an intermediate virtual machine,
and Web browsers provide an interpreter for that virtual machine that
can in prinipal catch illegal memory accesses and attempts to access
operating system services that could threaten system integrity. The Java
virtual machine simultaneously acts as a reasonably efficient portable
platform for executing programs and as a filter on the actions of those
programs that protects the underlying operating system.

\section{The {\tt mini} family} In the following chapters we will
illustrate the interpreted virtual machine approach to compilation by
describing the development of single and multiple-pass compilers for
{\tt mini} which work in this fashion, outputting instructions for a
`paper' processor called the Mini Virtual Machine (MVM). Along the way
we will look at fully interpreted versions of {\tt mini} and the design
of an assembler and simulator for MVM.  The level of presentation is
aimed at readers who are familiar with the principles of parser
generators and the ANSI-C programming language. If you are completely
new to translator design you may find it helpful to read the 
\rdp\ tutorial manual~\cite{rdp:tut:1.5} and the accompanying
user~\cite{rdp:user:1.5} and support~\cite{rdp:supp:1.5} manuals.

In detail we will develop the following tools. \begin{enumerate} \item A
syntax checker and interpreter for {\tt minicalc}, a language that
provides declarations, assignment, expression evaluation and output.
\item An interpreter for {\tt minicond} which has block statements,
relational operators and an {\tt if-then-else} statement 
in addition to the
basic {\tt minicalc} language. \item A paper architecture called the
Mini Virtual Machine (MVM) and its specification as a simulator for MVM
(called {\tt mvmsim}) written in ANSI-C. \item An assembler called {\tt
mvmasm} that translates MVM assembly language into MVM binary code. The
implementation of {\tt mvmasm} illustrates the design issues in
assemblers which are culturally rather different from high level
programming languages. \item A single-pass compiler for the language {\tt miniloop}
which adds a {\tt while} loop construct to {\tt minicond} and outputs MVM
assembler source, suitable for translation with {\tt mvmasm} into MVM
binary which may be executed by {\tt mvmsim}.
\item A multiple-pass compiler in which the parser builds a tree-based intermediate
form and a separate code-generation pass traverses the tree and outputs MVM assembler
source code which may then be assembled and simulated.
\item A pretty-printer for ANSI-C which illustrates the use of a highly under-specified
grammar to process a language which will be checked for syntactic correctness by
another tool using a fully specified language.
\end{enumerate}
We conclude this report by suggesting some design projects based on
extensions to the compilers.

All of these tools are included in the \rdp\ distribution and 
are automatically built and
tested as part of the standard installation {\tt makefile}. If you have
successfully installed \rdp, therefore, you should already have working
versions of the tools, and all the source files described here will be
found in the main \rdp\ directory.

\chapter{The {\tt minicalc} language: a simple calculator with declared variables}
\label{minicalc}
In this chapter we give a grammar and associated syntax checker
for a tiny language, {\tt minicalc}, which includes only the features at the
core of any procedural programming language \dash expression
evaluation and assignment to named variables. In {\tt minicalc}, as in
most modern languages,
variables must be declared before they are used, so as to catch the
elementary programming error of assigning to a variable whose name has
been misspelled. In early high level programming languages, a system
would quietly make a new variable with the misspelt name and assign the
value there. Subsequent expressions using the value of the correctly
spelt variable would then use the old value, causing hard to find errors. 

Variable declarations are also used to establish the {\em type} of a
variable which restricts the kinds of values that may be assigned, and
the kinds of operations that  may be applied to the declared variable. Type checking can
catch programming errors such as trying to add a number to a string, or
attempting to use an integer instead of a pointer value.

{\tt minicalc} provides constructs for variable
declaration, for assignment of the results of arithmetic operations to
those variables and for the values of those variables to be printed out.
It is, effectively, only as powerful as a desktop calculator with named
variables. An example {\tt minicalc} program listing is shown in
Figure~\ref{minicalc:program}: it corresponds to the file {\tt
testcalc.m} in the standard \rdp\ distribution. In later chapters we
shall extend {\tt mini} to include control structures such as loops and
{\tt if} statements.

\section{{\tt minicalc} features}

{\tt minicalc} programs comprise a sequence of declarations and
statements. Each statement and declaration must be terminated by a
semicolon, in much the same way as in an ANSI-C program. {\tt minicalc}
supports only integer variables. Variable declarations look like ANSI-C
{\tt int} declarations, taking an optional initialisation expression.
Line 11 in the listing shows an example of two variables being declared,
both with initialisation expressions.

{\tt minicalc} expressions are built up using the four basic diadic left
associative arithmetic operators ({\tt +, -, * and /}) along with unary
{\tt +} and {\tt -} and  the diadic right associative exponentiation
operator ({\tt **}). Operands may be either numeric literals or
variable names. The result of an expression may be assigned to a
variable, as shown in line 15, or used within a {\tt print} statement,
as shown in line 17. {\tt print} statements take a parenthesised, comma
delimited list of expressions or strings, which are evaluated and
printed in left to right order, much like the Pascal {\tt write}
statement. The usual ANSI-C escape sequences may be used to output
non-printing characters such as line end (represented by \verb+\n+).

\begin{figure}
\hspace*{-1cm}
\begin{minipage}{30cm}
\footnotesize
\begin{verbatim}
     1: (*******************************************************************************
     2: *
     3: * RDP release 1.50 by Adrian Johnstone (A.Johnstone@rhbnc.ac.uk) 20 December 1997
     4: *
     5: * testcalc.m - a piece of Mini source to test the Minicalc interpreter
     6: *
     7: * This file may be freely distributed. Please mail improvements to the author.
     8: *
     9: *******************************************************************************)
    10: 
    11: int a=3+4, b=1;
    12: 
    13: print("a is ", a, "\n");
    14: 
    15: b=a*2;
    16: 
    17: print("b is ", b, ", -b is ", -b, "\n");
    18: 
    19: int z = a ** 3;
    20: print(a, " cubed is ", z, "\n");
    21: 
    22: (* End of testcalc.m *)
\end{verbatim}
\end{minipage}
\caption{An example {\tt minicalc} program ({\tt testcalc.m})}
\label{minicalc:program}
\end{figure}

\section{{\tt minicalc} limitations}

{\tt minicalc} can only perform integer computations, and only allows
strict sequencing of statements, there being no flow of control
statements. In addition, there is no {\tt read} input statement to
accompany the {\tt print} output statement. Enhanced versions of {\tt
minicalc} will be presented in later chapters.

\section{A grammar for {\tt minicalc}}

It is easy to construct an LL(1) grammar for {\tt minicalc} suitable for
input to \rdp. A parser generated from such a grammar with no semantic
actions embedded within it acts as a pure parser or {\em syntax checker}
for the {\tt minicalc} language. Figure~\ref{minicalc:grammar} shows a
suitable grammar from which to generate a {\tt mini} syntax checker: it is supplied with
the \rdp\ distribution as file \verb+mini_syn.bnf+ and will be discussed in the
remainder of this section.

\begin{figure}
\hspace*{-1cm}
\begin{minipage}{30cm}
\footnotesize
\begin{verbatim}
     1: (*******************************************************************************
     2: *
     3: * RDP release 1.50 by Adrian Johnstone (A.Johnstone@rhbnc.ac.uk) 20 December 1997
     4: *
     5: * mini_syn.bnf - a mini grammar for syntax checking
     6: *
     7: * This file may be freely distributed. Please mail improvements to the author.
     8: *
     9: *******************************************************************************)
    10: TITLE("Mini_syn V1.50 (c) Adrian Johnstone 1997")
    11: SUFFIX("m")
    12: 
    13: program   ::= { [var_dec | statement ] ';' }.
    14: 
    15: var_dec   ::= 'int' ( ID [ '=' e1 ] )@','.
    16: 
    17: statement ::= ID '=' e1 | 'print' '(' ( e1 | String )@',' ')'.
    18: 
    19: e1 ::= e2 { '+' e2 (* Add *)      | '-' e2 (* Subtract *) }.         
    20: 
    21: e2 ::= e3 { '*' e3 (* Multiply *) | '/' e3 (* Divide   *) }.         
    22: 
    23: e3 ::= e4 | '+' e3 (* Posite *)   | '-' e3 (* Negate   *).
    24: 
    25: e4 ::= e5 [ '**' e4 ] (* Exponentiate *).
    26: 
    27: e5 ::= ID (* Variable *) | INTEGER (* Numeric literal *) | '(' e1 ')'.
    28: 
    29: comment ::= COMMENT_NEST('(*' '*)').  (* Comments *)
    30: 
    31: String  ::= STRING_ESC('"' '\\').     (* Strings for print *)
    32: 
    33: (* End of mini_syn.bnf *)
\end{verbatim}
\end{minipage}
\caption{An \rdp\ grammar specification for {\tt minicalc} ({\tt mini\_syn.bnf})}
\label{minicalc:grammar}
\end{figure}

A {\tt minicalc} source program comprises an arbitrary number of
variable declarations and statements, each terminated with a semicolon,
as specified by rule {\tt program} in line 13. Variable declarations,
specified in line 15, comprise the keyword {\tt int} followed by a comma
delimited list of variable names which may be optionally followed by an
{\tt =} sign and an initialisation expression. 

Statements in {\tt minicalc} may be either
assignments or {\tt print} statements, as specified in line 17. The
{\tt print} statement takes parameters by way of a comma delimited list of
strings and expressions.

Comments present particular problems for parser generators because the modern
convention is to allow a comment to occur anywhere that whitespace is allowed: typically
between any two tokens of the language. A full specification of this convention using
only the grammar rules would require a call to a comment rule after every terminal in the
grammar, and this would make the grammar very unwieldy. The usual solution is to instruct the
scanner to detect and filter out comments in exactly the same way as whitespace (such as
line ends, tabs and space characters) is discarded.

\rdp\ offers a range of scanner primitives to support three different commenting conventions.
You can read more about the use of these primitives, and the general problems of comment
specification in Chapter 4 of the user manual~\cite{rdp:user:1.5}.
In \verb+mini_syn.bnf+  comments comprising matching \verb+(*+ and
\verb+*)+ brackets are specified on line 29. This rule is only used to
parameterise the scanner, and is never actually called by the main
parser so it will be deleted when \rdp\ processes the grammar.

\subsection{Specifying expressions}

The forms of {\tt mini} expressions are specified on lines 19--27.
Most programming languages provide support for expressions made up of
operators for common arithmetic and logical operations. Some even allow
control flow to  be specified using operators: the ANSI-C if-then-else
operator ({\verb+? :+) is perhaps the most well known
example of this feature.

Syntactically, expressions are simply streams of operator and operand
tokens. For an expression made up of diadic (two-operand) operators we
expect to see expressions of the form 
\begin{quote} operand operator operand ~~~\ldots~~~ operand operator operand
\end{quote}
Monadic (single operand) operators are
distinguished by appearing between diadic operators and operands or next to other
monadic operators. Here is an 
expression made up of monadic {\tt -} (negation) and the diadic addition
and subtraction operators.
\begin{quote}
\verb|3 + -4 - -6 + 2|
\end{quote}

The following is a simple grammar that generates expressions of this form:
\begin{quote}
\small
\begin{verbatim}
expression ::= {monadic_op} operand { diadic_op {monadic_op} operand }.
operand ::= INTEGER.
monadic_op ::= '-'.
diadic_op ::= '+' | '-'.
\end{verbatim}
\end{quote}

If all we want to do is to check that an expression is syntactically
valid then we can simply extend the definitions of \verb+monadic_op+ and
 \verb+diadic_op+ to include all the monadic and diadic operators
present in the language being specified. Here, for instance is a
suitable grammar for {\tt mini} expressions which include monadic {\tt
+} and {\tt -} and diadic {\tt +}, {\tt -}, {\tt *}, {\tt /} and {\tt
**} (exponentiation).

\begin{quote}
\small
\begin{verbatim}
expression ::= {monadic_op} operand { diadic_op {monadic_op} operand }.
operand ::= INTEGER.
monadic_op ::= '+' | '-'.
diadic_op ::= '+' | '-' | '*' | '/' | '**'.
\end{verbatim}
\end{quote}

If we extend the definition of rule {\tt operand} we can similarly allow
named variables and non-integer literal operands such as {\tt REAL}s.

Deeper problems arise when we consider the evaluation of an expression.
The string \verb|fred = 1 - 2 - 3| is a legal {\tt minicalc} statement, but what
value should actually be assigned to {\tt fred}? We could begin evaluating
from the left, effectively carrying out the steps
\begin{quote}
\small
\begin{verbatim}
fred = 1
fred = fred - 2
fred = fred - 3
\end{verbatim}
\end{quote}
or from the right, effectively carrying out the steps
\begin{quote}
\small
\begin{verbatim}
fred = 3
fred = 2 - fred
fred = 1 - fred
\end{verbatim}
\end{quote}
In the first case {\tt fred} ends up with value -4 and in the second
case with value 2. The usual convention is to evaluate subtractions from
left to right, {\em i.e.} using the first of the two choices above, and this is
called {\em left associativity}.
The programmer may wish to override this and other order-of-evaluation
conventions, and traditionally this is done using parentheses.
The following grammar allows expressions of
the form \verb|1 - (2 - 3)| and \verb|3 + (x * y) - 2|

\begin{quote}
\small
\begin{verbatim}
expression ::= {monadic_op} operand { diadic_op {monadic_op} operand }.
operand ::= INTEGER | ID | '(' expression ')'.
monadic_op ::= '+' | '-'.
diadic_op ::= '+' | '-' | '*' | '/' | '**'.
\end{verbatim}
\end{quote}

Note that we have introduced recursion into the grammar: the {\tt
operand} rule accepts a left parenthesis after which it calls the {\tt
expression} rule before accepting a matching closing parenthesis. This
nested structure incorporates the notion of `do-first' into the grammar
which is exactly what parentheses `mean' in expressions\dash the
parentheses in an expression are used to override the default order of
expression evaluation so that the sub-expression in parentheses is
evaluated first.

\subsubsection{Specifying operator priority}
We have seen that parentheses can be used to override default evaluation orders
in expressions. However, expressions
with lots of parentheses can be hard to read (although LISP programmers
seem to manage) and so the conventions of operator priority have grown up 
to allow expressions to be written  with {\em implicit} parentheses.
Most people use priority rules instinctively because they are taught to us
when we first learn arithmetic at school.  Multiplication and division,
for instance, have higher priority than addition and subtraction. This
means that the expression \verb|3 + 4 * 5| evaluates to {\tt 23} {\em
not} {\tt 35} as would be the case if strict left-to-right evaluation
were used. Effectively, the priority allows us to write \verb|3 + 4 * 5|
as a shorthand for \verb|3 + (4 * 5)|. If we need to force left-to-right
evaluation then we can write \verb|(3 + 4) * 5|. In conventional 
arithmetic, exponentiation has the highest priority followed by
negation, multiplication (and division) and finally addition (and
subtraction). We can express these priorities by using the nest of
production rules shown in lines 
19--27 of Figure~\ref{minicalc:grammar}.

\subsubsection{Specifying operator associativity}

In programming languages, operators take values of a particular type and
return values with a type. Integer addition, for instance, takes two
integers and returns an integer, and the `greater than or equal'
relational operator \verb+>=+ takes two integers and returns a boolean
result. If the return-type of an operator is the same as the type of its
acceptable operands then we can write expressions that contain a run of
similar operators such as \verb|3 + 4 + 5| which we can read as either
\verb|(3 + 4) + 5| or \verb|3 + (4 + 5)|. With addition, both
interpretations evaluate to \verb+12+ but if we use subtraction instead
then an ambiguity arises: \verb|(3 - 4) - 5| is \verb+-6+ but \verb|3 - (4 - 5)| 
is \verb|3 - (-1)| which is \verb+4+. The {\em associativity}
of an operator specifies which of the two interpretations should be
selected: subtraction is in fact {\em left associative} so \verb|3 - 4 - 5| 
is interpreted as \verb|(3 - 4) - 5|. 

In general, if we have several operators at the same level of priority, we need
to decide in which order to evaluate the operands. In most cases we evaluate
from left to right, so that \verb|2 - 3 + 4| evaluates as \verb|(2 - 3) + 4|
not as \verb|2 - (3 + 4)| and \verb|2 / 3 * 4| evaluates as \verb|(2 / 3) * 4|.
Evaluating from left to right automatically gives each of the operators
left associativity.

Left to right evaluation is most common, but strings of exponents, such as
\verb|2 ** 3 ** 4|, are traditionally evaluated in right to left order.
The {\tt mini} grammars demonstrate how to ensure left to right
(and right to left) operand evaluation and we shall now discuss this
in detail.

\subsubsection{Left to right evaluation and left associative operators}

The left associative arithmetic operators {\tt +} and {\tt -}
are specified with rules of the form
\begin{quote}
\small
\begin{verbatim}
e1 ::= e2 { '+' e2 | '-' e2 }.         
\end{verbatim}
\end{quote}
The rule specifying the left-associative operators ({\tt e1} in this case) calls its
immediate successor rule in the operator tree ({\tt e2}) on both sides of the operators
being recognised in {\tt e1}. This has the effect of ensuring that higher priority operators
on both sides of a {\tt +} or {\tt -} are evaluated first. In addition, the use of the
{\em zero-or-many} iterator bracket \verb+{  }+ ensures that a run of {\tt +} and/or {\tt -}
operators is processed in strictly left to right order, i.e. the operators are evaluated
in a left associative manner.

\subsubsection{Right to left evaluation and right associative operators}
Right associative operators such as exponentiation {\tt **} are specified using rules of
the form
\begin{quote}
\small
\begin{verbatim}
e4 ::= e5 { '**' e4 }.
\end{verbatim}
\end{quote}
The crucial difference between this kind of rule for right associative operators and the
previous rule for defining left associative operators is that in this case the rule calls
{\em itself} on the right hand side of the operator. Because of the way the
iterator works, this ensures that, in a run of
exponentiation operators all of the operators to the right of the first one will be processed
before the first one is processed. By extension, it is easy to see that the effect of this
kind of right-recursive rule is to ensure that a run of exponentiation operators is
evaluated in the {\em reverse} order to that in which they are read, that is right to left,
which is what we require for a right associative operator.

In detail, it is clear that the right recursion will absorb all instances in a run of exponentiation
operators, so even though we have used the {\em zero-or-many} iterator bracket \verb+{  }+
each invocation of rule {\tt e4} can only ever absorb zero or one instances of the {\tt **}
operator, so in practice we write such rules in this way:
\begin{quote}
\small
\begin{verbatim}
e4 ::= e5 [ '**' e4 ].
\end{verbatim}
\end{quote}

\subsubsection{Operators that do not combine}
Some operators yield result values that are incompatible with their
operands and therefore can not be used next to each other in expressions. 
It is not mathematically meaningful, for instance, to write an expression
like \verb|3 < 4 <= 6| because the result of evaluating \verb|3 < 4| is
a boolean truth value and this cannot reasonably be compared to the
integer \verb+6+. We might loosely call such operators `non-associative'
but strictly speaking it is meaningless to speak of the associativity of such 
an operator. The arithmetic relationals are the standard examples of such 
operators, and we implement them using rules such as
\begin{quote}
\small
\begin{verbatim}
rel_expr ::= exp [ '>' exp ].
\end{verbatim}
\end{quote}
The important point here is that the curly braces \verb+{  }+ used for
the expression rules {\tt e1} and {\tt e2} in
Figure~\ref{minicalc:grammar} to specify zero or more consecutive
instances of an operator are replaced by square brackets \verb+[  ]+
which only allow zero or one occurrence of the relational operator,
so a sequence of such operators in an expression will be rejected by the
parser. 

In the next chapter we shall add relational operators to {\tt
mini} using a rule of the form described here. It is, perhaps, worth
noting that in some languages this issue is rather obscured by the
confusion of boolean values with integer values. Languages such as
Pascal are strict whereas others (such as ANSI-C) simply use
integer values instead of  true booleans and may even provide fully left
associative relational operators.

\section{Hints on selecting operator priority and associativity}
Most common operators are left associative since this corresponds to a
left-to-right evaluation rule which is natural for cultures that read
left-to-right. Occasionally an operator is given right associativity for
special reasons. The exponentiation operator {\tt **} is an example of such an
operator. The reason that exponentiation is traditionally
right associative is that, when written
in the traditional mathematical notation using position rather than a
symbol for the operator, the expression
$(x^y)^z$ can be trivially rewritten as $x^{yz}$. Since there is
already such a straightforward way of writing left associating
exponentiation it makes sense to define the exponent operator as right
associative, so $x^{y^z}$ corresponds to $x^{(y^z)}$. Thus, using the
programming language notation, \verb|x ** y ** z| is interpreted as 
\verb|x ** (y ** z)|.

Similar considerations may be used to decide the relative priorities of
operators. Remember that the higher priority operators need to be evaluated
first in an expression. In common usage, for instance, it is clear that
the expression \verb|-2 ** 2| (i.e. $-2^2$) is expected to yield {\tt -4},
that is, it is a shorthand for \verb|-(2 ** 2)| {\em not} \verb|(-2) **
2| which would yield {\tt +4}. Hence we must give exponentiation  higher
priority than monadic {\tt -}. On the other hand it is also clear that
\verb|-2 * -2|  evaluates to {\tt +4}, not {\tt -4}, that is we should
interpret the expression as \verb|(-2) * (-2)| from which we deduce that
multiplication has {\em lower} priority than monadic {\tt -}.

The number of priority levels provided by a language is a fundamental
design decision. Pascal provides rather few levels, and in particular
expressions containing adjacent logical operators {\em must} be 
parenthesised. ANSI-C goes to the other extreme and provides so many
priority levels that many C programmers are unsure of the relative
priorities of unusual operators. From the perspective of the language
user (as opposed to designer) the golden rule is: if in doubt, insert
explicit parentheses.

\section{A {\tt minicalc} syntax checker}

As it stands, \verb+mini_syn.bnf+ can be processed by \rdp\ in the normal
way to make a syntax checker for {\tt mini}. Such a checker can detect
badly spelled keywords, and syntactically ill formed expressions but is
not able to check that variables have been declared before use.
\begin{figure}
\hspace*{-1cm}
\begin{minipage}{30cm}
\footnotesize
\begin{verbatim}
******: 
     1: (* Erroneous minicalc input *)
     2: 
     3: int a;
     4: 
     5: Error 1 (error.m) Scanned ID whilst expecting '='
     5: innt b = 3;     (* should be int b; *)
     5: -----1
     6: 
     7: b=a*2;          (* a used before being initialised *)
     8: 
     9: Error 1 (error.m) Scanned '*' whilst expecting one of ID, INTEGER, '(', '+', '-'
     9: a = 3 - * 4;    (* should be a = 3 * - 4; *)
     9: --------1
    10: 
    11: bb = b * 3;     (* undeclared variable *)
    12: 
******: 2 errors and 0 warnings
******: Fatal - errors detected in source file
\end{verbatim}
\end{minipage}
\caption{Error reporting in the syntax checker}
\label{minicalc:errors}
\end{figure}

The \rdp\ make file contains the commands for constructing a syntax checker from
\verb+mini_syn.bnf+ and running it on a test file called \verb+testcalc.m+. These commands
will be executed if you type
\begin{quote}
\verb+make ms_test+
\end{quote}
This make file target is automatically built as part of the standard installation, so if
you have already built \rdp\ using the make file then the already-compiled syntax checker will
simply be run on the test file. 

Figure~\ref{minicalc:errors} shows the output of the syntax checker for
an erroneous program and illustrates the syntax checker's limitations.
The misspelling of {\tt int} in line 5 and the incorrect orderings of the
arithmetic operators in line 9 have been detected, but the use of an
uninitialised variable in line 7 and the assignment to an undeclared
variable in line 11 have been ignored.

These kinds of errors can only be detected  by checking {\em long range}
relationships between program symbols. A variable declaration may occur
a long way before that variable is used, but the context free grammars
used by \rdp\ are essentially only powerful enough to check local
features of the language. A {\em context sensitive} grammar may be
written in such a way as to support type checking, but efficient parsing
techniques for practical context sensitive grammars are not available.
Instead, we use an external symbol table and embedded semantic actions
to keep track of the declaration and use of identifiers. Our next tool,
which is a full interpreter for {\tt minicalc}, can check for undeclared
variables without any extra overhead: the interpreter needs a symbol
table anyway to keep track of computed results and it turns out that
adding checks for undeclared variables is straightforward.

\chapter{An interpreter for  {\tt minicalc}}

The primary purpose of \rdp\ is to construct a parser for the language
generated by an \rdp-IBNF specification. Such a parser may be used as a
syntax checker for the language, as we have seen in the previous
chapter. Syntax checkers are useful, but we really want to be able to
write {\em translators} that perform some useful action as a side effect
of performing a parse. An {\em interpreter} is a translator that
executes actions specified in the parser whilst a parse is occurring. To
be suitable for interpretation, the language grammar must be designed to
be both parsable and executable in a single linear pass, and {\tt
minicalc} is an example of a language which has such a grammar.
An interpreter which is very similar to {\tt minicalc} is described in
the tutorial manual~\cite{rdp:tut:1.5}.


\rdp\ allows us to embed {\em semantic actions} into a grammar. \rdp's
semantic actions are written in C, and are copied into the generated
parser so that as soon as a fragment of the language to be parsed is
recognised the action can be performed. For instance, on recognition of
the {\tt minicalc} fragment \begin{quote} \verb+ int temp+ \end{quote}
we can make a new symbol table entry for a variable called {\tt temp}.
If the fragment is followed by an {\tt =} token then we can go on to
parse and evaluate an arithmetic expression, placing the result into the
symbol table record for {\tt temp}. Figures~\ref{minicalc:interp1} and
\ref{minicalc:interp2} show the specification for a full interpreter for
{\tt minicalc} that operates in this way. This interpreter IBNF
specification uses the same grammar as that for the {\tt mini} syntax
checker described in the last chapter. The only differences are the
addition of semantic actions and synthesised attributes to allow
declaration of variables, evaluation of arithmetic operations and the
printing of results.

You can read more about
semantic actions in Chapter~5 of the user manual~\cite{rdp:user:1.5} and
Chapter~6 of the tutorial manual~\cite{rdp:tut:1.5}.  To understand the
{\tt minicalc} interpreter you also need to be familiar with the use of
\rdp's built-in symbol table package which you can read about in
Chapter~7 of the support library manual~\cite{rdp:supp:1.5} and
Chapter~7 of the tutorial manual}~\cite{rdp:tut:1.5}.

\begin{figure}
\hspace*{-2.5cm}
\begin{minipage}{30cm}
\footnotesize
\begin{verbatim}
     1: (*******************************************************************************
     2: *
     3: * RDP release 1.50 by Adrian Johnstone (A.Johnstone@rhbnc.ac.uk) 20 December 1997
     4: *
     5: * minicalc.bnf - a decorated mini calculator grammar with interpreter semantics
     6: *
     7: * This file may be freely distributed. Please mail improvements to the author.
     8: *
     9: *******************************************************************************)
    10: TITLE("Minicalc interpreter V1.50 (c) Adrian Johnstone 1997")
    11: SUFFIX("m")
    12: USES("math.h")
    13: 
    14: SYMBOL_TABLE(mini 101 31
    15:              symbol_compare_string
    16:              symbol_hash_string
    17:              symbol_print_string
    18:              [* char* id; integer i; *]
    19:             )
    20: 
    21: program   ::= {[var_dec | statement ] ';' }.
    22: 
    23: var_dec   ::= 'int'
    24:               ( ID:name [ '=' e1:val ]
    25:                 [* mini_cast(symbol_insert_key(mini, &name, sizeof(char*), sizeof(mini_data)))
    26:                    ->i = val; 
    27:                 *]
    28:               )@','.
    29: 
    30: statement ::= ID:name
    31:               [* if (symbol_lookup_key(mini, &name, NULL) == NULL)
    32:                  {
    33:                    text_message(TEXT_ERROR, "Undeclared variable '%s'\n", name);
    34:                    symbol_insert_key(mini, &name, sizeof(char*), sizeof(mini_data));
    35:                  }
    36:               *]
    37:               '=' e1:val
    38:               [* mini_cast(symbol_lookup_key(mini, &name, NULL))->i = val; *] |
    39: 
    40:               'print' '(' ( e1:val [* printf("%li", val); *] |
    41:                             String:str [* printf("%s", str); *]
    42:                           )@','
    43:                       ')'.
    44: 
\end{verbatim}
\end{minipage}
\caption{An \rdp\ specification for the {\tt minicalc} interpreter: part 1}
\label{minicalc:interp1}
\end{figure}
\begin{figure}
\hspace*{-2.5cm}
\begin{minipage}{30cm}
\footnotesize
\begin{verbatim}
    45: e1:integer ::= e2:result {'+' e2:right [* result += right; *] |          (* Add *)
    46:                           '-' e2:right [* result -= right; *] }.         (* Subtract *)
    47: 
    48: e2:integer ::= e3:result {'*' e3:right [* result *= right; *] |          (* Multiply *)
    49:                           '/' e3:right [* if (result == 0) 
    50:                text_message(TEXT_FATAL_ECHO, "Divide by zero attempted\n"); else result /= right; *] 
    51:                          }.                                              (* Divide *)
    52: 
    53: e3:integer ::= '+' e3:result |                                           (* Posite *)
    54:                '-' e3:result [* result = -result; *] |                   (* Negate *)
    55:                e4:result.
    56: 
    57: e4:integer ::= e5:result [ '**' e4:right 
    58:                            [* result = (integer) pow((double) result, (double) right); *] 
    59:                          ]                                               (* Exponentiate *).
    60: 
    61: e5:integer ::= ID:name 
    62:                [* if (symbol_lookup_key(mini, &name, NULL) == NULL)
    63:                  {
    64:                    text_message(TEXT_ERROR, "Undeclared variable '%s'\n", name);
    65:                    symbol_insert_key(mini, &name, sizeof(char*), sizeof(mini_data));
    66:                  }
    67:               *]
    68:                [* result = mini_cast(symbol_lookup_key(mini, &name, NULL))->i; *] | (* Variable *)
    69:                INTEGER:result |                                          (* Numeric literal *)
    70:                '(' e1:result ')'.                                        (* Do-first *)
    71: 
    72: comment    ::= COMMENT_NEST('(*' '*)').                                  (* Comments *)
    73: 
    74: String: char * ::= STRING_ESC('"' '\\'):result.                          (* Strings for print *)
    75: 
    76: (* End of minicalc.bnf *)
\end{verbatim}
\end{minipage}
\caption{An \rdp\ specification for the {\tt minicalc} interpreter: part 2}
\label{minicalc:interp2}
\end{figure}

\section{Declaring symbol tables}

Lines 14--19 of Figure~\ref{minicalc:interp1}  specify the creation of a
symbol table to hold the variables declared in a {\tt minicalc} program.
A symbol table is a repository for records which may be stored and
retrieved using a {\em key}. Typically the key is a string corresponding
to the name of an identifier, but \rdp\ allows keys to be made up of
combinations of different fields. The symbol table package itself is
quite general\dash the user must supply a set of routines for comparing,
hashing and printing keys which effectively tune the package to use
tables with a particular kind of key. The library itself comes with
suitable functions for the very common  case in which the single string
key field is the first field in the  symbol table record, and it is
those routines that are used here. For these routines to work we must be
sure to set up the data part of the symbol table record correctly: in
this case a single {\tt char*} field to hold the variable's identifier
is the first field and then an {\tt integer} field is declared to hold
the working value of a variable.

\section{Using synthesized attributes}
A synthesized attribute is a value (which may be of any C type, including primitive types
such as characters and integers as well as complex types such as structures and arrays) which
is passed back up a parse tree, or equivalently in \rdp\ terms `returned' by a grammar rule
or scanner primitive. A simple example may be found in the definition for rule {\tt e5}, part
of which is reproduced here:
\begin{quote}
\small
\begin{verbatim}
e5:integer ::= ... | INTEGER:result | ... .
\end{verbatim}
\end{quote}
When rule {\tt e5} matches against an {\tt INTEGER} the scanner can be asked to return the
binary number corresponding to the {\tt INTEGER} lexeme just recognised. The specification 
here indicates that the return value should be loaded into an attribute called {\tt result}.
At the end of a rule, the current value of {\tt result} is returned to the caller of the rule,
so the effect of this \rdp\ IBNF fragment is to parse an integer and return the corresponding
binary number to the caller.

\section{Expression evaluation} The expression tree (rules {\tt
e1}--{\tt e5} specified in lines 45--70) evaluates expressions by
collecting the values of operands in rule {\tt e5} and passing them back
up through the tree, performing any calculations specified by operators
{\em en route}. 

Each operator has an attached semantic action which
evaluates its operands into the {\tt result} return value. The semantic
actions just use the equivalent operator in the underlying C language
except in the case of the exponentiation operator which does not exist
in ANSI-C. Exponentiation is therefore handled by calling the {\tt pow()} standard
library function (ensuring that the {\tt integer} operands supplied by
the {\tt mini} code are re-cast as {\tt double} precision real numbers).
The header file for the maths library must be added to the list of files which are 
\verb+#include+ed into the parser, and this is specified with the {\tt USES} directive 
in line 12.

We must be particularly cautious with the divide operator {\tt /} because an attempt to divide
by zero would generate an arithmetic trap
on some computer architectures (or, even worse, quietly
generate undefined results on some others!) The semantic action for the divide operator
checks for this condition before attempting to evaluate any divisions and issues a fatal
error message if necessary which will abort interpretation. You can read about the routine
\verb+text_message()+ which is used to issue error messages in Chapter~8 of the support
library manual~\cite{rdp:supp:1.5}.

\section{Accessing the symbol table} When a new variable is declared
in a {\tt mini} program using an {\tt int} declaration we must create a new symbol
table entry which will hold the value of the variable. When the
corresponding variable  identifier appears within an expression we must
access the symbol table to retrieve the value, and when an identifier
appears on the left hand side of an assignment we must access the symbol
table to update the variable's value field. The symbol table library
provides two routines \verb+symbol_lookup_key()+ and
\verb+symbol_insert_key()+ to search for and insert keys. You should
look at Chapter~7 of the support library manual~\cite{rdp:supp:1.5}
for a complete description of these routines. Lines 30--36 illustrate the use of
these functions to look up an identifier in the symbol table:
\begin{quote}
{\footnotesize
\begin{verbatim}
30: statement ::= ID:name
31:               [* if (symbol_lookup_key(mini, &name, NULL) == NULL)
32:                  {
33:                    text_message(TEXT_ERROR, "Undeclared variable '%s'\n", name);
34:                    symbol_insert_key(mini, &name, sizeof(char*), sizeof(mini_data));
35:                  }
36:               *]
\end{verbatim}
}
\end{quote}
The {\tt ID} scanner primitive will accept an alphanumeric identifier
whose lexeme is returned in attribute {\tt name}. The semantic action
calls \verb+symbol_lookup_key()+ to search the symbol table called {\tt
mini} for the identifier {\tt name} in any scope region. If the symbol
table does not contain {\tt name} then \verb+symbol_lookup_key()+ will
return a {\tt NULL} value, in which case the action issues an error
message and then inserts the identifier into the table. This is done so
as to suppress subsequent error messages  that might be triggered by
later references to the variable.

\chapter{The {\tt minicond} language: interpretation with conditionals}

The {\tt minicalc} language discussed in the last chapter is only really
as powerful as an integer-only pocket calculator with a large number of
memories. Historically, calculators were distinguished from full blown
computers on the basis of their control capability: to be worthy of the
name a computer must be capable of making decisions. A `decision' in
this context usually means conditionally executing some parts of a
program on the basis of calculations performed whilst the program is
running (that is, at {\em run-time}). By this definition, {\tt minicalc}
has the abilities of a calculator, not a computer. We shall
progressively add capabilities to our {\tt mini} language. We start in this chapter
by making these additions:
\begin{enumerate}
\item relational operators (\verb+>+, \verb+>=+, \verb+<+, \verb+<=+, \verb+==+ and \verb+!=+)
with lower priority than any of the arithmetic operators, and
\item an {\tt if-then-else} statement which allows conditional interpretation of programs.
\end{enumerate}
The result is a language {\tt minicond} whose
programs look like {\tt minicalc} programs with some
additional features\dash  {\tt minicalc} is a strict subset of the
{\tt minicond} language so any {\tt minicalc} program will be correctly
evaluated by a {\tt minicond} interpreter. Figure~\ref{minicond:program}
 shows an example {\tt minicond} program. The output produced when this
is run through the {\tt minicond} interpreter is shown in
Figure~\ref{minicond:output}.


\begin{figure}
\hspace*{-1cm}
\begin{minipage}{30cm}
\footnotesize
\begin{verbatim}
     1: (*******************************************************************************
     2: *
     3: * RDP release 1.50 by Adrian Johnstone (A.Johnstone@rhbnc.ac.uk) 20 December 1997
     4: *
     5: * testcond.m - a piece of Minicond source to test the Minicond interpreter
     6: *
     7: * This file may be freely distributed. Please mail improvements to the author.
     8: *
     9: *******************************************************************************)
    10: 
    11: int a=3+4, b=1;
    12: 
    13: print("a is ", a, "\n");
    14: 
    15: b=a*2;
    16: 
    17: print("b is ", b, ", -b is ", -b, "\n");
    18: 
    19: print(a, " cubed is ", a**3, "\n");
    20: 
    21: int z = a;
    22: 
    23: if z==a then print ("z equals a\n") else print("z does not equal a\n");
    24: 
    25: z=a - 3;
    26: 
    27: if z==a then print ("z equals a\n") else print("z does not equal a\n");
    28: 
    29: (* End of testcond.m *)
\end{verbatim}
\end{minipage}
\caption{An example {\tt minicond} program ({\tt testcond.m})}
\label{minicond:program}
\end{figure}

\begin{figure}
\hspace*{2cm}
\begin{minipage}{30cm}
\footnotesize
\begin{verbatim}
a is 7
b is 14, -b is -14
7 cubed is 343
z equals a
z does not equal a
\end{verbatim}
\end{minipage}
\caption{{\tt minicond} output for example program}
\label{minicond:output}
\end{figure}

In a later chapter we shall see how to add looping constructs and a facility for grouping
statements together in blocks.

\section{A grammar for {\tt minicond}}

The grammar for {\tt minicond} shown in Figures~\ref{minicond:interp1}
and \ref{minicond:interp2} follows the general form of the interpreter
presented in the previous chapter, except that large semantic actions
have been placed in their own {\em semantic rules}, and the necessary
syntax and semantic actions have been added to support relational
expressions and the {\tt if} statement.

\begin{figure} 
\hspace*{-2cm}
\begin{minipage}{30cm}
\footnotesize 
\begin{verbatim}
     1: (*******************************************************************************
     2: *
     3: * RDP release 1.50 by Adrian Johnstone (A.Johnstone@rhbnc.ac.uk) 20 December 1997
     4: *
     5: * minicond.bnf - a decorated mini-conditional grammar with interpreter semantics
     6: *
     7: * This file may be freely distributed. Please mail improvements to the author.
     8: *
     9: *******************************************************************************)
    10: TITLE("Minicond interpreter V1.50 (c) Adrian Johnstone 1997")
    11: SUFFIX("m")
    12: USES("math.h")
    13: 
    14: SYMBOL_TABLE(minicond 101 31
    15:              symbol_compare_string
    16:              symbol_hash_string
    17:              symbol_print_string
    18:              [* char* id; integer i; *]
    19:             )
    20: 
    21: program   ::= {[var_dec(1) | statement(1)] ';'}.
    22: 
    23: (* semantic rules - implemented as macros in the C code *)
    24: _insert(id)       ::= [* if (interpret) 
    25:                            symbol_insert_key(minicond, &id, sizeof(char*), 
    26:                                              sizeof(minicond_data)); 
    27:                       *].
    28: _lookup(id ret)   ::= [* {
    29:                            void * sym = symbol_lookup_key(minicond, &id, NULL);
    30:                            if (sym == NULL) /* not found! */
    31:                            {
    32:                              text_message(TEXT_ERROR_ECHO, "Undeclared variable, '%s'\n", id);
    33:                              sym = symbol_insert_key(minicond, &id, 
    34:                                                      sizeof(char*), sizeof(minicond_data));
    35:                            }
    36:                            ret = minicond_cast(sym)->i;
    37:                          }
    38:                        *].
    39: _update(id val)   ::= [* if (interpret)
    40:                          {
    41:                            void * sym = symbol_lookup_key(minicond, &id, NULL);
    42:                            if (sym == NULL) /* not found! */
    43:                            {
    44:                              text_message(TEXT_ERROR_ECHO, "Undeclared variable, '%s'\n", id);
    45:                              sym = symbol_insert_key(minicond, &id, 
    46:                                                      sizeof(char*), sizeof(minicond_data));
    47:                            }
    48:                            minicond_cast(sym)->i = val;
    49:                          }
    50:                       *].
    51: _and(dst a b)     ::= [* dst = a && b;  *].
    52: _and_not(dst a b) ::= [* dst = !a && b; *].
    53: _local_int(a)     ::= [* integer a; *].
    54: 
\end{verbatim}
\end{minipage}
\caption{An \rdp\ specification for the {\tt minicond} interpreter: part 1}
\label{minicond:interp1}
\end{figure}

\begin{figure}
\hspace*{-2cm}
\footnotesize
\begin{minipage}{30cm}
\begin{verbatim}
    55: var_dec(interpret:integer) ::=
    56:   'int' ( ID:name _insert(name)                                  (* Declaration *)
    57:           ['=' e0:val _update(name val) ]                        (* Initialisation *)
    58:         )@','.
    59: 
    60: statement(interpret:integer) ::=
    61:   ID:name '=' e0:value _update(name value) |                     (* Assignment *) 
    62: 
    63:   _local_int(flag)
    64:   'if' e0:cnd 'then' _and(flag cnd interpret) statement(flag)    (* if statement *)
    65:      [ 'else' _and_not(flag cnd interpret) statement(flag) ] |
    66: 
    67:   'print' '(' ( e0:value [* if (interpret) printf("%li", value); *] | (* output *)
    68:                 String:str [* if (interpret) printf("%s", str); *]
    69:               )@','
    70:           ')'.
    71: 
    72: e0:integer ::=
    73:   e1:result ['>' e1:right  [* result = result > right; *] |      (* Greater than *)
    74:              '<' e1:right  [* result = result < right; *] |      (* Less than *)
    75:              '>=' e1:right [* result = result >= right; *] |     (* Greater than or equal *)
    76:              '<=' e1:right [* result = result <= right; *] |     (* Less than or equal *)
    77:              '==' e1:right [* result = result == right; *] |     (* Equal *)
    78:              '!=' e1:right [* result = result != right; *] ].    (* Not equal *)
    79: 
    80: e1:integer ::= e2:result {'+' e2:right [* result += right; *] |  (* Add *)
    81:                           '-' e2:right [* result -= right; *] }. (* Subtract *)
    82: 
    83: e2:integer ::= e3:result {'*' e3:right [* result *= right; *] |  (* Multiply *)
    84:                           '/' e3:right                           (* Divide *) 
    85:                           [* if (result == 0)       
    86:                                text_message(TEXT_FATAL_ECHO, "Divide by zero attempted\n"); 
    87:                              else result /= right; 
    88:                           *] 
    89:                          }. 
    90: 
    91: e3:integer ::= '+' e3:result |                                   (* Posite *)
    92:                '-' e3:result [* result = -result; *] |           (* Negate *)
    93:                e4:result.
    94: 
    95: e4:integer ::= e5:result [ '**' e4:right                         (* Exponentiate *)
    96:                            [* result = (integer) pow((double) result, (double) right); *] 
    97:                          ].
    98: 
    99: e5:integer ::= ID:name _lookup(name result) |                    (* Variable access *)
   100:                INTEGER:result |                                  (* Numeric literal *)
   101:                '(' e1:result ')'.                                (* Do-first *)
   102: 
   103: comment    ::= COMMENT_NEST('(*' '*)').                          (* Comments *)
   104: 
   105: String: char* ::= STRING_ESC('"' '\\'):result.                   (* Strings for print *)
   106: 
   107: (* End of minicond.bnf *)
\end{verbatim}
\end{minipage}
\caption{An \rdp\ specification for the {\tt minicond} interpreter: part 2}
\label{minicond:interp2}
\end{figure}

\section{Adding conditional operators}

The rule {\tt e0} defined in lines 72--78 adds a specification for the
six new  relational operators at a priority level below that of the
operators defined in the {\tt minicalc} grammar expression tree.
It is not meaningful to write a sequence of relational operators;
an expression such as \verb|(3 < 2) < 4| attempts to compare a boolean value,
in this case {\sc false} (the result of $3<2$) with the integer 4.
This issue is
confused in some languages such as C where booleans are not directly
supported, integers being used in their place. This expression actually
yields {\sc true} in ANSI-C because the subexpression \verb+(3<2)+
yields {\tt 0} which is indeed less than {\tt 4}. So as to avoid this kind of
confusion in {\tt minicond} the rule will only accept individual instances of
relational operators: that is an expression such as
\begin{quote}
\verb|a + b > 3|
\end{quote}
is legal but 
\begin{quote}
\verb|a > b > 3| and \verb|(a > b) > 3|
\end{quote}
are not.
This is achieved by using the {\em zero-or-one} \verb+[  ]+ construct rather than
the {\em zero-or-many} \verb+{  }+ bracket in rule {\tt e0} and only allowing bracketed
expressions to contain arithmetic operators as specified on line 101.

In other respects the rule is entirely conventional: on recognition of an operator 
subexpression the parser will execute the associated semantic action and in each case
we have simply used the equivalent operator in the underlying ANSI-C language.

\section{Using inherited attributes} In the last chapter we saw how
information about a token could be passed from the scanner to the
parser's semantic actions using attributes, and we also saw how
information calculated within a parser rule could be passed back to a
calling rule using a similar mechanism. These kinds of attributes are
called  {\em synthesized attributes} because the information is
synthesized at the lower level (either within the scanner or a rule) and
passed back {\em up} the chain of production rules. Synthesized
attributes correspond roughly to the return values of functions in a
programming language, and as we have seen this is precisely how they are
implemented in \rdp.

Sometimes we need to reverse this process and pass information down into
production rules. We can think of this as a rule inheriting information
from the rule which called it, and so these kinds of attributes are
called {\em inherited attributes}. They correspond roughly to function
parameters in conventional programming languages, and that is how they
are implemented in \rdp. You can read more about the use of inherited attributes in
Chapter~5 of the user manual~\cite{rdp:user:1.5} and Chapter~6 of the tutorial
manual~\cite{rdp:tut:1.5}.

In the {\tt minicond} interpreter we use inherited attributes in some rules to pass in a flag
called {\tt interpret} which controls the execution of semantic actions. The use of this
flag will be explained more fully in section~\ref{conditionals} below. Here we simply note
that an inherited attribute is specified on the left hand side of a rule definition by
adding parenthesised parameters to the rule name. In line 50 of {\tt minicond.bnf}, for instance,
the original {\tt minicalc} variable declaration rule is redefined as
\begin{quote}
\small
\begin{verbatim}
var_dec(interpret:integer) ::= ...
\end{verbatim}
\end{quote}
This specifies that rule \verb+var_dec+ has a single inherited attribute called {\tt interpret}
of type {\tt integer}. \rdp\ grammar rules can have multiple inherited attributes each of
which must be specified with an accompanying type. When such a rule is called, the parameter
values must be filled in using either literal numbers, literal strings or the names of other 
attributes. You can see examples in line 21 where the top level rule calls subrules with a literal
integer:
\begin{quote}
\small
\begin{verbatim}    
program   ::= {[var_dec(1) | statement(1)] ';'}.
\end{verbatim}
\end{quote}
and in line 64 where the {\tt statement} rule is called and passed the value of an attribute.

\section{Using semantic rules}

In complex translators the semantic actions can become very large, and
reading a decorated \rdp\ grammar can become difficult as the C-language
semantic actions obscure the underlying form of the grammar. One
solution to this problem is to parcel all but the most trivial actions
into separate C functions that reside in the auxiliary file, in which
case the semantic actions in the grammar may be reduced to function
calls. This certainly allows the grammar to `show through' but then a full
understanding of the translator requires two files (the \rdp\ IBNF file and the C
language auxiliary file) to be coordinated. Semantic rules are a sort of half way
house in which the C language actions may be separated out from the main part of the
grammar whilst still residing in the same source file.

A semantic rule is one which contains {\em only} a single sequence of semantic actions. As
such, these rules do not affect the language generated by the grammar
(or, equivalently, matched by the parser generated from the grammar). By
convention, semantic rule names begin with a leading underscore so that
when reading the grammar we can mentally delete them from consideration
of the language generated. 

Semantic rules are implemented using ANSI-C macros rather than as
functions. This is to allow the semantic rule to automatically have
access to all of the attributes in the rule that calls the semantic
rule but you should be aware that each instance of a semantic rule will result
in the complete body of the rule being instantiated into the parent rule, so casual
use could lead to very large generated parsers.

Semantic rules can take inherited attributes but may not return
synthesized attributes\dash since the semantic rule automatically has
access to the complete state of the calling rule it can access the
parent's attributes directly. The inherited attributes are treated
slightly differently for semantic rules than for normal rules in that
the attributes are made into macro parameters and are thus available for
textual substitution within the semantic actions. As such they do not
take a type and they follow the rules for macro parameters in the ANSI-C
macro preprocessor.

The {\tt minicond} interpreter contains six semantic
rules. 
\begin{itemize}
\item \verb+_local_int(a) ::= [* integer a; *].+ generates a macro that will declare a
new local variable of type integer. The name of the variable will be whatever identifier
is supplied as the actual parameter in a call to this semantic production.
\item \verb+_and(dst a b) ::= [* dst = a && b;  *].+ the destination attribute is set
to the logical {\sc and} of attributes {\tt a} and {\tt b}.
\item \verb+_and_not(dst a b) ::= [* dst = !a && b; *].+ the destination attribute is set
to the logical {\sc and} of the inverse of attribute {\tt a} and attribute {\tt b}.
\item \verb+_insert(id)+ the identifier {\tt id} is added to the symbol table {\tt minicond}.
\item \verb+_lookup(id ret)+ the attribute {\tt ret} is set to the integer value field of
the symbol table record for identifier {\tt id}. If {\tt id} is not found in the symbol
table then an error message is issued and the symbol is added in, so as to suppress
subsequent messages.
\item \verb+_update(id val)+ the integer value field of
the symbol table record for identifier {\tt id} is set to {\tt val}. If {\tt id} is not found in the symbol
table then an error message is issued and the symbol is added in, so as to suppress
subsequent messages.
\end{itemize}

\section{Adding conditional execution}
\label{conditionals}
Our first task when adding an {\tt if} statement to {\tt mini} is to add
the necessary syntax
to the grammar. This is done in lines 64 and 65 of {\tt minicond.bnf}:
\begin{quote}
\small
\begin{verbatim}
63:   ...
64:   'if' e0:cnd 'then' _and(flag cnd interpret) statement(flag)
65:      [ 'else' _and_not(flag cnd interpret) statement(flag) ] |
66:   ...
\end{verbatim}
\end{quote}
If we strip out the semantic actions, the semantic rules and the attributes from this rule 
we see that its effect on the language is to define an {\tt if} statement with this syntax:
\begin{quote}
\small
\begin{verbatim}
statement ::= 'if' e0 'then' statement [ 'else' statement ].
\end{verbatim}
\end{quote}

This recursive rule allows nesting of {\tt minicond} statements, which
leads to an ambiguity in the grammar. Consider this fragment of {\tt
minicond} code:
\begin{quote}
\small
\begin{verbatim}
     1: int x = 0, a = 10, b = 20, c = 30;
     2: if a>b then
     3:   if b>c then
     4:     x = 1
     5:   else
     6:     x = 2
\end{verbatim}
\end{quote}
Here we see two nested {\tt if} statements, with one optional
{\tt else} clause present. The ambiguity in the grammar means that
we cannot tell, just by looking at lines 1-5 whether the {\tt else}
clause at line 5 belongs to the {\tt if} statement at line 3 or the 
{\tt if} statement at line 2. The ambiguity is reflected in the error
message that \rdp\ generates when presented with the full grammar:
\begin{quote}
\small
\begin{verbatim}
******: Error - LL(1) violation - rule
 rdp_statement_2 ::= [ 'else' _and_not statement ] .
 contains null but first and follow sets both include: 'else'
\end{verbatim}
\end{quote}
Since an {\tt else} clause may be immediately followed by another 
{\tt else} clause {\em and} the {\tt else} clause is optional we have
an LL(1) violation because the IBNF phrase \verb+[ 'else' statement]+
is (1) optional,  and (2) starts with the keyword {\tt else} and may be followed
by the keyword {\tt else}.
In practice, it is almost universally agreed by programming language designers
that an {\tt else} clause should bind to the nearest {\tt if} statement, in this
case to the {\tt if} statement at line 3.

Whilst \rdp\ is an LL(1) parser generator it is not strictly true that
it can only generate parsers for LL(1) grammars. When \rdp\ is presented
with a non-LL(1) grammar it is effectively being asked to parse
strings that may provide matches for more than one alternative at some
point in the derivation. By default, \rdp\ simply rejects such grammars
with an appropriate error message, but if we add a {\tt -F} flag to the
\rdp\ command line then \rdp\ will be forced to output a parser that
disambiguates such cases by choosing the alternative that is lexically
first in the grammar. As long as the grammar writer is able to achieve
the non-LL(1) behaviour required by putting the most important
alternative first then the generated parser will operate correctly. In
the case of iterators (including the optional bracket \verb+[  ]+ here)
\rdp\ will choose to go into an  iterator rather than skipping over it
if the currently parsed token is in both the {\sc first} and {\sc
follow} sets of the iterator. This rule has the effect of parsing the
{\tt else} clause in such a way that the derivation tree shows the {\tt
else} clause as bound to the nearest {\tt if}.

There are other techniques for handling the so-called dangling-else
problem. Perhaps the simplest is to change the language syntax so that
{\tt if} statements are explicitly terminated. The Algol-68 language for 
instance uses a rule of this form:
\begin{quote}
\small
\begin{verbatim}
statement ::= 'if' e0 'then' statement [ 'else' statement ] 'fi'.
\end{verbatim}
\end{quote}

The closing \verb+'fi'+ (which is {\tt if} backwards) marks the end of
each {\tt if} statement and removes both the grammatical ambiguity for
dangling-else's and the LL(1) breach caused by the presence of the
keyword  {\tt else} in both the {\sc first} and {\sc follow} sets of the
optional {\tt else} clause. The modern trend in programming languages is
to insist on this kind of explicit termination because it has been
observed that programmers are more likely to accidentally leave out
tokens than to add in spurious tokens. Forcing the programmer to mark the
end of compound statements is a useful discipline. However, languages 
designed during the 60's and 70's such as Pascal and C typically allow
unterminated control statements.

\subsection{Semantic actions for conditional execution}

When we write an {\tt if} statement in a program we think of the
computer `jumping' over one of the two branches. In a compiler we can
generate instructions that do indeed cause a section of code to be
jumped over as we shall see in Chapter~\ref{miniloop}, but in an
interpreter we cannot simply jump over part of the input stream because
the whole source text must be checked for syntactic correctness. Hence
the parser will read and process both the {\tt then} and the {\tt else}
branches of an {\tt if} statement, executing the semantic actions in
both branches as it goes. In practice, of course, we only want to
execute the semantic actions for one branch or the other so we need to
be able to dynamically disable semantic action execution at run-time. We
do this by supplying an inherited attribute to the productions {\tt
statement} and \verb|var_dec| which is a boolean value. If the attribute
is true then the embedded semantic actions are executed and if not they
are skipped over.

At the top level, rule {\tt program} in line 21 calls the
\verb+statement+ and \verb+var_dec+ rules with the attribute set to {\tt
1} (i.e. {\sc true}) so at the start of a program all semantic actions
will be executed. When an {\tt if} statement is encountered, the 
conditional expression is evaluated and the result is logically {\sc
and}-ed with the value of the {\tt interpret} attribute. This new value
is then supplied as a parameter to a new (nested) instance of the {\tt
statement} rule.

The semantic actions in the expression tree are {\em not} switched on
and off in this way because they do not need to be: during the
evaluation of an expression attributes are calculated and passed back up
the tree of expression rules but no changes are made to the variables
declared in a {\tt minicond} program until an assignment is executed.
The \verb+_update+ semantic rule associated with the assignment
statement {\em is} guarded by a check against the {\tt interpret}
attribute, so the result of an  expression is simply discarded if
interpretation has been switched off.

\section{Next steps}
The techniques used in this chapter to handle conditional interpretation
can not easily be extended to handle looping because our parsers are
designed to make complete passes over the source program, and a loop
construct would require us to skip {\em backwards} in the parse. This
is certainly not impossible to implement but would require detailed
knowledge of \rdp's internals and is not the recommended approach.
Instead we shall move to a full compiler for {\tt mini} which outputs
instructions for a very simple computer called the Mini Virtual Machine
(MVM). By providing an assembler and simulator for MVM we can build a
complete system that models the tasks of a compiler for a real processor.

\chapter{The Mini Virtual Machine (MVM)}

MVM is a paper architecture designed to support efficient interpretation
on a host architecture. We will use MVM to illustrate the techniques  of
virtual machine simulation, assembly language translation and
compilation. In this chapter we shall describe the MVM architecture and
a simulator for that architecture written in ANSI-C. As well as
providing a means to execute MVM programs, the simulator source code can
be treated as an exact specification of the architecture. We will begin
by describing the architecture informally.

The Mini Virtual Machine is a very simple architecture based
around a conventional memory to memory processor. This means that all
MVM operations execute directly on the contents of memory locations:
there are no registers or stacks available for storing data, although
there are two internal registers used to hold the address and contents
of the currently executing instruction. 

MVM is a {\em 16-bit} processor in which arithmetic operations take
place on 16-bit quantities and in which memory addresses also fit into
16-bit words. This limitation to 16-bit memory addresses does constrain
the size of the programs that we can write, but is sufficient for
demonstrating the ideas behind the development of a compiler. It also
means that the tools can be compiled and run on older 16-bit computers
such as ordinary MS-DOS machines. If you have a 32-bit system and a
suitable C compiler, it is quite easy to extend the MVM specification
and its simulator to support 32-bit operations and addresses.

Understanding a new processor is made easier if we list the capabilities
of the architecture under three main headings: \begin{enumerate} \item
the memory resources provided by the architecture, \item the various
ways in which operands may be fetched during instruction execution (the
{\em addressing modes}) and \item the collection of operations that may
be programmed on that architecture (the {\em instruction set}). 
\end{enumerate}

In each of these three areas MVM provides very limited facilities. This
makes MVM easy to understand, easy to program and easy to write software
simulators for, but it does not make MVM a good target for efficient
hardware implementation. That need not concern us: MVM is only really
intended to be used {\em via} a software simulator, so the many clever
devices that hardware designers have introduced into real architectures
to aid hardware realisation are irrelevant to our purpose. You should
bear in mind, however, that writing a compiler for a real processor is
more complex than writing a compiler for MVM: the principles remain the
same, but the large scale design of a real compiler requires much more
detail to be handled.

\section{MVM memory}

All MVM data and instructions are stored in a single main memory. MVM
has no special or general purpose registers for data. The MVM memory can
be regarded as an array of eight-bit (byte) locations, individually
addressed. The size of the MVM memory is fixed at 64K (= 65536$_{10}$)
bytes. This allows all MVM addresses to be specified using 16-bit
numbers.  A diagrammatic representation of the MVM memory is shown in
Figure~\ref{MVM:memory}.

\begin{figure}
\input{mvmmem.pic}
\caption{MVM memory structure}
\label{MVM:memory}
\end{figure}

Since the memory cells can only hold eight bit numbers, and since MVM
usually operates on 16-bit quantities, in general two adjacent
cells are used to hold each data item. When accessing 16-bit numbers,
the address of the least significant byte is specified, (say $n$) and
the operand is understood to be made up of the contents of the addressed
cell concatenated with the contents of the next highest address ($n$+1).
In the example shown in the figure, the 16-bit variable {\tt temp}
resides at locations 2 and 3. If {\tt memory[2]} contains 9$_{10}$ (1001$_2$) and {\tt
memory[3]} contains 3$_{10}$ (0011$_2$) then the value of {\tt temp} is 0003
concatenated with 0009, which is $3_{10}\times256_{10} + 9_{10} = 777_{10}$ (1100001001$_2$).

MVM instructions range in size from two to eight bytes. By analogy with
the addressing for data items, the address of the instruction is taken
to be the address of the least significant byte which will be the lowest
address of the range of locations occupied by the instruction.


\section{MVM instruction execution}
A block diagram of the internal structure of an MVM processor is shown
in Figure~\ref{MVM:block}.
MVM is an example of a {\em Von Neumann} processor, as indeed are most
real computers in use today. In a Von Neumann machine, instructions and
data can co-exist in the same memory as described in the previous
section. It is not possible, just by looking at the contents of memory to distinguish
between instructions and data. 

\begin{figure}
\begin{center}\input{mvmblock.pic}\end{center}
\caption{MVM internal structure}
\label{MVM:block}
\end{figure}

The processor maintains a pointer to memory (that is, a register which
holds the address of a location in memory) called the {\em program
counter}. Before a program can be executed, it must be loaded into
memory and then the program counter initialised with the address of the first
instruction to be executed. 

Once the machine starts running the program, it reads the instruction
pointed to by the program counter into some internal registers
collectively called the {\em Instruction Register}. In this case, the
instruction register has space for an operation code, an address mode
and up to three operands called the destination, source 1 and source 2
operands. These registers between them can hold all of the information
needed to execute a single MVM instruction: the significance of the
individual registers will be described in the following sections. For
now, note that the data from memory may be loaded into the instruction
register or sent to the execution unit; that memory addresses may be
supplied by the program counter or by the operand registers; that only
the execution unit can generate data to be written back into memory and
that the contents of the operand registers may connected directly to the
execution unit.

After the instruction register has been loaded with a new instruction
ready for execution, the program counter is incremented so that it
points to the location just past the end of the instruction that has
just been read. The processor then performs whatever action is specified
by the instruction in the instruction register, which might for instance
be the addition of two numbers or the copying of a data item
from one memory location to another. These kinds of instructions are
called {\em data manipulation} instructions because they allow data to
be modified in various ways. 

In addition to the data manipulation instructions, Von Neumann processors
like MVM have {\em control manipulation} instructions which affect the
order in which the program's instructions are executed. By default, the
program counter is simply incremented to point to the next instruction
after the current one. In the absence of any control manipulation
instructions, therefore, all programs would simply be executed once only
in strict order by address. This is the kind of program that we can
write using the simple {\tt minicalc} language which has no control flow
constructs. 

The control manipulation instructions allow sequences of instructions to
be jumped over. They work by loading a new value directly into the
program counter which overrides the simple sequential execution. Often 
the new value is only loaded if some condition is true. An {\tt if} {\em
condition} {\tt then} {\em action} statement can be implemented as a
test of {\em condition}. If {\em condition} is false, then the program counter
is loaded with the address of the instruction after the code
corresponding to {\em action}, and this has the effect of skipping over
{\em action} without executing it.

\section{MVM addressing modes}
\label{addressing:modes}

Most high level programming languages provide both variables and numeric
literals. In {\tt minicalc}, for instance, the assignments 
\begin{quote}
{\tt temp = x + y}

and

{\tt temp = x + 12}
\end{quote}
are both valid. In practice, they
will be compiled into an {\tt ADD} instruction with three
operands: a destination and two sources corresponding to the  left and
right sides of the {\tt +} operator. The variables {\tt x} and {\tt
y}  will be stored at specific memory addresses. What if variable {\tt
y} were to be stored at location 12? How would an MVM processor
distinguish between an instruction to add the number 12 and an
instruction to add the contents of a variable stored at location 12? The
answer is to provide some extra information called the {\em addressing
mode}. It is the
responsibility of the compiler to specify the correct addressing mode
when it generates an MVM instruction. We shall look at how the modes are
specified in the next section.

MVM provides only two addressing modes: literal and variable. Real
processor architectures often provide many complex addressing modes
which, for instance, might allow an access within a two dimensional
array to be specified as a single machine instruction. The trend in
recent years has been to discourage the use of any but the most
straightforward addressing operations because they complicate the use of
{\em pipelining} in hardware implementations. Pipelined processors are
very efficient, but their execution units are disrupted by the overhead
of having to decode complicated addressing modes. Broadly speaking,
Complex Instruction Set Computer (CISC) architectures such as the DEC
VAX, the Motorola 68000 and the Intel 80x86 family have many exotic
addressing modes, and Reduced Instruction Set Computer (RISC)
architectures such as the MIPS, Sun SPARC and Dec Alpha have essentially
only three modes.  MVM is simple, but is not comparable to a real RISC
architecture because it does not have any data registers, and the
efficient use of such registers is perhaps the defining characteristic
of a true RISC architecture.

\section{MVM instructions}

MVM instructions are made up of a string of bytes. Depending on the
instruction, the string may be between two and eight bytes long: every
MVM instruction has an operation code (opcode) byte followed by an
address mode byte, and most instructions also contain some operands.
Each operand is represented by a 16-bit number, so each operand adds two
bytes to the length of an instruction: one for the most significant byte
(MSB) and one for the least significant byte (LSB). The format of a
three address instruction, therefore is  \begin{quote}
\hspace*{-1.5cm}\begin{tabular}{|l|l|l|l|l|l|l|l|}  \hline \em
opcode&\em mode&\em dst MSB&\em dst LSB&\em src1 MSB&\em src1 LSB&\em
src2 MSB&\em src2 LSB\\ \hline \end{tabular} \end{quote}

Instructions with less than three operands follow this general format
but simply omit the unused operand fields. Even zero address
instructions such as {\sc halt} have a mode byte.

\subsection{Instruction set capabilities}
The opcode byte could encode up to 256 unique instructions, but in fact
MVM only uses the first 17 codes, numbered 0--16. As we shall see
in the next chapter, it is more convenient to use hexadecimal (base 16)
than decimal (base 10) to represent machine level quantities, so 
Table~\ref{MVM:instr} which shows the complete MVM instruction set gives
the hexadecimal encodings for the instructions.

The functional description of each instruction in Table~\ref{MVM:instr}
uses a C-like syntax to explain the actions of the MVM processor on
receipt of each instruction. Main memory is modeled as an array of
locations called {\tt mem[]} and the program counter as a variable
called {\tt PC}. The function {\tt resolve()} looks at the addressing
mode of its corresponding operand and fetches the actual data. Later in
this chapter we give extracts from  the source code of a simulator for
MVM instructions which shows exactly how these functional descriptions
may be turned into executable code.

\begin{table} \hspace*{-1.5cm}\begin{tabular}{cccccl}
Opcode&Mnemonic&\multicolumn{3}{c}{Operands}&\multicolumn{1}{c}{Function}\\
00&HALT&--&--&--&Stop the processor\\
01&ADD&{\em dst}&{\em src1}&{\em src2}&\tt mem[dst] = resolve(src1) + resolve(src2)\\
02&SUB&{\em dst}&{\em src1}&{\em src2}&\tt mem[dst] = resolve(src1) - resolve(src2)\\
03&MUL&{\em dst}&{\em src1}&{\em src2}&\tt mem[dst] = resolve(src1) * resolve(src2)\\
04&DIV&{\em dst}&{\em src1}&{\em src2}&\tt mem[dst] = resolve(src1) / resolve(src2)\\
05&EXP&{\em dst}&{\em src1}&{\em src2}&\tt mem[dst] = resolve(src1) ** resolve(src2)\\
06&EQ&{\em dst}&{\em src1}&{\em src2}&\tt mem[dst] = resolve(src1) == resolve(src2)\\
07&NE&{\em dst}&{\em src1}&{\em src2}&\tt mem[dst] = resolve(src1) != resolve(src2)\\
08&GT&{\em dst}&{\em src1}&{\em src2}&\tt mem[dst] = resolve(src1) > resolve(src2)\\
09&GE&{\em dst}&{\em src1}&{\em src2}&\tt mem[dst] = resolve(src1) >= resolve(src2)\\
0A&LT&{\em dst}&{\em src1}&{\em src2}&\tt mem[dst] = resolve(src1) < resolve(src2)\\
0B&LE&{\em dst}&{\em src1}&{\em src2}&\tt mem[dst] = resolve(src1) <= resolve(src2)\\
0C&CPY&{\em dst}&{\em src1}&--&\tt mem[dst] = resolve(src1)\\
0D&BNE&{\em target}&\em src1&--&\tt if resolve(src1) != 0 then PC = target\\
0E&BEQ&{\em target}&\em src1&--&\tt if resolve(src1) == 0 then PC = target\\
0F&PRTS&0&\em src1&--&Print {\tt resolve(src1)} as string\\
10&PRTI&0&\em src1&--&Print {\tt resolve(src1)} as decimal integer\\
\end{tabular}
\caption{The MVM instruction set} \label{MVM:instr} \end{table}

\subsection{Address mode encoding}

The mode byte is split into two four-bit nibbles called mode fields
\footnote{Since we only have two addressing modes to encode, we could make do with
only a single bit for each field, but we wish to leave some capacity so
that, for instance, a register based variant of MVM could be easily
defined.}. Each of the two mode fields encodes the address mode for one of
the two source operands: the most significant nibble encodes for {\em
src1} and the least significant nibble for {\em src2}. For instructions
that do not use one or both of the source operands, the corresponding
mode fields are set to zero. No mode field is required for the
destination operand because the destination must clearly always be an
address: it is never meaningful to assign a result to a literal! On some
real architectures, multiple destination addressing modes are provided
but MVM has no need of them.

\section{Example MVM instructions}

MVM programs are made up of sequences of MVM instructions which will
usually include both data manipulation and control manipulation
instructions. Each valid program must finish with a {\tt
HALT} instruction which the simulator interprets as an  instruction to
finish interpreting instructions and return control to the user. It is
not an accident that the {\tt HALT} instruction uses opcode number 0.
Within the simulator, the memory is initialised throughout to zero. If a
user programming error causes the simulator to try executing from memory
that has not been loaded with instructions, the simulator will
immediately terminate because those zeros will be interpreted as {\tt
HALT} instructions.

\subsection{Data manipulation instructions and address modes}

In section~\ref{addressing:modes} we distinguished between literal
and variable addressing. Here we look at the MVM instructions that
correspond to the {\tt minicalc} code fragments {\tt temp = x + y} and
{\tt temp = x + 12}.

If the variable {\tt x} is resident at location $10_{10}$ (location 000A
in hexadecimal) and {\tt y} resides at location $12_{10}$ (location 000C
in hexadecimal) then the instruction to add them together and store them
in a variable called {\tt temp} at location 4 is
\begin{quote}
\begin{tabular}{ccccc}
\em Op&\em Mode&\em Dst&\em Src1&\em Src2\\
\tt 01&\tt 11&\tt 0004&\tt 000A&\tt 000C\\
\end{tabular}
\end{quote}
Here we have the operation code for {\tt ADD} ($01_{16}$) followed by a mode
byte that specifies  variable mode addressing for both source operands
($11_{16}$). Then we have three operands  specified as the addresses of the 
destination ($0004_{16}$) and the two sources ($000A_{16}$ and $000C_{16}$).

By contrast, if we wish to add the number 12 to the contents of {\tt x}
and put the result in {\tt temp} then the correct instruction is
\begin{quote}
\begin{tabular}{ccccc}
\em Op&\em Mode&\em Dst&\em Src1&\em Src2\\
\tt 01&\tt 10&\tt 0004&\tt 000A&\tt 000C\\
\end{tabular}
\end{quote}

The only difference between these instructions is that the mode field
for operand {\tt src2} is 1 in the first example and 0 in the second corresponding
to variable mode addressing and literal mode addressing respectively.

\subsection{Control manipulation instructions}

Control manipulation instructions are used in the implementation of {\tt if} statements,
loop statements and {\tt goto} statements. Consider the {\tt minicond} fragment 
\begin{quote}
\small
\begin{verbatim}
if temp then a = a + 1;
z = z - 2;
\end{verbatim}
\end{quote}
If {\tt temp} resides at location 000A$_{16}$, {\tt a} at location
000E$_{16}$ and  {\tt z} at location 001C$_{16}$, then the following sequence
of instructions based at location $2134_{16}$ corresponds to the {\tt minicond}
fragment.

\begin{quote}
\begin{tabular}{cccccc}
\em Location&\em Op&\em Mode&\em Dst&\em Src1&\em Src2\\
\tt 2134:&\tt 0E&\tt 10&\tt 2142&\tt 000A\\
\tt 213A:&\tt 01&\tt 10&\tt 001C&\tt 001C&\tt 0001\\
\tt 2142:&\tt 02&\tt 10&\tt 000E&\tt 000E&\tt 0001\\
\end{tabular}
\end{quote}

The instruction at location 2134$_{16}$ is a {\tt BEQ} which will restart
execution at address 2142$_{16}$ if the variable at location 000A$_{16}$ is zero. The
next line adds one to the variable at  location 001C$_{16}$, and the final line
subtracts one from the variable at location 000E$_{16}$. The  overall effect of
the fragment is to skip over the middle instruction if the value of {\tt
temp} at location 001C$_{16}$ is zero.

\section{Using an assembler to program MVM}

Writing MVM programs in this numerical code is time consuming and highly
error prone.  An {\em assembler} is a translator for a very simple
language that offers English-language-like mnemonic names for the machine
instructions and can also perform branch calculations automatically, so
that instructions can be referred to by a symbolic label rather than by 
their numeric address. Assemblers do not make machine level programming
easy, but they do free the programmer from a great deal of bookkeeping
work. Assemblers are in themselves  examples of an interesting class of
translator. We shall describe the implementation of an assembler for MVM
(called {\tt mvmasm}) in the next chapter.
We complete this chapter with the description of a simulator,
{\tt mvsim}, for MVM code.

\section{{\tt mvmsim} -- a simulator for MVM byte codes}

The MVM instruction set is designed to be efficiently implemented as a simulator. In this
section we look at the design and use of such a simulator. 

\subsection{Using {\tt mvmsim}}
The function of the simulator is two-fold: firstly it provides a concrete model of the
behaviour of an MVM processor, and secondly it allows instruction execution to be
{\em traced} by printing out each instruction as it is executed. The {\tt mvmsim} executable
is built as part of the standard \rdp\ installation, so if you have already run {\tt make} 
on the supplied {\tt makefile} you should have a working simulator. To check, type
{\tt mvmsim} at the command line prompt. You should see the following output:
\begin{quote}
\hspace*{-1cm}
\begin{minipage}{30cm}
\small
\begin{verbatim}
Fatal: No source file specified

mvmsim v1.5 - simulator for MVM

Usage: mvmsim [options] source

-l     Show load sequence
-t     Print execution trace
-v     Set verbose mode

You can contact the author (Adrian Johnstone) at:

Computer Science Department, Royal Holloway, University of London
Egham, Surrey, TW20 0EX UK. Email: A.Johnstone@rhbnc.ac.uk
\end{verbatim}
\end{minipage}
\end{quote}

This is the standard {\tt mvmsim} help message: in this case it has been
triggered because no source file was specified. It tells you about the
three optional flags that can be supplied to {\tt mvmsim}:
\begin{itemize}
\item {\tt -l} tells {\tt mvmsim} to echo the data it is writing into the simulator's
memory during the load phase
\item {\tt -t} switches on {\em trace} mode in which instructions are echoed as they are
executed.
\item {\tt -v} sets verbose mode which causes {\tt mvmsim} to print out a title line,
and then at the end of a run, the total CPU time
along with the number of MVM instructions executed
\end{itemize}
 
\subsection{The {\tt mvmsim} input file format}

The MVM program to be simulated is read by {\tt mvmsim} from an input file which contains
binary information rendered as a hexadecimal dump of the required memory contents. 
Each line of the dump file starts with a 16-bit hexadecimal number which
specifies the  base address to which the rest of the data on that line
will be loaded. The data is specified as zero or more pairs of
hexadecimal digits. Each pair specifies the contents of one eight-bit
memory cell, and the corresponding memory locations are loaded in
ascending order starting with the base address.

Spaces are allowed (but not required) between each pair of digits. Blank
lines are also allowed.

This kind of load format is commonly used by assemblers for real
processors, although executable file formats used by commercially
available processors are usually in pure binary to save space. In a pure
binary file each location could be represented by a single binary byte
but in our case each location requires two bytes, each representing a
hexadecimal character. Therefore, MVM executable files are likely to be
at least twice as large as their pure binary equivalents. On the other
hand, pure binary files can not easily be read into an editor or printed
out.

As well as specifying memory contents, the input file must tell the
simulator which memory location contains the first instruction to be
executed. The {\tt mvmsim} input file uses a special format to specify
this {\em transfer address} comprising an asterisk followed by the
transfer address itself.

The short example below shows the contents of an {\tt mvmsim} input file for a program
comprising three instructions. 

\begin{quote}
\small
\begin{verbatim}
1000 0C 01 000A 007B
1006 10 11 0000 000A
100C 00 11
100E *1000
\end{verbatim}
\end{quote}

The first instruction, based at location $1000_{16}$
copies the number $123_{10}$ (7B$_{16}$) to the memory location 000A$_{16}$. The next
instruction prints out the contents of that location as a decimal number and the third 
instruction is a {\sc halt} which will cause the simulator to terminate. The final line
specifies a transfer address of $1000_{16}$: the transfer address is denoted with a leading
asterisk ({\tt *}) which warns the assembler not to attempt to load the data on that line
into memory. The file may be found in the standard \rdp\
distribution as \verb+examples/rdp_case/mvmsim.sim+.

\subsection{Running a simulation}
\label{mvmsim.sim}
We can run the simulator on the above test file with all options enabled by issuing
the command
\begin{quote}
\small
\begin{verbatim}
mvmsim -l -t -v examples/rdp_case/mvmsim.sim 
\end{verbatim}
\end{quote}

The output of this command is shown below:

\begin{quote}
\small
\begin{verbatim}
mvmsim v1.5 - simulator for mvm

Load address 1000 0C01000A007B
Load address 1006 10110000000A
Load address 100C 0011
Load address 100E *1000

1000 CPY  000A, 007B, 0000 -> 007B  
1006 PRTI 0000, 007B, 0000 -> 0000  123
100C HALT 0000, 0000, 0000 -> 0000   -- Halted --


0.006 CPU seconds used, 3 MVM instructions executed
\end{verbatim}
\end{quote}

After the title line, {\tt mvmsim} echoes to the output the contents of
the input file as it is loaded into the internal memory. Execution then
begins, starting at the transfer address.  As each instruction is
executed, {\tt mvmsim} outputs the address of the instruction, its
mnemonic and then the three operands in the order {\em dst}, {\em src1}
and {\em src2}. If an operand is not used by an opcode, then {\tt 0000}
is output. The operands are printed {\em after} the addressing mode has
been resolved, that is the actual data to be operated on is displayed
rather than its address. Hence, when the instruction at location
$1006_{16}$ is being executed, its second operand is shown as 7B$_{16}$
not as 000A$_{16}$ which is the address specified in the load file. 

The value written back to memory by the instruction is shown after a
`yields' sign
(\verb+->+). If no value is written back (as for instance
in the case of the {\sc prti} instruction)  then a zero is displayed. 

Any output produced by {\sc prti} or {\sc prts} instructions is
displayed after the instruction. If the {\tt -t} option is not used on
the command line, then the instruction display is completely suppressed,
so only program output appears.

Finally, when the simulator encounters a {\sc halt} instruction, it
prints the message \verb+-- Halted --+ and  terminates.

\subsection{Implementing {\tt mvmsim}}

The full source code of the simulator runs to a little over 300 lines of
ANSI-C which may be found in the file {\tt mvmsim.c}. In this section we
shall look at the overall structure of the simulator and look in detail
at the code corresponding to the MVM instruction execution unit.

About half of the code in {\tt mvmsim.c} is concerned with processing
the command line options, parsing the input file and then loading of the
internal memory. These functions are easy to understand, and we shall not discuss
them further here. The parts of the code we are interested in are those that
model the MVM architecture's memory and program counter, and the function that
controls the simulated execution of the MVM instructions.

\subsubsection{Memory and program counter declarations}

Figure~\ref{mvmsim1} shows the declarations that model the MVM memory.
Line 18 specifies the size of the simulated memory, which is restricted
to {\tt 65536lu} (65536 as a long unsigned number or 64K) bytes in this
16-bit MVM simulator. It is possible to reduce the size of the MVM
memory by adjusting this figure, but of course MVM programs must then
ensure that they only work within the available memory. The MVM internal
memory itself is modeled by an array of {\tt unsigned char} (line 22)
and the program counter by an {\tt unsigned long} integer (line 23).
\begin{figure}
\hspace*{0cm}
\begin{minipage}{30cm}
\small
\begin{verbatim}
    18: #define MEM_SIZE 65536lu

    22: unsigned char memory[MEM_SIZE];
    23: unsigned long pc = 0;

    39: static int get_memory_byte(unsigned long address)

    52: static int get_memory_word(unsigned long address)

    65: static void put_memory_byte(unsigned long address, int data)

    71: static void put_memory_word(unsigned long address, int data)
\end{verbatim}
\end{minipage}
\caption{Extracts from the {\tt mvmsim} simulator: memory declarations}
\label{mvmsim1}
\end{figure}

We could access the MVM memory by simply reading and writing to the
memory array, but one of the characteristics of machine level
programming is that programs often contain errors. A bad error might
cause the simulator to run amok and start executing from illegal host
addresses. So as to control this kind of problem, all memory access is
channeled through the routines \verb+get_memory_byte()+,
\verb+get_memory_word()+, \verb+put_memory_byte()+ and
\verb+put_memory_word()+ which are declared in lines 39--76. These
routines validate the memory address, issuing a fatal error message if
the program being simulated tried to access a non-existent location.

The \verb+get_memory_byte()+ and \verb+get_memory_word()+ routines take
an address and return either a single byte or a single word which is
formed by concatenating the addressed byte with the contents of the
location \verb!address + 1!. In this case, the addressed byte forms the
least significant byte of the returned word. The
\verb+put_memory_word()+ function takes an address and a 16-bit data
word. The least significant byte of the data word is written into memory
at the specified address,  and the most significant byte is loaded to
location \verb!address + 1!

\subsubsection{The main execution loop}

After the simulator has loaded the {\tt memory} array and set the
program counter to the value of the transfer address, the function
\verb+mvmsim_execute()+ is called. This function loops until a {\sc
halt} instruction is encountered, executing one instruction {\em per}
iteration. The full source of the \verb+mvm_execute()+ function is shown in
Figures~\ref{mvmsim2}--\ref{mvmsim4}.

\begin{figure}
\hspace*{0cm}
\begin{minipage}{30cm}
\footnotesize
\begin{verbatim}
   160: static void mvmsim_execute(void)
   161: {
   162:   int stop = 0;
   163: 
   164:   while (!stop)
   165:   {
   166:     unsigned op = get_memory_byte(pc),
   167:              mode = get_memory_byte(pc + 1);
   168:     int dst = get_memory_word(pc + 2),
   169:         src1 = get_memory_word(pc + 4),
   170:         src2 = get_memory_word(pc + 6);
   171: 
   172:     exec_count++;
   173:     
   174:     /* do indirections on modes */
   175:     if ((mode >> 4) == 1)
   176:       src1 = get_memory_word(src1);
   177: 
   178:     if ((mode & 7) == 1)
   179:       src2 = get_memory_word(src2);
   180: 
\end{verbatim}
\end{minipage}
\caption{Extracts from the {\tt mvmsim} simulator: the execute function part 1}
\label{mvmsim2}
\end{figure}

\begin{figure}
\hspace*{0cm}
\begin{minipage}{30cm}
\footnotesize
\begin{verbatim}
   181:     switch (op)
   182:     {
   183:     case OP_ADD:
   184:       put_memory_word(dst, src1 + src2);
   185:       display("ADD ", dst, src1, src2);
   186:       pc += 8;
   187:       break;
   188:     case OP_SUB:
   189:       put_memory_word(dst, src1 - src2);
   190:       display("SUB ", dst, src1, src2);
   191:       pc += 8;
   192:       break;
   193:     case OP_MUL:
   194:       put_memory_word(dst, src1 * src2);
   195:       display("MUL ", dst, src1, src2);
   196:       pc += 8;
   197:       break;
   198:     case OP_DIV:
   199:       put_memory_word(dst, src1 / src2);
   200:       display("DIV ", dst, src1, src2);
   201:       pc += 8;
   202:       break;
   203:     case OP_EXP:
   204:       put_memory_word(dst, (int) pow((double) src1, (double) src2));
   205:       display("EXP ", dst, src1, src2);
   206:       pc += 8;
   207:       break;
   208:     case OP_EQ:
   209:       put_memory_word(dst, src1 == src2);
   210:       display("EQ  ", dst, src1, src2);
   211:       pc += 8;
   212:       break;
   213:     case OP_NE:
   214:       put_memory_word(dst, src1 != src2);
   215:       display("NE  ", dst, src1, src2);
   216:       pc += 8;
   217:       break;
   218:     case OP_GT:
   219:       put_memory_word(dst, src1 > src2);
   220:       display("GT  ", dst, src1, src2);
   221:       pc += 8;
   222:       break;
\end{verbatim}
\end{minipage}
\caption{Extracts from the {\tt mvmsim} simulator: the execute function part 2}
\label{mvmsim3}
\end{figure}

\begin{figure}
\hspace*{0cm}
\begin{minipage}{30cm}
\footnotesize
\begin{verbatim}
   223:     case OP_GE:
   224:       put_memory_word(dst, src1 >= src2);
   225:       display("GE  ", dst, src1, src2);
   226:       pc += 8;
   227:       break;
   228:     case OP_LT:
   229:       put_memory_word(dst, src1 < src2);
   230:       display("LT  ", dst, src1, src2);
   231:       pc += 8;
   232:       break;
   233:     case OP_LE:
   234:       put_memory_word(dst, src1 <= src2);
   235:       display("LE  ", dst, src1, src2);
   236:       pc += 8;
   237:       break;
   238:     case OP_CPY:
   239:       put_memory_word(dst, src1);
   240:       display("CPY ", dst, src1, src2);
   241:       pc += 6;
   242:       break;
   243:     case OP_BNE:
   244:       display("BNE ", dst, src1, src2);
   245:       if (src1 != 0)
   246:         pc = dst;
   247:       else
   248:         pc += 6;
   249:       break;
   250:     case OP_BEQ:
   251:       display("BEQ ", dst, src1, src2);
   252:       if (src1 == 0)
   253:         pc = dst;
   254:       else
   255:         pc += 6;
   256:       break;
   257:     case OP_PRTS:
   258:       display("PRTS", dst, src1, src2);
   259:       printf("%s", memory + src1);
   260:       pc += 6;
   261:       break;
   262:     case OP_PRTI:
   263:       display("PRTI", dst, src1, src2);
   264:       printf("%i", (int) src1);
   265:       pc += 6;
   266:       break;
   267:     case OP_HALT:
   268:       display("HALT", dst, src1, src2);
   269:       printf(" -- Halted --\n");
   270:       stop = 1;
   271:       pc += 2;
   272:       break;
   273:     default:
   274:       display("----", dst, src1, src2);
   275:       text_printf("\n");
   276:       text_message(TEXT_FATAL, "illegal instruction encountered\n");
   277:       break;
   278:     }
   279:   }
   280: }
\end{verbatim}
\end{minipage}
\caption{Extracts from the {\tt mvmsim} simulator: the execute function part 3}
\label{mvmsim4}
\end{figure}

Variable {\tt stop} declared at line 162 is used as a flag to signal
termination of the simulation. It is initialised to false, and only set
to true when a {\sc halt} instruction is encountered. The main
simulation loop comprises lines 164 to 279. The body of the loop
comprises the code to fetch the new instruction (lines 166--170), the
address mode resolution code in lines 174--179 and a large switch
statement which decodes the operation code (lines 181--278 shown in
Figures~\ref{mvmsim3} and \ref{mvmsim4}.). Within the
switch statement, each of the 17 cases includes a call to the {\tt
display()} function which provides the trace output if a {\tt -t}
option has been specified on the simulator command line. Each case
finishes with an increment of the program counter by the length in bytes
of the decoded instruction.

The address mode resolution code examines the mode byte loaded from the
instruction. If the corresponding mode field (see
section~\ref{addressing:modes}) is a one, then the source operand is
reloaded with the contents of the memory location addressed by the data.
There is no need to resolve the destination operand, because
destinations are always assumed to be addresses not literal data.

The code within the simulation loop provides a detailed specification of
the meaning of each instruction in terms of the semantics of ANSI-C. The
{\sc bne} instruction for instance (lines 243--249) tests the value of
the first source operand against zero, and if the test succeeds the
program counter is loaded with the address specified in the destination
operand. If the test fails, the program counter is simply incremented in
the normal way, thus passing control to the next instruction.

\chapter{{\tt mvmasm} -- an assembler for MVM}
\label{mvmasm}
Writing MVM programs directly in the binary machine code is  very
error prone. In the early days of computing it was not unusual for
programmers to take great pride in their ability to remember all the
binary codes for instructions, but even if the machine code is easy to
remember (as indeed it is for the very simple MVM processor) it is still
hard to keep track of lots of variables if they can only be referred to
by their numeric machine addresses. 

Assemblers evolved as the earliest available programming aids. Most
assemblers provide two basic facilities:
\begin{itemize}
\item a set of mnemonic names for the machine instructions
\item the ability to {\em label} instructions and data locations 
allowing jump targets and variable addresses to be referred to using symbolic names
rather than numeric values.
\end{itemize}

In addition, assemblers usually allow {\em arithmetic} to be performed on symbolic
addresses. This allows the address calculations associated with array indexing, record 
field selection and jump branch selection to be done by the assembler, rather than
by the programmer.

\section{A first example}

The {\tt mvmasm} source code corresponding to the short example used in
section~\ref{mvmsim.sim} is shown below: a
variable is loaded with decimal 123 and then printed.
\begin{quote}
\begin{minipage}{30cm}
\footnotesize
\begin{verbatim}
;Simulator example file
 DATA 0x000A     ;start assembling data at address 000A hex
temp: WORD 1     ;declare an integer variable called temp

 CODE 0x1000     ;switch to assembling code at address 1000 hex
start:
 CPY temp, #123  ;load temp with decimal 123
 PRTI temp       ;print the value of temp as an integer
 HALT            ;terminate the simulator

 END start       ;transfer address is code start
\end{verbatim}
\end{minipage}
\end{quote}

Each line of {\tt mvmasm} source code may contain a label such as {\tt
temp:} or {\tt start:}, an instruction such as {\tt PRTI temp} and a
comment which comprises anything between a semicolon {\tt ;} and the end
of a line. All three of these fields are individually optional, so lines
containing only a label, only an instruction or only a comment are
valid as indeed are blank lines.

Most instructions in an assembler program correspond to machine opcodes,
but some are {\em directives} which are instructions to the
assembler. In the example above, the instructions {\tt DATA}, {\tt
CODE}, {\tt WORD} and {\tt END} are directives.

\subsection{Assembler output}
The effect of assembling opcodes and executing directives is best seen by
examining the assembler's output. The example source code is available
within the \rdp\ distribution as file \verb+examples/rdp_case/mvmsim.mvm+.
Executing the command
\begin{quote}
\small
\verb+mvmasm -l examples/rdp_case/mvmsim+
\end{quote}
produces the following output listing:
\begin{quote}
\hspace*{-1cm}
\begin{minipage}{30cm}
\footnotesize
\begin{verbatim}
******: 
0000                       1: ;Simulator example file
0000                       2:  DATA 0x000A     ;start assembling data at address 000A hex
000A 0001                  3: temp: WORD 1     ;declare an integer variable called temp
000C                       4: 
000C                       5:  CODE 0x1000     ;switch to assembling code at address 1000 hex
1000                       6: start:
1000 0C01000A007B          7:  CPY temp, #123  ;load temp with decimal 123
1006 10110000000A          8:  PRTI temp       ;print the value of temp as an integer
100C 0011                  9:  HALT            ;terminate the simulator
100E                      10: 
100E *1000                11:  END start       ;transfer address is code start
******: Transfer address 00001000
******: 0 errors and 0 warnings
\end{verbatim}
\end{minipage}
\end{quote}

\subsubsection{Listing format}

This listing shows the familiar line numbered source file listing on the
right, with the assembler generated output on the left. The first field
of the output is the current {\em assembly address}, that is the MVM
memory address to which any data or instructions following on the line
will be loaded. A single space is followed by a string of pairs of
hexadecimal digits representing the assembled output. You will see that
the output is in the same format as the input for the {\tt mvmsim}.


\subsubsection{Assembly using the {\tt DATA} and {\tt CODE} pointers}

Two internal counters are maintained by {\tt mvmasm} called the {\em
current data address} and the {\em current code address}. Their values
are set by the {\tt DATA} and {\tt CODE} directives respectively and
they keep track of the next available data and code memory locations.
Since MVM is a Von Neumann processor, data and code may be loaded at any
memory locations, but it is conventional to separate them into blocks.
Line 2 ({\tt DATA 0x000A}) sets the current data address to hexadecimal
000A and makes the data pointer the current assembly address. All
subsequent instructions will be assembled into succeeding locations
until such time as another {\tt DATA} or {\tt CODE} directive is
encountered. If a {\tt DATA} or {\tt CODE} directive appears on its own
without an operand then it simply switches the current assembly address
to the current data address or current code address respectively.

\subsubsection{Labels}
Labels have the same syntactic form as C language identifiers, that is
an alphabetic character or an underscore followed by zero or more
alpha-numeric characters or underscores. A label definition must be followed by a
colon ({\tt :}). When a label is encountered, it is given the value of
the current assembly address. Whether a label gets the current data address or the
current code address depends upon which of the {\tt DATA} and {\tt CODE} directives was
most recently encountered. Hence, in the above example {\tt temp} is
given the value 000A$_{16}$ (the current data address)
and {\tt start} the value 1000$_{16}$ (the current code address).

\subsubsection{Machine instructions and addressing modes}
Lines 7, 8 and 9 show actual machine instructions being assembled. Each
line comprises one of the operation codes from Table~\ref{MVM:instr}
followed by between zero and three operands. An operand may be either an
address or literal data, which is distinguished by a preceding hash 
\verb+#+ sign. Hence the instruction \verb+CPY temp, #123+ assembles to
{\tt 0B~01~000A~007B} where 000A is the value of the label {\tt temp}
and 007B is the hexadecimal form of the literal decimal constant 
\verb+#123+. As in ANSI-C, hexadecimal numbers are marked by the prefix {\tt
0x}. Numeric values lacking this prefix are assumed to be decimal.

\subsubsection{Data declaration directives}

Data may be declared using the {\tt WORD} directive, which specifies
that enough space be reserved for a machine word (two bytes) and in this
case also provides an initialisation expression so that {\tt temp} is
initialised to 1.  There are other data declaration directives which may
be used to reserve  larger blocks of storage. These other directives are
described below in section~\ref{mvmasm:directives}.

\subsubsection{The {\tt END} directive}
Line 11 shows an {\tt END} directive which both marks the end of the
assembler input file and specifies the transfer address, that is the
address of the first instruction to be executed by the simulator. In
this case, the value of the {\tt start} label, which is 1000$_{16}$.

\subsection{Using the assembler and the simulator together}

The assembler is usually used to prepare input for the {\tt mvmsim}
simulator, and if the assembler is invoked with a {\tt -x} option
then the simulator will be automatically run in trace mode on the assembler
output. Hence issuing this command
\begin{quote}
\verb+mvmasm -l -x examples/rdp_case/mvmsim.mvm+
\end{quote}
produces this output:
\begin{quote}
\hspace*{-1cm}
\begin{minipage}{30cm}
\footnotesize
\begin{verbatim}
******: 
0000                       1: ;Simulator example file
0000                       2:  DATA 0x000A     ;start assembling data at address 000A hex
000A 0001                  3: temp: WORD 1     ;declare an integer variable called temp
000C                       4: 
000C                       5:  CODE 0x1000     ;switch to assembling code at address 1000 hex
1000                       6: start:
1000 0C01000A007B          7:  CPY temp, #123  ;load temp with decimal 123
1006 10110000000A          8:  PRTI temp       ;print the value of temp as an integer
100C 0011                  9:  HALT            ;terminate the simulator
100E                      10: 
100E *1000                11:  END start       ;transfer address is code start
******: Transfer address 00001000
******: Calling simulator: mvmsim -t -v mvmasm.out 

mvmsim v1.5 - simulator for mvm


1000 CPY  000A, 007B, 0000 -> 007B  
1006 PRTI 0000, 007B, 0000 -> 0000  123
100C HALT 0000, 0000, 0000 -> 0000   -- Halted --


0.030 CPU seconds used, 3 MVM instructions executed
******: 0 errors and 0 warnings
\end{verbatim}
\end{minipage}
\end{quote}

\section{Assembler syntax reference}

In this section we describe the features of the {\tt mvmasm}
assembler in terms of the lexical structure, the available arithmetic
operators, the directives and the machine instructions. The
implementation of {\tt mvmasm} as an \rdp\ translator specification is
described in the next section. Large examples of {\tt mvmasm} code
which exercise most of the features may be found in the following chapters,
which describe compilers that translate to {\tt mvmasm}.

\subsection{Line oriented and free format languages}
\label{line:oriented}
The {\tt mvmasm} syntax follows the tradition of assemblers in being
{\em line oriented} with only one statement allowed {\em per} line.
Early high level programming languages were line oriented in this way,
but most programming languages designed since the early 1960's  have
been free format, allowing whitespace and line breaks to appear between
any two language tokens. Low level languages such as assemblers have
tended to retain the older style, not least because it can be simpler to
hand write a parser for a line oriented language. In particular,
error recovery is eased: if a syntax error is detected on a line then
after reporting the error the parser can simply restart at the start of
the next line. The re-synchronisation of the parser after an error in a
free format language can be much harder, and as a result errors in free
format languages can generate an avalanche
of spurious error messages.

\subsection{Lexical elements}

Identifiers in {\tt mvmasm} follow the rules for identifiers in ANSI-C,
that is an identifier may begin with an alphabetic character or an
underscore and continue with zero or more alphabetic characters, digits
or underscores. The length of an identifier is limited only by the
available memory within the running assembler and is for practical
purposes unbounded.

Numbers start with a digit. If the first digit is a zero ({\tt 0}) and this is
immediately followed by a lower or upper case {\tt x} character, then
the rest of the number is assumed to be in hexadecimal format, otherwise
the number is assumed to be decimal. Decimal numbers are made up of the
digits {\tt 0}--{\tt 9}. Hexadecimal numbers can additionally use the letters {\tt A}--{\tt F}
in either upper or lower case to represent hexadecimal 10--15
respectively.

Within a line, space and tab characters may be used to format the
source. Comments are marked by a leading semicolon ({\tt ;}). Any
characters between a semicolon and the end of a line are ignored by the
assembler. A comment may start in any column.

\subsection{Expressions}
In any {\tt mvmasm} context requiring a numeric value, an expression may
be used. Expression operands may be identifiers or numbers as defined
above, or the pre-defined identifiers {\tt TRUE} and {\tt FALSE} which
are synonyms for the values {\tt 1} and {\tt 0} respectively. The full
set of ANSI-C numeric operators is provided, augmented by the operator
{\tt **} which stands for exponentiation. The supported operators, with
their priorities on a scale  of 1 (the lowest) to 11 (the highest)
are listed in Table~\ref{mvmasm:operators}.
Internally, all assembler arithmetic is done with the precision of a {\tt long integer}. 
Most C compilers treat this as a 32-bit integer.

\begin{table}
\begin{center}
\begin{tabular}{|c|c|l|}
\hline
Operator&Priority&Function\\
\hline
\verb+>+&1&Greater than\\
\verb+<+&1&Less than\\
\verb+>=+&1&Greater than or equal to\\
\verb+<=+&1&Less than or equal to\\
\verb+==+&1&Equal to\\
\verb+!=+&1&Not equal to\\
\hline
\verb+||+&2&Logical inclusive OR\\
\hline
\verb+&&+&3&Logical AND\\
\hline
\verb+^+&4&Bitwise exclusive OR\\
\hline
\verb+|+&5&Bitwise inclusive OR\\
\hline
\verb+&+&6&Bitwise AND\\
\hline
\verb+<<+&7&Shift left \\
\verb+>>+&7&Shift right\\
\hline
\verb+++&8&Add\\
\verb+-+&8&Subtract\\
\hline
\verb+*+&9&Divide\\
\verb+/+&9&Multiply\\
\hline
\verb+-+&10&Monadic {\tt -} (negate)\\
\verb-+-&10&Monadic {\tt +} (posite)\\
\verb+~+&10&Bitwise complement\\
\verb+!+&10&Logical not\\
\hline
\verb+**+&11&Exponentiate\\
\hline
\end{tabular}
\end{center}
\caption{Operator priorities in {\tt mvmasm}}
\label{mvmasm:operators}
\end{table}

\subsection{Instructions and addressing modes}
The 17 MVM instructions are assembled using the mnemonics listed in
Table~\ref{MVM:instr}. Operands are separated by commas, and take
the form of an expression as defined above. For source, but not
destination, operands the expression may be preceded by a hash sign (\verb+#+)
denoting literal addressing mode. The hash has no effect on the value
returned by the expression, but sets the addressing mode for the
operand containing the \verb+#+ to literal mode.

The following are all valid instructions:
\begin{quote}
\small
\begin{verbatim}
ADD temp, x, y       ;sum x and y

SUB temp, temp, #1   ;decrement temp by 1
SUB temp, temp, #x   ;decrement temp by the value of x
SUB temp, temp, x    ;decrement temp by the value of the contents 
                     ;of memory location with address x

CPY temp, #(300 + 6) * 2  ;assign 612 to temp

HALT                 ;terminate execution

BEQ temp, start      ;If temp is zero, branch to start otherwise
                     ;continue execution with the next instruction
\end{verbatim}
\end{quote}


\subsection{Directives}
\label{mvmasm:directives}

\subsubsection{File inclusion}
\begin{description}
\item[{\tt INCLUDE ("{\em filename}")}]
--
Open {\em filename} for reading at
this point, continuing to read the parent file after the end of {\em
filename} has been reached. This directive works just like the
\verb+#include+ preprocessor directive in ANSI-C and the \verb+INCLUDE+ directive
in \rdp's IBNF source language.
\end{description}

\subsubsection{Assembly pointer manipulation}
\begin{description}
\item[{\tt CODE {\em optional-expression}}]
--
Use the {\tt CODE} pointer for
subsequent assembly. If the {\em optional-expression} is present, set the {\tt
CODE} pointer to its value, otherwise carry on assembling starting at the most recent value 
of the {\tt CODE} pointer. The {\tt CODE} pointer is initialised to zero when the assembler 
starts.

\item[{\tt DATA {\em optional-expression}}]
--
Use the {\tt DATA} pointer for
subsequent assembly. If the {\em optional-expression} is present, set the {\tt
DATA} pointer to its value, otherwise carry on assembling starting at the most recent value 
of the {\tt DATA} pointer. The {\tt DATA} pointer is initialised to zero when the assembler 
starts.

\end{description}

\subsubsection{Data declaration directives}
\begin{description}

\item[{\tt WORD {\em expression}}]
--
Reserve a word (two bytes) of memory and
initialise the contents to the value of {\em expression}.

\item[{\tt BLOCKW {\em expression}}]
--
Reserve {\em expression} words (2 $\times$
{\em expression} bytes) of memory. No initialisation of the memory is performed.

\item[{\tt STRING "{\em character-string\/}"}]
--
Reserve sufficient bytes to hold
the number of characters in {\em character-string} plus one, and
initialise them to hold the {\em character-string} and a terminating
zero byte.
\end{description}

\subsubsection{Symbol assignment}

\begin{description}
\item[{\tt {\em label}: EQU {\em expression}}]
--
Force the value of {\em label} to
be the value of {\em expression}. This allows symbols to be set to arbitrary values, rather
than the default behaviour which is for symbols to acquire the value of
the assembly pointer at the time they are translated. The following are
legal uses of {\tt EQU}:
\begin{quote}
\small
\begin{verbatim}
large_prime: EQU 131     ;large_prime <- 131

top_bit: EQU 128         ;top_bit <- 128

length: EQU top_bit + 1  ;length <- 129
\end{verbatim}
\end{quote}
\end{description}

\subsubsection{Transfer address specification}

\begin{description}
\item[{\tt END {\em expression}}]
--
Mark the last valid line of the assembler source file and
set the transfer address to the value of {\em expression}. The transfer
address is written into the output file, and is used by the simulator to
specify the address of the first instruction to be executed by the simulator.
\end{description}

\section{Implementing {\tt mvmasm}}

Assembler syntax is designed to be easy to parse, and it  is quite
straightforward to design an assembler completely by hand. However, this
tutorial manual is about \rdp, so we shall use \rdp\ to implement
{\tt mvmasm}. It turns out that two special \rdp\
features are needed to efficiently implement assemblers: support for
multiple passes and support for line oriented languages.

\subsection{Multiple pass parsers}
An interesting aspect of nearly all high level languages is that they
may be translated in a single pass. This requires variables and
functions to be declared before they are used, a rule rigidly enforced
by Pascal and loosely enforced with the help of default behaviour in C. 
In an assembler, however, such a rule would make writing programs very tedious
because of the large number of forward jumps present in real code. A forward jump
has this form:

\begin{quote}
\small
\begin{verbatim}
  BEQ temp, done
  ...
  ...
done:
  ...
\end{verbatim}
\end{quote}

Recall that labels take the value of the current assembly address at the point
of their declaration, so declaring a label before it is used is not
helpful here. On the other hand, the actual value of {\tt
done} will be unknown when the {\tt BEQ} instruction is encountered for
the first time.

There are three solutions to this predicament: we can either ban forward
references; we can use a {\em fixup}; or we can use a multiple pass
assembler. The first option is draconian since it means that only
backward jumps are allowable. Remarkably, the standard assembler for at
least one real computer (the Digico M16 minicomputer, a 16-bit machine
with an architecture similar to that of the 12-bit DEC PDP-8) did indeed
enforce this restriction. This machine assembled from paper tape, and
internal memory was very limited. In addition, the design of the
instruction set meant that forward jumps were less common than on modern
machines so the designers thought that only having to feed the source
papertape through once was a sufficient advantage to justify banning
forward references.

A fixup assembler assembles the source into a buffer in memory. When it
encounters the {\tt BEQ} instruction above, it assumes a value of zero
for the value of the label {\tt done}, but also adds the instruction to
a list of references for {\tt done}. When it subsequently assembles the definition of
{\tt done}, it then knows the correct value and so can go back through
the list for {\tt done} filling in the correct value wherever it has
been used. This approach, called fixing up the forward references, allows assembly to be completed in a single
pass of the source file, but it requires the assembler to maintain an
internal buffer which is as large as the largest possible program that
could be assembled, and in addition a potentially large number of
reference lists. In practice, a fixup based assembler can be rather
complicated and might require a large amount of runtime storage.

By far the most common solution to the problem is to make two or more
passes over the source file. On the first pass, a symbol table is loaded
with the labels and their values as they are encountered. If they are
first seen as an operand, then the corresponding table entry is loaded
with an arbitrary value. By the end of the first pass, however,
definitions will have been seen for all the symbols if the source
program is syntactically well formed. The assembler then repeats the
entire process, but making use of the label information from the first
pass. The success of this approach relies on the fact that all
instructions use a fixed size field to hold symbol values. As a result,
the position of each instruction and data item in memory is fixed during
the first pass, so symbol values will not change as a result of other
symbols changing their value.

Are two passes sufficient? Well, if our only concern is forward
references the two passes are enough, but consider this use of the {\tt
EQU} directive:
\begin{quote}
\small
\begin{verbatim}
first: EQU second + 2
second: EQU third + 3
third: EQU 100
\end{verbatim}
\end{quote}
Here we have a chain of forward references. On pass one,
labels {\tt first} and {\tt second} are to receive the value of
expressions which include unknown data but label {\tt third} will be
correctly set to 100. On pass two label {\tt second} can be correctly
set to 103, but label {\tt first} is still indeterminate, so in this case two passes
is not sufficient. In general, we
need as many passes as there are levels of forward referencing plus one.
Since we can always add another level of forward referencing to a source
file, any fixed number of passes is insufficient. 

In practice, this situation is rather artificial, and real assemblers
typically put an upper limit on the number of passes although it is not
hard to simply keep re-parsing until all the symbols in the symbol table
are determined. The {\tt mvmasm} parser makes three passes, so it can in
fact handle the situation shown above, but no more than two levels of
forward referencing are allowed. As we shall see in a later section,
\rdp\ generated parsers can be set to make multiple passes by adding a
directive of the form {\tt PASSES(3)} to the \rdp\ BNF specification file.

\subsection{The {\tt EOLN} scanner primitive}

As noted in section~\ref{line:oriented} assemblers (and some early
languages like the original FORTRAN) are line oriented, in that a
maximum of one statement {\em per} line of source file is allowed.
The \rdp\ generated parsers that we have looked at previously have been
{\em free format} in that line ends and white space may be introduced
arbitrarily between language tokens so as to format the source file for
human convenience. \rdp\ provides a special scanner primitive denoted by
{\tt EOLN} which matches against the line end marker, and a special
comment primitive \verb+COMMENT_LINE+ which can be used to specify
comments which are introduced by a grammar token and terminated by a
line end. If an \rdp\ grammar does not include any instances of {\tt
EOLN} then line end markers are suppressed and treated as whitespace.

\section{The {\tt mvmasm} grammar}

A listing of {\tt mvmasm.bnf}, the \rdp\ specification for {\tt mvmasm}
is shown in Figures~\ref{mvmasm:bnf1}--\ref{mvmasm:bnf3}. The main body
of the {\tt mvmasm} grammar is shown in Figure~\ref{mvmasm:bnf2}. The
third part of the listing (Figure~\ref{mvmasm:bnf3}) shows a self contained interpreter for
arithmetic expressions based on the C-language operators. This part of
the grammar is a useful starting point for any small language based
around expression evaluation. We shall look at the three parts in turn.

\begin{figure}
\hspace*{-3cm}
\begin{minipage}{30cm}
\footnotesize
\begin{verbatim}
     1: (*******************************************************************************
     2: *
     3: * RDP release 1.50 by Adrian Johnstone (A.Johnstone@rhbnc.ac.uk) 20 December 1997
     4: *
     5: * mvmasm.bnf - an assembler for Mini Virtual Machine assembler language
     6: *
     7: * This file may be freely distributed. Please mail improvements to the author.
     8: *
     9: *******************************************************************************)
    10: TITLE("mvmasm v1.5 - absolute assembler for mvm")
    11: SUFFIX("mvm")
    12: USES("mvm_aux.h")
    13: USES("math.h")
    14: USES("mvm_def.h")
    15: PASSES(3)
    16: PARSER(unit) (* name of start production *)
    17: 
    18: PRE_PARSE([* init(rdp_outputfilename); *])
    19: POST_PARSE([* quit(rdp_outputfilename); *])
    20: 
    21: ARG_BOOLEAN(x execute_sim "execute assembled code using mvmsim simulator")
    22: ARG_BLANK("")
    23: ARG_BLANK("You can contact the author (Adrian Johnstone) at:")
    24: ARG_BLANK("")
    25: ARG_BLANK("Computer Science Department, Royal Holloway, University of London")
    26: ARG_BLANK("Egham, Surrey, TW20 0EX UK. Email: A.Johnstone@rhbnc.ac.uk")
    27: 
    28: SYMBOL_TABLE(mvmasm 101 31
    29:              symbol_compare_string
    30:              symbol_hash_string
    31:              symbol_print_string
    32:              [* char *id;
    33:                 integer val;
    34:              *]
    35:             )
    36: 
    37: unit ::= [* emit_code = (rdp_pass == 3);
    38:             data_location = code_location = 0;  /* clear location counters */
    39:             location = &code_location;          /* make code counter current */
    40:             dummy_label = symbol_new_symbol(sizeof(mvmasm_data));  /* initialise error symbol */
    41:          *]
    42:          { code }.
    43: 
    44: code  ::= [* emit_eoln(); emit_loc(); last_label = NULL; *]
    45:           [label ':'] [instr] [* emit_fill(); *] EOLN.
    46: 
\end{verbatim}
\end{minipage}
\caption{An \rdp\ BNF specification for {\tt mvmasm} part 1: \rdp\
directives and the start production}
\label{mvmasm:bnf1}
\end{figure}
\begin{figure}
\hspace*{-3.5cm}
\begin{minipage}{30cm}
\footnotesize
\begin{verbatim}
    47: label ::= ID:lab
    48:           [* if ((last_label = symbol_lookup_key(mvmasm, &lab, NULL)) == NULL)
    49:                last_label = symbol_insert_key(mvmasm, &lab, sizeof(char*), sizeof(mvmasm_data));
    50:              mvmasm_cast(last_label)->val = *location;
    51:           *].
    52: 
    53: instr   ::= diadic | copy | branch | print | halt | directive.
    54: 
    55: diadic ::= [* int op, m1 = 1, m2 = 1; *]
    56:            (
    57:            'ADD' [* op = OP_ADD; *] e1: dst ',' ['#' [* m1=0; *] ] e1: src1 ',' ['#' [* m2=0; *] ] e1:src2 |
    58:            'SUB' [* op = OP_SUB; *] e1: dst ',' ['#' [* m1=0; *] ] e1: src1 ',' ['#' [* m2=0; *] ] e1:src2 |
    59:            'MUL' [* op = OP_MUL; *] e1: dst ',' ['#' [* m1=0; *] ] e1: src1 ',' ['#' [* m2=0; *] ] e1:src2 |
    60:            'DIV' [* op = OP_DIV; *] e1: dst ',' ['#' [* m1=0; *] ] e1: src1 ',' ['#' [* m2=0; *] ] e1:src2 |
    61:            'EXP' [* op = OP_EXP; *] e1: dst ',' ['#' [* m1=0; *] ] e1: src1 ',' ['#' [* m2=0; *] ] e1:src2 |
    62: 
    63:            'EQ'  [* op = OP_EQ;  *] e1: dst ',' ['#' [* m1=0; *] ] e1: src1 ',' ['#' [* m2=0; *] ] e1:src2 |
    64:            'NE'  [* op = OP_NE;  *] e1: dst ',' ['#' [* m1=0; *] ] e1: src1 ',' ['#' [* m2=0; *] ] e1:src2 |
    65:            'GT'  [* op = OP_GT;  *] e1: dst ',' ['#' [* m1=0; *] ] e1: src1 ',' ['#' [* m2=0; *] ] e1:src2 |
    66:            'GE'  [* op = OP_GE;  *] e1: dst ',' ['#' [* m1=0; *] ] e1: src1 ',' ['#' [* m2=0; *] ] e1:src2 |
    67:            'LT'  [* op = OP_LT;  *] e1: dst ',' ['#' [* m1=0; *] ] e1: src1 ',' ['#' [* m2=0; *] ] e1:src2 |
    68:            'LE'  [* op = OP_LE;  *] e1: dst ',' ['#' [* m1=0; *] ] e1: src1 ',' ['#' [* m2=0; *] ] e1:src2 
    69:            ) [* emit_op(op, dst, src1, src2, m1, m2, 3); *] .
    70: 
    71: copy   ::= [* int m1 = 1; *]
    72:            'CPY' e1: dst ',' ['#' [* m1=0; *] ] e1: src [* emit_op(OP_CPY, dst, src, 0, m1, 1, 2); *] .
    73: 
    74: branch ::= 'BEQ' e1: src ',' e1: label [* emit_op(OP_BEQ, label, src, 0, 1, 1, 2); *] |
    75:            'BNE' e1: src ',' e1: label [* emit_op(OP_BNE, label, src, 0, 1, 1, 2); *] |
    76:            'BRA' e1: label [* emit_op(OP_BEQ, label, 0, 0, 0, 1, 2); /* force immediate mode */ *] .
    77: 
    78: print  ::= [* int m1 = 1; *]
    79:            (
    80:            'PRTS' e1: src [* emit_op(OP_PRTS, 0, src, 0, 0, 1, 2); /* force immediate mode */ *] |
    81:            'PRTI' ['#' [* m1=0; *] ] e1: src [* emit_op(OP_PRTI, 0, src, 0, m1, 1, 2); *]
    82:            ).
    83: 
    84: halt   ::= 'HALT' [* emit_op(OP_HALT, 0, 0, 0, 1, 1, 0); *] .
    85: 
    86: directive  ::= 'INCLUDE' '(' string: filename ')'
    87:                [* if (text_open(filename) == NULL)
    88:                      text_message(TEXT_ERROR_ECHO, "include file '%s' not found\n", filename);
    89:                   else
    90:                   {
    91:                     text_get_char();
    92:                     scan_();
    93:                   }
    94:                *] |
    95: 
    96:                'CODE' [* location = &code_location; *] [ e1:n [* *location = n; *] ] |
    97:                'DATA' [* location = &data_location; *] [ e1:n [* *location = n; *] ] |
    98:                'WORD' e1:val [* emit2(val); *] |
    99:                'BLOCKW' e1:val [* *location += 2 * val; *] |
   100:                'STRING' string:str [* while (*str!=0) emit1(*str++); emit1(0); *] |
   101:                'EQU' e1:val [* mvmasm_cast(current_label())->val = val; *] |
   102:                'END' e1: val [* transfer = val; emit_transfer(); *] .
   103: 
\end{verbatim}
\end{minipage}
\caption{An \rdp\ BNF specification for {\tt mvmasm} part 2: instructions}
\label{mvmasm:bnf2}
\end{figure}
\begin{figure}
\hspace*{-3.5cm}
\begin{minipage}{30cm}
\footnotesize
\begin{verbatim}
   104: (* Expression interpreter using C operators and long int data ***************)
   105: 
   106: e1:integer ::= e2:result ['>'  e2:right [* result = result > right;  *] |  (* Greater than *)
   107:                           '<'  e2:right [* result = result < right;  *] |  (* Less than *)
   108:                           '>=' e2:right [* result = result >= right; *] |  (* Greater than or equal to *)
   109:                           '<=' e2:right [* result = result <= right; *] |  (* Less than or equal to *)
   110:                           '==' e2:right [* result = result == right; *] |  (* Equal to *)
   111:                           '!=' e2:right [* result = result != right; *] ]. (* Not equal to *)
   112: 
   113: e2:integer ::= e3:result {'||' e3:right  [* result = result || right; *]}. (* Logical inclusive OR *)
   114: 
   115: e3:integer ::= e4:result {'&&' e4:right  [* result = result && right; *]}. (* Logical AND *)
   116: 
   117: e4:integer ::= e5:result {'^' e5:right  [* result ^= right; *]}.           (* Bitwise exclusive OR *)
   118: 
   119: e5:integer ::= e6:result {'|' e6:right  [* result |= right; *]}.           (* Bitwise inclusive OR *)
   120: 
   121: e6:integer ::= e7:result {'&' e7:right  [* result &= right; *]}.           (* Bitwise AND *)
   122: 
   123: e7:integer ::= e8:result {'<<' e8:right [* result <<= right; *] |          (* Shift left  *)
   124:                           '>>' e8:right [* result >>= right; *] }.         (* Shift right *)
   125:
   126: e8:integer ::= e9:result {'+' e9:right  [* result += right; *] |           (* Add *)
   127:                           '-' e9:right  [* result -= right; *] }.          (* Subtract *)
   128:
   129: e9:integer ::= e10:result {'*' e10:right  [* result *= right; *] |         (* Divide *)
   131:
   132: e10:integer ::= '+' e10:result |                                           (* Posite *)
   133:                 '-' e10:result [* result = -result; *] |                   (* Negate *)
   134:                 '~' e10:result [* result = ~result; *] |                   (* Bitwise complement *)
   135:                 '!' e10:result [* result = !result; *] |                   (* Logical not *)
   136:                 e11:result.
   137: 
   138: e11:integer ::= e0:result ['**' e10:right [* result = (integer) pow((double) result, (double) right); *]].
   139: 
   140: e0:integer ::= [* mvmasm_data* temp; *]
   141:                ID:name
   142:                [* temp = mvmasm_cast(symbol_lookup_key(mvmasm, &name, NULL));
   143:                   if (temp == NULL)
   144:                   {
   145:                     if (rdp_pass == 3)
   146:                       text_message(TEXT_ERROR_ECHO,"Undefined symbol '%s'\n", name);
   147:                     result = 0;
   148:                   }
   149:                   else
   150:                     result = temp->val;
   151:                *] |                                                        (* Variable *)
   152:                INTEGER:result |                                            (* Numeric literal *)
   153:                'TRUE' [* result = 1; *] |                                  (* Logical TRUE *)
   154:                'FALSE' [* result = 0; *] |                                 (* Logical FALSE *)
   155: 
   156:                '(' e1:result ')'.                                          (* Parenthesised expression *)
   157: 
   158: string: char* ::= STRING_ESC('"' '\\'):result.
   159: 
   160: Comment ::= COMMENT_LINE(';').
\end{verbatim}
\end{minipage}
\caption{An \rdp\ BNF specification for {\tt mvmasm} part 3: expressions}
\label{mvmasm:bnf3}
\end{figure}

\subsection{Directives for setting up the parser}

{\tt mvmasm} source files have default file type {\tt .mvm} as specified
in line 11.  Three header files are used by the grammar:
\verb+mvm_aux.h+ which contains  the function prototypes for the
auxiliary functions described in the next section, \verb+mvm_def.h+ 
which contains an enumeration listing the MVM operation codes (see
Figure~\ref{mvm_def.h}) and the ANSI-C library file \verb+math.h+ which
is used to implement the exponentiation operator.

\subsection{The MVM definition header}

The parser uses three passes to resolve forward references in the way
described above. Output file handling is performed by the {\tt PRE} and
\verb+POST_PARSE+ functions (\verb+init()+ and \verb+quit()+,
respectively) declared on lines~18 and 19. The \verb+-x+ command line
switch is set up using an \verb+ARG_BOOLEAN+ directive in line 21 along
with some other additional information for the help message.
\begin{figure}
\hspace*{-1cm}
\begin{minipage}{30cm}
\footnotesize
\begin{verbatim}
     1: /*******************************************************************************
     2: *
     3: * RDP release 1.50 by Adrian Johnstone (A.Johnstone@rhbnc.ac.uk) 20 December 1997
     4: *
     5: * mvm_def.h - Mini Virtual Machine opcode definitions
     6: *
     7: * This file may be freely distributed. Please mail improvements to the author.
     8: *
     9: *******************************************************************************/
    10: enum opcodes{OP_HALT, OP_ADD, OP_SUB, OP_MUL, OP_DIV, OP_EXP, 
    11:   OP_EQ, OP_NE, OP_GT, OP_GE, OP_LT, OP_LE, 
    12:   OP_CPY, 
    13:   OP_BNE, OP_BEQ, 
    14:   OP_PRTS, OP_PRTI}; 
\end{verbatim}
\end{minipage}
\caption{The MVM opcode definitions}
\label{mvm_def.h}
\end{figure}

{\tt mvmasm} uses a symbol table to keep track of labels and their contents. 
When a label is first declared it is added to the symbol table and given the value
of the assembler's current location counter. However, the {\tt EQU} directive can be
used to assign arbitrary numeric values to labels by evaluating expressions, and label
values may of course be used in those expressions. Thus labels in {\tt mvmasm} perform the
same r\^ole as variables in the {\tt minicalc} interpreter and it is perhaps to be expected
that the symbol table declaration in lines~28--35 is essentially identical to the
symbol table declaration in the {\tt minicalc} and {\tt minicond} grammars. The alphanumeric
label indentifier is stored in the {\tt char*} field {\tt id} and the value of the label
is held in the {\tt val} field.

\subsection{The main {\tt mvmasm} grammar}
The top level rule {\tt unit} accepts zero or more lines of assembler source. {\tt unit} itself
is activated three times, once for each pass over the source. \rdp\ automatically resets
the input at the start of each pass, but some {\tt mvmasm} variables need to be re-initialised
each time as shown in lines~37--40. The boolean flag \verb+emit_code+ is set to
{\sc true} on pass three and is used to control the output to the binary file: code emission
is inhibited on passes one and two when this flag is {\sc false}. Both the data and code
location counters are zeroed, and the code location is set as the default assembly address. 
Finally, \verb+dummy_label+ is initialised to point to a new symbol table record. This record is
used to handle errors involving the {\tt EQU} assembler directive as will be described below.

Each line of assembler source is processed by the {\tt code} rule which can match an 
optional label, an optional instruction and a line end ({\tt EOLN}) primitive. At the start
of each line, an end of line character is sent to the output by calling \verb+emit_eoln()+
followed by the value of current location counter. The global variable \verb+last_label+ is
set to {\tt NULL} to indicate that no label has been seen yet on this line. After processing
the contents of the line the {\tt code} rule calls \verb+emit_fill()+ to pad the binary output 
to column 16. This ensures that the mixed binary/source output listing is properly aligned.

Labels are processed by rule {\tt label}. The string representing the
label's name is returned in attribute {\tt lab} and the semantic action
in lines~48--51 first looks up the label in the symbol table (inserting
it if not already present) before loading the current value of the 
location counter into the symbol's {\tt val} field. It should be clear
that labels may be redefined in {\tt mvmasm}, that is they may appear
more than once in a label field. This is primarily intended to allow
labels to have new values assigned with the {\tt EQU} directive, but it does
mean that a label might  accidentally be used several times within a
code segment and it is hard to imagine a situation where this would not
represent a programming error. The reader might like to consider whether
it would be appropriate to issue a warning message when such a
doubly-declared label is encountered.

Rule {\tt instr} on line~53 splits the handling of instructions into six cases:
the first five handle the five syntactically different classes of MVM instructions 
and the sixth handles the assembler directives. 

The diadic instructions (matched by rule {\tt diadic}) illustrate the
general principles used in all MVM instruction processing. Three local
variables {\tt op}, {\tt m1} and {\tt m2} are used to collect the
operation code and the addressing modes for the two destination
operands. Upon recognition of the opcode {\tt op} is set to the
corresponding member of the {\tt opcodes} enumeration shown in
Figure~\ref{mvm_def.h}. The addressing modes are set to 1 (variable mode
addressing) by default but are set to 0 (constant mode addressing) if
the corresponding operand starts with a \verb+#+ character. The
expression evaluator  (which is described in the next section) is called
for each operand. After the line has been processed the auxiliary
function \verb+emit_op()+ is called to output the binary pattern
corresponding to the instruction.

The other MVM instructions are processed similarly. The eight assembler
directives are handled by rule {\tt directive}. The {\tt INCLUDE}
directive collects a filename and calls \verb+text_open()+ to lookup and
open the file. If the file is not found, \verb+text_open()+ returns {\tt
NULL} and an error message is issued. If the file is successfully 
opened, the text handler and scanner are initialised (lines~91--92).
There is no need to restore the scanner and text handler context when an
included file is closed because the text handler performs
this task automatically.

The {\tt CODE} and {\tt DATA} directives switch the current assembly location to
the code or data pointer respectively. They also optionally take an expression
and update the location accordingly. 

The {\tt WORD}, {\tt BLOCKW} and {\tt STRING} directives allocate storage space for
data. {\tt WORD} takes an expression which is evaluated and emitted directly. The {\tt BLOCKW}
also takes an expression which is then used to update the location counter which has the
effect of reserving a block of storage without initialising it. The {\tt STRING} directive
accepts a double quote delimited string and then emits along with a terminating zero (the ASCII
{\sc nul} character).

The {\tt EQU} directive takes an expression and updates the current label's {\tt val}
field accordingly. The {\tt END} directive marks the end of the assembly unit and specifies
the start address of the unit.

\subsection{The expression evaluator}

The expression evaluator follows the general principles used in the {\tt
minicalc}  interpreter. In {\tt mvmasm} a more complete set of operators
is available than in {\tt minicalc},
corresponding to the complete set of ANSI-C integer operators augmented
with the exponentiation operator {\tt **}. Two literal values have also been added,
{\sc true} and {\sc false}, which yield 1 and 0 respectively. Identifiers are checked
for validity on the final pass (lines 143--150): undefined labels on earlier passes are
simply ignored.

\section{{\tt mvmasm} auxiliary functions}

The {\tt mvmasm} auxiliary functions shown in
Figures~\ref{mvm_aux.c:1}~--\ref{mvm_aux.c:3} perform file handling and
output to the binary object file. Function \verb+emitf()+ 
(lines~34--51) forms the heart of the output routines: it simulates the
behaviour of  the ANSI-C {\tt printf()} output function by accepting a
formatted output string and an arbitrary number of output fields and
then using ANSI-C \verb+vprintf()+ and \verb+vfprintf()+ functions to
format the output. The ANSI-C standard library macros \verb|va_list|, \verb|va_start|
and \verb|va_end| are used to handle the variable number of arguments which \verb|emitf()|
may be passed\dash see any good book on ANSI-C for an explanation of their use.
If the \verb+emit_code+ flag is false, the output is
simply discarded, but if it is true (as it will be on pass 3) then the
output is sent to the  object file. In addition, if text echoing is
enabled with a {\tt -l} command line option (to construct an assembler
listing) then up to the first 16 characters are also echoed to the 
screen.

\begin{figure}
\hspace*{-1cm}
\begin{minipage}{30cm}
\footnotesize
\begin{verbatim}
     1: /*******************************************************************************
     2: *
     3: * RDP release 1.50 by Adrian Johnstone (A.Johnstone@rhbnc.ac.uk) 20 December 1997
     4: *
     5: * mvm_aux.c - Mini Virtual Machine assembler semantic routines
     6: *
     7: * This file may be freely distributed. Please mail improvements to the author.
     8: *
     9: *******************************************************************************/
    10: #include <stdarg.h>
    11: #include <stdio.h>
    12: #include <stdlib.h>
    13: #include "scan.h"
    14: #include "memalloc.h"
    15: #include "textio.h"
    16: #include "mvmasm.h"
    17: #include "mvm_aux.h"
    18: 
    19: int emit_code = 0; 
    20: int execute_sim = 0; 
    21:
    22: static FILE * objfile = NULL; 
    23: 
    24: unsigned long * location; 
    25: unsigned long data_location; 
    26: unsigned long code_location;
    27: unsigned long transfer = 0; 
    28: 
    29: void * last_label = NULL;     /* pointer to most recently seen label */
    30: void * dummy_label = NULL;    /* dummy symbol returned by current label on error */
    31: 
    32: static int emitted = 0;       /* Count of bytes emitted this line */
    33: 
\end{verbatim}
\end{minipage}
\caption{{\tt mvmasm} auxiliary functions part 1: declarations}
\label{mvm_aux.c:1}
\end{figure}
\begin{figure}
\hspace*{-1cm}
\begin{minipage}{30cm}
\footnotesize
\begin{verbatim}
    34: static int emitf(char * fmt, ...) /* conditional print to object file */
    35: {
    36:   int i; 
    37:   va_list ap;                 /* argument list walker */
    38:   
    39:   va_start(ap, fmt); 
    40:
    41:   if (emit_code)              /* no-op if not emitting... */
    42:   {
    43:     if (emitted < 16 && text_get_echo())
    44:       i = vprintf(fmt, ap); 
    45:     vfprintf(objfile, fmt, ap);  /* ... otherwise pass to fprintf() */
    46:   }
    47:   
    48:   va_end(ap); 
    49:   
    50:   return(i);                  /* for completeness, although not used here */
    51: }
    52: 
    53: void emit_eoln(void)
    54: {
    55:   if (emit_code)
    56:     fprintf(objfile, "\n"); 
    57: }
    58: 
    59: void emit_transfer(void)
    60: {
    61:   if (emit_code)
    62:     emitted += emitf("*%.4lX", transfer); 
    63: }
    64: 
    65: void emit_loc(void)
    66: {
    67:   emitted = 0; 
    68:   emitf("%.4lX ", * location); 
    69: }
    70: 
    71: void emit_fill(void)
    72: {
    73:   if (text_get_echo())
    74:   {
    75:     while (emitted++ < 16) printf(" "); 
    76:       printf(" "); 
    77:   }
    78: }
    79: 
    80: void emit_op(int op, unsigned long oper1, unsigned long oper2, unsigned long oper3, 
                     int mode1, int mode2, int opers)
    81: {
    82:   emit1((unsigned long) op);  /* output opcode */
    83:   emit1((unsigned long)((mode1 << 4)| mode2));  /* output addressing modes */
    84:   if (opers > 0)
    85:     emit2(oper1); 
    86:   if (opers > 1)
    87:     emit2(oper2); 
    88:   if (opers > 2)
    89:     emit2(oper3); 
    90: }
    91: 
\end{verbatim}
\end{minipage}
\caption{{\tt mvmasm} auxiliary functions part 2: main output routines}
\label{mvm_aux.c:2}
\end{figure}
\begin{figure}
\hspace*{-1cm}
\begin{minipage}{30cm}
\footnotesize
\begin{verbatim}
    92: void emit1(unsigned long val)
    93: {
    94:   emitted += emitf("%.2lX", val); 
    95:   (* location)++; 
    96: }
    97: 
    98: void emit2(unsigned long val)
    99: {
   100:   emitted += emitf("%.4lX", val); 
   101:   (* location)+= 2; 
   102: }
   103: 
   104: void * current_label(void)    /* check that there is a valid label on this line */
   105: {
   106:   if (last_label == NULL)
   107:   {
   108:     text_message(TEXT_ERROR_ECHO, "Missing label on directive\n"); 
   109:     return & dummy_label; 
   110:   }
   111:   else
   112:     return last_label; 
   113: }
   114: 
   115: void init(char * outputfilename)
   116: {
   117:   if (* outputfilename == '-')
   118:     objfile = stdout; 
   119:   else if ((objfile = fopen(outputfilename, "w"))== NULL)
   120:     text_message(TEXT_FATAL, "Unable to open object file"); 
   121: }
   122:
   123: int quit(char * outputfilename)
   124: {
   125:   fclose(objfile); 
   126:   
   127:   text_message(TEXT_INFO, "Transfer address %.8lX\n", transfer); 
   128:   
   129:   if (execute_sim && * outputfilename != '-')
   130:   {
   131:     #define COMMAND "mvmsim -t -v "
   132:     char * command =(char *) mem_calloc(1, strlen(outputfilename)+ strlen(COMMAND)+ 1); 
   133:     
   134:     command = strcat(command, COMMAND); 
   135:     command = strcat(command, outputfilename); 
   136:     
   137:     text_message(TEXT_INFO, "Calling simulator: %s \n", command); 
   138:     
   139:     if (system(command)!= 0)
   140:       text_message(TEXT_FATAL, "Not enough memory or simulator not found\n"); 
   141:   }
   142:   
   143:   return 0; 
   144: }
\end{verbatim}
\end{minipage}
\caption{{\tt mvmasm} auxiliary functions part 3: housekeeping functions}
\label{mvm_aux.c:3}
\end{figure}

The functions \verb+emit_transfer()+, \verb+emit_loc()+ and \verb+emit_fill()+ call 
\verb+emitf()+ to print the transfer address and the current value of the location
counter and to pad the line with spaces to column 16. 

The \verb+emit1()+ and \verb+emit2()+
functions in lines~92--102 output one and two byte (two and four hexadecimal digit) values
and then update the current assembly location accordingly. They are used by the \verb+emit_op()+
function to output complete MVM instructions. Each instruction comprises an opcode byte and
a mode byte constructed from the two mode fields passed into the function. Between zero
and three 16-bit operands are then output.

Function \verb+current_label()+ (lines~104--113) returns the value of the last label seen.
At the start of each line of assembler source, the parser resets the variable \verb+last_label+ to
{\tt NULL}. This flags the error condition for the {\tt EQU} directive\dash
if no label has been seen an error message is issued and a pointer to \verb+dummy_label+
is returned instead. This is so as to ensure that subsequent assignments to the label fields
of the symbol table record returned by \verb+current_label()+ do not need to check for a {\tt NULL}
pointer.

The {\tt init()} function in lines 115--121 is straightforward: it
simply attempts to open the output file and issues an error message if
the file open fails. The {\tt quit()} function closes the object file
and echoes the transfer address to the screen. If the {\tt -x} command
line option has been used then the flag \verb+execute_sim+ will be true.
Assuming that the object file was not sent to {\tt stdout}, i.e. that a
file containing the object code exists, a command is constructed that
will run the simulator on the object file and then the ANSI-C library
function \verb+system()+ is called to pass control to the simulator.


\chapter{A single pass compiler for {\tt miniloop}} \label{miniloop}
This chapter describes the first of two full compilers for an extended
version of  the {\tt minicond} syntax that provides a {\tt while} loop
and a compound statement delimited by {\tt begin} and {\tt end}
keywords. The compiler works by recognising compilable fragments of the
source code, such as an individual assignment or an arithmetic operation,
and then emitting the corresponding MVM  assembler instruction. The output of
the compiler is a complete assembler program with the same semantics as
the {\tt miniloop} source program, and this can then be assembled using
{\tt mvmasm} and executed using {\tt mvmsim}. 

In this chapter we shall describe the language features added to {\tt
miniloop}, give an example of the compiler's output and then describe
the assembler code patterns that are used to implement the {\tt
miniloop} high level language constructs. We shall then describe in
detail the \rdp\ grammar and auxiliary routines that are used to
implement {\tt miniloop}. In the next chapter we shall describe another
compiler called {\tt minitree} which compiles from the same source
language to the same MVM assembler code as {\tt miniloop}. The
difference between  the two compilers is that {\tt miniloop} emits
assembler code during the parse whereas {\tt minitree} builds an
internal representation of the source program (a modified derivation
tree) and then, in a separate phase, traverses the tree to output the
assembler code. The two compilers are functionally almost identical as
they stand, but {\tt minitree} allows code optimisations such as
rearranging the order of instructions to be performed. Since {\tt
miniloop} is a single pass compiler it cannot perform code re-ordering.

\section{{\tt miniloop} features}

{\tt miniloop} programs look like {\tt minicond} programs with some
additional features\dash the {\tt minicond} and {\tt minicalc} languages
are almost strict subsets of the {\tt miniloop} language so any {\tt
minicalc} or {\tt minicond} program will be correctly handled by the
{\tt miniloop} compiler. The only exception to this rule is that {\tt
miniloop} variable names {\em must not} start with two underscore
characters. This is because {\tt miniloop} generates  internal
identifier names with that form, and we do not want user identifiers and
internal identifiers to clash. Figure~\ref{miniloop:program} shows an
example {\tt miniloop} program. 

The output produced when this is run through the {\tt miniloop} compiler
and then assembled and simulated by {\tt mvmasm} and {\tt mvmsim}, is
shown in Figure~\ref{miniloop:output}. The assembler code produced by
{\tt miniloop} is shown in
Figures~\ref{miniloop:assembler1}--\ref{miniloop:assembler3} and
discussed in section~\ref{miniloop:assembler}.

\begin{figure}
\hspace*{-1cm}
\begin{minipage}{30cm}
\footnotesize
\begin{verbatim}
     1: (*******************************************************************************
     2: *
     3: * RDP release 1.50 by Adrian Johnstone (A.Johnstone@rhbnc.ac.uk) 20 December 1997
     4: *
     5: * testloop.m - a piece of Miniloop source to test the Miniloop compiler
     6: *
     7: * This file may be freely distributed. Please mail improvements to the author.
     8: *
     9: *******************************************************************************)
    10: 
    11: int a=3+4, b=1;
    12: 
    13: print("a is ", a, "\n");
    14: 
    15: b=a*2;
    16: 
    17: print("b is ", b, ", -b is ", -b, "\n");
    18: 
    19: print(a, " cubed is ", a**3, "\n");
    20: 
    21: int z = a;
    22: 
    23: if z==a then print ("z equals a\n") else print("z does not equal a\n");
    24: 
    25: z=a - 3;
    26: 
    27: if z==a then print ("z equals a\n") else print("z does not equal a\n");
    28: 
    29: a = 3;
    30: 
    31: while a > 0 do
    32: begin
    33:   print("a is ", a, "\n");
    34:   a = a - 1
    35: end;
    36: 
    37: (* End of testloop.m *)
\end{verbatim}
\end{minipage}
\caption{An example {\tt miniloop} program ({\tt testloop.m})}
\label{miniloop:program}
\end{figure}

\begin{figure}
\small
\begin{verbatim}
a is 7
b is 14, -b is -14
7 cubed is 343
z equals a
z does not equal a
a is 3
a is 2
a is 1
 -- Halted --
\end{verbatim}
\caption{{\tt mvmsim} output for assembled output from {\tt miniloop} for the example program}
\label{miniloop:output}
\end{figure}

\subsection{The {\tt begin} {\tt end} block (compound statement)} It is
useful to be able to group statements together into blocks so that a
single  {\tt if} statement can control the execution of a list of
statements. In {\tt minicond} only a single statement could be placed
within the {\tt then} or {\tt else} clause of an {\tt if} statement. The
{\tt begin} {\tt end} brackets allow statements to be grouped and
treated as a single, compound, statement. It is worth noting that {\tt
miniloop} is strict about the placement of semicolons which are
statement {\em separators} not statement {\em terminators} as they are
in ANSI-C.  The last statement in a {\tt begin} {\tt end} block cannot
by definition therefore have  a semicolon following it, so it is always
an error to have a semicolon before an {\tt end} statement. This usage
follows that of Pascal and Algol-68 although Pascal does allow an {\em
empty} statement which in most cases allows spurious semicolons to be
accepted.

\subsection{{The \tt while} loop} Lines 31--35 of
Figure~\ref{miniloop:program} illustrate the use of the {\tt while} loop
which is essentially identical to the {\tt while} loop in Pascal. A
relational expression is repeatedly evaluated and the statement after the {\tt do}
keyword is evaluated as long as the expression is {\sc true}.
The statement may be either a simple statement (such as  {\tt print} or
indeed another {\tt while}) or it may be a compound statement, as in the
example.

\section{Arranging data and code in memory} MVM is limited to 64K bytes of
memory because the address fields in the instructions are only 16 bits
long and $2^{16}= 65536 = 64$K. MVM instructions can be executed from
any location and operands can also reside anywhere in memory, but {\tt
miniloop} places code in a single sequence starting at
location $1000_{16}$ and data in a single block starting at location
$8000_{16}$. Within the data block, internal temporary variables created
during the compilation of expressions are placed at the end. This memory
map is shown in Figure~\ref{miniloop:map}.
\begin{figure}
\begin{center}
\input{ml_map.pic}
\end{center}
\caption{MVM memory map for programs compiled by {\tt miniloop}}
\label{miniloop:map}
\end{figure}

We establish this memory map by setting the {\tt CODE} and {\tt DATA} assembly pointers
appropriately. At the start of each program, {\tt miniloop} issues the following assembler
directives:
\begin{quote}
\small
\begin{verbatim}
             DATA 0x8000
__MPP_DATA:
             CODE 0x1000
__MPP_CODE:
\end{verbatim}
\end{quote}

This has the effect of initialising the start address for data assembly
to $8000_{16}$ and setting the label \verb+__MPP_DATA+ to the address of
the first data item, and then initialising the start address for code
assembly to $1000_{16}$ and  setting the label \verb+__MPP_CODE+ to the
address of the first instruction, which will subsequently be used as the
transfer address.

At the end of each program {\tt miniloop} writes out directives of this form:
\begin{quote}
\small
\begin{verbatim}
        DATA
__temp: BLOCKW 9  ;declare array of temporaries

        END __MPP_CODE
\end{verbatim}
\end{quote}
\label{wrapper}
Here assembly is switched to the data region and a block of temporaries
(in this case nine words long) is specified. These form the array of
temporary variables used during expression evaluation (as described in
section~\ref{expressions}) and represented by the region {\em Internal
temporary data} in Figure~\ref{miniloop:map}. Finally, the value of
\verb+__MPP_CODE+ is established as the transfer address by naming it in
an {\tt END} directive.

\section{Compiling declarations}
A declaration in {\tt miniloop} such as
\begin{quote}
\verb+int a;+
\end{quote}
reserves space for one integer in memory and makes the identifier {\tt a} a synonym for
the address of that variable. Whenever the compiler encounters a declaration it switches to 
the {\tt DATA} location and assembles a {\tt WORD} directive:
\begin{quote}
\small
\begin{verbatim}
   DATA
a: WORD 0
\end{verbatim}
\end{quote}
The {\tt WORD} directive reserves one word (two bytes) of memory and initialises them, in
this case to zero.
Following such a declaration we can use the identifier {\tt a} to refer
symbolically to the location holding the contents of the variable {\tt
a} just as we would in the high level source code.

\section{Compiling arithmetic expressions}
\label{expressions}

The parser breaks expressions down into individual operations taking
account of operator priority and associativity as discussed in
Chapter~\ref{minicalc}. Each operation is then compiled into the corresponding
MVM instruction with the destination operand being a temporary variable. A sub-expression
of the form \verb|3 + 4| will be compiled to
\begin{quote}
\small
\begin{verbatim}
   ADD  __temp + 0,#3,#4    ;__temp + 0 := #3 + #4
\end{verbatim}
\end{quote}
The temporary variables do not need to be separately declared in the way
that user variables were handled in the previous section. Instead, the
compiler keeps count of the number of temporaries used and declares them
in a block at the end of the program. The temporaries are always referred to as
\verb|__temp + |$n$ where $n$ is the number of the temporary. This uses the address
calculation capability of the assembler to avoid the need for a large number of 
separate labels.

\section{Compiling {\tt print} statements}
\label{compile:print}
The {\tt print} statement can take an arbitrary number of parameters of either string or
integer type. The MVM instruction set provides two opcodes specifically for printing
strings and integers. 

For an integer parameter, code to evaluate the arithmetic expression is issued which
leaves a value in a temporary variable $t$. The compiler then simply
issues an instruction of the form
\begin{quote}
\verb|PRTI __temp + |$t$\verb|  ;print integer|
\end{quote}
For the case of an expression made up of a single variable, the expression evaluator returns
the name of that variable instead of the name of a temporary, so code of the form
\begin{quote}
\verb|PRTI |$v$\verb|                ;print integer|
\end{quote}
will be issued, where $v$ is the name of the variable.

For a string parameter the compiler outputs code of the form
\begin{quote}
\small
\begin{verbatim}
       DATA
__STR_2: STRING "b is "

       CODE
       PRTS __STR_2
\end{verbatim}
\end{quote}
The string is stored in data space and given a unique label (in this case \verb+__STR_2+). The compiler
then switches back to code space and emits a {\tt PRTS} instruction.

\section{Compiling {\tt if} statements}
An {\tt if-then-else} statement defines three blocks of code: a relational expression,
a {\tt then} block and an {\tt else} block. Figure~\ref{if:statement} illustrates the
code template used by {\tt miniloop} and the allowed forms of
control flow through the construct.
\begin{figure}
\begin{center}
\input{if_stat.pic}
\end{center}
\caption{Flow of control through a compiled {\tt if-then-else} statement}
\label{if:statement}
\end{figure}
{\tt miniloop} maintains an internal label counter which is advanced
each time a new unique label is required. Such labels are needed for
labelling the strings used when assembling {\tt print} statements
containing string parameters and whenever a structured statement (such
as {\tt if-then} or {\tt while-do}) is encountered.  In the case of an
{\tt if-then-else} statement the start of the statement (corresponding
to the first assembler instruction in the compiled version of the
relational expression) is labeled \verb+__IF_+$n$ where $n$ is the
current value of the label counter. $n$ is called the number of the control statement. 
Similarly, the end of the statement is
labeled \verb+__FI_+$n$ and the start of the {\tt else} block is labeled
with \verb+__ELSE_+$n$. 

The relational expression is compiled first, yielding a temporary variable which will contain
a zero if the expression evaluates to {\sc false} and a one otherwise. The compiler then
issues the assembler instruction
\begin{quote}
\verb|BEQ  __temp + |$t$\verb|, __ELSE_|$n$\verb|   ;ifn __temp + |$t$\verb| go to __ELSE_|$n$
\end{quote}
where $t$ is the number of the temporary containing the result of
evaluating the relational expression and $n$ is the number of the
control statement as defined above. This has the effect of jumping to the {\tt else}
block if the condition was false. 

The compiler then emits the code for the {\tt then} block followed by the assembler instruction
\begin{quote}
\verb|BRA  __FI_|$n$\verb|     ;go to __FI_|$n$
\end{quote}
which causes control to flow unconditionally to the end of the {\tt if}
statement. Finally, the compiler emits the \verb|__ELSE_|$n$ label and the
code for the {\tt else} block (which may be empty) finishing off with the \verb+__FI_+$n$
label.

\section{Compiling {\tt while} loops}
A {\tt while-do} statement is similar to an {\tt if-then} statement (with no {\tt else}) clause
which is followed by a jump back to the relational test. There are two blocks of code:
a relational expression,
and the {\tt do} block. Figure~\ref{while:statement} illustrates the
code template used by {\tt miniloop} and the allowable control flow through the construct.
\begin{figure}
\begin{center}
\input{wh_stat.pic}
\end{center}
\caption{Flow of control through a compiled {\tt while-do} statement}
\label{while:statement}
\end{figure}

The compiler emits two labels for each {\tt while-do} loop: one of the form \verb|__DO_|$n$
to mark the start of the statement and one of the form \verb|__OD_|$n$ to mark the end, where
$n$ is the number of the control statement. 

The relational expression is compiled first, yielding a temporary variable which will contain
a zero if the expression evaluates to {\sc false} and a one otherwise. The compiler then
issues the assembler instruction
\begin{quote}
\verb|BEQ  __temp + |$t$\verb|, __OD_|$n$\verb|    ;ifn __temp + |$t$\verb| go to __OD_|$n$ 
\end{quote}
where $t$ is the number of the temporary containing the result of evaluating the relational
expression and $n$ is the number of the control statement. This has the effect of jumping to the
end of the {\tt while-do} if the condition was false. The code for the {\tt do} block is then
emitted followed by the \verb|__OD_|$n$ label.

\section{Typical compiler output}
\label{miniloop:assembler}
Figures~\ref{miniloop:assembler1}--\ref{miniloop:assembler3} show the compiled output for
the test program in Figure~\ref{miniloop:program} which contains instances of all the constructs
described above. In particular, note the setup and wrapup code in lines 3--6 and 137--142,
the declaration in lines 8--9, the arithmetic expression evaluation in line 12 and the assignment
of its result to user variable {\tt a} in line 13, the {\tt if-then-else} statement at 
lines 97--114 and the {\tt while-do} statement at lines 116--135.
\begin{figure}
\hspace*{-1cm}
\begin{minipage}{30cm}
\footnotesize
\begin{verbatim}
0000                       1: ; testloop.mvm - generated from 'testloop.m'
0000                       2: 
0000                       3:  DATA 0x8000
8000                       4: __MPP_DATA:
8000                       5:  CODE 0x1000
1000                       6: __MPP_CODE:
1000                       7:  
1000                       8:  DATA
8000 0001                  9: a: WORD 0
8002                      10: 
8002                      11:  CODE
1000 0100807400030004     12:  ADD  __temp + 0, #3, #4        ;__temp + 0 := #3 + #4
1008 0C1180008074         13:  CPY  a, __temp + 0     ;a := __temp + 0 
100E                      14:  
100E                      15:  DATA
8002 0001                 16: b: WORD 0
8004                      17: 
8004                      18:  CODE
100E 0C0180020001         19:  CPY  b, #1     ;b := #1 
1014                      20: 
1014                      21:  DATA
8004 612069732000         22: __STR_0: STRING "a is "
800A                      23: 
800A                      24:  CODE
1014 0F0100008004         25:  PRTS __STR_0
101A 101100008000         26:  PRTI a ;print integer
1020                      27: 
1020                      28:  DATA
800A 0A00                 29: __STR_1: STRING "\n"
800C                      30: 
800C                      31:  CODE
1020 0F010000800A         32:  PRTS __STR_1
1026 0310807580000002     33:  MUL  __temp + 1, a, #2         ;__temp + 1 := a * #2
102E 0C1180028075         34:  CPY  b, __temp + 1     ;b := __temp + 1 
1034                      35: 
1034                      36:  DATA
800C 622069732000         37: __STR_2: STRING "b is "
8012                      38: 
8012                      39:  CODE
1034 0F010000800C         40:  PRTS __STR_2
103A 101100008002         41:  PRTI b ;print integer
1040                      42: 
1040                      43:  DATA
8012 2C202D6220697320     44: __STR_3: STRING ", -b is "
801B                      45: 
801B                      46:  CODE
1040 0F0100008012         47:  PRTS __STR_3
1046 0211807600008002     48:  SUB  __temp + 2, 0, b  ;__temp + 2 := 0 - b
104E 101100008076         49:  PRTI __temp + 2        ;print integer
1054                      50: 
\end{verbatim}
\end{minipage}
\caption{{\tt miniloop} compiled output for the example program: part 1}
\label{miniloop:assembler1}
\end{figure}
\begin{figure}
\hspace*{-1cm}
\begin{minipage}{30cm}
\footnotesize
\begin{verbatim}
1054                      51:  DATA
801B 0A00                 52: __STR_4: STRING "\n"
801D                      53: 
801D                      54:  CODE
1054 0F010000801B         55:  PRTS __STR_4
105A 101100008000         56:  PRTI a ;print integer
1060                      57: 
1060                      58:  DATA
801D 2063756265642069     59: __STR_5: STRING " cubed is "
8028                      60: 
8028                      61:  CODE
1060 0F010000801D         62:  PRTS __STR_5
1066 0510807780000003     63:  EXP  __temp + 3, a, #3         ;__temp + 3 := a ** #3
106E 101100008077         64:  PRTI __temp + 3        ;print integer
1074                      65: 
1074                      66:  DATA
8028 0A00                 67: __STR_6: STRING "\n"
802A                      68: 
802A                      69:  CODE
1074 0F0100008028         70:  PRTS __STR_6
107A                      71:  
107A                      72:  DATA
802A 0001                 73: z: WORD 0
802C                      74: 
802C                      75:  CODE
107A 0C11802A8000         76:  CPY  z, a      ;z := a 
1080                      77: __IF_7:
1080 06118078802A8000     78:  EQ   __temp + 4, z, a  ;__temp + 4 := z == a
1088 0E11109A8078         79:  BEQ  __temp + 4,__ELSE_7       ;ifn __temp + 4 go to __ELSE_7 
108E                      80: 
108E                      81:  DATA
802C 7A20657175616C73     82: __STR_8: STRING "z equals a\n"
8038                      83: 
8038                      84:  CODE
108E 0F010000802C         85:  PRTS __STR_8
1094 0E0110A00000         86:  BRA  __FI_7    ;go to __FI_7
109A                      87: __ELSE_7:
109A                      88: 
109A                      89:  DATA
8038 7A20646F6573206E     90: __STR_9: STRING "z does not equal a\n"
804C                      91: 
804C                      92:  CODE
109A 0F0100008038         93:  PRTS __STR_9
10A0                      94: __FI_7:
10A0 0210807980000003     95:  SUB  __temp + 5, a, #3         ;__temp + 5 := a - #3
10A8 0C11802A8079         96:  CPY  z, __temp + 5     ;z := __temp + 5 
10AE                      97: __IF_10:
10AE 0611807A802A8000     98:  EQ   __temp + 6, z, a  ;__temp + 6 := z == a
10B6 0E1110C8807A         99:  BEQ  __temp + 6,__ELSE_10      ;ifn __temp + 6 go to __ELSE_10 
10BC                     100: 
\end{verbatim}
\end{minipage}
\caption{{\tt miniloop} compiled output for the example program: part 2}
\label{miniloop:assembler2}
\end{figure}
\begin{figure}
\hspace*{-1cm}
\begin{minipage}{30cm}
\footnotesize
\begin{verbatim}
10BC                     101:  DATA
804C 7A20657175616C73    102: __STR_11: STRING "z equals a\n"
8058                     103: 
8058                     104:  CODE
10BC 0F010000804C        105:  PRTS __STR_11
10C2 0E0110CE0000        106:  BRA  __FI_10   ;go to __FI_10
10C8                     107: __ELSE_10:
10C8                     108: 
10C8                     109:  DATA
8058 7A20646F6573206E    110: __STR_12: STRING "z does not equal a\n"
806C                     111: 
806C                     112:  CODE
10C8 0F0100008058        113:  PRTS __STR_12
10CE                     114: __FI_10:
10CE 0C0180000003        115:  CPY  a, #3     ;a := #3 
10D4                     116: __DO_13:
10D4 0810807B80000000    117:  GT   __temp + 7, a, #0         ;__temp + 7 := a > #0
10DC 0E111108807B        118:  BEQ  __temp + 7,__OD_13        ;ifn __temp + 7 go to __OD_13 
10E2                     119: 
10E2                     120:  DATA
806C 612069732000        121: __STR_14: STRING "a is "
8072                     122: 
8072                     123:  CODE
10E2 0F010000806C        124:  PRTS __STR_14
10E8 101100008000        125:  PRTI a ;print integer
10EE                     126: 
10EE                     127:  DATA
8072 0A00                128: __STR_15: STRING "\n"
8074                     129: 
8074                     130:  CODE
10EE 0F0100008072        131:  PRTS __STR_15
10F4 0210807C80000001    132:  SUB  __temp + 8, a, #1         ;__temp + 8 := a - #1
10FC 0C118000807C        133:  CPY  a, __temp + 8     ;a := __temp + 8 
1102 0E0110D40000        134:  BRA  __DO_13   ;go to __DO_13
1108                     135: __OD_13:
1108                     136: 
1108 0011                137:  HALT
110A                     138: 
110A                     139:  DATA
8074                     140: __temp: BLOCKW 9  ;declare array of temporaries
8086                     141: 
8086 *1000               142:  END __MPP_CODE
\end{verbatim}
\end{minipage}
\caption{{\tt miniloop} compiled output for the example program: part 3}
\label{miniloop:assembler3}
\end{figure}

\section{Implementing {\tt miniloop}}
The {\tt miniloop} compiler makes a single pass over the source file emitting MVM 
instructions as it goes. We shall examine the grammar first and then look at the
auxiliary functions which perform the actual code output.

\subsection{A grammar for {\tt miniloop}} The overall form of the {\tt
miniloop} grammar shown in Figures~\ref{miniloop:bnf1} and
\ref{miniloop:bnf2} is similar to the {\tt minicond} grammar with the
addition of syntax for a {\tt while-do} loop in lines 56--61 and syntax
for the {\tt begin-end} compound statement on line 67. The symbol table
declared in lines 17--22 is used only for keeping track of whether a
variable has been correctly identified and so the symbol table data
specified in line 21 includes only the {\tt id} field\dash there is no
need for an integer data field as there was for the {\tt minicalc} and
{\tt minicond} interpreters. When a variable is declared it is checked
for validity  (line 39--40): {\tt miniloop} variable names must not
begin with a double underscore (\verb|__|) because these might clash
with the internal label names. Lines 44--67 show the statement compiler.
This emits code according to the templates described in the previous
sections.

\begin{figure}
\hspace*{-2.5cm}
\begin{minipage}{30cm}
\footnotesize
\begin{verbatim}
     1: (*******************************************************************************
     2: *
     3: * RDP release 1.50 by Adrian Johnstone (A.Johnstone@rhbnc.ac.uk) 20 December 1997
     4: *
     5: * miniloop.bnf - a decorated mini loop grammar with single pass compiler semantics
     6: *
     7: * This file may be freely distributed. Please mail improvements to the author.
     8: *
     9: *******************************************************************************)
    10: TITLE("Miniloop compiler V1.50 (c) Adrian Johnstone 1997")
    11: SUFFIX("m")
    12: PARSER(program)
    13: USES("ml_aux.h")
    14: TREE
    15: OUTPUT_FILE("miniloop.mvm")
    16: 
    17: SYMBOL_TABLE(mini 101 31
    18:              symbol_compare_string
    19:              symbol_hash_string
    20:              symbol_print_string
    21:              [* char* id; *]
    22:             )
    23: 
    24: check_declared ::= [* if (symbol_lookup_key(mini, &dst, NULL) == NULL)
    25:                       {
    26:                         text_message(TEXT_ERROR, "Undeclared variable '%s'\n", dst);
    27:                         symbol_insert_key(mini, &dst, sizeof(char*), sizeof(mini_data));
    28:                       }
    29:                    *].
    30: 
    31: program   ::=  [* emit_open(rdp_sourcefilename, rdp_outputfilename); *]
    32:                { [var_dec | statement] ';'} 
    33:                [* emit_close(); *].
    34: 
    35: var_dec ::= 'int' ( ID:dst 
    36:                     [* emitf(" \n DATA\n%s: WORD 0\n\n CODE\n",dst); *]
    37:                     ['=' e0:left [* emit("CPY", "", dst, left, NULL); *] ] 
    38:                     [* symbol_insert_key(mini, &dst, sizeof(char*), sizeof(mini_data)); 
    39:                        if (*dst == '_' && *(dst+1) == '_')
    40:        text_message(TEXT_ERROR_ECHO, "variable names must not begin with two underscores\n");
    41:                     *]
    42:                   )@','.                       (* Declaration *)
    43: 
    44: statement ::= ID:dst check_declared
    45:               '=' e0:left [* emit("CPY", "", dst, left, NULL); *] | (* assignment *)
    46: 
    47:               [* integer label = new_label(); *]                    (* if statement *)
    48:               [* emitf("__IF_%lu:\n", label); *]
    49:               'if' e0:left
    50:               [* emitf(" BEQ  %s,__ELSE_%lu\t;ifn %s go to __ELSE_%lu \n",left,label,left, label); *]
    51:               'then' statement
    52:               [* emitf(" BRA  __FI_%lu\t;go to __FI_%lu\n__ELSE_%lu:\n", label, label, label); *]
    53:               [ 'else' statement ]
    54:               [* emitf("__FI_%lu:\n", label); *] |
    55: 
\end{verbatim}
\end{minipage}
\caption{An \rdp\ BNF specification for {\tt miniloop} part 1: statements}
\label{miniloop:bnf1}
\end{figure}
\begin{figure}
\hspace*{-2.5cm}
\footnotesize
\begin{minipage}{30cm}
\begin{verbatim}
    56:               [* integer label = new_label(); *]        (* while do statement *)
    57:               [* emitf("__DO_%lu:\n", label); *]
    58:               'while' e0:left
    59:               [* emitf(" BEQ  %s,__OD_%lu\t;ifn %s go to __OD_%lu \n",left,label,left, label); *]
    60:               'do' statement
    61:               [* emitf(" BRA  __DO_%lu\t;go to __DO_%lu\n__OD_%lu:\n", label, label, label); *] |
    62: 
    63:               'print' '(' ( e0:left [* emit_print('I', left); *] |
    64:                             String:left [* emit_print('S', left); *]
    65:                           )@',' ')' |            (* print statement *)
    66: 
    67:               'begin' (statement)@';' 'end'.  (* compound statement *)
    68: 
    69: e0:char* ::= [* char* dst; *] e1:left [ [* dst = new_temporary(); *]
    70:                ('>' e1:right [* emit("GT ", ">", dst, left, right); *]  |  (* Greater than *)
    71:                 '<' e1:right [* emit("LT ", "<", dst, left, right); *]  |  (* Less than *)
    72:                 '>=' e1:right [* emit("GE ", ">=", dst, left, right); *]|  (* Greater than or equal *)
    73:                 '<=' e1:right [* emit("LE ", ">=", dst, left, right); *]|  (* Less than or equal *)
    74:                 '==' e1:right [* emit("EQ ", "==", dst, left, right); *]|  (* Equal *)
    75:                 '!=' e1:right [* emit("NE ", "!=", dst, left, right); *]   (* Not equal *)
    76:                ) [* left = dst; *]
    77:              ] [* result = left; *].
    78: 
    79: e1:char* ::= [* char* dst; *] e2:left { [* dst = new_temporary(); *]
    80:                ( '+' e2:right [* emit("ADD", "+", dst, left, right); *] |   (* Add *)
    81:                  '-' e2:right [* emit("SUB", "-", dst, left, right); *]     (* Subtract *)
    82:                )
    83:                [* left = dst; *]
    84:              } [* result = left; *].
    85: 
    86: e2:char* ::= [* char* dst; *] e3:left { [* dst = new_temporary(); *]
    87:                ( '*' e3:right [* emit("MUL", "*", dst, left, right); *] |   (* Multiply *)
    88:                  '/' e3:right [* emit("DIV", "/", dst, left, right); *]     (* Divide *)
    89:                )
    90:                [* left = dst; *]
    91:              } [* result = left; *].
    92: 
    93: e3:char* ::= [* int negate = 0; char* dst;*]
    94: 
    95:              {('+'|'-' [* negate ^= 1; *])} e4:result (* Posite or negate *)
    96: [* if (negate) {dst = new_temporary(); emit("SUB", "-", dst, "0", result); result = dst; } *].
    97: 
    98: e4:char* ::= [* char *dst; *]
    99:              e5:left
   100:              [ [* dst = new_temporary(); *]
   101:                '**' e4:right [* emit("EXP", "**", dst, left, right);  *] (* Exponentiate *)
   102:                [* left = dst; *]
   103:              ] [* result = left; *].
   104: 
   105: e5:char* ::= ID:dst check_declared [* result = dst; *] |                 (* Variable access *)
   106:              INTEGER:val [* result = (char*) mem_malloc(12); sprintf(result, "#%lu", val); *] |      
   107:             '(' e1:result ')'.    (* Parenthesised expression *)
   108: 
   109: comment ::= COMMENT_NEST('(*' '*)').  (* Comments: stripped by lexer *)
   110: String:char*  ::= STRING_ESC('"' '\\'):result.     (* Strings for print *)
   111: 
   112: (* End of miniloop.bnf *)
\end{verbatim}
\end{minipage}
\caption{An \rdp\ BNF specification for {\tt miniloop} part 2: expressions}
\label{miniloop:bnf2}
\end{figure}

A significant difference between the {\tt miniloop} grammar and the earlier {\tt minicond}
and {\tt minicalc} grammars is that here the expression rules return {\tt char*} attributes
rather then {\tt integer} ones. In the previous grammars, the expression rules formed an
{\em interpreter} that returned {\tt values}. In {\tt miniloop} the rules return the labels
of locations that will contain the values at run time. Each level of the expression tree has this basic form:
\begin{quote}
\footnotesize
\begin{verbatim}
79: e1:char* ::= [* char* dst; *] e2:left { [* dst = new_temporary(); *]
80:                ( '+' e2:right [* emit("ADD", "+", dst, left, right); *] |  
81:                  '-' e2:right [* emit("SUB", "-", dst, left, right); *]    
82:                )
83:                [* left = dst; *]
84:              } [* result = left; *].
\end{verbatim}
\end{quote}
The auxiliary function \verb+emit()+ outputs one assembler instruction constructed
from the supplied opcode and operand parameters.
The \verb+new_temporary()+ function constructs a string of the form
\verb|__temp + |$n$ where $n$ is the name of the next available temporary variable.
This temporary then becomes the destination operand for the assembler instruction
corresponding to the operator being processed. 

\subsection{{\tt miniloop} auxiliary functions}

The {\tt miniloop} auxiliary functions are shown in
Figures~\ref{ml_aux.c:1} and \ref{ml_aux.c:2}. They perform file handling,
output to the assembler object file and some housekeeping concerned with the
generation of unique labels. Function \verb+emitf()+ 
(lines~24--31) forms the heart of the output routines: it simulates the
behaviour of  the ANSI-C {\tt printf()} output function by accepting a
formatted output string and an arbitrary number of output fields and
then using ANSI-C \verb+vprintf()+ and \verb+vfprintf()+ functions to
format the output. The ANSI-C standard library macros \verb|va_list|, \verb|va_start|
and \verb|va_end| are used to handle the variable number of arguments which \verb|emitf()|
may be passed\dash see any good book on ANSI-C for an explanation of their use.

\begin{figure}
\hspace*{-2cm}
\begin{minipage}{30cm}
\footnotesize
\begin{verbatim}
     1: /*******************************************************************************
     2: *
     3: * RDP release 1.50 by Adrian Johnstone (A.Johnstone@rhbnc.ac.uk) 20 December 1997
     4: *
     5: * ml_aux.c - miniloop one pass compiler semantic routines
     6: *
     7: * This file may be freely distributed. Please mail improvements to the author.
     8: *
     9: *******************************************************************************/
    10: #include <stdarg.h>
    11: #include <stdio.h>
    12: #include <string.h>
    13: #include "textio.h"
    14: #include "memalloc.h"
    15: #include "ml_aux.h"
    16: 
    17: FILE * outfile; 
    18: 
    19: static long unsigned temp_count = 0; 
    20: 
    21: int emitf(const char * fmt, ...)
    22: {
    23:   int i; 
    24:   va_list ap;                 /* argument list walker */
    25:   
    26:   va_start(ap, fmt);          /* pass parameters to vprintf */
    27:   i = vfprintf(outfile, fmt, ap);  /* remember count of characaters printed */
    28:   va_end(ap);                 /* end of var args block */
    29:   
    30:   return i;                   /* return number of characters printed */
    31: }
    32: 
    33: void emit_open(char * sourcefilename, char * outfilename)
    34: {
    35:   if ((outfile = fopen(outfilename, "w"))== NULL)
    36:     text_message(TEXT_FATAL, "unable to open output file \'%s\' for writing\n", outfilename); 
    37:   emitf("; %s - generated from \'%s\'\n\n", outfilename, sourcefilename); 
    38:   emitf(" DATA 0x8000\n__MPP_DATA:\n CODE 0x1000\n__MPP_CODE:\n"); 
    39: }
    40: 
    41: void emit_close(void)
    42: {
    43:   emitf("\n HALT\n\n DATA\n__temp: BLOCKW %lu  ;declare array of temporaries\n\n"
    44:         " END __MPP_CODE\n", temp_count); 
    45:   fclose(outfile); 
    46: }
    47: 
\end{verbatim}
\end{minipage}
\caption{{\tt miniloop} auxiliary functions part 1: low level output}
\label{ml_aux.c:1}
\end{figure}
\begin{figure}
\hspace*{-1cm}
\footnotesize
\begin{minipage}{30cm}
\begin{verbatim}
    48: void emit(char * asm_op, char * alg_op, char * dst, char * src1, char * src2)
    49: {
    50:   emitf(" %s  %s, %s", asm_op, dst, src1); 
    51:   if (src2 != NULL)
    52:     emitf(", %s", src2); 
    53:   
    54:   /* Now output algebraic style */
    55:   emitf(" \t;%s := %s %s", dst, src1, alg_op); 
    56:   if (src2 != NULL)
    57:     emitf(" %s", src2); 
    58:   emitf("\n"); 
    59: }
    60: 
    61: void emit_print(char kind, char * src)
    62: {
    63:   if (kind == 'S')
    64:   {
    65:     unsigned long label = new_label(); 
    66:     
    67:     emitf("\n DATA\n__STR_%lu: STRING \"", label); 
    68:     text_print_C_string_file(outfile, src); 
    69:     emitf("\"\n\n CODE\n PRTS __STR_%lu\n", label); 
    70:   }
    71:   else
    72:   {
    73:     emitf(" PRTI "); 
    74:     text_print_C_string_file(outfile, src); 
    75:     emitf("\t;print integer\n"); 
    76:   }
    77: }
    78: 
    79: char * new_temporary(void)
    80: {
    81:   char * ret =(char *) mem_malloc(30); 
    82:   
    83:   sprintf(ret, "__temp + %lu", temp_count++); 
    84:   
    85:   return ret; 
    86: }
    87: 
    88: unsigned long new_label(void)
    89: {
    90:   static long unsigned label = 0; 
    91:   
    92:   return label++; 
    93: }
    94: 
    95: /* End of ml_aux.c */
\end{verbatim}
\end{minipage}
\caption{{\tt miniloop} auxiliary functions part 2: high level output and housekeeping}
\label{ml_aux.c:2}
\end{figure}
The \verb|emit_open()| and \verb|emit_close()| functions open and close the
output file as well as writing the wrapper code that appears at the start and
end of every compiled program (see section~\ref{wrapper}). The function \verb|emit()|
is used to output a single assembler instruction along with a comment that renders
the operation in an algebraic form to make reading the output easier for those not used
to assembler format. The \verb|emit_print()|
function is a specialised output routine for handling the {\tt print} statement in
{\tt miniloop}. It generates the code templates discussed in section~\ref{compile:print}.
The \verb|new_temporary()| function allocates a block of memory to hold the name of the
temporary and then uses the {\tt sprintf()} function to construct the name.

\chapter{{\tt minitree} -- a multiple pass compiler}
\label{minitree}

Some translation tasks are difficult to perform during a parse, even if
a multi-pass parser is employed. High quality compilers, for instance,
can perform many different code improvement transformations as part of
an optimisation phase. Typically, optimisations work by relating
together widely separated parts of the source text. Take for example,
{\em common sub-expression elimination} which is one of the most
commonly applied optimisations: an assignment between array elements in
ANSI-C such as \begin{quote} \verb+a[i,j] = b[i,j];+ \end{quote}
actually contains two identical calculations if the sizes of the {\tt a}
and {\tt b} arrays are the same. (In detail, {\tt i} must be multiplied
by the width of the array and added to {\tt j}.) A single pass
translator has to process each of these identical calculations in
isolation and so is unlikely to be able to rearrange the calculations
into the equivalent but more efficient form \begin{quote}\verb|temp = (j
* array_width) + i; *(a+temp) = *(b+temp);|\end{quote}

If a multiple pass translator is to be used then it is usual to
construct a data structure  in memory that represents the user program
in a manner which may be efficiently processed.  Simply storing the
original program text is inefficient because discovering a derivation
for an input text is so time consuming: that is after all the primary
function of the parsers that \rdp\ constructs and it would clearly be
wasteful to run the process several times. (Of course, just  because this
is a wasteful process it need not stop us using it where applicable and
\rdp\ provides the {\tt PASSES} directive for precisely this purpose.
Simple multi-pass applications, such as the implementation of a
translator from a machine's assembly language to its machine code, may
usefully exploit this strategy. You can read about the design and
implementation of such an assembler in Chapter~\ref{mvmasm}.)

Leaving aside issues of efficiency, making multiple independent passes
over the source text does not allow us to make connections
between widely separated parts of the text because the parsers generated
by \rdp\ only look at a single symbol at a time: they do not of
themselves keep track of complete sentences or program statements.
However, \rdp\ can be set to build a {\em derivation tree} whilst it
performs a parse. This tree shows explicitly the relationships between symbols in the
source program that are only implicitly present in the original text, and
can be traversed and rearranged efficiently.

This chapter is about a compiler called {\tt minitree} that accepts the
same source language as the {\tt miniloop} compiler described in the
previous chapter and which outputs almost identical MVM assembler code,
but which uses a tree as an internal data structure. During the parse,
the \rdp\ generated {\tt minitree} parser automatically constructs the
intermediate form, and then a \verb|POST_PARSE| function called
\verb|code_generate()| is called which traverses the tree, emitting MVM
instructions as it goes. In principle, optimising phases could be
inserted between the parse phase and the code generation phase that
would rearrange the tree to create more efficient code, although we do
not describe such optimisations here.

We strongly recommend that before proceeding with this chapter you read
Chapters~9 and 10 of the \rdp\ user manual~\cite{rdp:user:1.5} which
describe \rdp's tree generation facilities in detail.

\section{{\tt minitree} intermediate form}
When designing a tree-based compiler, the central decision concerns the information
to be retained in the tree after parsing. One extreme option is to simply use the
entire derivation tree which contains all the terminals matched as well as a node for
every rule instance activated during the parse.

The small programs in Figures~\ref{tree:dec}--\ref{tree:wh} exercise all
of the major syntactic features of {\tt minitree} including declarations
(with and without initialisation); assignment of expressions to
variables; print statements; both {\tt if-then} and {\tt if-then-else}
statements; a {\tt while-do} statement; and a compound {\tt begin-end}
statement. Each program fragment is accompanied by a full derivation
tree and the corresponding reduced derivation tree used as an
intermediate form by {\tt minitree}.

Full derivation trees for a parse grow rapidly with program length:
putting all the  program fragments together into a ten-line program
yields a tree containing 184 nodes. The tree is mostly broad and flat
with long `catkins' hanging off of some nodes. The catkins are generated
by the expression rules: every time an integer or a variable is
referenced the parser must recurse right down to the bottom of the
expression tree giving rise to these long vertical chains. More than a
quarter of the nodes in the derivation tree are of this form, and the
proportion would be even higher if the expression tree had more levels
(that is, if we had more priority levels in the expressions as we do in
the {\tt mvmasm} grammar, for instance). Our reduced derivation trees
typically contain only one quarter of the nodes of a full derivation
tree and yet the original program may be reconstructed from a reduced
derivation tree. In particular, the expression rules no longer generate
`catkins' but are only as deep as they need to be to show the operators
actually used in the source expression.

\begin{figure}
\hspace*{4cm}
\begin{minipage}{10cm}
\begin{verbatim}
     1: int a, 
     2:     b = 3 + 4;
\end{verbatim}
\end{minipage}

\vspace*{1cm}

\hspace*{4cm}
\begin{minipage}{10cm}
\epsfbox{big_dec.ps}
\end{minipage}

\vspace*{1cm}

\hspace*{5cm}
\begin{minipage}{10cm}
\epsfbox{sma_dec.ps}
\end{minipage}

\caption{A {\tt minitree} declaration, its full derivation tree and a reduced derivation tree}
\label{tree:dec}
\end{figure}

\begin{figure}
\hspace*{2cm}
\begin{minipage}{10cm}
\begin{verbatim}
     1: int a, b;
     2:  
     3:  a = (a + b * 3) / 2;
\end{verbatim}
\end{minipage}

\vspace*{1cm}

\hspace*{3cm}
\begin{minipage}{10cm}
\epsfbox{big_exp.ps}
\end{minipage}

\vspace*{1cm}

\hspace*{5cm}
\begin{minipage}{10cm}
\epsfbox{sma_exp.ps}
\end{minipage}

\caption{A {\tt minitree} expression, its full derivation tree and a reduced derivation tree}
\label{tree:exp}
\end{figure}

\begin{figure}
\hspace*{3cm}
\begin{minipage}{10cm}
\begin{verbatim}
     1: int a;
     2: 
     3:  print("a is ", a, "\n");
\end{verbatim}
\end{minipage}

\vspace*{1cm}

\hspace*{2cm}
\begin{minipage}{10cm}
\epsfbox{big_prn.ps}
\end{minipage}

\vspace*{1cm}

\hspace*{5cm}
\begin{minipage}{10cm}
\epsfbox{sma_prn.ps}
\end{minipage}

\caption{A {\tt minitree} {\tt print} statement, its full derivation tree and a reduced derivation tree}
\label{tree:prn}
\end{figure}

\begin{figure}
\hspace*{3cm}
\begin{minipage}{10cm}
\begin{verbatim}
     1: int a,b;
     2: 
     3:  begin 
     4:   a = a + b;
     5:   b = b - 1
     6:  end;
\end{verbatim}
\end{minipage}

\vspace*{1cm}

\hspace*{2cm}
\begin{minipage}{10cm}
\epsfbox{big_cmp.ps}
\end{minipage}

\vspace*{1cm}

\hspace*{5cm}
\begin{minipage}{10cm}
\epsfbox{sma_cmp.ps}
\end{minipage}

\caption{A {\tt minitree} compound statement, its full derivation tree and a reduced derivation tree}
\label{tree:cmp}
\end{figure}

\begin{figure}
\hspace*{2.5cm}
\begin{minipage}{10cm}
\begin{verbatim}
     1: int a = 1, b = 1;
     2: 
     3:  if a == 1 then a = 0;
     4: 
     5:  if a > b then a = 0 else a = 1;
\end{verbatim}
\end{minipage}

\vspace*{1cm}

\hspace*{0cm}
\begin{minipage}{10cm}
\epsfbox{big_if.ps}
\end{minipage}

\vspace*{\fill}

\hspace*{2cm}
\begin{minipage}{10cm}
\epsfbox{sma_if.ps}
\end{minipage}

\caption{A {\tt minitree} {\tt if} statement, its full derivation tree and a reduced derivation tree}
\label{tree:if}
\end{figure}

\begin{figure}
\hspace*{3cm}
\begin{minipage}{10cm}
\begin{verbatim}
     1: int a = 1, b =10;
     2: 
     3:  while a < b do
     4:   begin
     5:    print(a);
     6:    a = a + 1
     7:   end;
\end{verbatim}
\end{minipage}

\vspace*{1cm}

\hspace*{1cm}
\begin{minipage}{10cm}
\epsfbox{big_wh.ps}
\end{minipage}

\vspace*{\fill}

\hspace*{3cm}
\begin{minipage}{10cm}
\epsfbox{sma_wh.ps}
\end{minipage}

\caption{A {\tt minitree} {\tt while} statement, its full derivation tree and a reduced derivation tree}
\label{tree:wh}
\end{figure}

An efficient intermediate form for a compiler should retain all the
information needed to reconstruct the original program {\em but no
more}. Text books on compilers often distinguish between {\em Concrete
Syntax Trees} and {\em Abstract Syntax Trees} (AST's). There is little
agreement on the formal definition of these objects, but broadly
speaking a Concrete Syntax Tree is either a full derivation tree 
or a {\em parse tree} made
up of just the terminal nodes whilst an AST is usually a tree made up of
{\em some} of the terminals.

The reason for the distinction between concrete and abstract forms is that some
terminals in real programming languages are just there to make the
program more readable (so-called `syntactic sugar') and some are only
there to represent the two-dimensional nature of programs. The concrete form includes
all such terminals but they may be dropped in the abstract form.

An example of the first case is the parentheses that appear around the
conditional expression in the ANSI-C {\tt if () else} and {\tt while ()
do} statements: it is perfectly straightforward to write an unambiguous
grammar that does not include these parentheses and in fact the
equivalent Pascal statements do not require them. They are just there to `please the eye'
and may be omitted from the intermediate form.

The second case is represented by the many kinds of brackets used in programming
languages including parentheses in arithmetic expressions, the brackets around array index
expressions and the {\tt begin end} constructs (or {\tt \{ \}} in ANSI-C). These brackets are used
to show the nesting in a program, but any tree form can show nesting naturally in terms of
the parent-child relationships between nodes, so the bracketing terminals are redundant.

The intermediate tree forms used by real compilers tend to be rather
{\em ad hoc}. \rdp\ provides a standardised way to build trees by
applying promotion operators to nodes within the full derivation tree.
The user manual~\cite{rdp:user:1.5} contains examples of standard
approaches to common language features and we have applied these to the
implementation of {\tt minitree}. 

\section{Implementing {\tt minitree}} One of the advantages of a
multi-pass implementation scheme is that it
allows a clean separation between the grammar and the semantics of code
generation. The only semantic actions left in the grammar file {\tt
minitree.bnf} are those that use the symbol table to check that all
variables encountered have been correctly declared. All of the code
generation calls to the various {\tt emit...()} auxiliary functions have
been shifted to the tree walker code. {\tt minitree} uses the same
auxiliary semantic functions as {\tt miniloop} and so needs to be linked
with the functions in \verb|ml_aux.c|. In addition, three extra
functions to handle the tree walking are contained in the auxiliary file
\verb|mt_aux.c|. We shall look at the grammar first, and then the new
auxiliary functions.

\subsection{A grammar for {\tt minitree}}

The starting point for the {\tt minitree} grammar is the {\tt miniloop}
grammar stripped of its semantic actions apart from those associated
with the symbol table. We then add promotion operators to terminals and
nonterminals so as to prune the derivation tree into the forms shown in
Figures~\ref{tree:dec}--\ref{tree:wh}. The first task is to remove nodes
that are pure syntactic sugar such as the semicolon and comma nodes. These are
used to separate items in lists when represented as a linear text, but
within a tree we can simply represent the list items as siblings under a
parent node. Hence, in  line~33 the semicolon node is promoted under its
parent, and thus effectively deleted from the tree. Similarly, in line
46, the parentheses in the {\tt print} statement and the comma
separating the parameters to be printed are deleted.

\begin{figure}
\hspace*{-2cm}
\begin{minipage}{30cm}
\footnotesize
\begin{verbatim}
     1: (*******************************************************************************
     2: *
     3: * RDP release 1.50 by Adrian Johnstone (A.Johnstone@rhbnc.ac.uk) 20 December 1997
     4: *
     5: * minitree.bnf - a mini parser which builds an intermediate form
     6: *
     7: * This file may be freely distributed. Please mail improvements to the author.
     8: *
     9: *******************************************************************************)
    10: TITLE("Minitree compiler V1.50 (c) Adrian Johnstone 1997")
    11: SUFFIX("m")
    12: PARSER(program)
    13: USES("ml_aux.h")
    14: USES("mt_aux.h")
    15: OUTPUT_FILE("minitree.mvm")
    16: TREE
    17: POST_PARSE([* code_generate(rdp_sourcefilename, rdp_outputfilename, rdp_tree); *])
    18: 
    19: SYMBOL_TABLE(mini 101 31
    20:              symbol_compare_string
    21:              symbol_hash_string
    22:              symbol_print_string
    23:              [* char* id; *]
    24:             )
    25: 
    26: check_declared ::= [* if (symbol_lookup_key(mini, &name, NULL) == NULL)
    27:                       {
    28:                         text_message(TEXT_ERROR, "Undeclared variable '%s'\n", name);
    29:                         symbol_insert_key(mini, &name, sizeof(char*), sizeof(mini_data));
    30:                       }
    31:                    *].
    32: 
    33: program   ::=  { [var_dec | statement] ';'^}.
    34: 
    35: var_dec ::= 'int'^^ (dec_body)@','^.
    36: 
    37: dec_body ::= ID:name^^ ['='^ e0 ]:^
    38:              [* symbol_insert_key(mini, &name, sizeof(char*), sizeof(mini_data)); 
    39:                 if (*name == '_' && *(name+1) == '_')
    40: text_message(TEXT_ERROR_ECHO, "variable names must not begin with two underscores\n");
    41:              *].
    42: 
    43: statement ::= ID:name check_declared '='^^ e0  |                   (* assignment *)
    44:               'if'^^ e0 'then'^ statement [ 'else'^ statement ] |  (* if statement *)
    45:               'while'^^ e0 'do'^ statement |                       (* while do statement *)
    46:               'print'^^ '('^ ( e0  | String )@','^ ')'^ |          (* print statement *)
    47:               'begin'^^ (statement)@';'^ 'end'^.                   (* compound statement *)
    48: 
\end{verbatim}
\end{minipage}
\caption{An \rdp\ BNF specification for {\tt minitree} part 1: statements}
\label{minitree.bnf:1}
\end{figure}
\begin{figure}
\hspace*{-0.5cm}
\begin{minipage}{30cm}
\footnotesize
\begin{verbatim}
    49: e0 ::= e1^^ [ '>'^^^ e1  |  (* Greater than *)
    50:               '<'^^^ e1  |  (* Less than *)
    51:               '>='^^^ e1 |  (* Greater than or equal *)
    52:               '<='^^^ e1 |  (* Less than or equal *)
    53:               '=='^^^ e1 |  (* Equal *)
    54:               '!='^^^ e1    (* Not equal *)
    55:             ] .
    56: 
    57: e1 ::= e2^^ { '+'^^^ e2  |  (* Add *)
    58:               '-'^^^ e2     (* Subtract *)
    59:           } .
    60: 
    61: e2 ::= e3^^ { '*'^^^ e3  |  (* Multiply *)
    62:               '/'^^^ e3     (* Divide *)
    63:             } .
    64: 
    65: e3 ::= e4^^ | 
    66:        '+'^ e3  |  (* Posite: note suppression from intermediate form! *)
    67:        '-'^^ e3 .  (* Negate *)
    68:              
    69: 
    70: e4 ::= e5 [ '**'^^ e4 ]:^^.
    71: 
    72: e5 ::= ID:name^^ check_declared | (* Variable access *)
    73:        INTEGER^^  |    (* Numeric literal *)
    74:        '('^ e1^^ ')'^.    (* Parenthesised expression *)
    75: 
    76: comment ::= COMMENT_NEST('(*' '*)').  (* Comments: stripped by lexer *)
    77: String^  ::= STRING_ESC('"' '\\').     (* Strings for print *)
    78: 
    79: (* End of minitree.bnf *)
\end{verbatim}
\end{minipage}
\caption{An \rdp\ BNF specification for {\tt minitree} part 2: expressions}
\label{minitree.bnf:2}
\end{figure}
The {\tt if} and {\tt while} statements also contain sugar nodes that
are deleted: the {\tt if} statement is represented in the tree as a
single {\tt if} node with two or three children, the first being the
expression tree for the relational condition and the second and third
corresponding to the {\tt then} block and the optional {\tt else} block.

The expression tree in lines~49--74 uses the techniques described in the user
manual to build operator trees with the usual priority and associativity
relationships built into their structure. The promote-above operator (\verb|^^^|) is
used to handle the left associative operators and the natural tree ordering ensures
that the operator priorities are correctly implemented. We assume that the tree is
to be traversed in a depth-first, left-to-right manner so that higher priority operators
will appear deeper in the tree.

\section{{\tt minitree} auxiliary functions}

{\tt minitree} makes use of the {\tt miniloop} auxiliary functions described previously 
for handling output to the assembler file and opening and closing the file. You should
refer to the previous chapter for a discussion of these code emission functions. 
The {\tt minitree} auxiliary file \verb|mt_aux.c| shown in Figures~\ref{mt_aux.c:1}--\ref{mt_aux.c:5}
contains three extra functions:
\begin{enumerate}
\item a top level function (\verb|code_generate()| at lines~188--193) that is called as the
\verb|POST_PARSE| function from the grammar,
\item a depth-first, left-to-right tree traversal function that processes expression trees
(\verb|expression_walk()| at lines~20--76), and
\item a depth-first, left-to-right tree traversal function that processes statements and
calls the expression walker where appropriate (\verb|tree_walk()| at lines 78--186).
\end{enumerate}

\begin{figure}
\hspace*{-1cm}
\begin{minipage}{30cm}
\footnotesize
\begin{verbatim}
     1: /*******************************************************************************
     2: *
     3: * RDP release 1.50 by Adrian Johnstone (A.Johnstone@rhbnc.ac.uk) 20 December 1997
     4: *
     5: * mt_aux.c - Minitree multiple pass compiler semantic routines
     6: *
     7: * This file may be freely distributed. Please mail improvements to the author.
     8: *
     9: *******************************************************************************/
    10: #include <stdarg.h>
    11: #include <stdio.h>
    12: #include <string.h>
    13: #include "graph.h"
    14: #include "memalloc.h"
    15: #include "textio.h"
    16: #include "minitree.h"
    17: #include "ml_aux.h"
    18: #include "mt_aux.h"
    19: 
\end{verbatim}
\end{minipage}
\caption{{\tt minitree} auxiliary functions part 1: declarations}
\label{mt_aux.c:1}
\end{figure}
\begin{figure}
\hspace*{-2.5cm}
\footnotesize
\begin{minipage}{30cm}
\begin{verbatim}
    20: char * expression_walk(rdp_tree_data * root)
    21: {
    22:   /* Postorder expression walk */
    23:   if (root->token == SCAN_P_ID)
    24:     return root->id; 
    25:   else if (root->token == SCAN_P_INTEGER)
    26:   {
    27:     char * result =(char *) mem_malloc(12); 
    28:     
    29:     sprintf(result, "#%lu", root->data.u); 
    30:     return result; 
    31:   }
    32:   else
    33:   {
    34:     void * left_edge = graph_get_next_edge(root); 
    35:     void * right_edge = graph_get_next_edge(left_edge); 
    36:     
    37:     char * left = expression_walk((rdp_tree_data *) graph_get_edge_target(left_edge)); 
    38:     
    39:     if (right_edge == NULL)   /* monadic operator */
    40:     {
    41:       char * dst = new_temporary(); 
    42:       
    43:       switch (root->token)
    44:       {
    45:         case RDP_T_26         /* - */ : emit("SUB", "-", dst, "0", left); break; 
    46:         default: 
    47:         text_message(TEXT_FATAL, "unexpected monadic operator found in expression walk: "
    48:         "token number %i, identifier \'%s\'\n", root->token, root->id); 
    49:       }
    50:       return dst; 
    51:     }
    52:     else
    53:     {
    54:       char * right = expression_walk((rdp_tree_data *) graph_get_edge_target(right_edge)); 
    55:       char * dst = new_temporary(); 
    56:       
    57:       switch (root->token)
    58:       {
    59:         case RDP_T_17         /* != */ : emit("NE ", "!=", dst, left, right); break; 
    60:         case RDP_T_22         /* * */ : emit("MUL", "*", dst, left, right); break; 
    61:         case RDP_T_23         /* ** */ : emit("EXP", "**", dst, left, right); break; 
    62:         case RDP_T_24         /* + */ : emit("ADD", "+", dst, left, right); break; 
    63:         case RDP_T_26         /* - */ : emit("SUB", "-", dst, left, right); break; 
    64:         case RDP_T_27         /* / */ : emit("DIV", "/", dst, left, right); break; 
    65:         case RDP_T_29         /* < */ : emit("LT ", "<", dst, left, right); break; 
    66:         case RDP_T_30         /* <= */ : emit("LE ", "<=", dst, left, right); break; 
    67:         case RDP_T_32         /* == */ : emit("EQ ", "==", dst, left, right); break; 
    68:         case RDP_T_33         /* > */ : emit("GT ", ">", dst, left, right); break; 
    69:         case RDP_T_34         /* >= */ : emit("GE ", ">=", dst, left, right); break; 
    70:         default: text_message(TEXT_FATAL, "unexpected diadic operator found in expression walk: "
    71:                               "token number %i, identifier \'%s\'\n", root->token, root->id); 
    72:       }
    73:       return dst; 
    74:     }
    75:   }
    76: }
    77: 
\end{verbatim}
\end{minipage}
\caption{{\tt minitree} auxiliary functions part 2: expression walker}
\label{mt_aux.c:2}
\end{figure}
\begin{figure}
\hspace*{-2.5cm}
\footnotesize
\begin{minipage}{30cm}
\begin{verbatim}
    78: void tree_walk(rdp_tree_data * root)
    79: {
    80:   /* Preorder tree walk */
    81:   if (root == NULL)
    82:     return; 
    83:   else
    84:   {
    85:     void * this_edge = graph_get_next_edge(root); 
    86:     
    87:     switch (root->token)
    88:     {
    89:       case 0:                 /* scan root or begin node's children */
    90:       case RDP_T_begin: 
    91:       {
    92:         void * this_edge = graph_get_next_edge(root); 
    93:         
    94:         while (this_edge != NULL) /* walk children, printing results */
    95:         {
    96:           tree_walk((rdp_tree_data *) graph_get_edge_target(this_edge)); 
    97:           this_edge = graph_get_next_edge(this_edge); 
    98:         }
    99:         break; 
   100:       }
   101:       
   102:       case RDP_T_31           /* = */ : 
   103:       emit("CPY", 
   104:       "", 
   105:       ((rdp_tree_data *) graph_get_edge_target(this_edge))->id, expression_walk(
   106:       (rdp_tree_data *) graph_get_edge_target(graph_get_next_edge(this_edge))), NULL); 
   107:       break; 
   108:       
   109:       case RDP_T_int: 
   110:       {
   111:         void * this_edge = graph_get_next_edge(root); 
   112:         
   113:         while (this_edge != NULL) /* walk children, declaring each variable */
   114:         {
   115:           void * child_edge; 
   116:           rdp_tree_data * this_node =(rdp_tree_data *) graph_get_edge_target(this_edge); 
   117:           
   118:           emitf(" \n DATA\n%s: WORD 1\n\n CODE\n", this_node->id); 
   119:           if ((child_edge = graph_get_next_edge(this_node))!= NULL)
   120:             emit("CPY", "", this_node->id, 
   121:           expression_walk((rdp_tree_data *) graph_get_edge_target(child_edge)), NULL); 
   122:           this_edge = graph_get_next_edge(this_edge); 
   123:         }
   124:         break; 
   125:       }
   126:       
\end{verbatim}
\end{minipage}
\caption{{\tt minitree} auxiliary functions part 3: program, assignment and declaration}
\label{mt_aux.c:3}
\end{figure}
\begin{figure}
\hspace*{-2.5cm}
\footnotesize
\begin{minipage}{30cm}
\begin{verbatim}
   127:       case RDP_T_print: 
   128:       {
   129:         void * this_edge = graph_get_next_edge(root); 
   130:         
   131:         while (this_edge != NULL) /* walk children, printing results */
   132:         {
   133:           rdp_tree_data * this_node =(rdp_tree_data *) graph_get_edge_target(this_edge); 
   134:           
   135:           if (this_node->token == RDP_T_18 /* " */)
   136:             emit_print('S', this_node->id); 
   137:           else
   138:             emit_print('I', expression_walk(this_node)); 
   139:           
   140:           this_edge = graph_get_next_edge(this_edge); 
   141:         }
   142:       }
   143:       break; 
   144:       
   145:       case RDP_T_if: 
   146:       {
   147:         char * relation; 
   148:         rdp_tree_data
   149:         * rel_stat =(rdp_tree_data *) graph_get_edge_target(this_edge), 
   150:         * then_stat =(rdp_tree_data *) graph_get_edge_target(graph_get_next_edge(this_edge)), 
   151:         * else_stat =(rdp_tree_data *) graph_get_edge_target(graph_get_next_edge(
   152:         graph_get_next_edge(this_edge))); 
   153:         
   154:         integer label = new_label(); 
   155:         emitf("__IF_%lu:\n", label); 
   156:         relation = expression_walk(rel_stat); 
   157:         emitf(" BEQ  %s,__ELSE_%lu\t;ifn %s go to __ELSE_%lu \n", relation, label, relation, label); 
   158:         tree_walk(then_stat); 
   159:         emitf(" BRA  __FI_%lu\t;go to __FI_%lu\n__ELSE_%lu:\n", label, label, label); 
   160:         tree_walk(else_stat); 
   161:         emitf("__FI_%lu:\n", label); 
   162:         break; 
   163:       }
   164:       
\end{verbatim}
\end{minipage}
\caption{{\tt minitree} auxiliary functions part 4: {\tt print} and {\tt if}}
\label{mt_aux.c:4}
\end{figure}
\begin{figure}
\hspace*{-2.5cm}
\footnotesize
\begin{minipage}{30cm}
\begin{verbatim}
   165:       case RDP_T_while: 
   166:       {
   167:         char * relation; 
   168:         rdp_tree_data
   169:         * rel_stat =(rdp_tree_data *) graph_get_edge_target(this_edge), 
   170:         * do_stat =(rdp_tree_data *) graph_get_edge_target(graph_get_next_edge(this_edge)); 
   171:         
   172:         integer label = new_label(); 
   173:         emitf("__DO_%lu:\n", label); 
   174:         relation = expression_walk(rel_stat); 
   175:         emitf(" BEQ  %s,__OD_%lu\t;ifn %s go to __OD_%lu \n", relation, label, relation, label); 
   176:         tree_walk(do_stat); 
   177:         emitf(" BRA  __DO_%lu\t;go to __DO_%lu\n__OD_%lu:\n", label, label, label); 
   178:         break; 
   179:       }
   180:       
   181:       default: 
   182:       text_message(TEXT_FATAL, "unexpected tree node found: "
   183:       "token number %i, identifier \'%s\'\n", root->token, root->id); 
   184:     }
   185:   }
   186: }
   187: 
   188: void code_generate(char * source, char * output, void * tree_root)
   189: {
   190:   emit_open(source, output); 
   191:   tree_walk((rdp_tree_data *) graph_get_next_node(tree_root)); 
   192:   emit_close(); 
   193: }
   194: 
   195: /* End of mt_aux.c */
\end{verbatim}
\end{minipage}
\caption{{\tt minitree} auxiliary functions part 5: {\tt while} and {\tt POST\_\,PARSE} function}
\label{mt_aux.c:5}
\end{figure}

The \verb|code_generate()| function is straightforward: it calls the
\verb|emit_open()| and \verb|emit_close()| functions used by {\tt
miniloop} to initialise and close the assembler output file, and between
them the tree walker is called.

\subsection{Use of the graph library}

\rdp's trees are built using the {\tt graph} library which you can read about in the support
library manual~\cite{rdp:supp:1.5}. The base of the tree is held in the global 
variable \verb+rdp_tree+ which is a pointer to the graph header node in the tree. The first
node in the underlying graph is the root of the derivation tree, and the edges emanating
from that node point to the first level children. The function \verb+graph_get_next_edge()+
is used to traverse the edge list, and the function \verb+graph_get_edge_target()+ is used to
retrieve the node pointed to by a particular edge.

\subsection{The tree walker}

The expression walker is recursively called, once for each node in the
expression tree. At each call a {\em subtree} is passed as a parameter,
and the function examines the token  number of the root node in that
subtree. The token numbers comprise either one of the scanner primitives
such as \verb|SCAN_P_ID| (the {\tt ID} primitive) or a keyword from the
{\tt minitree} grammar such as \verb|RDP_T_17| (the \verb|!=| token).
The definitions of the primitives may be found in \verb|rdp_supp/scan.h|
and the definitions of the {\tt minitree} tokens in \verb|minitree.h|.
The expression walker returns at each level the name of the variable
containing the result of the calculation performed at that level in
exactly the same way as the expression rules in {\tt miniloop} transmit the names
of locations back up the tree.

The leaf nodes in an expression must be either {\tt INTEGER} or {\tt ID}
tokens. In these two cases \verb|expression_walk()| simply returns a
string corresponding to the lexeme of the token. Any other nodes will be
operator nodes, and the expression walker will call their children 
before emitting an assembler instruction corresponding to the operator.
The left child is called at line~37. The right child is then examined in
line~39 and if it is {\tt NULL} (empty) then the node must be a monadic
operator so assembler code for the monadic operators (only monadic {\tt
-} in this case) is emitted {\em via} the switch statement at lines~43--49.
For non-monadic operators, the right child is processed and then the switch
statement at lines~57--72 is used to select the assembler instruction corresponding to
the operator. 

The tree walker has this following outline form:
\begin{quote}
\footnotesize
\begin{verbatim}
 78: void tree_walk(rdp_tree_data * root)
 79: {
 80:   /* Preorder tree walk */
 81:   if (root == NULL)
 82:     return; 
 83:   else
 84:   {
 85:     void * this_edge = graph_get_next_edge(root); 
 86:     
 87:     switch (root->token)
 88:     {
 89:       case 0:                 /* scan root or begin node's children */
 90:       case RDP_T_begin: 
 91:       {
 92:         void * this_edge = graph_get_next_edge(root); 
 93:         
 94:         while (this_edge != NULL) /* walk children, printing results */
 95:         {
 96:           tree_walk((rdp_tree_data *) graph_get_edge_target(this_edge)); 
 97:           this_edge = graph_get_next_edge(this_edge); 
 98:         }
 99:         break; 
100:       }

             case ...:
             .
             .
             .
         }
       } 
\end{verbatim}
\end{quote}

The function is designed to be called recursively and at each level to
look at the type of node in the root of the subtree being processed and
act accordingly. The first case, shown here, corresponds to a {\tt
begin} node or the root node of the reduced derivation tree which has
token number 0. {\tt begin} nodes do not of themselves generate any
output code but their children are {\tt minitree} statements that must
be recursively processed, hence in line~96 we see \verb|tree_walk()|
being called on the current node's children.

Five other statements are handled within the tree walker. Assignment
(lines~102--107) emits a {\tt CPY} assembler instruction with the first
child of the root as the destination  operand. The source is obtained by
calling the expression walker on the right child of the root.

Declarations are denoted by a sub-tree with an {\tt INT} root node which
have one or more child nodes containing the names of the variables to be
declared. The {\tt while} loop at lines~113--123 walks the children
outputting a {\tt WORD} assembler directive for each variable labeled
with the name of that variable. The optional initialisation expression
is represented in the tree as an expression sub-tree hanging under the
node containing the name of the variable being declared, so if this tree
is non-null then  the expression walker is called to generate code to
evaluate the initialisation expression.

{\tt print} statements are handled in lines 127--143. The {\tt while}
loop in lines 131--141 walks the children of the {\tt print} node. If
the child is a string (marked with a node type of \verb|RDP_T_18|
corresponding to the \verb|"| token) then \verb|emit_print()| is called
to emit a print string instruction. If not, then the expression walker
is called on the child and \verb|emit_print()| is called to emit a print integer
instruction.

The code to handle {\tt if} and {\tt while} statements is at lines
145--163 and 165--179 respectively. The general format of the code is
exactly the same as for the semantic actions in the {\tt miniloop}
grammar except that the tree walker is called in lines 158, 160 and 176
to generate the code for the {\tt then}, {\tt else} and {\tt do} blocks.

It would be quite straightforward to integrate the expression and
statement walker functions together into a single function. We have
separated them for clarity, but the reader may like to  consider how to
combine them together. Further ideas for projects are given in the final
chapter.


\chapter{A pretty-printer for ANSI-C} 

A pretty-printer is a tool that rearranges the formatting of a program
so as to meet some standard for indentation and comment placement. It
turns out that ANSI-C and its embedded preprocessor present some
difficult challenges in the design of a pretty-printer which we shall
explore in this chapter. The tool described here is called
\verb+pretty_c+ and you can see some examples of its output in
Figures~\ref{pr_c_aux.c:1}--\ref{pr_c_aux.c:4}.

\rdp\ is usually used to specify parsers that describe a language {\em
tightly}, that is the parser should accept inputs that are in the
language and reject inputs that are not. It can be very hard to ensure that a
parser does have this property, and we know that some aspects of
language (such as type checking) are not amenable to specification using
just context-free grammars. In these cases we must use semantic
checks to increase the checking power of the parser.

For our pretty-printer, we look at a radically different approach to
language parsing in which a minimalist \rdp\ grammar is
constructed that will parse all valid ANSI-C programs as well as a large
number of syntactically invalid ones. The rationale here is that an
ANSI-C programmer who wishes to use the pretty-printer will also have
access to an ANSI-C compiler which {\em will} be able to detect
syntactically invalid programs, so we can reasonably assume that the
ANSI-C program presented to the pretty-printer will {\em already} have
been checked for validity. Therefore we can safely use a parser for a
superset of the ANSI-C language and not bother to check every detail.
This allows us to use a very significantly simplified grammar, but the
limitation is that our pretty-printer has to make formatting decisions on the
basis of the current input lexeme and its immediate predecessor. The pretty-printer
never `knows' whether it is inside a function definition or processing global definitions,
for instance, and as a result it cannot vary formatting according to the kind of construct
it is processing.

\section{Using the pretty-printer}

The pretty-printer is built during installation of \rdp\ as a side effect of running the
command {\tt make}. To check whether all is well type
\begin{quote}
\verb+pretty_c+
\end{quote}
and you should receive the following help message:
\begin{quote}
\footnotesize
\begin{verbatim}
Fatal - No source file specified

C pretty-printer V1.50 (c) Adrian Johnstone 1997
Generated on Dec 20 1997 21:55:41 and compiled on Dec 20 1997 at 21:51:16

Usage: pretty_c [options] source[.c]
-f     Filter mode (read from stdin and write to stdout)
-l     Make a listing
-o <s> Write output to filename
-s     Echo each scanner symbol as it is read
-S     Print summary symbol table statistics
-t <n> Tab expansion width (default 8)
-T <n> Text buffer size in bytes for scanner (default 20000)
-v     Set verbose mode
-V <s> (Write derivation tree to filename in VCG format - not available in this parser)

-i <n> Number of spaces per indent level: 0 means use tabs (default 2)
-c <n> Preferred start column for trailing comments (default 30)
\end{verbatim}
\end{quote}
These command line options are described below. Now type
\begin{quote}
\verb+pretty_c test.c+
\end{quote}
The pretty printer will reformat the file {\tt test.c} (which is part of the standard distribution)
and print out
\begin{quote}
\small
\begin{verbatim}
test.c,2133,12267,5.75
\end{verbatim}
\end{quote}
The first field is the name of the file that was formatted, the second is the number of
lines in the file ({\tt 2133}) and the third is the number of language tokens processed
({\tt 12267} in this case). The final field is the average number of tokens per line.


\subsection{Command line options}
The pretty-printer provides the normal \rdp-generated parser command line options along with
the following two pretty-printer specific flags.

\quietsection{{\tt -i} indent spacing} The default indentation spacing is two spaces. 
A larger value makes the indentation clearer (whilst making the lines longer) and some standards
require the use of tab characters to show indentation. A flag of {\tt -i0} will force
\verb+pretty_c+ to use one tab character {\em per} indent. A non-zero value (such as {\tt -i4})
will set the pretty-printer to use that number of spaces {\em per} indent.

\quietsection{{\tt -c} comment start column} The pretty-printer handles
comments specially, as will be described in the next section.
\verb+pretty_c+ attempts to line up comments by moving them across to
the comment start  column, which is column 30 by default. This flag may
be used to change the comment start column.

\subsection{File usage}
\verb+pretty_c+ is a single pass parser which reads the lexemes in the input file
from left to right in the usual way and writes a reformatted version to a temporary
file. By default, this file is called \verb+pretty.c+ but a different temporary file name
can be specified with the \verb+-o+ option. At the end of a successful
run, \verb+pretty_c+ renames the source file to a file with the same name but a filetype
of {\tt .bak} and then renames the temporary file to the original source file name.
It is a fatal error to try to make the temporary output file the same name as the input file
because under some operating systems (such as MS-DOS) the temporary file will overwrite the
input file during processing which results in a corrupted file.

\subsection{Making a listing}
\verb+pretty_c+ can be used to make a line-numbered listing of a program by using the
\verb+-l+ option. However, bear in mind that it is the input file that will be listed, not
the pretty-printed file. If you run the pretty-printer twice on the same file, then a listing generated
on the second run will show the formatted file.

\subsection{Error messages}
Although \verb+pretty_c+ accepts a very loose C grammar it will reject files
that contain invalid C lexemes. In such cases \verb+pretty_c+ issues the usual syntax
error messages. In addition, one of the following three fatal error messages may appear
if \verb+pretty_c+ has difficulty accessing files.

\errorsection{\tt temporary output filename is the same as the source filename}
An output file name that is the same as the source file name has been specified.
It is a fatal error to try and make the temporary output file the same name as the input file
because under some operating systems (such as MS-DOS) the temporary file will overwrite the
input file during processing which results in a corrupted file. Use a different
output file name.

\errorsection{\tt unable to open output file {\em output filename}}
\verb+pretty_c+ was unable to open the temporary output file
 for writing. This may be because there is no disk
space left, or there may already exist a file of that name that
is write protected.

\errorsection{\tt unable to rename {\em filename 1} to {\em filename 2}}
\verb+pretty_c+ was unable to rename the first file to the second file.
This may be because there is no disk
space left, or there may already exist a file called {\em filename 2} that
is write protected.

\section{Pretty-printer features}

The first requirement of a pretty-printer is that it should only modify
the spacing of a program and not change its meaning: a pretty-printer is
an interesting example of a translator whose input and output language
are the same! The particular details of the formatting changes are
essentially a matter of taste. A variety of standards exist for C
formatting, but there is no universal agreement on how a C program
should be indented. We choose to follow the format that \rdp\ uses
for its machine generated parsers. In detail, \verb+pretty_c+ uses the following conventions.
\begin{enumerate}

\item Each line of a program has an {\em indentation level}. The indentation level
of the first line of a program is 0.

\item All of the original spacing in the file to be pretty printed is discarded, 
except for the contents of comments, preprocessor directives and string literals which are preserved.

\item Each output line is preceded by a (possibly zero-length) space,
the length of which is proportional to the indentation level. By
default, each indentation level is represented by two  spaces, but the
user can specify {\em via} the \verb+-i+ command line argument, the use
of a single tab character or an arbitrary non-zero number of space
characters {\em per} indentation level.

\item Some lexemes are output with a preceding {\em inter-token space}.
Diadic operators such as \verb+>>+ or \verb+%+, for instance, are
always surrounded by single  space characters. In detail,
\verb+pretty_c+ classifies each language token into one of 16 {\em
kinds} and maintains a $16\times16$ array of boolean values that specify
whether an ordered pair of language tokens should be separated by a space or not.

\item All line endings are preserved. (Some pretty-printers attempt to
ensure that a blank line is inserted after each block of declarations and in 
some other contexts. \verb+pretty_c+ preserves whatever convention for vertical
spacing already exists in the file to be formatted: the only changes
made are within a line.)

\item An opening brace \verb+{+ increases the indentation level by one, and a closing
brace \verb+}+ decreases the indentation level by one.

\item The keywords \verb+do+, \verb+while+, \verb+for+, \verb+if+,
\verb+else+ and \verb+switch+ are {\em indenting keywords}. The line
after an indenting keyword will have its indentation level increased by
one unless it starts with an open brace \verb+{+. 
Subsequent lines will not be affected and will be indented as they would
have been if the indenting keyword had not been encountered.

\item A comment that starts in the first column is never indented.

\item A comment that does not start in the first column but which is the
first lexeme on a line is indented using the current indentation level for
that line.

\item A comment that is not the first lexeme on a line is reformatted to
begin in the  {\em comment start column}, or two columns to the right of
the previous lexeme, whichever is the least. By default, the comment
start column is column 30, but this may be changed with the \verb+-c+ 
command line option. 
\end{enumerate}


\section{Pretty-printer limitations}

The conventions listed above are a useful start, but it turns out that
there are some sequences of C statements that can result in ugly
formatting. In its present form, \verb+pretty_c+ is good enough for
everyday use (all of the \rdp\ source has been formatted using it, for
instance) but in this section we note a series of special cases that are
handled poorly. In the next chapter  we make some suggestions on how to
extend the tool to cope with some more esoteric constructions.

\subsection{Operators which may be monadic or diadic}
\label{bad:diadic}
Some language tokens serve a dual r\^ole. The \verb+*+ operator, for instance,
is used to denote
multiplication, pointer definition and pointer dereferencing. Ideally we should like
to produce formatted output is the following form:
\begin{quote}
\small
\begin{verbatim}
char *str;
int a;

a = *str * 4;
\end{verbatim}
\end{quote}
Since \verb+pretty_c+ only ever examines the token to be formatted and its immediate 
predecessor it is hard to distinguish between the monadic and diadic uses of \verb+*+. In the
present pretty-printer, \verb+*+ is always treated as a diadic operator with a space on
both sides, resulting in output of the form
\begin{quote}
\small
\begin{verbatim}
char * str;
int a;

a = * str * 4;
\end{verbatim}
\end{quote}

\subsection{Consecutive indenting keywords}
\label{double:indent}
The convention for indenting keywords is that they should cause a temporary indentation
of the following line. This is inadequate for the case of a sequence of indenting keywords
on neighbouring lines. For instance, this piece of code
\begin{quote}
\small
\begin{verbatim}
if (x != 0) 
  do
    y += 3;
  while (y < x); 
\end{verbatim}
\end{quote}
will be reformatted as
\begin{quote}
\small
\begin{verbatim}
if (x != 0) 
  do
  y += 3;
while (y < x); 
\end{verbatim}
\end{quote}
This is because temporary indentations do not accumulate.
\subsection{Continuation lines}
Occasionally, a long expression or function call will be broken over several lines, with
significant horizontal formatting. \verb+pretty_c+ does not preserve this formatting.
Consider
\begin{quote}
\small
\begin{verbatim}
x = 4 +
    long_function_call(first,
                       second,
                       third
                      );
\end{verbatim}
\end{quote}
Ideally we would like \verb+pretty_c+ to recognise that the open parenthesis marks the 
start of a new indentation level, but in fact \verb+pretty_c+ will simply reformat this as
\begin{quote}
\small
\begin{verbatim}
x = 4 +
long_function_call(first,
second,
third
);
\end{verbatim}
\end{quote}
\subsection{Embedded comments}
A comment which is not the first lexeme on a line will be moved to the comment start column,
if possible. This is undesirable if the comment is intended to be embedded within a line.
\begin{quote}
\small
\begin{verbatim}
x = func(3 /* parameter width */, 45, 67);
\end{verbatim}
\end{quote}
will be reformatted as
\begin{quote}
\small
\begin{verbatim}
x = func(3                    /* parameter width */, 45, 67);
\end{verbatim}
\end{quote}

\subsection{Formatting of lexemes}
\label{bad:string}
In one place, \verb+pretty_c+ does not even follow its own conventions:
a string or character literal containing an octal escape sequence such
as  
\begin{quote}
\verb+'\03'+ or \verb"An embedded control \012 character"
\end{quote}
will be output with the numerical escape sequence reformatted to use hexadecimal
notation, as in
\begin{quote}
\verb+'\X03'+ or \verb"An embedded control \X0A character"
\end{quote}
This minor unpleasantness arises from a limitation of the \rdp\ scanner which only returns
the binary version of a string or character literal.

\section{A grammar for a superset of ANSI-C}
Our aim with the grammar for \verb+pretty_c+ is to accept all valid ANSI-C programs, but
we are not limited to accepting {\em only} valid ANSI-C.
The outline form of the grammar is:
\begin{quote}
{\tt program ::= \{} {\em any valid ANSI-C lexeme} {\tt \}.}
\end{quote}

This will be a string of zero or more ANSI-C lexemes in whatever order, including 
sequences that are not syntactically correct ANSI-C, so for instance
\verb+pretty_c+ would accept a `program' of the form 
\begin{quote}
\small
\begin{verbatim}
int main(void)
{
  else 3 do case 16:
}
\end{verbatim}
\end{quote}
which should certainly be rejected by any real C compiler.

The full \verb+pretty_c+ grammar specification is shown in Figures~\ref{pretty_c.bnf:1} and
\ref{pretty_c.bnf:2}.
The top level rule {\tt program} accepts zero or more matches against one of 16 subrules
that between them generate the complete ANSI-C lexicon. Each of the 16 subrules defines a
particular kind of token, and each kind has different spacing conventions\dash all of the diadic
operators, for instance, are defined in rule {\tt diadic}. Rule {\tt program} receives (in
the synthesized attribute {\tt lexeme}) the string of characters matched by the scanner, and a local
attribute {\tt kind} is assigned one member of the {\em kind} enumeration which is defined in the
auxiliary file \verb+pr_c_aux.h+ shown in Figure~\ref{pr_c_aux.h}. Rule {\tt program} also
includes calls to the auxiliary functions \verb+pretty_open()+ and \verb+pretty_close()+ that
control the file handling.


\begin{figure}
\hspace*{-2cm}
\begin{minipage}{30cm}
\footnotesize
\begin{verbatim}
     1: (*******************************************************************************
     2: *
     3: * RDP release 1.50 by Adrian Johnstone (A.Johnstone@rhbnc.ac.uk) 20 December 1997
     4: *
     5: * pretty_c.bnf - a pretty-printer for ANSI-C
     6: *
     7: * This file may be freely distributed. Please mail improvements to the author.
     8: *
     9: * This grammar illustrates a rather different approach to writing language
    10: * parsers. Instead of trying to exactly define the language with the
    11: * grammar we try and find a simple grammar that accepts the language, and
    12: * also allow it to accept lots of incorrect strings. The rationale is that
    13: * a pretty-printer does not need to check a program for syntax errors
    14: * because a conventional compiler will be used subsequently to do that.
    15: * As a result we end up with a very flat, loose grammar
    16: *
    17: *******************************************************************************)
    18: TITLE("C pretty-printer V1.50 (c) Adrian Johnstone 1997")
    19: SUFFIX("c")
    20: PARSER(program)
    21: OUTPUT_FILE("pretty.c")
    22: TEXT_SIZE(100_000)
    23: USES("pr_c_aux.h")
    24: 
    25: ARG_NUMERIC(i indent_size "Number of spaces per indent level: 0 means use tabs (default 2)")
    26: ARG_NUMERIC(c comment_start "Preferred start column for trailing comments (default 30)")
    27: 
    28: program ::= [* enum kinds kind;
    29:                long unsigned line, column;
    30:                pretty_open(rdp_sourcefilename, rdp_outputfilename);
    31:             *]
    32:             {
    33:               [* line = scan_line_number(); column = scan_column_number(); *]
    34:               (
    35:                 comment: lexeme        [* kind = K_COMMENT;        *] |
    36:                 string: lexeme         [* kind = K_STRING;         *] |
    37:                 character: lexeme      [* kind = K_CHARACTER;      *] |
    38:                 block_open: lexeme     [* kind = K_BLOCK_OPEN;     *] |
    39:                 block_close: lexeme    [* kind = K_BLOCK_CLOSE;    *] |
    40:                 preprocessor: lexeme   [* kind = K_PREPROCESSOR;   *] |
    41:                 monadic: lexeme        [* kind = K_MONADIC;        *] |
    42:                 diadic: lexeme         [* kind = K_DIADIC;         *] |
    43:                 open_bracket: lexeme   [* kind = K_OPEN_BRACKET;   *] |
    44:                 close_bracket: lexeme  [* kind = K_CLOSE_BRACKET;  *] |
    45:                 item: lexeme           [* kind = K_ITEM;           *] |
    46:                 field_delim: lexeme    [* kind = K_FIELD_DELIM;    *] |
    47:                 punctuation: lexeme    [* kind = K_PUNCTUATION;    *] |
    48:                 keyword: lexeme        [* kind = K_KEYWORD;        *] |
    49:                 keyword_indent: lexeme [* kind = K_KEYWORD_INDENT; *] |
    50:                 EOLN: lexeme           [* kind = K_EOLN;           *]
    51:               )
    52:               [* pretty_print(lexeme, kind, column, line); *]
    53:             }
    54:             [* pretty_close(rdp_sourcefilename, rdp_outputfilename); *].
    55: 
\end{verbatim}
\end{minipage}
\caption{\rdp\ grammar for pretty-printer: part 1}
\label{pretty_c.bnf:1}
\end{figure}
\begin{figure}
\hspace*{-1cm}
\begin{minipage}{30cm}
\footnotesize
\begin{verbatim}
    56: comment: char* ::= COMMENT_VISIBLE('/*' '*/'):result.
    57: 
    58: preprocessor: char* ::= COMMENT_LINE_VISIBLE('#'):result.
    59: 
    60: monadic: char* ::= '!':result | '++':result | '--':result | '~':result .
    61: 
    62: diadic: char* ::= '&&':result | '&':result | '^':result | '|':result |
    63:                   '||':result | '%':result | '*':result | '/':result |
    64:                   '+':result | '-':result | '<<':result | '>>':result |
    65:                   '<':result | '<=':result | '==':result | '>':result |
    66:                   '>=':result | '?':result | '!=':result | '%=':result |
    67:                   '&=':result | '*=':result | '+=':result | '-=':result |
    68:                   '/=':result | '=':result | '^=':result | '|=':result |
    69:                   '<<=':result | '>>=':result | '\\':result.
    70: 
    71: block_open: char* ::= '{':result.
    72: 
    73: block_close: char* ::= '}':result.
    74: 
    75: open_bracket: char* ::= '(':result | '[':result.
    76: 
    77: close_bracket: char* ::= ')':result | ']':result.
    78: 
    79: item: char* ::= ([* result = SCAN_CAST->id; *] (INTEGER | REAL)) |
    80:                 ID:result | '...':result .
    81: 
    82: string: char* ::= STRING_ESC('"''\\'):result.
    83: 
    84: character:char* ::= STRING_ESC('\'''\\'): result.
    85: 
    86: field_delim: char* ::= '->':result | '.':result.
    87: 
    88: punctuation: char* ::= ':':result | ';':result | ',': result.
    89: 
    90: keyword: char* ::= 'auto':result | 'break':result | 'case':result |
    91:                    'char':result | 'const':result | 'continue':result |
    92:                    'default':result | 'double':result | 'enum':result |
    93:                    'extern':result | 'float':result | 'goto':result |
    94:                    'int':result | 'long':result | 'register':result |
    95:                    'return':result | 'short':result | 'signed':result |
    96:                    'sizeof':result | 'static':result | 'struct':result |
    97:                    'union':result | 'unsigned':result | 'void':result |
    98:                    'volatile':result.
    99: 
   100: keyword_indent: char* ::= 'do':result | 'else':result | 'for':result |
   101:                           'if':result | 'switch':result | 'while':result.
\end{verbatim}
\end{minipage}
\caption{\rdp\ grammar for pretty-printer: part 2}
\label{pretty_c.bnf:2}
\end{figure}

There are two cases where the string returned in {\tt lexeme} is not necessarily the
actual string matched by the scanner. In the case of both character and string literals
(defined in lines 82 and 84) the scanner will process embedded escape sequences to produce
a string which may contain binary characters. This is the source of the restriction noted in
section~\ref{bad:string} in which octal escape sequences will be rewritten as hexadecimal escape
sequences on output: the scanner does not preserve information on whether a particular escape
sequence was octal or hexadecimal so we have arbitrarily decided to output them all as
hexadecimal.

Comments in \rdp\ generated parsers are usually defined using one of the `invisible' 
comment scanner primitives and quietly suppressed by the scanner. In this application, of
course, we wish to pass comments from the parser into the pretty printer (otherwise the
comments would be removed from the formatted output!) As a result, comments are defined in
line 56 using the \verb+COMMENT_VISIBLE+ primitive.

Preprocessor directives in ANSI-C present the pretty printer with particular problems.
Unusually for a high level language, spacing is critical in preprocessor definitions. These
two commands have quite different meanings:
\begin{quote}
\small
\begin{verbatim}
#define a(b) b=3;

#define a (b) b=3;
\end{verbatim}
\end{quote}
The first defines a macro called {\tt a} with a parameter {\tt b} which has 3 assigned
to it in the body of the macro.
The second defines a parameterless macro {\tt a} which expands to the string \verb+(b) b=3;+.
The absence or presence of the space between the macro name and the opening parenthesis
is used to decided whether a macro has parameters or not. This is an immediate problem for the
\rdp\ scanner because spaces are discarded and must be reconstructed from the token stream.
It {\em would} be possible to do this by keeping track of the column numbers for the
tokens immediately after a \verb+#define+ token, but fortunately for us there is a simpler
solution. In the C preprocessor, no line endings are allowed within preprocessor directives. As
a result we can make use of the \rdp\ scanner's \verb+COMMENT_LINE_VISIBLE+ primitive
to define a `comment' that opens with the token \verb+#+ and closes with the line end. This
will cause the complete preprocessor directive to be handled in the parser as a single
monolithic unit, just like a comment. In this way the spacing is preserved. Of course, a 
side effect of this is that preprocessor lines will never be `prettified', but given
the subtleties of parsing preprocessor directives this conservative design decision is
perhaps justified.

The lexeme and its associated {\tt kind} value are passed to the auxiliary function
\verb+pretty_print()+ in line 52 along with the line and column numbers for the token.
This function will be described in the next section: we simply note here that the lexeme
will be printed (possibly with a preceding space) to the output file, and that line end
tokens will be followed by a string of spaces corresponding to the indentation level.

\section{Auxiliary routines}

The auxiliary functions and the {\em kind} enumeration are defined in
the auxiliary header file \verb+pr_c_aux.h+ shown in
Figure~\ref{pr_c_aux.h}. The two externally visible variables,
\verb+indent_size+ and \verb+comment_start+ receive the values of the
{\tt -i} and {\tt -c} command line arguments. The {\em kind} enumeration
has 17 values: the first 16 correspond to the 16 subrules in the
\verb+pretty_c+ grammar and the last one \verb+K_TOP+ is a dummy value
that is set to the number of subrules.

\begin{figure}
\hspace*{-2cm}
\begin{minipage}{30cm}
\footnotesize
\begin{verbatim}
     1: /****************************************************************************
     2: *
     3: * RDP release 1.50 by Adrian Johnstone (A.Johnstone@rhbnc.ac.uk) 20 December 1997
     4: *
     5: * pr_c_aux.h - pretty-printer semantic routines
     6: *
     7: * This file may be freely distributed. Please mail improvements to the author.
     8: *
     9: ****************************************************************************/
    10: enum kinds
    11: {
    12:   K_BLOCK_CLOSE, K_BLOCK_OPEN, K_CHARACTER, K_CLOSE_BRACKET, K_COMMENT, 
    13:   K_DIADIC, K_EOLN, K_FIELD_DELIM, K_KEYWORD, K_KEYWORD_INDENT, K_ITEM, 
    14:   K_MONADIC, K_OPEN_BRACKET, K_PREPROCESSOR, K_PUNCTUATION, K_STRING, K_TOP
    15: }; 
    16: 
    17: extern unsigned long indent_size; 
    18: extern unsigned long comment_start; 
    19: 
    20: void pretty_close(char * sourcefilename, char * outputfilename); 
    21: void pretty_open(char * sourcefilename, char * outputfilename); 
    22: void pretty_print(char * lexeme, enum kinds kind, unsigned long column, unsigned long line); 
    23: 
    24: /* End of pr_c_aux.h */
\end{verbatim}
\end{minipage}
\caption{Pretty-printer auxiliary functions: header file}
\label{pr_c_aux.h}
\end{figure}


The source code for the three auxiliary functions is shown in
Figures~\ref{pr_c_aux.c:1}--\ref{pr_c_aux.c:4}. The data declarations
are in Figure~\ref{pr_c_aux.c:1} and include variables to keep count of
the number of line endings seen, the number of lexemes seen and the
number of comments. We also remember the value of the last reported line
number. This may be different to the number of line endings seen because
a comment that spans a line ending will be parsed as a single comment
lexeme, and so some line endings may be hidden.

The file handling routines \verb+pretty_open()+ and
\verb+pretty_close()+ are shown in Figure~\ref{pr_c_aux.c:2} and are
straightforward.

\begin{figure}
\hspace*{-1cm}
\begin{minipage}{30cm}
\footnotesize
\begin{verbatim}
     1: /*******************************************************************************
     2: *
     3: * RDP release 1.50 by Adrian Johnstone (A.Johnstone@rhbnc.ac.uk) 20 December 1997
     4: *
     5: * pr_c_aux.c - pretty printer semantic routines
     6: *
     7: * This file may be freely distributed. Please mail improvements to the author.
     8: *
     9: *******************************************************************************/
    10: #include <stdio.h>
    11: #include "scan.h"
    12: #include "textio.h"
    13: #include "pr_c_aux.h"
    14: 
    15: static int lexeme_count = 0; 
    16: static int eoln_count = 0; 
    17: static int comment_count = 0; 
    18: static int last_line = 1; 
    19: static FILE * outputfile; 
    20: unsigned long indent_size = 2l; 
    21: unsigned long comment_start = 30l; 
    22: 
    23: 
    24: static int space_table[K_TOP][K_TOP]= {
    25: /*                                               K
    26:                                C                 E
    27:                                L                 Y        O  P
    28:                       B        O           F     W        P  R  P
    29:                       L  B     S           I     O        E  E  U
    30:                       O  L  C  E           E     R        N  P  N
    31:                       C  O  H  _           L     D        _  R  C
    32:                       K  C  A  B  C        D  K  _     M  B  O  T
    33:                       _  K  R  R  O  D     _  E  I     O  R  C  U  S
    34:                       C  _  A  A  M  I     D  Y  N     N  A  E  A  T
    35:                       L  O  C  C  M  A  E  E  W  D  I  A  C  S  T  R
    36:                       O  P  T  K  E  D  O  L  O  E  T  D  K  S  I  I
    37:                       S  E  E  E  N  I  L  I  R  N  E  I  E  O  O  N
    38:                       E  N  R  T  T  C  N  M  D  T  M  C  T  R  N  G
    39:                       ---------------------------------------------- */
    40: /* BLOCK_CLOSE    */ {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0}, 
    41: /* BLOCK_OPEN     */ {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
    42: /* CHARACTER      */ {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
    43: /* CLOSE_BRACKET  */ {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0}, 
    44: /* COMMENT        */ {1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1}, 
    45: /* DIADIC         */ {1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1}, 
    46: /* EOLN           */ {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
    47: /* FIELD_DELIM    */ {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
    48: /* KEYWORD        */ {0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0}, 
    49: /* KEYWORD_INDENT */ {0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0}, 
    50: /* ITEM           */ {0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1}, 
    51: /* MONADIC        */ {1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1}, 
    52: /* OPEN_BRACKET   */ {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
    53: /* PREPROCSSOR    */ {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1}, 
    54: /* PUNCTUATION    */ {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}, 
    55: /* STRING         */ {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1}
    56: }; 
    57: 
\end{verbatim}
\end{minipage}
\caption{Pretty-printer auxiliary functions: part 1}
\label{pr_c_aux.c:1}
\end{figure}

\subsection{The space array}

The $16\times16$ array of booleans \verb+space_array+ is used by the
pretty printer to decide whether a space should precede the current
lexeme before it is output. The \verb+pretty_print()+ function remembers
in a static variable the {\em token kind} of last lexeme seen, so at each
stage it has access to the token kinds of the previous and current lexemes. Line 129 uses
the space array to check whether a space should be output:
\begin{quote}
\footnotesize
\begin{verbatim}
129:   if (space_table[last_kind][kind]) /* insert space if necessary */
130:     printed += fprintf(outputfile, " "); 
\end{verbatim}
\end{quote}
Here we see that if there is a one at position (last, current) of the space array then 
a preceding space will be output. Line 54, for instance, specifies that a space shall always 
be output if the last kind was punctuation (such as a comma or semicolon). This effectively
inserts a space after every punctuation character.

This lookup table mechanism is very flexible and almost sufficiently powerful 
but it does suffer from some limitations. In particular, it is not easy
to decide whether a {\tt *} token is a diadic multiplication or a
monadic pointer dereference operator, especially in contexts such as
\verb+mytype *temp;+ where {\tt mytype} is a user defined type definition
that has been created using a {\tt typedef} statement. To be able to
handle such cases we would need to keep track of all {\tt typedef}
statements which would require a much more detailed grammar. In fact, we
would have to implement a complete C preprocessor to perform this
task perfectly because it is conceivable that the user defined type
\verb+mytype+ had been defined in a macro or in an included file.
\verb+pretty_c+ simply ignores these complications and always treats
{\tt *} (and for that matter {\tt \&}) as a diadic operator with spaces
on both sides. This is the source of the restrictions described in
section~\ref{bad:diadic}.

\begin{figure}
\hspace*{-2.5cm}
\begin{minipage}{30cm}
\footnotesize
\begin{verbatim}
    58: void pretty_open(char * sourcefilename, char * outputfilename)
    59: {
    60:   if (strcmp(sourcefilename, outputfilename)== 0)
    61:     text_message(TEXT_FATAL, "temporary output filename is the same as the source filename"); 
    62:   
    63:   if (* outputfilename == '-')
    64:     outputfile = stdout; 
    65:   else if ((outputfile = fopen(outputfilename, "w"))== NULL)
    66:     text_message(TEXT_FATAL, "unable to open output file \'%s\'", outputfilename); 
    67: }
    68: 
    69: void pretty_close(char * sourcefilename, char * outputfilename)
    70: {
    71:   unsigned long useful_lexeme_count = lexeme_count - comment_count - eoln_count; 
    72:   char * backup_filename = text_force_filetype(sourcefilename, "bak"); 
    73:   
    74:   fclose(outputfile); 
    75:   
    76:   remove(backup_filename); 
    77:   
    78:   if (rename(sourcefilename, backup_filename)!= 0)
    79:     text_message(TEXT_FATAL, "unable to rename \'%s\' to \'%s\'\n", sourcefilename, backup_filename); 
    80:   
    81:   if (rename(outputfilename, sourcefilename)!= 0)
    82:     text_message(TEXT_FATAL, "unable to rename \'%s\' to \'%s\'\n", outputfilename, sourcefilename); 
    83:   
    84:   text_printf("%s,%lu,%lu,%.2lf\n", sourcefilename, 
    85:   last_line, 
    86:   useful_lexeme_count, 
    87:   (double) useful_lexeme_count /(double) last_line); 
    88: }
    89: 
\end{verbatim}
\end{minipage}
\caption{Pretty-printer auxiliary functions: part 2}
\label{pr_c_aux.c:2}
\end{figure}

\begin{figure}
\hspace*{-2.5cm}
\begin{minipage}{30cm}
\footnotesize
\begin{verbatim}
    90: void pretty_print(char * lexeme, enum kinds kind, unsigned long column, unsigned long line)
    91: {
    92:   static int last_kind = K_EOLN; 
    93:   static int indentation = 0; 
    94:   static int temporary_indent = 0; 
    95:   static int printed = 0; 
    96:   
    97:   lexeme_count++;             /* bump lexeme counter for statistics */
    98:   last_line = line;           /* remember the highest line number seen */
    99:   
   100:   if (kind == K_BLOCK_CLOSE)
   101:     indentation--; 
   102:   else if (last_kind == K_BLOCK_OPEN)
   103:     indentation++; 
   104:   
   105:   if (last_kind == K_EOLN)    /* do indentation */
   106:   {
   107:     int indent_count, space_count; 
   108:     
   109:     if (temporary_indent && kind != K_BLOCK_OPEN) /* add an indent of we aren't opening a block */
   110:       indentation++; 
   111:     
   112:     for (indent_count = 0; indent_count < indentation; indent_count++)
   113:       if (!((column == 1)&&(kind == K_COMMENT))) /* Don't indent comments that start in column 1 */
   114:       if (indent_size == 0)
   115:     {
   116:       fprintf(outputfile, "\t");  /* indent using a tab */
   117:       printed += text_get_tab_width(); 
   118:     }
   119:     else
   120:       for (space_count = 0; space_count < indent_size; space_count++)
   121:       printed += fprintf(outputfile, " "); 
   122:     
   123:     if (temporary_indent && kind != K_BLOCK_OPEN) /* reset temporary indent */
   124:       indentation--; 
   125:     
   126:     temporary_indent = 0; 
   127:   }
   128:   
   129:   if (space_table[last_kind][kind]) /* insert space if necessary */
   130:     printed += fprintf(outputfile, " "); 
   131:   
\end{verbatim}
\end{minipage}
\caption{Pretty-printer auxiliary functions: part 3}
\label{pr_c_aux.c:3}
\end{figure}

\begin{figure}
\hspace*{-1.5cm}
\begin{minipage}{30cm}
\footnotesize
\begin{verbatim}
   132:   /* Print the lexeme: some kinds need special actions */
   133:   switch (kind)
   134:   {
   135:     case K_EOLN: 
   136:     fprintf(outputfile, "\n"); 
   137:     eoln_count++; 
   138:     printed = 0; 
   139:     break; 
   140:     
   141:     case K_COMMENT: 
   142:     comment_count++; 
   143:     if (last_kind != K_EOLN)  /* comments that aren't first on a line move to middle */
   144:       do
   145:       printed += fprintf(outputfile, " "); 
   146:     while (printed < comment_start); 
   147:       
   148:     printed += fprintf(outputfile, "/*%s*/", lexeme); 
   149:     break; 
   150:     
   151:     case K_STRING: 
   152:     printed += fprintf(outputfile, "\""); 
   153:     printed += text_print_C_string_file(outputfile, lexeme); 
   154:     printed += fprintf(outputfile, "\""); 
   155:     break; 
   156:     
   157:     case K_CHARACTER: 
   158:     printed += fprintf(outputfile, "\'"); 
   159:     printed += text_print_C_char_file(outputfile, lexeme); 
   160:     printed += fprintf(outputfile, "\'"); 
   161:     break; 
   162:     
   163:     case K_PREPROCESSOR: 
   164:     printed += fprintf(outputfile, "#%s", lexeme); 
   165:     break; 
   166:     
   167:     default: 
   168:     printed += fprintf(outputfile, "%s", lexeme); 
   169:     break; 
   170:   }
   171:   
   172:   if (kind == K_KEYWORD_INDENT) /* Set an indent for next line */
   173:     temporary_indent = 1; 
   174:   
   175:   last_kind = kind; 
   176: }
   177: /* End of pr_c_aux.c */
\end{verbatim}
\end{minipage}
\caption{Pretty-printer auxiliary functions: part 4}
\label{pr_c_aux.c:4}
\end{figure}

\subsection{The pretty-print function}
The pretty-print function is called after each lexeme read by the parser. It is defined in
Figures~\ref{pr_c_aux.c:3} and \ref{pr_c_aux.c:4}, lines 90--176. The internal state of
the pretty printer is maintained between calls in four static integer variables:
\begin{enumerate}
\item \verb+last_kind+ contains the token kind of the lexeme processed on the previous
call to \verb+pretty_print()+,
\item \verb+indentation+ contains the current indentation level,
\item \verb+temporary_indent+ is a boolean flag that is set after an indenting keyword
such as {\tt if} or {\tt while} is seen, and 
\item \verb+printed+ contains the number of characters output since the last new line character,
or (equivalently) the current output column number.
\end{enumerate}

In lines 97 and 98 the global variables \verb+lexeme_count+ and
\verb+last_line+ are updated. These variables are used within function
\verb+pretty_close+ to output the number of lines, number of lexemes and
the average lexeme {\em per} line count at the end of a run.

The indentation of lines is performed by the code in lines 105-127,
which is only executed if the last token seen was a new line so as to
ensure that indentation is only performed at the beginning of a line. 
Lines 109-110 temporarily increment the indentation level if the
\verb+temporary_indent+ flag is set and we are not processing a new
block. Any temporary increment is reset  in lines 123--124. 

Line 113 detects comments that start in column 1 and suppresses their
indentation. Lines 114--121 output tab characters or groups of spaces
according to the value of the \verb+indent_size+ variable that is set
using the {\tt -i} command line option. In each case, the {\tt printed}
variable is updated to show the column number after printing. The routine
\verb+text_get_tab_width()+ is used to get the current value of the tab
setting as set using the {\tt -t} command line option. Incidentally, note the ugly layout
of this code which is a manifestation of the problem described in section~\ref{double:indent}.

The space table is accessed in lines 129--130 to control the output of a space
character before the current lexeme is printed. You may dislike the spacing convention used
here (some people like a space after an opening parenthesis and a space before a 
closing parenthesis, for instance) in which case you should
experiment with modifications to the space table.

The lexemes are printed out under the control of the {\tt switch} statement at lines
133--170. Most token kinds receive the {\tt default} treatment of being simply
printed out. However the following token kinds require special treatment:
\begin{enumerate}
\item \verb+K_EOLN+ must be output as a newline character, and the \verb+eoln_count+ and
\verb+printed+ variables must be updated at the same time,
\item \verb+K_COMMENT+ lexemes do not contain the delimiting \verb+/*+ and \verb+*/+ brackets
so these must be reinstated on output, and the comment must be placed as
near to the comment start column as possible,
\item \verb+K_STRING+ and \verb+K_CHARACTER+
lexemes do not contain the delimiting quote marks
so these must be reinstated on output, and
\item \verb+K_PREPROCESSOR+ lexemes do not contain the delimiting \verb+#+ token, so this
must be inserted before output of the body of the preprocessor command.
\end{enumerate}

The final actions of the pretty-print function are to set a temporary indent if an 
indentable keyword has been output and to update the \verb+last_kind+ variable ready for the next
invocation.

\chapter{Design projects}

In this chapter we list suggestions for enhancements to the {\tt mini}
languages described in earlier chapters that might reasonably be
undertaken as exercises, as well as a larger project to build a subset C
compiler. 

\begin{enumerate}
\item Add block definition to {\tt minicond} (hint: follow the syntax in {\tt miniloop.bnf}).

\item Add left and right shift operators to {\tt minicalc} and its descendent languages.

\item Add logical operators to {\tt minicalc} and its descendent languages.

\item Add real arithmetic {\tt minicalc} and its descendent languages.

\item Add a switch statement to {\tt minicond} and {\tt miniloop}.

\item Add a for loop to {\tt miniloop}.

\item Add a goto statement to {\tt miniloop}.

\item Add function definition and call to {\tt miniloop}.

\item Implement common mode subexpression elimination for {\tt minitree}.

\item Add registers to MVM and a simple register allocator to {\tt minitree}.

\item Add a graph colouring register allocator to {\tt minitree}.

\item Add conditional assembly to {\tt mvmasm}.

\item Add macro definition and call to {\tt mvmasm}.

\item Implement a subset C compiler with \rdp.

This is an ambitious project which could build into a complete compiler
for C targeted at a virtual machine of the MVM form. The suggestions
here form a coherent path through the tasks but an experienced language
implementor would probably coalesce some of the intermediate stages
together.

\begin{enumerate}

\item Define a language for the target machine. The MVM assembly
language used in this manual is suitable as a basic language and has the
advantage that an assembler and a simulator already exist for that
language. An extremely ambitious choice would be to use the language of a real
processor, although this is only recommended for readers that are very
familiar with programming the chosen processor.

\item Define a tree-like intermediate data structure to represent the
result of parsing the source program. The student can either decide to
build this structure using actions embedded in the parser specification
or use the automatic tree building capability of \rdp.

\item Define a subset of C. A simple subset might correspond to a
version of C that only allows integer operations, has no pointers, no
user-defined types and no capability to define functions. Control
structures might also be restricted: a simple {\tt if-then-else}
statement  and a {\tt while-do} statement would suffice in the first
instance.

\item Write an \rdp\ specification that parses the chosen subset
language and test it against a set of test examples illustrating both
correct and incorrect usage.

\item Enhance the \rdp\ specification using either explicit semantic
actions or the \rdp\ tree operators to build the intermediate form.

\item Write a \verb+POST_PARSE+ function that traverses the intermediate
form emitting instructions for the target processor.

\item Demonstrate correct compilation and execution of test programs
using simulation or by direct execution on the target architecture.

\item Add a full complement of C control structures, including {\tt switch, break, goto} and
{\tt for}.
\item Add support for floating point arithmetic.
\item Add support for function definition.
\item Add support for user defined type definition.
\item Add support for pointers.
\item Implement common subexpression elimination.
\item Implement register allocation using graph colouring.
\end{enumerate}
\end{enumerate}

\input{rdp_inst.tex}

\bibliographystyle{alpha}
\bibliography{adrian}

\end{document}

