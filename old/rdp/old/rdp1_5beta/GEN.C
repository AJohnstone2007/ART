/****************************************************************************
*
* Parser generated by RDP on Oct 24 1996 14:20:20 from GEN.bnf
*
****************************************************************************/
#include <time.h>
#include "arg.h"
#include "graph.h"
#include "memalloc.h"
#include "scan.h"
#include "set.h"
#include "symbol.h"
#include "textio.h"
#include "gen.h"

char
 *rdp_sourcefilename = NULL,   /* source file name */
 *rdp_outputfilename = "gen.out";         /* output file name */

int
  rdp_symbol_echo = 0,                 /* symbol echo flag */
  rdp_verbose = 0,                     /* verbosity flag */
  rdp_pass;                            /* pass number */

int rdp_error_return = 0;              /* return value for main routine */

char *rdp_tokens = "IGNORE\0" 
"ID\0" "INTEGER\0" "REAL\0" "CHAR\0" "CHAR_ESC\0" "STRING\0" "STRING_ESC\0" "COMMENT\0" 
"COMMENT_VISIBLE\0" "COMMENT_NEST\0" "COMMENT_NEST_VISIBLE\0" "COMMENT_LINE\0" "COMMENT_LINE_VISIBLE\0" "KEYWORD\0" "EOF\0" "EOLN\0" 
"'\''\0" "'.'\0" "':'\0" "'::'\0" "'::='\0" "'|'\0" ;

generate_data * generate_temp = NULL;
void* generate = NULL;

/* Load keywords */
static void rdp_load_keywords(void)
{
  scan_load_keyword("\'", NULL, RDP_T_17 /* ' */, SCAN_P_STRING);
  scan_load_keyword(".", NULL, RDP_T_18 /* . */, SCAN_P_IGNORE);
  scan_load_keyword(":", NULL, RDP_T_19 /* : */, SCAN_P_IGNORE);
  scan_load_keyword("::", NULL, RDP_T_20 /* :: */, SCAN_P_IGNORE);
  scan_load_keyword("::=", NULL, RDP_T_21 /* ::= */, SCAN_P_IGNORE);
  scan_load_keyword("|", NULL, RDP_T_22 /* | */, SCAN_P_IGNORE);
}

/* Set declarations */

  set_ production_first = SET_NULL;
  set_ production_stop = SET_NULL;
  set_ rdp_production_2_first = SET_NULL;
  set_ rdp_production_3_first = SET_NULL;
  set_ rule_stop = SET_NULL;
  set_ ruleName_stop = SET_NULL;
  set_ terminal_stop = SET_NULL;
  set_ text_stop = SET_NULL;

/* Initialise sets */

static void rdp_set_initialise(void)
{
  set_assign_list(&production_first, SCAN_P_ID, RDP_T_17 /* ' */, SET_END);
  set_assign_list(&production_stop, SCAN_P_EOF, RDP_T_18 /* . */, RDP_T_22 /* | */,SET_END);
  set_assign_list(&rdp_production_2_first, SCAN_P_ID, RDP_T_17 /* ' */, SET_END);
  set_assign_list(&rdp_production_3_first, SCAN_P_ID, RDP_T_17 /* ' */, SET_END);
  set_assign_list(&rule_stop, SCAN_P_ID, SCAN_P_EOF,SET_END);
  set_assign_list(&ruleName_stop, SCAN_P_ID, SCAN_P_EOF, RDP_T_17 /* ' */, RDP_T_18 /* . */, RDP_T_21 /* ::= */, 
RDP_T_22 /* | */,SET_END);
  set_assign_list(&terminal_stop, SCAN_P_ID, SCAN_P_EOF, RDP_T_17 /* ' */, RDP_T_18 /* . */, RDP_T_22 /* | */,SET_END);
  set_assign_list(&text_stop, SCAN_P_EOF,SET_END);
}

/* Parser forward declarations and macros */
static void production(void);
static void rule(void);
static char* ruleName(void);
static char* terminal(void);
void text(void);

/* Parser functions */
static void production(void)
{
  char* name;
  void *parent = scan_parent;   /* remember tree parent */

  if (!scan_retain_parent && rdp_pass == RDP_PASSES)
  {
    scan_parent = graph_insert_node_child(sizeof(scan_data), 0, parent);
    ((scan_data*) scan_parent)->id = "production";
  }

  if (scan_test_set(NULL, &production_first, NULL))
  {
    if (scan_test_set(NULL, &rdp_production_2_first, NULL))
    { /* Start of rdp_production_2 */
      while (1)
      {
        if (scan_test(NULL, RDP_T_17 /* ' */, NULL))
        {
          terminal();
        }
        else
        if (scan_test(NULL, SCAN_P_ID, NULL))
        {
          name = ruleName();
          if (rdp_pass == 2) { \
 symbol_find(generate, name, sizeof(char*), sizeof(generate_data), NULL, SYMBOL_OLD);  \
}
        }
        if (!scan_test_set(NULL, &rdp_production_2_first, NULL)) break;
      }
    } /* end of rdp_production_2 */
    scan_test_set(NULL, &production_stop, &production_stop);
  }

  scan_parent = parent;    /* restore parent node */

}

static void rule(void)
{
  char* name;
  void *parent = scan_parent;   /* remember tree parent */

  if (!scan_retain_parent && rdp_pass == RDP_PASSES)
  {
    scan_parent = graph_insert_node_child(sizeof(scan_data), 0, parent);
    ((scan_data*) scan_parent)->id = "rule";
  }

  if (scan_test(NULL, SCAN_P_ID, &rule_stop))
  {
     generate_data* this_rule; 
    name = ruleName();
     this_rule = generate_cast(symbol_find(generate, name, sizeof(char*), \
                                       sizeof(generate_data), NULL, \
                                       rdp_pass == 1 ? SYMBOL_NEW : SYMBOL_OLD) \
                                      ); \
             this_rule->tree_node = (scan_data*) scan_parent; \
          
    scan_test(NULL, RDP_T_21 /* ::= */, &rule_stop);
    SCAN_ADD_CHILD scan_();
    production();
    if (scan_test(NULL, RDP_T_22 /* | */, NULL))
    { /* Start of rdp_rule_1 */
      while (1)
      {
        scan_test(NULL, RDP_T_22 /* | */, &rule_stop);
        SCAN_ADD_CHILD scan_();
        production();
        if (!scan_test(NULL, RDP_T_22 /* | */, NULL)) break;
      }
    } /* end of rdp_rule_1 */
    scan_test(NULL, RDP_T_18 /* . */, &rule_stop);
    SCAN_ADD_CHILD scan_();
    scan_test_set(NULL, &rule_stop, &rule_stop);
  }

  scan_parent = parent;    /* restore parent node */

}

static char* ruleName(void)
{
  char* result;
  void *parent = scan_parent;   /* remember tree parent */

  if (!scan_retain_parent && rdp_pass == RDP_PASSES)
  {
    scan_parent = graph_insert_node_child(sizeof(scan_data), 0, parent);
    ((scan_data*) scan_parent)->id = "ruleName";
  }

  if (scan_test(NULL, SCAN_P_ID, &ruleName_stop))
  {
    result = SCAN_CAST->id;
    scan_test(NULL, SCAN_P_ID, &ruleName_stop);
    SCAN_ADD_CHILD scan_();
    scan_test_set(NULL, &ruleName_stop, &ruleName_stop);
  }

  scan_parent = parent;    /* restore parent node */

  return result;
}

static char* terminal(void)
{
  char* result;
  void *parent = scan_parent;   /* remember tree parent */

  if (!scan_retain_parent && rdp_pass == RDP_PASSES)
  {
    scan_parent = graph_insert_node_child(sizeof(scan_data), 0, parent);
    ((scan_data*) scan_parent)->id = "terminal";
  }

  if (scan_test(NULL, RDP_T_17 /* ' */, &terminal_stop))
  {
    result = SCAN_CAST->id;
    scan_test(NULL, RDP_T_17 /* ' */, &terminal_stop);
    SCAN_ADD_CHILD scan_();
    scan_test_set(NULL, &terminal_stop, &terminal_stop);
  }

  scan_parent = parent;    /* restore parent node */

  return result;
}

void text(void)
{
  void *parent = scan_parent;   /* remember tree parent */

  if (!scan_retain_parent && rdp_pass == RDP_PASSES)
  {
    scan_parent = graph_insert_node_child(sizeof(scan_data), 0, parent);
    ((scan_data*) scan_parent)->id = "text";
  }

  if (scan_test(NULL, SCAN_P_ID, NULL))
  {
    if (scan_test(NULL, SCAN_P_ID, NULL))
    { /* Start of rdp_text_1 */
      while (1)
      {
        rule();
        if (!scan_test(NULL, SCAN_P_ID, NULL)) break;
      }
    } /* end of rdp_text_1 */
    scan_test_set(NULL, &text_stop, &text_stop);
  }

  scan_parent = parent;    /* restore parent node */

}

int main(int argc, char *argv[])
{
  clock_t rdp_finish_time, rdp_start_time = clock();
  int
    rdp_symbol_statistics = 0,    /* show symbol_ table statistics flag */
    rdp_line_echo_all = 0,        /* make a listing on all passes flag */
    rdp_filter = 0,               /* filter flag */
    rdp_line_echo = 0;            /* make listing flag */

  unsigned long rdp_textsize = 35000l;   /* size of scanner text array */

  unsigned long rdp_tabwidth = 8l;   /* tab expansion width */

  char* rdp_vcg_filename = NULL;      /* filename for -V option */

  void* rdp_tree = graph_insert_graph("RDP derivation tree");  /* hook for derivation tree */

  scan_parent = rdp_tree;

  arg_message("Generate V1.00 (c) Elizabeth Scott and Adrian Johnstone 1996\n" RDP_STAMP "\n\n""Usage: gen [options] source[.gen]");

  arg_message("");
  arg_boolean('f', "Filter mode (read from stdin and write to stdout)", &rdp_filter);
  arg_boolean('l', "Make a listing", &rdp_line_echo);
  arg_string ('o', "Write output to filename", &rdp_outputfilename);
  arg_boolean('s', "Echo each scanner symbol as it is read", &rdp_symbol_echo);
  arg_boolean('S', "Print summary symbol table statistics", &rdp_symbol_statistics);
  arg_numeric('t', "Tab expansion width (default 8)", &rdp_tabwidth);
  arg_numeric('T', "Text buffer size in bytes for scanner (default 20000)", &rdp_textsize);
  arg_boolean('v', "Set verbose mode", &rdp_verbose);
  arg_string ('V', "Write derivation tree to filename in VCG format", &rdp_vcg_filename);

  rdp_sourcefilename = arg_process(argc, argv);

  if (rdp_filter)
{
    rdp_sourcefilename = "-";
    rdp_outputfilename = "-";

}
  if (rdp_sourcefilename == NULL)
     arg_help("No source file specified");

  text_init(rdp_textsize, 25, 100, (int) rdp_tabwidth);
  scan_init(0, 0, 0, rdp_symbol_echo, rdp_tokens);
  generate = symbol_new_table("generate", 101, 31, symbol_compare_string, symbol_hash_string, symbol_print_string);
  rdp_set_initialise();
  rdp_load_keywords();
  if (rdp_verbose)
     text_printf("\nGenerate V1.00 (c) Elizabeth Scott and Adrian Johnstone 1996\n" RDP_STAMP "\n\n");
  for (rdp_pass = 1; rdp_pass <= RDP_PASSES; rdp_pass++)
  {
    text_echo(rdp_line_echo_all || (rdp_line_echo && rdp_pass == RDP_PASSES));
    if (text_open(text_default_filetype(rdp_sourcefilename, "gen")) == NULL)
      arg_help("Can't open source file");

    text_get_char();
    scan_();

    text();            /* call parser at top level */
    if (text_total_errors() != 0)
      text_message(TEXT_FATAL, "Error%s detected in source file\n", text_total_errors() == 1 ? "" : "s");   /* crash quietly */ 
  }
  if (rdp_symbol_statistics)
    symbol_print_all_table_statistics(11);

  if (rdp_vcg_filename != NULL)
  {
    FILE *rdp_vcg_file;

    if (*rdp_vcg_filename == '\0')   /* No filename supplied */
      rdp_vcg_filename = "rdparser";
    rdp_vcg_file = fopen((rdp_vcg_filename = text_default_filetype(rdp_vcg_filename, "vcg")), "w");

    if (rdp_vcg_file == NULL)
      text_message(TEXT_FATAL, "Unable to open VCG file '%s' for write\n", rdp_vcg_filename);

    if (rdp_verbose)
      text_message(TEXT_INFO, "Dumping derivation tree to VCG file '%s'\n", rdp_vcg_filename);

    text_redirect(rdp_vcg_file);
    graph_vcg(rdp_tree, scan_vcg_print_node, NULL);
    text_redirect(stdout);
  }

  if (rdp_verbose)
  {
    rdp_finish_time = clock();
    text_message(TEXT_INFO, "%.3f CPU seconds used\n", ((double) (rdp_finish_time-rdp_start_time)) / CLOCKS_PER_SEC);
  }
  return rdp_error_return;
}

/* End of gen.c */
