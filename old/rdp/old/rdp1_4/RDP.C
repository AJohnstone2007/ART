/****************************************************************************
*
* Parser generated by RDP on Feb 13 1995 at 07:53:50 from rdp.bnf
*
****************************************************************************/
#include <time.h>
#include "memalloc.h"
#include "scan.h"
#include "set.h"
#include "symbol.h"
#include "textio.h"
#include "rdp_aux.h"
#include "rdp_gram.h"
#include "rdp_prnt.h"
#include "rdp.h"

char
 *rdp__sourcefilename = NULL,   /* source file name */
 *rdp__outputfilename = "rdparser",         /* output file name */
  rdp__symbol_echo = 0,                 /* symbol echo flag */
  rdp__verbose = 0,                     /* verbosity flag */
  rdp__pass;                            /* pass number */

int rdp__error_return = 0;              /* return value for main routine */

char *rdp__tokens = "IGNORE\0" 
"ID\0" "INTEGER\0" "REAL\0" "ISTRING\0" "ISTRING_ESC\0" "ICOMMENT\0" "ICOMMENT_VISIBLE\0" "ICOMMENT_NEST\0" 
"ICOMMENT_NEST_VISIBLE\0" "ICOMMENT_LINE\0" "ICOMMENT_LINE_VISIBLE\0" "KEYWORD\0" "EOF\0" "EOLN\0" "'('\0" "')'\0" 
"'*'\0" "'.'\0" "':'\0" "'::'\0" "'::='\0" "'<'\0" "'>'\0" "'@'\0" 
"'ALT_ID'\0" "'CASE_INSENSITIVE'\0" "'COMMENT'\0" "'COMMENT_LINE'\0" "'COMMENT_LINE_VISIBLE'\0" "'COMMENT_NEST'\0" "'COMMENT_NEST_VISIBLE'\0" "'COMMENT_VISIBLE'\0" 
"'HASH_PRIME'\0" "'HASH_SIZE'\0" "'INCLUDE'\0" "'INTERPRETER'\0" "'MAX_ERRORS'\0" "'MAX_WARNINGS'\0" "'NEW_ID'\0" "'NUMBER'\0" 
"'OPTION'\0" "'OUTPUT_FILE'\0" "'PARSER'\0" "'PASSES'\0" "'POST_PARSE'\0" "'POST_PROCESS'\0" "'PRE_PARSE'\0" "'PRE_PROCESS'\0" 
"'SCANNER'\0" "'SET_SIZE'\0" "'SHOW_SKIPS'\0" "'STRING'\0" "'STRING_ESC'\0" "'SUFFIX'\0" "'SYMBOL_TABLE'\0" "'TAB_WIDTH'\0" 
"'TEXT_SIZE'\0" "'TITLE'\0" "'USES'\0" "'['\0" "']'\0" "'{'\0" "'|'\0" "'}'\0" 
;

void* locals = NULL;
void* codes = NULL;
void* tokens = NULL;
void* rdp = NULL;


static void rdp__help(char *msg)
{
  text__message(TEXT__FATAL, "%s\n\n"
          "Recursive descent parser generator V1.40 (c) Adrian Johnstone 1995\n"
          "Generated on Feb 13 1995 at 07:53:50 and compiled on " __DATE__ " at " __TIME__ "\n\n"
          "Usage: rdp [options] source[.bnf]\n\n"
          "Options:\n\n"
          "-f  Filter mode (read from stdin and write to stdout)\n"
          "-l  Make a listing\n"
          "-ofilename Write output to filename\n"
          "-s  Echo each scanner symbol as it is read\n"
          "-S  Print summary symbol table statistics\n"
          "-tn Tab expansion width (default 8)\n"
          "-Tn Text buffer size in bytes for scanner (default 30000)\n"
          "-v  Set verbose mode\n"
                  "-e  Write out expanded BNF along with first and follow sets\n"
                  "-E  Add production name to error messages in generated parser\n"
                  "-F  Force creation of output files\n"
                  "-p  Make parser only (omit semantic actions from generated code)\n"
                  "\n"
                  "You can contact the author (Adrian Johnstone) at:\n"
                  "\n"
                  "Computer Science Department, Royal Holloway, University of London\n"
                  "Egham, Surrey, TW20 0EX UK. Email: adrian@dcs.rhbnc.ac.uk\n"
          ,msg == NULL ? "" : msg);
}

/* Load keywords */
static void rdp__load_keywords(void)
{
  scan__load_keyword("\"", "\\", T__ISTRING_ESC);
  scan__load_keyword("\'", "\\", T__ISTRING_ESC);
  scan__load_keyword("(", NULL, T__15 /* ( */);
  scan__load_keyword("(*", "*)", T__ICOMMENT);
  scan__load_keyword(")", NULL, T__16 /* ) */);
  scan__load_keyword("*", NULL, T__17 /* * */);
  scan__load_keyword(".", NULL, T__18 /* . */);
  scan__load_keyword(":", NULL, T__19 /* : */);
  scan__load_keyword("::", NULL, T__20 /* :: */);
  scan__load_keyword("::=", NULL, T__21 /* ::= */);
  scan__load_keyword("<", NULL, T__22 /* < */);
  scan__load_keyword(">", NULL, T__23 /* > */);
  scan__load_keyword("@", NULL, T__24 /* @ */);
  scan__load_keyword("ALT_ID", NULL, T__ALT_ID);
  scan__load_keyword("CASE_INSENSITIVE", NULL, T__CASE_INSENSITIVE);
  scan__load_keyword("COMMENT", NULL, T__COMMENT);
  scan__load_keyword("COMMENT_LINE", NULL, T__COMMENT_LINE);
  scan__load_keyword("COMMENT_LINE_VISIBLE", NULL, T__COMMENT_LINE_VISIBLE);
  scan__load_keyword("COMMENT_NEST", NULL, T__COMMENT_NEST);
  scan__load_keyword("COMMENT_NEST_VISIBLE", NULL, T__COMMENT_NEST_VISIBLE);
  scan__load_keyword("COMMENT_VISIBLE", NULL, T__COMMENT_VISIBLE);
  scan__load_keyword("HASH_PRIME", NULL, T__HASH_PRIME);
  scan__load_keyword("HASH_SIZE", NULL, T__HASH_SIZE);
  scan__load_keyword("INCLUDE", NULL, T__INCLUDE);
  scan__load_keyword("INTERPRETER", NULL, T__INTERPRETER);
  scan__load_keyword("MAX_ERRORS", NULL, T__MAX_ERRORS);
  scan__load_keyword("MAX_WARNINGS", NULL, T__MAX_WARNINGS);
  scan__load_keyword("NEW_ID", NULL, T__NEW_ID);
  scan__load_keyword("NUMBER", NULL, T__NUMBER);
  scan__load_keyword("OPTION", NULL, T__OPTION);
  scan__load_keyword("OUTPUT_FILE", NULL, T__OUTPUT_FILE);
  scan__load_keyword("PARSER", NULL, T__PARSER);
  scan__load_keyword("PASSES", NULL, T__PASSES);
  scan__load_keyword("POST_PARSE", NULL, T__POST_PARSE);
  scan__load_keyword("POST_PROCESS", NULL, T__POST_PROCESS);
  scan__load_keyword("PRE_PARSE", NULL, T__PRE_PARSE);
  scan__load_keyword("PRE_PROCESS", NULL, T__PRE_PROCESS);
  scan__load_keyword("SCANNER", NULL, T__SCANNER);
  scan__load_keyword("SET_SIZE", NULL, T__SET_SIZE);
  scan__load_keyword("SHOW_SKIPS", NULL, T__SHOW_SKIPS);
  scan__load_keyword("STRING", NULL, T__STRING);
  scan__load_keyword("STRING_ESC", NULL, T__STRING_ESC);
  scan__load_keyword("SUFFIX", NULL, T__SUFFIX);
  scan__load_keyword("SYMBOL_TABLE", NULL, T__SYMBOL_TABLE);
  scan__load_keyword("TAB_WIDTH", NULL, T__TAB_WIDTH);
  scan__load_keyword("TEXT_SIZE", NULL, T__TEXT_SIZE);
  scan__load_keyword("TITLE", NULL, T__TITLE);
  scan__load_keyword("USES", NULL, T__USES);
  scan__load_keyword("[", NULL, T__60 /* [ */);
  scan__load_keyword("[*", "*]", T__ICOMMENT_VISIBLE);
  scan__load_keyword("]", NULL, T__61 /* ] */);
  scan__load_keyword("{", NULL, T__62 /* { */);
  scan__load_keyword("|", NULL, T__63 /* | */);
  scan__load_keyword("}", NULL, T__64 /* } */);
}

/* Set declarations */

  set__ String_stop = SET__NULL;
  set__ alt_first = SET__NULL;
  set__ alt_stop = SET__NULL;
  set__ alt__0_first = SET__NULL;
  set__ alt__1_first = SET__NULL;
  set__ alt__2_first = SET__NULL;
  set__ code_stop = SET__NULL;
  set__ comment_stop = SET__NULL;
  set__ dir_first = SET__NULL;
  set__ dir_stop = SET__NULL;
  set__ item_inl_first = SET__NULL;
  set__ item_inl_stop = SET__NULL;
  set__ item_ret_first = SET__NULL;
  set__ item_ret_stop = SET__NULL;
  set__ prod_stop = SET__NULL;
  set__ seq_first = SET__NULL;
  set__ seq_stop = SET__NULL;
  set__ seq__10_first = SET__NULL;
  set__ seq__11_first = SET__NULL;
  set__ seq__12_first = SET__NULL;
  set__ seq__2_first = SET__NULL;
  set__ seq__3_first = SET__NULL;
  set__ seq__4_first = SET__NULL;
  set__ seq__7_first = SET__NULL;
  set__ seq__8_first = SET__NULL;
  set__ seq__9_first = SET__NULL;
  set__ token_stop = SET__NULL;
  set__ unit_first = SET__NULL;
  set__ unit_stop = SET__NULL;
  set__ unit__1_first = SET__NULL;
  set__ unit__2_first = SET__NULL;
  set__ unit__3_first = SET__NULL;

/* Initialise sets */

static void rdp__set_initialise(void)
{
  set__assign_list(&String_stop, T__ICOMMENT_VISIBLE, T__EOF, T__16 /* ) */,SET__END);
  set__assign_list(&alt_first, T__ID, T__ISTRING_ESC, T__ICOMMENT_VISIBLE, T__15 /* ( */, T__22 /* < */, T__ALT_ID, T__COMMENT, T__COMMENT_LINE, T__COMMENT_LINE_VISIBLE, T__COMMENT_NEST, T__COMMENT_NEST_VISIBLE, T__COMMENT_VISIBLE, T__NEW_ID, T__NUMBER, T__STRING, T__STRING_ESC, T__60 /* [ */, T__62 /* { */, SET__END);
  set__assign_list(&alt_stop, T__EOF, T__16 /* ) */, T__18 /* . */, T__23 /* > */, T__61 /* ] */, T__64 /* } */,SET__END);
  set__assign_list(&alt__0_first, T__ID, T__ISTRING_ESC, T__ICOMMENT_VISIBLE, T__15 /* ( */, T__22 /* < */, T__ALT_ID, T__COMMENT, T__COMMENT_LINE, T__COMMENT_LINE_VISIBLE, T__COMMENT_NEST, T__COMMENT_NEST_VISIBLE, T__COMMENT_VISIBLE, T__NEW_ID, T__NUMBER, T__STRING, T__STRING_ESC, T__60 /* [ */, T__62 /* { */, SET__END);
  set__assign_list(&alt__1_first, T__ID, T__ISTRING_ESC, T__ICOMMENT_VISIBLE, T__15 /* ( */, T__22 /* < */, T__ALT_ID, T__COMMENT, T__COMMENT_LINE, T__COMMENT_LINE_VISIBLE, T__COMMENT_NEST, T__COMMENT_NEST_VISIBLE, T__COMMENT_VISIBLE, T__NEW_ID, T__NUMBER, T__STRING, T__STRING_ESC, T__60 /* [ */, T__62 /* { */, SET__END);
  set__assign_list(&alt__2_first, T__ID, T__ISTRING_ESC, T__ICOMMENT_VISIBLE, T__15 /* ( */, T__22 /* < */, T__ALT_ID, T__COMMENT, T__COMMENT_LINE, T__COMMENT_LINE_VISIBLE, T__COMMENT_NEST, T__COMMENT_NEST_VISIBLE, T__COMMENT_VISIBLE, T__NEW_ID, T__NUMBER, T__STRING, T__STRING_ESC, T__60 /* [ */, T__62 /* { */, SET__END);
  set__assign_list(&code_stop, T__ID, T__ISTRING_ESC, T__ICOMMENT_VISIBLE, T__EOF, T__15 /* ( */, T__16 /* ) */, T__18 /* . */, T__22 /* < */, T__23 /* > */, T__24 /* @ */, T__ALT_ID, T__COMMENT, T__COMMENT_LINE, T__COMMENT_LINE_VISIBLE, T__COMMENT_NEST, T__COMMENT_NEST_VISIBLE, T__COMMENT_VISIBLE, T__NEW_ID, T__NUMBER, T__STRING, T__STRING_ESC, T__60 /* [ */, T__61 /* ] */, T__62 /* { */, T__63 /* | */, T__64 /* } */,SET__END);
  set__assign_list(&comment_stop, T__EOF,SET__END);
  set__assign_list(&dir_first, T__CASE_INSENSITIVE, T__HASH_PRIME, T__HASH_SIZE, T__INCLUDE, T__INTERPRETER, T__MAX_ERRORS, T__MAX_WARNINGS, T__OPTION, T__OUTPUT_FILE, T__PARSER, T__PASSES, T__POST_PARSE, T__POST_PROCESS, T__PRE_PARSE, T__PRE_PROCESS, T__SCANNER, T__SET_SIZE, T__SHOW_SKIPS, T__SUFFIX, T__SYMBOL_TABLE, T__TAB_WIDTH, T__TEXT_SIZE, T__TITLE, T__USES, SET__END);
  set__assign_list(&dir_stop, T__ID, T__EOF, T__CASE_INSENSITIVE, T__HASH_PRIME, T__HASH_SIZE, T__INCLUDE, T__INTERPRETER, T__MAX_ERRORS, T__MAX_WARNINGS, T__OPTION, T__OUTPUT_FILE, T__PARSER, T__PASSES, T__POST_PARSE, T__POST_PROCESS, T__PRE_PARSE, T__PRE_PROCESS, T__SCANNER, T__SET_SIZE, T__SHOW_SKIPS, T__SUFFIX, T__SYMBOL_TABLE, T__TAB_WIDTH, T__TEXT_SIZE, T__TITLE, T__USES,SET__END);
  set__assign_list(&item_inl_first, T__ICOMMENT_VISIBLE, T__15 /* ( */, T__22 /* < */, T__60 /* [ */, T__62 /* { */, SET__END);
  set__assign_list(&item_inl_stop, T__ID, T__ISTRING_ESC, T__ICOMMENT_VISIBLE, T__EOF, T__15 /* ( */, T__16 /* ) */, T__18 /* . */, T__22 /* < */, T__23 /* > */, T__ALT_ID, T__COMMENT, T__COMMENT_LINE, T__COMMENT_LINE_VISIBLE, T__COMMENT_NEST, T__COMMENT_NEST_VISIBLE, T__COMMENT_VISIBLE, T__NEW_ID, T__NUMBER, T__STRING, T__STRING_ESC, T__60 /* [ */, T__61 /* ] */, T__62 /* { */, T__63 /* | */, T__64 /* } */,SET__END);
  set__assign_list(&item_ret_first, T__ID, T__ISTRING_ESC, T__ALT_ID, T__COMMENT, T__COMMENT_LINE, T__COMMENT_LINE_VISIBLE, T__COMMENT_NEST, T__COMMENT_NEST_VISIBLE, T__COMMENT_VISIBLE, T__NEW_ID, T__NUMBER, T__STRING, T__STRING_ESC, SET__END);
  set__assign_list(&item_ret_stop, T__ID, T__ISTRING_ESC, T__ICOMMENT_VISIBLE, T__EOF, T__15 /* ( */, T__16 /* ) */, T__18 /* . */, T__19 /* : */, T__22 /* < */, T__23 /* > */, T__ALT_ID, T__COMMENT, T__COMMENT_LINE, T__COMMENT_LINE_VISIBLE, T__COMMENT_NEST, T__COMMENT_NEST_VISIBLE, T__COMMENT_VISIBLE, T__NEW_ID, T__NUMBER, T__STRING, T__STRING_ESC, T__60 /* [ */, T__61 /* ] */, T__62 /* { */, T__63 /* | */, T__64 /* } */,SET__END);
  set__assign_list(&prod_stop, T__ID, T__EOF, T__CASE_INSENSITIVE, T__HASH_PRIME, T__HASH_SIZE, T__INCLUDE, T__INTERPRETER, T__MAX_ERRORS, T__MAX_WARNINGS, T__OPTION, T__OUTPUT_FILE, T__PARSER, T__PASSES, T__POST_PARSE, T__POST_PROCESS, T__PRE_PARSE, T__PRE_PROCESS, T__SCANNER, T__SET_SIZE, T__SHOW_SKIPS, T__SUFFIX, T__SYMBOL_TABLE, T__TAB_WIDTH, T__TEXT_SIZE, T__TITLE, T__USES,SET__END);
  set__assign_list(&seq_first, T__ID, T__ISTRING_ESC, T__ICOMMENT_VISIBLE, T__15 /* ( */, T__22 /* < */, T__ALT_ID, T__COMMENT, T__COMMENT_LINE, T__COMMENT_LINE_VISIBLE, T__COMMENT_NEST, T__COMMENT_NEST_VISIBLE, T__COMMENT_VISIBLE, T__NEW_ID, T__NUMBER, T__STRING, T__STRING_ESC, T__60 /* [ */, T__62 /* { */, SET__END);
  set__assign_list(&seq_stop, T__EOF, T__16 /* ) */, T__18 /* . */, T__23 /* > */, T__61 /* ] */, T__63 /* | */, T__64 /* } */,SET__END);
  set__assign_list(&seq__10_first, T__ID, T__ISTRING_ESC, T__ICOMMENT_VISIBLE, T__15 /* ( */, T__22 /* < */, T__ALT_ID, T__COMMENT, T__COMMENT_LINE, T__COMMENT_LINE_VISIBLE, T__COMMENT_NEST, T__COMMENT_NEST_VISIBLE, T__COMMENT_VISIBLE, T__NEW_ID, T__NUMBER, T__STRING, T__STRING_ESC, T__60 /* [ */, T__62 /* { */, SET__END);
  set__assign_list(&seq__11_first, T__ID, T__ISTRING_ESC, T__ICOMMENT_VISIBLE, T__15 /* ( */, T__22 /* < */, T__ALT_ID, T__COMMENT, T__COMMENT_LINE, T__COMMENT_LINE_VISIBLE, T__COMMENT_NEST, T__COMMENT_NEST_VISIBLE, T__COMMENT_VISIBLE, T__NEW_ID, T__NUMBER, T__STRING, T__STRING_ESC, T__60 /* [ */, T__62 /* { */, SET__END);
  set__assign_list(&seq__12_first, T__ID, T__ISTRING_ESC, T__ICOMMENT_VISIBLE, T__15 /* ( */, T__22 /* < */, T__ALT_ID, T__COMMENT, T__COMMENT_LINE, T__COMMENT_LINE_VISIBLE, T__COMMENT_NEST, T__COMMENT_NEST_VISIBLE, T__COMMENT_VISIBLE, T__NEW_ID, T__NUMBER, T__STRING, T__STRING_ESC, T__60 /* [ */, T__62 /* { */, SET__END);
  set__assign_list(&seq__2_first, T__ID, T__ISTRING_ESC, T__ALT_ID, T__COMMENT, T__COMMENT_LINE, T__COMMENT_LINE_VISIBLE, T__COMMENT_NEST, T__COMMENT_NEST_VISIBLE, T__COMMENT_VISIBLE, T__NEW_ID, T__NUMBER, T__STRING, T__STRING_ESC, SET__END);
  set__assign_list(&seq__3_first, T__ICOMMENT_VISIBLE, T__15 /* ( */, T__22 /* < */, T__60 /* [ */, T__62 /* { */, SET__END);
  set__assign_list(&seq__4_first, T__ID, T__ISTRING_ESC, T__ICOMMENT_VISIBLE, T__15 /* ( */, T__22 /* < */, T__ALT_ID, T__COMMENT, T__COMMENT_LINE, T__COMMENT_LINE_VISIBLE, T__COMMENT_NEST, T__COMMENT_NEST_VISIBLE, T__COMMENT_VISIBLE, T__NEW_ID, T__NUMBER, T__STRING, T__STRING_ESC, T__60 /* [ */, T__62 /* { */, SET__END);
  set__assign_list(&seq__7_first, T__ID, T__ISTRING_ESC, T__ALT_ID, T__COMMENT, T__COMMENT_LINE, T__COMMENT_LINE_VISIBLE, T__COMMENT_NEST, T__COMMENT_NEST_VISIBLE, T__COMMENT_VISIBLE, T__NEW_ID, T__NUMBER, T__STRING, T__STRING_ESC, SET__END);
  set__assign_list(&seq__8_first, T__ICOMMENT_VISIBLE, T__15 /* ( */, T__22 /* < */, T__60 /* [ */, T__62 /* { */, SET__END);
  set__assign_list(&seq__9_first, T__ID, T__ISTRING_ESC, T__ICOMMENT_VISIBLE, T__15 /* ( */, T__22 /* < */, T__ALT_ID, T__COMMENT, T__COMMENT_LINE, T__COMMENT_LINE_VISIBLE, T__COMMENT_NEST, T__COMMENT_NEST_VISIBLE, T__COMMENT_VISIBLE, T__NEW_ID, T__NUMBER, T__STRING, T__STRING_ESC, T__60 /* [ */, T__62 /* { */, SET__END);
  set__assign_list(&token_stop, T__ID, T__ISTRING_ESC, T__ICOMMENT_VISIBLE, T__EOF, T__15 /* ( */, T__16 /* ) */, T__18 /* . */, T__19 /* : */, T__22 /* < */, T__23 /* > */, T__ALT_ID, T__COMMENT, T__COMMENT_LINE, T__COMMENT_LINE_VISIBLE, T__COMMENT_NEST, T__COMMENT_NEST_VISIBLE, T__COMMENT_VISIBLE, T__NEW_ID, T__NUMBER, T__STRING, T__STRING_ESC, T__60 /* [ */, T__61 /* ] */, T__62 /* { */, T__63 /* | */, T__64 /* } */,SET__END);
  set__assign_list(&unit_first, T__ID, T__CASE_INSENSITIVE, T__HASH_PRIME, T__HASH_SIZE, T__INCLUDE, T__INTERPRETER, T__MAX_ERRORS, T__MAX_WARNINGS, T__OPTION, T__OUTPUT_FILE, T__PARSER, T__PASSES, T__POST_PARSE, T__POST_PROCESS, T__PRE_PARSE, T__PRE_PROCESS, T__SCANNER, T__SET_SIZE, T__SHOW_SKIPS, T__SUFFIX, T__SYMBOL_TABLE, T__TAB_WIDTH, T__TEXT_SIZE, T__TITLE, T__USES, SET__END);
  set__assign_list(&unit_stop, T__EOF,SET__END);
  set__assign_list(&unit__1_first, T__CASE_INSENSITIVE, T__HASH_PRIME, T__HASH_SIZE, T__INCLUDE, T__INTERPRETER, T__MAX_ERRORS, T__MAX_WARNINGS, T__OPTION, T__OUTPUT_FILE, T__PARSER, T__PASSES, T__POST_PARSE, T__POST_PROCESS, T__PRE_PARSE, T__PRE_PROCESS, T__SCANNER, T__SET_SIZE, T__SHOW_SKIPS, T__SUFFIX, T__SYMBOL_TABLE, T__TAB_WIDTH, T__TEXT_SIZE, T__TITLE, T__USES, SET__END);
  set__assign_list(&unit__2_first, T__ID, T__CASE_INSENSITIVE, T__HASH_PRIME, T__HASH_SIZE, T__INCLUDE, T__INTERPRETER, T__MAX_ERRORS, T__MAX_WARNINGS, T__OPTION, T__OUTPUT_FILE, T__PARSER, T__PASSES, T__POST_PARSE, T__POST_PROCESS, T__PRE_PARSE, T__PRE_PROCESS, T__SCANNER, T__SET_SIZE, T__SHOW_SKIPS, T__SUFFIX, T__SYMBOL_TABLE, T__TAB_WIDTH, T__TEXT_SIZE, T__TITLE, T__USES, SET__END);
  set__assign_list(&unit__3_first, T__ID, T__CASE_INSENSITIVE, T__HASH_PRIME, T__HASH_SIZE, T__INCLUDE, T__INTERPRETER, T__MAX_ERRORS, T__MAX_WARNINGS, T__OPTION, T__OUTPUT_FILE, T__PARSER, T__PASSES, T__POST_PARSE, T__POST_PROCESS, T__PRE_PARSE, T__PRE_PROCESS, T__SCANNER, T__SET_SIZE, T__SHOW_SKIPS, T__SUFFIX, T__SYMBOL_TABLE, T__TAB_WIDTH, T__TEXT_SIZE, T__TITLE, T__USES, SET__END);
}

/* Parser forward declarations and macros */
static char* String(void);
static rdp__list* alt(void);
static char* code(void);
static void dir(void);
static rdp__data* item_inl(void);
static rdp__data* item_ret(void);
static rdp__data* prod(void);
static rdp__list* seq(void);
static char* token(void);
void unit(void);

/* Parser functions */
static char* String(void)
{
  char* result;
  if (scan__test(T__ISTRING_ESC, &String_stop))
  {
    result = SCAN__CAST->id;
    scan__test(T__ISTRING_ESC, &String_stop);
    scan__();
    scan__test_set(&String_stop, &String_stop);
  }
  return result;
}

static rdp__list* alt(void)
{
  rdp__list* result;
  rdp__list* body;
  if (scan__test_set(&alt_first, &alt_stop))
  {
     rdp__list* end; if (rdp__pass == 2) { \
 end = result = (rdp__list*) mem__calloc(sizeof(rdp__list), 1);  \
}
    {
      body = seq();
      if (rdp__pass == 2) { \
 end->next = (rdp__list*) mem__calloc(sizeof(rdp__list), 1); \
                                  end = end->next; \
                                  end->production = rdp__find(text__insert_substring(rdp__primary_id, rdp__component++), K__SEQUENCE, RDP__NEW); \
                                  end->production->call_count++; \
                                  end->production->list = body; \
                                \
}
    }
    while (SCAN__CAST->token == T__63 /* | */)
    {
      scan__(); /* skip delimiter */
      body = seq();
      if (rdp__pass == 2) { \
 end->next = (rdp__list*) mem__calloc(sizeof(rdp__list), 1); \
                                  end = end->next; \
                                  end->production = rdp__find(text__insert_substring(rdp__primary_id, rdp__component++), K__SEQUENCE, RDP__NEW); \
                                  end->production->call_count++; \
                                  end->production->list = body; \
                                \
}
    }
    if (rdp__pass == 2) { \
 result = result->next;  \
}
    scan__test_set(&alt_stop, &alt_stop);
  }
  return result;
}

static char* code(void)
{
  char* result;
  if (scan__test(T__ICOMMENT_VISIBLE, &code_stop))
  {
    result = SCAN__CAST->id;
    scan__test(T__ICOMMENT_VISIBLE, &code_stop);
    scan__();
    scan__test_set(&code_stop, &code_stop);
  }
  return result;
}

static void dir(void)
{
  char* filename;
  char* s;
  char* name;
  long int size;
  long int prime;
  char* compare;
  char* hash;
  char* print;
  char* data_fields;
  long int n;
  if (scan__test_set(&dir_first, &dir_stop))
  {
    if (scan__test(T__INCLUDE, NULL))
    {
      scan__test(T__INCLUDE, &dir_stop);
      scan__();
      scan__test(T__15 /* ( */, &dir_stop);
      scan__();
      filename = code();
      if (rdp__pass == 2) { \
 if (text__open(filename) == NULL) \
                           text__message(TEXT__ERROR_ECHO, "include file '%s' not found\n", filename); \
                        text__get_char(); \
                        scan__(); \
                       \
}
      scan__test(T__16 /* ) */, &dir_stop);
      scan__();
    }
    else
    if (scan__test(T__OPTION, NULL))
    {
       rdp__string_list *temp; if (rdp__pass == 2) { \
 temp = (rdp__string_list *) mem__malloc(sizeof(rdp__string_list));  \
}
      scan__test(T__OPTION, &dir_stop);
      scan__();
      scan__test(T__15 /* ( */, &dir_stop);
      scan__();
      s = String();
      if (rdp__pass == 2) { \
 temp->str1 = s; \
                                 temp->str2 = NULL; \
                                 temp->next = rdp__dir_help; \
                                 rdp__dir_help = temp; \
                               \
}
      if (scan__test(T__ICOMMENT_VISIBLE, NULL))
      {
        s = code();
        if (rdp__pass == 2) { \
 temp->str2 = s;  \
}
      }
      scan__test(T__16 /* ) */, &dir_stop);
      scan__();
    }
    else
    if (scan__test(T__SYMBOL_TABLE, NULL))
    {
       rdp__table_list *temp; if (rdp__pass == 2) { \
 temp = (rdp__table_list *) mem__malloc(sizeof(rdp__table_list));  \
}
      scan__test(T__SYMBOL_TABLE, &dir_stop);
      scan__();
      scan__test(T__15 /* ( */, &dir_stop);
      scan__();
      name = SCAN__CAST->id;
      scan__test(T__ID, &dir_stop);
      scan__();
      size = SCAN__CAST->data.i;
      scan__test(T__INTEGER, &dir_stop);
      scan__();
      prime = SCAN__CAST->data.i;
      scan__test(T__INTEGER, &dir_stop);
      scan__();
      compare = SCAN__CAST->id;
      scan__test(T__ID, &dir_stop);
      scan__();
      hash = SCAN__CAST->id;
      scan__test(T__ID, &dir_stop);
      scan__();
      print = SCAN__CAST->id;
      scan__test(T__ID, &dir_stop);
      scan__();
      data_fields = code();
      if (rdp__pass == 2) { \
temp = (rdp__table_list*) mem__malloc(sizeof(rdp__table_list)); \
                            temp->name = name; \
                            temp->size = (unsigned) size; \
                            temp->prime = (unsigned) prime; \
                            temp->compare = compare; \
                            temp->hash = hash; \
                            temp->print = print; \
                            temp->data_fields = data_fields; \
                            temp->next = rdp__dir_symbol_table; \
                            rdp__dir_symbol_table = temp; \
                           \
}
      scan__test(T__16 /* ) */, &dir_stop);
      scan__();
    }
    else
    if (scan__test(T__USES, NULL))
    {
       rdp__string_list *temp; if (rdp__pass == 2) { \
 temp = (rdp__string_list*) mem__malloc(sizeof(rdp__string_list));  \
}
      scan__test(T__USES, &dir_stop);
      scan__();
      scan__test(T__15 /* ( */, &dir_stop);
      scan__();
      s = String();
      if (rdp__pass == 2) { \
temp = (rdp__string_list*) mem__malloc(sizeof(rdp__string_list)); \
                    temp->str1 = s; \
                    temp->next = rdp__dir_include; \
                    rdp__dir_include = temp; \
                   \
}
      scan__test(T__16 /* ) */, &dir_stop);
      scan__();
    }
    else
    if (scan__test(T__OUTPUT_FILE, NULL))
    {
      scan__test(T__OUTPUT_FILE, &dir_stop);
      scan__();
      scan__test(T__15 /* ( */, &dir_stop);
      scan__();
      s = String();
       rdp__dir_output_file = s; 
      scan__test(T__16 /* ) */, &dir_stop);
      scan__();
    }
    else
    if (scan__test(T__PARSER, NULL))
    {
      scan__test(T__PARSER, &dir_stop);
      scan__();
      scan__test(T__15 /* ( */, &dir_stop);
      scan__();
      name = SCAN__CAST->id;
      scan__test(T__ID, &dir_stop);
      scan__();
      if (rdp__pass == 2) { \
 rdp__start_prod = rdp__find(name, K__PRIMARY, RDP__OLD); rdp__start_prod->call_count++;  \
}
      scan__test(T__16 /* ) */, &dir_stop);
      scan__();
    }
    else
    if (scan__test(T__POST_PARSE, NULL))
    {
      scan__test(T__POST_PARSE, &dir_stop);
      scan__();
      scan__test(T__15 /* ( */, &dir_stop);
      scan__();
      s = code();
       rdp__dir_post_parse = s; 
      scan__test(T__16 /* ) */, &dir_stop);
      scan__();
    }
    else
    if (scan__test(T__PRE_PARSE, NULL))
    {
      scan__test(T__PRE_PARSE, &dir_stop);
      scan__();
      scan__test(T__15 /* ( */, &dir_stop);
      scan__();
      s = code();
       rdp__dir_pre_parse = s; 
      scan__test(T__16 /* ) */, &dir_stop);
      scan__();
    }
    else
    if (scan__test(T__SUFFIX, NULL))
    {
      scan__test(T__SUFFIX, &dir_stop);
      scan__();
      scan__test(T__15 /* ( */, &dir_stop);
      scan__();
      s = String();
       rdp__dir_suffix = s; 
      scan__test(T__16 /* ) */, &dir_stop);
      scan__();
    }
    else
    if (scan__test(T__TITLE, NULL))
    {
      scan__test(T__TITLE, &dir_stop);
      scan__();
      scan__test(T__15 /* ( */, &dir_stop);
      scan__();
      s = String();
       rdp__dir_title = s; 
      scan__test(T__16 /* ) */, &dir_stop);
      scan__();
    }
    else
    if (scan__test(T__MAX_ERRORS, NULL))
    {
      scan__test(T__MAX_ERRORS, &dir_stop);
      scan__();
      scan__test(T__15 /* ( */, &dir_stop);
      scan__();
      n = SCAN__CAST->data.i;
      scan__test(T__INTEGER, &dir_stop);
      scan__();
       rdp__dir_max_errors = (unsigned) n; 
      scan__test(T__16 /* ) */, &dir_stop);
      scan__();
    }
    else
    if (scan__test(T__MAX_WARNINGS, NULL))
    {
      scan__test(T__MAX_WARNINGS, &dir_stop);
      scan__();
      scan__test(T__15 /* ( */, &dir_stop);
      scan__();
      n = SCAN__CAST->data.i;
      scan__test(T__INTEGER, &dir_stop);
      scan__();
       rdp__dir_max_warnings = (unsigned) n; 
      scan__test(T__16 /* ) */, &dir_stop);
      scan__();
    }
    else
    if (scan__test(T__PASSES, NULL))
    {
      scan__test(T__PASSES, &dir_stop);
      scan__();
      scan__test(T__15 /* ( */, &dir_stop);
      scan__();
      n = SCAN__CAST->data.i;
      scan__test(T__INTEGER, &dir_stop);
      scan__();
       rdp__dir_passes = (unsigned) n; 
      scan__test(T__16 /* ) */, &dir_stop);
      scan__();
    }
    else
    if (scan__test(T__TAB_WIDTH, NULL))
    {
      scan__test(T__TAB_WIDTH, &dir_stop);
      scan__();
      scan__test(T__15 /* ( */, &dir_stop);
      scan__();
      n = SCAN__CAST->data.i;
      scan__test(T__INTEGER, &dir_stop);
      scan__();
       rdp__dir_tab_width = (unsigned) n; 
      scan__test(T__16 /* ) */, &dir_stop);
      scan__();
    }
    else
    if (scan__test(T__TEXT_SIZE, NULL))
    {
      scan__test(T__TEXT_SIZE, &dir_stop);
      scan__();
      scan__test(T__15 /* ( */, &dir_stop);
      scan__();
      n = SCAN__CAST->data.i;
      scan__test(T__INTEGER, &dir_stop);
      scan__();
       rdp__dir_text_size = (unsigned) n; 
      scan__test(T__16 /* ) */, &dir_stop);
      scan__();
    }
    else
    if (scan__test(T__CASE_INSENSITIVE, NULL))
    {
      scan__test(T__CASE_INSENSITIVE, &dir_stop);
      scan__();
       rdp__dir_case_insensitive = 1; 
    }
    else
    if (scan__test(T__SHOW_SKIPS, NULL))
    {
      scan__test(T__SHOW_SKIPS, &dir_stop);
      scan__();
       rdp__dir_show_skips = 1; 
    }
    else
    if (scan__test(T__PRE_PROCESS, NULL))
    {
      scan__test(T__PRE_PROCESS, &dir_stop);
      scan__();
       text__message(TEXT__ERROR_ECHO, "obsolete directive: PRE_PROCESS renamed PRE_PARSE at version 1.3\n"); 
      scan__test(T__15 /* ( */, &dir_stop);
      scan__();
      code();
      scan__test(T__16 /* ) */, &dir_stop);
      scan__();
    }
    else
    if (scan__test(T__POST_PROCESS, NULL))
    {
      scan__test(T__POST_PROCESS, &dir_stop);
      scan__();
       text__message(TEXT__ERROR_ECHO, "obsolete directive: POST_PROCESS renamed POST_PARSE at version 1.3\n"); 
      scan__test(T__15 /* ( */, &dir_stop);
      scan__();
      code();
      scan__test(T__16 /* ) */, &dir_stop);
      scan__();
    }
    else
    if (scan__test(T__SCANNER, NULL))
    {
      scan__test(T__SCANNER, &dir_stop);
      scan__();
       text__message(TEXT__ERROR_ECHO, "unimplemented directive: SCANNER directive is a version 2.0 feature\n"); 
      scan__test(T__15 /* ( */, &dir_stop);
      scan__();
      scan__test(T__ID, &dir_stop);
      scan__();
      scan__test(T__16 /* ) */, &dir_stop);
      scan__();
    }
    else
    if (scan__test(T__SET_SIZE, NULL))
    {
      scan__test(T__SET_SIZE, &dir_stop);
      scan__();
       text__message(TEXT__ERROR_ECHO, "obsolete directive: SET_SIZE deletd at version 1.4\n"); 
      scan__test(T__15 /* ( */, &dir_stop);
      scan__();
      scan__test(T__INTEGER, &dir_stop);
      scan__();
      scan__test(T__16 /* ) */, &dir_stop);
      scan__();
    }
    else
    if (scan__test(T__HASH_SIZE, NULL))
    {
      scan__test(T__HASH_SIZE, &dir_stop);
      scan__();
       text__message(TEXT__ERROR_ECHO, "obsolete directive: HASH_SIZE replaced by SYMBOL_TABLE at version 1.4\n"); 
      scan__test(T__15 /* ( */, &dir_stop);
      scan__();
      scan__test(T__INTEGER, &dir_stop);
      scan__();
      scan__test(T__16 /* ) */, &dir_stop);
      scan__();
    }
    else
    if (scan__test(T__HASH_PRIME, NULL))
    {
      scan__test(T__HASH_PRIME, &dir_stop);
      scan__();
       text__message(TEXT__ERROR_ECHO, "obsolete directive: HASH_PRIME replaced by SYMBOL_TABLE at version 1.4\n"); 
      scan__test(T__15 /* ( */, &dir_stop);
      scan__();
      scan__test(T__INTEGER, &dir_stop);
      scan__();
      scan__test(T__16 /* ) */, &dir_stop);
      scan__();
    }
    else
    if (scan__test(T__INTERPRETER, NULL))
    {
      scan__test(T__INTERPRETER, &dir_stop);
      scan__();
       text__message(TEXT__ERROR_ECHO, "obsolete directive: INTERPRETER mode deleted at version 1.4\n"); 
      scan__test(T__15 /* ( */, &dir_stop);
      scan__();
      scan__test(T__INTEGER, &dir_stop);
      scan__();
      scan__test(T__16 /* ) */, &dir_stop);
      scan__();
    }
    scan__test_set(&dir_stop, &dir_stop);
  }
}

static rdp__data* item_inl(void)
{
  rdp__data* result;
  char* name;
  long int pass;
  rdp__list* body;
  char* delimiter;
  if (scan__test_set(&item_inl_first, &item_inl_stop))
  {
    if (scan__test(T__ICOMMENT_VISIBLE, NULL))
    {
      name = code();
      if (rdp__pass == 2) { \
 result = rdp__find(name, K__CODE, RDP__ANY); \
                        result->contains_null = 1; \
                        result->call_count++; /* increment call count */ \
                      \
}
      if (scan__test(T__24 /* @ */, NULL))
      {
        scan__test(T__24 /* @ */, &item_inl_stop);
        scan__();
        pass = SCAN__CAST->data.i;
        scan__test(T__INTEGER, &item_inl_stop);
        scan__();
        if (rdp__pass == 2) { \
 result->code_pass = (unsigned) pass;  \
}
      }
    }
    else
    if (scan__test(T__15 /* ( */, NULL))
    {
      scan__test(T__15 /* ( */, &item_inl_stop);
      scan__();
      body = alt();
      scan__test(T__16 /* ) */, &item_inl_stop);
      scan__();
      if (rdp__pass == 2) { \
 result = rdp__find(text__insert_substring(rdp__primary_id, rdp__component++), K__DO_FIRST, RDP__ANY); \
                        result->list = body; \
                        result->call_count++; \
                      \
}
    }
    else
    if (scan__test(T__62 /* { */, NULL))
    {
      scan__test(T__62 /* { */, &item_inl_stop);
      scan__();
      body = alt();
      scan__test(T__64 /* } */, &item_inl_stop);
      scan__();
      if (rdp__pass == 2) { \
 result = rdp__find(text__insert_substring(rdp__primary_id, rdp__component++), K__ITERATION, RDP__ANY); \
                        result->list = body; result->contains_null = 1; \
                        result->call_count++; \
                      \
}
    }
    else
    if (scan__test(T__60 /* [ */, NULL))
    {
      scan__test(T__60 /* [ */, &item_inl_stop);
      scan__();
      body = alt();
      scan__test(T__61 /* ] */, &item_inl_stop);
      scan__();
      if (rdp__pass == 2) { \
 result = rdp__find(text__insert_substring(rdp__primary_id, rdp__component++), K__CONDITIONAL, RDP__ANY); \
                        result->list = body; result->contains_null = 1; \
                        result->call_count++; \
                      \
}
    }
    else
    if (scan__test(T__22 /* < */, NULL))
    {
      scan__test(T__22 /* < */, &item_inl_stop);
      scan__();
      body = alt();
      scan__test(T__23 /* > */, &item_inl_stop);
      scan__();
      delimiter = token();
      if (rdp__pass == 2) { \
 result = rdp__find(text__insert_substring(rdp__primary_id, rdp__component++), K__LIST, RDP__ANY); \
                        result->list = body; \
                        result->supplementary_token = rdp__find(delimiter, K__TOKEN, RDP__ANY); \
                        result->call_count++; \
                      \
}
    }
    scan__test_set(&item_inl_stop, &item_inl_stop);
  }
  return result;
}

static rdp__data* item_ret(void)
{
  rdp__data* result;
  char* name;
  char* quote;
  char* close;
  if (scan__test_set(&item_ret_first, &item_ret_stop))
  {
    if (scan__test(T__ID, NULL))
    {
      name = SCAN__CAST->id;
      scan__test(T__ID, &item_ret_stop);
      scan__();
      if (rdp__pass == 2) { \
 result = rdp__find(name, K__PRIMARY, RDP__OLD); \
                                  rdp__check_eoln(name); \
                                  result->call_count++; /* increment call count */ \
                                  result->actuals = NULL; \
                                \
} if (rdp__pass == 2 && result->parameterised ) { 
      scan__test(T__15 /* ( */, &item_ret_stop);
      scan__();
      while (scan__test(T__ID, NULL))
      {
         rdp__param_list *param = NULL; 
        name = SCAN__CAST->id;
        scan__test(T__ID, &item_ret_stop);
        scan__();
        if (rdp__pass == 2) { \
 param = (rdp__param_list* ) mem__calloc(sizeof(rdp__param_list), 1); \
                                param->id = name; \
                                param->next = result->actuals; \
                                result->actuals = param; \
                              \
}
      }
      scan__test(T__16 /* ) */, &item_ret_stop);
      scan__();
       } 
    }
    else
    if (scan__test(T__ISTRING_ESC, NULL))
    {
      name = token();
      if (rdp__pass == 2) { \
 rdp__check_token_valid(name); \
                                     result = rdp__find(name, K__TOKEN, RDP__ANY); \
                                     result->call_count++; /* increment call count */ \
                                   \
}
    }
    else
    if (scan__test(T__STRING, NULL))
    {
      scan__test(T__STRING, &item_ret_stop);
      scan__();
      scan__test(T__15 /* ( */, &item_ret_stop);
      scan__();
      name = token();
      scan__test(T__16 /* ) */, &item_ret_stop);
      scan__();
      if (rdp__pass == 2) { \
 result = rdp__find_extended(name, NULL, T__ISTRING);  \
}
    }
    else
    if (scan__test(T__STRING_ESC, NULL))
    {
      scan__test(T__STRING_ESC, &item_ret_stop);
      scan__();
      scan__test(T__15 /* ( */, &item_ret_stop);
      scan__();
      name = token();
      quote = token();
      scan__test(T__16 /* ) */, &item_ret_stop);
      scan__();
      if (rdp__pass == 2) { \
 result = rdp__find_extended(name, quote, T__ISTRING_ESC);  \
}
    }
    else
    if (scan__test(T__COMMENT, NULL))
    {
      scan__test(T__COMMENT, &item_ret_stop);
      scan__();
      scan__test(T__15 /* ( */, &item_ret_stop);
      scan__();
      name = token();
      close = token();
      scan__test(T__16 /* ) */, &item_ret_stop);
      scan__();
      if (rdp__pass == 2) { \
 result = rdp__find_extended(name, close, T__ICOMMENT);  \
}
    }
    else
    if (scan__test(T__COMMENT_VISIBLE, NULL))
    {
      scan__test(T__COMMENT_VISIBLE, &item_ret_stop);
      scan__();
      scan__test(T__15 /* ( */, &item_ret_stop);
      scan__();
      name = token();
      close = token();
      scan__test(T__16 /* ) */, &item_ret_stop);
      scan__();
      if (rdp__pass == 2) { \
 result = rdp__find_extended(name, close, T__ICOMMENT_VISIBLE);  \
}
    }
    else
    if (scan__test(T__COMMENT_NEST, NULL))
    {
      scan__test(T__COMMENT_NEST, &item_ret_stop);
      scan__();
      scan__test(T__15 /* ( */, &item_ret_stop);
      scan__();
      name = token();
      close = token();
      scan__test(T__16 /* ) */, &item_ret_stop);
      scan__();
      if (rdp__pass == 2) { \
 result = rdp__find_extended(name, close, T__ICOMMENT_NEST);  \
}
    }
    else
    if (scan__test(T__COMMENT_NEST_VISIBLE, NULL))
    {
      scan__test(T__COMMENT_NEST_VISIBLE, &item_ret_stop);
      scan__();
      scan__test(T__15 /* ( */, &item_ret_stop);
      scan__();
      name = token();
      close = token();
      scan__test(T__16 /* ) */, &item_ret_stop);
      scan__();
      if (rdp__pass == 2) { \
 result = rdp__find_extended(name, close, T__ICOMMENT_NEST_VISIBLE);  \
}
    }
    else
    if (scan__test(T__COMMENT_LINE, NULL))
    {
      scan__test(T__COMMENT_LINE, &item_ret_stop);
      scan__();
      scan__test(T__15 /* ( */, &item_ret_stop);
      scan__();
      name = token();
      scan__test(T__16 /* ) */, &item_ret_stop);
      scan__();
      if (rdp__pass == 2) { \
 result = rdp__find_extended(name, NULL, T__ICOMMENT_LINE);  \
}
    }
    else
    if (scan__test(T__COMMENT_LINE_VISIBLE, NULL))
    {
      scan__test(T__COMMENT_LINE_VISIBLE, &item_ret_stop);
      scan__();
      scan__test(T__15 /* ( */, &item_ret_stop);
      scan__();
      name = token();
      scan__test(T__16 /* ) */, &item_ret_stop);
      scan__();
      if (rdp__pass == 2) { \
 result = rdp__find_extended(name, NULL, T__ICOMMENT_LINE_VISIBLE);  \
}
    }
    else
    if (scan__test(T__NUMBER, NULL))
    {
      scan__test(T__NUMBER, &item_ret_stop);
      scan__();
       text__message(TEXT__ERROR_ECHO, "obsolete scanner primitive: NUMBER renamed INTEGER at version 1.3\n"); 
    }
    else
    if (scan__test(T__NEW_ID, NULL))
    {
      scan__test(T__NEW_ID, &item_ret_stop);
      scan__();
       text__message(TEXT__ERROR_ECHO, "obsolete scanner primitive: NEW_ID deleted at version 1.4\n"); 
    }
    else
    if (scan__test(T__ALT_ID, NULL))
    {
      scan__test(T__ALT_ID, &item_ret_stop);
      scan__();
       text__message(TEXT__ERROR_ECHO, "obsolete scanner primitive: ALT_ID deleted at version 1.4\n"); 
    }
    scan__test_set(&item_ret_stop, &item_ret_stop);
  }
  return result;
}

static rdp__data* prod(void)
{
  rdp__data* result;
  char* name;
  char* type;
  rdp__list* body;
  if (scan__test(T__ID, &prod_stop))
  {
     unsigned stars = 0; type = "void"; 
    name = SCAN__CAST->id;
    scan__test(T__ID, &prod_stop);
    scan__();
     rdp__primary_id = name; rdp__component = 0; \
                      result = rdp__find(rdp__primary_id, K__PRIMARY, rdp__pass == 1 ? RDP__NEW : RDP__OLD); \
                      if (rdp__start_prod == NULL) \
                      { \
                        rdp__start_prod = result; \
                        result->call_count++; \
                      } \
                   
    if (scan__test(T__15 /* ( */, NULL))
    {
      scan__test(T__15 /* ( */, &prod_stop);
      scan__();
       result->parameterised = 1; 
      while (scan__test(T__ID, NULL))
      {
         rdp__param_list *param = NULL; type = "void"; 
        name = SCAN__CAST->id;
        scan__test(T__ID, &prod_stop);
        scan__();
        if (scan__test(T__19 /* : */, NULL))
        {
          scan__test(T__19 /* : */, &prod_stop);
          scan__();
          type = SCAN__CAST->id;
          scan__test(T__ID, &prod_stop);
          scan__();
        }
        if (rdp__pass == 1) { \
 param = (rdp__param_list* ) mem__calloc(sizeof(rdp__param_list), 1); \
                             param->id = name; \
                             param->type = type; \
                             param->next = result->params; \
                             result->params = param; \
                           \
}
      }
      scan__test(T__16 /* ) */, &prod_stop);
      scan__();
    }
     type = "void"; stars = 0; 
    if (scan__test(T__19 /* : */, NULL))
    {
      scan__test(T__19 /* : */, &prod_stop);
      scan__();
      type = SCAN__CAST->id;
      scan__test(T__ID, &prod_stop);
      scan__();
      while (scan__test(T__17 /* * */, NULL))
      {
        scan__test(T__17 /* * */, &prod_stop);
        scan__();
         stars++; 
      }
    }
    scan__test(T__21 /* ::= */, &prod_stop);
    scan__();
    body = alt();
    if (rdp__pass == 2) { \
 result->list = body; \
                                     result->been_defined = 1; \
                                     result->return_type = type; \
                                     result->return_type_stars = stars; \
                                   \
}
    scan__test(T__18 /* . */, &prod_stop);
    scan__();
    scan__test_set(&prod_stop, &prod_stop);
  }
  return result;
}

static rdp__list* seq(void)
{
  rdp__list* result;
  rdp__data* body;
  char* ret_name;
  if (scan__test_set(&seq_first, &seq_stop))
  {
     rdp__list* end; if (rdp__pass == 2) { \
 end = result = (rdp__list*) mem__calloc(sizeof(rdp__list), 1);  \
}
if (rdp__pass == 2) { \
 ret_name = NULL;  \
}
    {
      if (scan__test_set(&seq__2_first, NULL))
      {
        body = item_ret();
        if (scan__test(T__19 /* : */, NULL))
        {
          scan__test(T__19 /* : */, &seq_stop);
          scan__();
          ret_name = SCAN__CAST->id;
          scan__test(T__ID, &seq_stop);
          scan__();
        }
      }
      else
      if (scan__test_set(&seq__3_first, NULL))
      {
        body = item_inl();
      }
    }
    if (rdp__pass == 2) { \
 end->next = (rdp__list*) mem__calloc(sizeof(rdp__list), 1); \
                      end = end->next; \
                      end->production = body; \
                      end->actuals = body->actuals; \
                      end->return_name = ret_name; \
                    \
}
    while (scan__test_set(&seq__11_first, NULL))
    {
if (rdp__pass == 2) { \
 ret_name = NULL;  \
}
      {
        if (scan__test_set(&seq__7_first, NULL))
        {
          body = item_ret();
          if (scan__test(T__19 /* : */, NULL))
          {
            scan__test(T__19 /* : */, &seq_stop);
            scan__();
            ret_name = SCAN__CAST->id;
            scan__test(T__ID, &seq_stop);
            scan__();
          }
        }
        else
        if (scan__test_set(&seq__8_first, NULL))
        {
          body = item_inl();
        }
      }
      if (rdp__pass == 2) { \
 end->next = (rdp__list*) mem__calloc(sizeof(rdp__list), 1); \
                        end = end->next; \
                        end->production = body; \
                        end->actuals = body->actuals; \
                        end->return_name = ret_name; \
                      \
}
    }
    if (rdp__pass == 2) { \
 result = result->next;  \
}
    scan__test_set(&seq_stop, &seq_stop);
  }
  return result;
}

static char* token(void)
{
  char* result;
  if (scan__test(T__ISTRING_ESC, &token_stop))
  {
    result = SCAN__CAST->id;
    scan__test(T__ISTRING_ESC, &token_stop);
    scan__();
    scan__test_set(&token_stop, &token_stop);
  }
  return result;
}

void unit(void)
{
  if (scan__test_set(&unit_first, NULL))
  {
    while (scan__test_set(&unit__2_first, NULL))
    {
      if (scan__test(T__ID, NULL))
      {
        prod();
      }
      else
      if (scan__test_set(&unit__1_first, NULL))
      {
        dir();
      }
    }
    scan__test_set(&unit_stop, &unit_stop);
  }
}

int main(int argc, char *argv[])
{
  clock_t rdp__finish_time, rdp__start_time = clock();
  unsigned
    rdp__tabwidth = 8,            /* tab expansion width */
    rdp__symbol_statistics = 0,    /* show symbol__ table statistics flag */
    rdp__line_echo = 0;            /* make listing flag */

  unsigned long rdp__textsize = 30000;   /* size of scanner text array */

  while (--argc > 0)
  {
     if ((*++argv)[0] == '-')      /* switch */
     {
       switch ((*argv)[1])
       {
         case 'f': /* filter mode */
           rdp__sourcefilename = "-";
           rdp__outputfilename = "-";
           break;
         case 'o':
           if (*(*argv + 2) != 0)
           rdp__outputfilename = *argv + 2;
           break;
         case 'S':
           rdp__symbol_statistics = 1;
           break;
         case 's':
           rdp__symbol_echo = 1;
           break;
         case 'l':
           rdp__line_echo = 1;
           break;
         case 't':
           sscanf(*argv + 2, "%u", &rdp__tabwidth);
           break;
         case 'T':
           sscanf(*argv + 2, "%lu", &rdp__textsize);
           break;
         case 'v':
           rdp__verbose = 1;
           break;
         case 'e':
            rdp__expanded = 1; 
           break;
         case 'E':
            rdp__error_production_name = 1; 
           break;
         case 'F':
            rdp__force = 1; 
           break;
         case 'p':
            rdp__parser_only = 1; 
           break;
         default:
           text__printf("\nUnrecognised option -%c", (*argv)[1]);
           rdp__help("");
       }
     }
   else
     rdp__sourcefilename = *argv;
  }
  if (rdp__sourcefilename == NULL)
     rdp__help("No source file specified");
  text__init((size_t) rdp__textsize, 50, 120, rdp__tabwidth);
  scan__init(0, 0, 1, rdp__symbol_echo, rdp__tokens);
  locals = symbol__new_table("locals", 101, 31, symbol__compare_string, symbol__hash_string, symbol__print_string);
  codes = symbol__new_table("codes", 101, 31, symbol__compare_string, symbol__hash_string, symbol__print_string);
  tokens = symbol__new_table("tokens", 101, 31, symbol__compare_string, symbol__hash_string, symbol__print_string);
  rdp = symbol__new_table("rdp", 101, 31, symbol__compare_string, symbol__hash_string, symbol__print_string);
  rdp__set_initialise();
  rdp__load_keywords();
  if (rdp__verbose)
     text__printf("\nRecursive descent parser generator V1.40 (c) Adrian Johnstone 1995\nGenerated on Feb 13 1995 at 07:53:50 and compiled on " __DATE__ " at " __TIME__ "\n\n");
   rdp__pre_parse(); 
  for (rdp__pass = 1; rdp__pass <= 2; rdp__pass++)
  {
    if (text__total_errors() != 0)
      text__message(TEXT__FATAL, "errors detected in source file\n");   /* crash quietly */ 
    text__echo(rdp__line_echo && rdp__pass == 2);
    if (text__open(text__default_filetype(rdp__sourcefilename, "bnf")) == NULL)
      rdp__help("Can't open source file");

    text__get_char();
    scan__();

    unit();            /* call parser at top level */
  }
  if (rdp__symbol_statistics)
    symbol__print_all_table_statistics(11);
   rdp__post_parse(rdp__outputfilename, rdp__force); 
  if (rdp__verbose)
  {
    rdp__finish_time = clock();
    text__message(TEXT__INFO, "%f CPU seconds used\n", ((double) (rdp__finish_time-rdp__start_time)) / CLOCKS_PER_SEC);
  }
  return rdp__error_return;
}

/* End of rdp.c */
