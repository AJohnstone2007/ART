/*******************************************************************************
*
* Parser generated by RDP on May 16 2016 14:55:49 from tg.bnf
*
*******************************************************************************/
#include <time.h>
#include "ctype.h"
#include "tg.h"

char
  *rdp_sourcefilename,          /* current source file name */
  **rdp_sourcefilenames,        /* array of source file names */
  *rdp_outputfilename = "tg.out";         /* output file name */

int
  rdp_symbol_echo = 0,                 /* symbol echo flag */
  rdp_verbose = 0,                     /* verbosity flag */
  rdp_sourcefilenumber,                /* Source file counter */
  rdp_pass;                            /* pass number */

int rdp_error_return = 0;              /* return value for main routine */

char *rdp_tokens = "IGNORE\0" 
"ID\0" "INTEGER\0" "REAL\0" "CHAR\0" "CHAR_ESC\0" "STRING\0" "STRING_ESC\0" "COMMENT\0" 
"COMMENT_VISIBLE\0" "COMMENT_NEST\0" "COMMENT_NEST_VISIBLE\0" "COMMENT_LINE\0" "COMMENT_LINE_VISIBLE\0" "EOF\0" "EOLN\0" "'$'\0" 
"'('\0" "'(*'\0" "'accept'\0" "'reject'\0" "'{'\0" ;


/* Load keywords */
static void rdp_load_keywords(void)
{
  scan_load_keyword("$", "\\", RDP_T_36 /* $ */, SCAN_P_STRING_ESC);
  scan_load_keyword("(", NULL, RDP_T_40 /* ( */, SCAN_P_IGNORE);
  scan_load_keyword("(*", "*)", RDP_T_4042 /* (* */, SCAN_P_COMMENT_NEST);
  scan_load_keyword("accept", NULL, RDP_T_accept, SCAN_P_IGNORE);
  scan_load_keyword("reject", NULL, RDP_T_reject, SCAN_P_IGNORE);
  scan_load_keyword("{", "}", RDP_T_123 /* { */, SCAN_P_COMMENT_VISIBLE);
}

/* Set declarations */

  set_ comment_stop = SET_NULL;
  set_ options_stop = SET_NULL;
  set_ string_stop = SET_NULL;
  set_ tests_stop = SET_NULL;

/* Initialise sets */

static void rdp_set_initialise(void)
{
  set_assign_list(&comment_stop, SCAN_P_EOF,SET_END);
  set_assign_list(&options_stop, SCAN_P_EOF, RDP_T_36 /* $ */,SET_END);
  set_assign_list(&string_stop, SCAN_P_ID, SCAN_P_EOF, RDP_T_36 /* $ */, RDP_T_accept, RDP_T_reject,SET_END);
  set_assign_list(&tests_stop, SCAN_P_EOF,SET_END);
}

/* Parser forward declarations and macros */
static char* options(void);
static char* string(void);
void tests(void);

/* Parser functions */
static char* options(void)
{
  char* result;
  {
    scan_test(NULL, RDP_T_123 /* { */, &options_stop);
    result = SCAN_CAST->id;
    scan_();
    scan_test_set(NULL, &options_stop, &options_stop);
   }
  return result;
}

static char* string(void)
{
  char* result;
  {
    scan_test(NULL, RDP_T_36 /* $ */, &string_stop);
    result = SCAN_CAST->id;
    scan_();
    scan_test_set(NULL, &string_stop, &string_stop);
   }
  return result;
}

void tests(void)
{
  char* filename;
  char* opt;
  char* grammar;
  char* s;
  {
     char tmp[1000]; FILE *f; 
    if (scan_test(NULL, SCAN_P_ID, NULL))
    { /* Start of rdp_tests_11 */
      while (1)
      {
        {
           int count = 1; 
          scan_test(NULL, SCAN_P_ID, &tests_stop);
          filename = SCAN_CAST->id;
          scan_();
          if (scan_test(NULL, RDP_T_123 /* { */, NULL))
          { /* Start of rdp_tests_1 */
            while (1)
            {
              {
                opt = options();
                }
              break;   /* hi limit is 1! */
            }
          } /* end of rdp_tests_1 */
          else
          {
            /* default action processing for rdp_tests_1*/
opt=NULL;
          }
          grammar = string();
          \
                if ((f=fopen(text_force_filetype(filename, "art"), "r")) != NULL)\
                  text_message(TEXT_FATAL, "test '%s' already exists\n", filename);\
                text_redirect((f=fopen(text_force_filetype(filename, "art"), "w")));\
                text_printf("(* %s.art *)\n\nM()", filename);\
\
                char* startSymbol = grammar;\
                while (!(*startSymbol == 0 || (isalnum(*startSymbol) || *(startSymbol+1) == '_'))) { \
                  if (*startSymbol == '(' && *(startSymbol+1) == '*') \
                    while(!(*startSymbol == 0 || (*startSymbol == '*' && *(startSymbol+1) == ')'))) { \
                      /* printf("Comment-skipping %c\n", *startSymbol); */\
                      startSymbol++; \
                    } \
                  /* printf("Initial-skipping %c\n", *startSymbol); */ \
                  startSymbol++;        \
                }                \
\
                char* startSymbolSuccessor = startSymbol;\
                while (*startSymbolSuccessor != 0 && isalnum(*startSymbolSuccessor) || *startSymbolSuccessor == '_') \
                  startSymbolSuccessor++;\
\
                char tmpChar = *startSymbolSuccessor;\
                *startSymbolSuccessor = 0;\
                text_printf("(%s)", startSymbol);\
                *startSymbolSuccessor = tmpChar;\
\
                if (opt != NULL)\
                  text_printf(" { %s }", opt);\
                text_printf("\n\n%s\n", grammar);\
                fclose(f);\
                text_redirect(stdout);\
             
          if (scan_test(NULL, RDP_T_accept, NULL))
          { /* Start of rdp_tests_5 */
            while (1)
            {
              {
                scan_test(NULL, RDP_T_accept, &tests_stop);
                scan_();
                if (scan_test(NULL, RDP_T_36 /* $ */, NULL))
                { /* Start of rdp_tests_3 */
                  while (1)
                  {
                    {
                      s = string();
                      \
                 sprintf(tmp, "%s.acc_%i", filename, count++);\
                 text_redirect(f=fopen(tmp, "w"));\
                 text_printf("%s", s);\
                 fclose(f);\
                 text_redirect(stdout);\
               
                      }
                    if (!scan_test(NULL, RDP_T_36 /* $ */, NULL)) break;
                  }
                } /* end of rdp_tests_3 */
                }
              break;   /* hi limit is 1! */
            }
          } /* end of rdp_tests_5 */
          if (scan_test(NULL, RDP_T_reject, NULL))
          { /* Start of rdp_tests_9 */
            while (1)
            {
              {
                scan_test(NULL, RDP_T_reject, &tests_stop);
                scan_();
                if (scan_test(NULL, RDP_T_36 /* $ */, NULL))
                { /* Start of rdp_tests_7 */
                  while (1)
                  {
                    {
                      s = string();
                      \
                 sprintf(tmp, "%s.rej_%i", filename, count++);\
                 text_redirect(f=fopen(tmp, "w"));\
                 text_printf("%s", s);\
                 fclose(f);\
                 text_redirect(stdout);\
               
                      }
                    if (!scan_test(NULL, RDP_T_36 /* $ */, NULL)) break;
                  }
                } /* end of rdp_tests_7 */
                }
              break;   /* hi limit is 1! */
            }
          } /* end of rdp_tests_9 */
          }
        if (!scan_test(NULL, SCAN_P_ID, NULL)) break;
      }
    } /* end of rdp_tests_11 */
    scan_test_set(NULL, &tests_stop, &tests_stop);
   }
}

int main(int argc, char *argv[])
{
  clock_t rdp_finish_time, rdp_start_time = clock();
  int
    rdp_symbol_statistics = 0,    /* show symbol_ table statistics flag */
    rdp_line_echo_all = 0,        /* make a listing on all passes flag */
    rdp_filter = 0,               /* filter flag */
    rdp_line_echo = 0,            /* make listing flag */

    rdp_lexicalise = 0;            /* print lexicalised output flag */

  unsigned long rdp_textsize = 10000000l;   /* size of scanner text array */

  unsigned long rdp_tabwidth = 8l;   /* tab expansion width */

  char* rdp_vcg_filename = NULL;      /* filename for -V option */

  arg_message("rdparser\n" RDP_STAMP "\n\n""Usage: tg [options] source");

  arg_message("");
  arg_boolean('f', "Filter mode (read from stdin and write to stdout)", &rdp_filter);
  arg_boolean('l', "Make a listing", &rdp_line_echo);
  arg_boolean('L', "Print lexicalised source file", &rdp_lexicalise);
  arg_string ('o', "Write output to filename", &rdp_outputfilename);
  arg_boolean('s', "Echo each scanner symbol as it is read", &rdp_symbol_echo);
  arg_boolean('S', "Print summary symbol table statistics", &rdp_symbol_statistics);
  arg_numeric('t', "Tab expansion width (default 8)", &rdp_tabwidth);
  arg_numeric('T', "Text buffer size in bytes for scanner (default 20000)", &rdp_textsize);
  arg_boolean('v', "Set verbose mode", &rdp_verbose);
  arg_string ('V', "Write derivation tree to filename in VCG format", &rdp_vcg_filename);

  rdp_sourcefilenames = arg_process(argc, argv);

  /* Fix up filetypes */
  for (rdp_sourcefilenumber = 0; rdp_sourcefilenames[rdp_sourcefilenumber] != NULL; rdp_sourcefilenumber++)
    rdp_sourcefilenames[rdp_sourcefilenumber] = text_default_filetype(rdp_sourcefilenames[rdp_sourcefilenumber], "");

  if (rdp_filter)
  {
    rdp_sourcefilenames[0] = "-";
    rdp_outputfilename = "-";
    rdp_sourcefilenames[1] = NULL;     /* make sure no further filenames are taken from the array */

  }
  if ((rdp_sourcefilename = rdp_sourcefilenames[0]) == NULL)
     arg_help("no source files specified");

  if (rdp_sourcefilenames[1] != NULL)
    arg_help("multiple source files not allowed\n");
  text_init(rdp_textsize, 25, 100, (int) rdp_tabwidth);
  scan_init(0, 0, 0, rdp_symbol_echo, rdp_tokens);
  if (rdp_lexicalise)
    scan_lexicalise();
  rdp_set_initialise();
  rdp_load_keywords();
  if (rdp_verbose)
     text_printf("\nrdparser\n" RDP_STAMP "\n\n");
  for (rdp_pass = 1; rdp_pass <= RDP_PASSES; rdp_pass++)
  {
    text_echo(rdp_line_echo_all || (rdp_line_echo && rdp_pass == RDP_PASSES));

    for (rdp_sourcefilenumber = 0; (rdp_sourcefilename = rdp_sourcefilenames[rdp_sourcefilenumber]) != NULL; rdp_sourcefilenumber++)
    {
      if (text_open(rdp_sourcefilename) == NULL)
        arg_help("unable to open source file");

      text_get_char();
      scan_();

      tests();            /* call parser at top level */
      if (text_total_errors() != 0)
        text_message(TEXT_FATAL, "error%s detected in source file '%s'\n", text_total_errors() == 1 ? "" : "s", rdp_sourcefilename);   /* crash quietly */ 
    }
  }

  rdp_sourcefilename = rdp_sourcefilenames[0];     /* Reset filename to first file in the list */

  if (rdp_symbol_statistics)
  {
    symbol_print_all_table_statistics(11);
    symbol_print_all_table();

  }
  text_print_total_errors();
  if (rdp_verbose)
  {
    rdp_finish_time = clock();
    text_message(TEXT_INFO, "%.3f CPU seconds used\n", ((double) (rdp_finish_time-rdp_start_time)) / CLOCKS_PER_SEC);
  }
  return rdp_error_return;
}

/* End of tg.c */
