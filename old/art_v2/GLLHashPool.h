/******************************************************************************
 * GLLHashPool.h
 *
 * An abstract class which defines concrete support methods for GLL parsers
 * generated by the ART tool.
 *
 * In this version we suppress type information and treat all of our objects as
 * indices into an integer array. This parallels the Java GLLHashPool
 *
 * (c) Adrian Johnstone 2013
 *****************************************************************************/
/**************************************************************************
 * Debug message control
 *************************************************************************/

#include "bccgcc.h"
#include "Text.h"
#include <math.h>
#if defined(STATISTICS)
#include "GLLHistogram.h"
#endif

#if defined(RUSAGE)
#include <sys/resource.h>
#endif

enum artFold {ART_FOLD_EMPTY, ART_FOLD_NONE, ART_FOLD_UNDER, ART_FOLD_OVER, ART_FOLD_TEAR, ART_FOLD_UNDER_RECURSION, ART_FOLD_OVER_RECURSION};
//NB the static constants are moved out of the class because the Borland linker hides them from the subclasses; probably a bug from this early compiler
	/**************************************************************************
	 * Node kind enumeration elements
	 *************************************************************************/
  static const int ART_K_ILLEGAL = 0;
  static const int ART_K_EOS = 1;
  static const int ART_K_EPSILON = 2;
  static const int ART_K_BUILTIN_TERMINAL = 3;
  static const int ART_K_CHARACTER_TERMINAL = 4;
  static const int ART_K_CASE_SENSITIVE_TERMINAL = 5;
  static const int ART_K_CASE_INSENSITIVE_TERMINAL = 6;
  static const int ART_K_NONTERMINAL = 7;
  static const int ART_K_INTERMEDIATE = 8;
  static const int ART_K_END_OF_RULE = 9;
  static const int ART_K_DO_FIRST = 10;
  static const int ART_K_OPTIONAL = 11;
  static const int ART_K_POSITIVE_CLOSURE = 12;
  static const int ART_K_KLEENE_CLOSURE = 13;

	/**************************************************************************
	 * Pool constants
	 *************************************************************************/
 	static const int poolBlockInitialCount = 1024;
	// poolAddressOffset must be a power of 2
	static const int poolAddressOffset = 16;
	static const int poolBlockSize = 1 << poolAddressOffset;
	static const int poolAddressMask = poolBlockSize - 1;

//  static const int bucketInitial = 65536;
//  static const int bucketInitial = 1000000;
    static const int bucketInitial = 1000003;
//  static const int hashPrime = 1299827; // A large prime
  static const int hashPrime = 1013;
	static const int sppfNodeBucketInitialCount = 1122281;
	static const int sppfPackNodeBucketInitialCount = 1125679;
	static const int gssNodeBucketInitialCount = 2541811;
	static const int gssEdgeBucketInitialCount = /*12785579*/ 26122469;
	static const int popElementBucketInitialCount = 2220839;
	static const int descriptorBucketInitialCount = 26122469;
	static const int testRepeatElementBucketInitialCount = bucketInitial;
	static const int clusterElementBucketInitialCount = 1047031;

// Do not change anything below this line

  static const int renderKindIllegal = 0;
  static const int renderKindSPPF = 1;
  static const int renderKindSPPFFull = 2;
  static const int renderKindDerivation = 3;
  static const int renderKindGSS = 4;

  /**
   * Constant field offsets for each kind
   */

  // Offset zero is link to next in hash chain
  static const int sppfNode_label = 1; // Negative if visited
  static const int sppfNode_leftExtent = 2;
  static const int sppfNode_rightExtent = 3;
  static const int sppfNode_packNodeList = 4; // Negative if selected
  static const int sppfNode_SIZE = 5;

  // Offset zero is link to next in hash chain
  static const int sppfPackNode_parent = 1;
  static const int sppfPackNode_label = 2; // Negative if visited
  static const int sppfPackNode_pivot = 3;
  static const int sppfPackNode_leftChildLabel = 4; // Negative if suppressed
  static const int sppfPackNode_rightChildLabel = 5; // Negative if selected
  static const int sppfPackNode_packNodeList = 6;
  static const int sppfPackNode_SIZE = 7;

  // Offset zero is link to next in hash chain
  static const int gssNode_label = 1;
  static const int gssNode_level = 2;
  static const int gssNode_edgeList = 3;
  static const int gssNode_pop_clusterElementList = 4;
  static const int gssNode_SIZE = 5;

  // Offset zero is link to next in hash chain
  static const int gssEdge_sppfNode = 1;
  static const int gssEdge_source = 2;
  static const int gssEdge_destination = 3;
  static const int gssEdge_edgeList = 4;
  static const int gssEdge_SIZE = 5;

  // Offset zero is link to next in hash chain
  static const int popElement_gssNode_nonterminal = 1;  // Chnge this to GSS label only!
  static const int popElement_unused_currentTokenIndex = 2; // Not needed now - delete and tidy up
  static const int popElement_sppfNode = 3;                 // gssNode level is in SPF extent
  static const int popElement_popElementList = 4;
  static const int popElement_SIZE = 5;

  // Offset zero is link to next in hash chain
  static const int descriptor_label = 1;
  static const int descriptor_gssNode = 2;
  static const int descriptor_inputIndex = 3;
  static const int descriptor_sppfNode = 4;
  static const int descriptor_descriptorList = 5;
  static const int descriptor_SIZE = 6;

  // Offset zero is link to next in hash chain
  static const int testRepeatElement_label = 1;
  static const int testRepeatElement_gssNode = 2;
  static const int testRepeatElement_inputIndex = 3;
  static const int testRepeatElement_sppfNode = 4;
  static const int testRepeatElement_SIZE = 5;

  // Offset zero is link to next in hash chain
  static const int clusterElement_label = 1; // A nonterminal
  static const int clusterElement_index = 2; // An offset into the string, aka level
  static const int clusterElement_nodeList = 3; // The list of nodes in this cluster
  static const int clusterElement_inEdgeList = 4; // The list of nodes and edge labels that connect to nodes in this cluster
  static const int clusterElement_popList = 5; // The list of SPPF labels on pops that have been done involving this cluster
  static const int clusterElement_SIZE = 6;

  // Offset zero does not need to be reserved since there is no hash table for cluster inedges - the gssEdge table manages uniqueness
  static const int clusterInEdge_source = 0;
  static const int clusterInEdge_sppfNode = 1;
  static const int clusterInEdge_inEdgeList = 2; // The list of nodes and edge labels that connect to nodes in this cluster
  static const int clusterInEdge_SIZE = 3;

  // Offset zero does not need to be reserved since there is no hash table for cluster pops - the popElement table manages uniqueness
  static const int clusterPopElement_sppfNode = 0;
  static const int clusterPopElement_popList = 1;
  static const int clusterPopElement_SIZE = 2;

class GLLHashPool {
  public:

#include "GLLEnum.h"

/**************************************************************************
 * Parser global variables
 *************************************************************************/
  protected:
  Text* text;
  const char* characterStringInput;
  int characterStringInputIndex;

  int inputLength;
  int* inputToCharacterStringMap;
  int* inputExtents;
  int* inputSets;
  int* inputSetBuffer;
  int currentInputPairReference;
  int currentInputIndex;

  const char* grammarName;
  int defaultStartSymbolLabel;
  int startSymbolLabel;
  const char* buildOptions;

  bool inLanguage;

  public:
  long primaryPops;
  long contingentPops;
  long poppingDescriptors;
  long nonpoppingDescriptors;

  long softPageFaults;
  long hardPageFaults;

  long hashCollisions;
  long hashTableResizes;

  protected:
  double hashMult;
  int hashMultInt;

  clock_t startTime;
  clock_t stopTime;
#if defined(NANOSECOND)
public:
  timespec startTime_CLOCK_MONOTONIC;
  timespec stopTime_CLOCK_MONOTONIC;
  timespec startTime_CLOCK_PROCESS_CPUTIME_ID;
  timespec stopTime_CLOCK_PROCESS_CPUTIME_ID;

static double compositeDelay(timespec startTime, timespec stopTime){
  double compositeStartTime = (double) startTime.tv_sec + (1E-9 * (double) startTime.tv_nsec);
  double compositeStopTime = (double) stopTime.tv_sec + (1E-9 * (double) stopTime.tv_nsec);

  return compositeStopTime - compositeStartTime;
}
#endif

#if defined(RUSAGE)
public:
  rusage startUsage, stopUsage;
#endif

#if defined(STATISTICS)
public:
  long unsigned sppfNodeCardinality;
  long unsigned sppfNodeFinds;
  void incSPPFNodeFinds() {
    sppfNodeFinds++;
  }


  long unsigned overallCardinality;
  long unsigned sppfPackNodeCardinality;
  long unsigned sppfPackNodeFinds;
  long unsigned gssNodeCardinality;
  long unsigned gssNodeFinds;
  long unsigned gssEdgeCardinality;
  long unsigned gssEdgeFinds;
  long unsigned popElementCardinality;
  long unsigned popElementFinds;
  long unsigned descriptorCardinality;
  long unsigned descriptorFinds;
  long unsigned testRepeatElementCardinality;
  long unsigned testRepeatElementFinds;
  long unsigned clusterElementCardinality;
  long unsigned clusterElementFinds;
  GLLHistogram* overallHistogram;
  GLLHistogram* sppfNodeHistogram;
  GLLHistogram* sppfPackNodeHistogram;
  GLLHistogram* gssNodeHistogram;
  GLLHistogram* gssEdgeHistogram;
  GLLHistogram* popElementHistogram;
  GLLHistogram* descriptorHistogram;
  GLLHistogram* testRepeatElementHistogram;
  GLLHistogram* clusterElementHistogram;
  long sppfEpsilonNodes;
  long sppfTerminalNodes;
  long sppfNonterminalNodes;
  long sppfIntermediateNodes;
  long sppfOtherNodes;
  long sppfAmbiguityNodes;
  bool FIFODescriptors;
#endif

protected:
  int rootSPPFNode;
  int dummySPPFNode;
  int rootGSSNode;

  int poppingDescriptorsToBeProcessed;
  int nonpoppingDescriptorsToBeProcessed;
  int poppingDescriptorsToBeProcessedTail;
  int nonpoppingDescriptorsToBeProcessedTail;
  int currentDescriptor;
  int currentRestartLabel;
  int currentSPPFNode;
  int currentSPPFRightChildNode;
  int currentGSSNode;
  int temporarySPPFNode;

  const char** artLabelInternalStrings;
  const char** artLabelStrings;
	const char** artAnnotations;
	enum artLabel* artPreSlots;
	enum artLabel* artPostSlots;
	enum artLabel* artInstanceOfs;
  int* artKindOfs;
  enum artLabel* artUserNameOfs;
  enum artLabel* artSlotInstanceOfs;
  bool* artTerminalRequiresWhiteSpace;
  bool* artTerminalCaseInsensitive;
  enum artFold* foldL;
  enum artLabel* lhsL;
  enum artLabel* pL;
  enum artLabel* aL;
  bool* fiRL;
  bool* eoOPL;
  bool* eoRL;
  bool* eoR_pL;
  bool* popD;

  int artFirstTerminalLabel;
  int artFirstUnusedLabel;
  int artSetExtent;

	/**************************************************************************
	 * Grammar alphabet enumeration elements
	 *************************************************************************/
  int ART_L__EOS;
  int ART_L__EPSILON;
  int ART_L__ANNOTATION;
  int ART_L__DUMMY;

	/**************************************************************************
	 * An expandable pool of integers which supports sequential allocation of
	 * small blocks. There is no facility to free memory once it has been
	 * allocated.
	 *
	 * We use a 2-D array of integers organised as an array of pointers to 1-D
	 * arrays of integers called poolBlocks. Initially, only one poolBlock is
	 * allocated.
	 *
	 * Further poolBlocks are allocated as needed. If the required number of
	 * poolBlocks exceeds the capacity of pool, it is resized by 150%
	 *************************************************************************/
 	int** pool;

	int poolBlockCount; // Total number of available pool blocks
	int poolBlockTop; // Current allocation point: block number
	int poolOffsetTop; // Current allocation point: offset

	// The allocation function: check to see if the current poolBlock has enough
	// space; if not make a new one.
	void allocate(int size) {
		if (poolOffsetTop + size > poolBlockSize) { // need new poolBlock

			poolBlockTop++;

			#if defined(TRACE)
				printf("Allocating new pool block %i\n", poolBlockTop);
      #endif

			if (poolBlockTop >= poolBlockCount) { // resize pointer array
				#if defined(TRACE)
					printf("Resizing pool\n");
        #endif

				poolBlockCount += poolBlockCount / 2;
				int** newPool = new int*[poolBlockCount];
        memset(newPool, 0, poolBlockCount * sizeof(int*));

				for (int i = 0; i < poolBlockTop; i++)
					// Copy old pointers
					newPool[i] = pool[i];

				pool = newPool;
			}
			pool[poolBlockTop] = new int[poolBlockSize];
      memset(pool[poolBlockTop], 0, poolBlockSize * sizeof(int));
			poolOffsetTop = 0;
		}
		poolOffsetTop += size; // Perform the actual allocation
	}

  void allocateAndLoad(int allocationSize, int a, int b) {
    if (allocationSize != 0) {
      allocate(allocationSize);
      findOffset = poolOffsetTop - allocationSize;
      findBlockIndex = poolBlockTop;
      findBlock = pool[findBlockIndex];
      findIndex = (findBlockIndex << poolAddressOffset) | findOffset;
      findLoadOffset = findOffset;

      findBlock[findLoadOffset++] = a;
      findBlock[findLoadOffset] = b;

      #if defined(TRACE)
        printf("***,%i,%i,%s\n", findIndex, allocationSize, "allocateAndLoad");
      #endif
    }
  }

  void allocateAndLoad(int allocationSize, int a) {
    if (allocationSize != 0) {
      allocate(allocationSize);
      findOffset = poolOffsetTop - allocationSize;
      findBlockIndex = poolBlockTop;
      findBlock = pool[findBlockIndex];
      findIndex = (findBlockIndex << poolAddressOffset) | findOffset;
      findLoadOffset = findOffset;

      findBlock[findLoadOffset++] = a;

      #if defined(TRACE)
        printf("***,%i,%i,%s\n", findIndex, allocationSize, "allocateAndLoad");
      #endif
    }
  }

	int poolGet(int index) {
		return pool[index >> poolAddressOffset][index & poolAddressMask];
	}

	void poolSet(int index, int value) {
		pool[index >> poolAddressOffset][index & poolAddressMask] = value;
	}

	/**************************************************************************
	 * Hash tables: array __Buckets contains the pool index of the first element
	 * in each hash list; each element in the hash list must have the pool index
	 * of its successor in its first element.
	 *
	 * Future extension: rehash function when load factor exceeds threshold
	 *************************************************************************/
	int sppfNodeBucketCount;
	int* sppfNodeBuckets;

	int sppfPackNodeBucketCount;
	int* sppfPackNodeBuckets;

	int gssNodeBucketCount;
	int* gssNodeBuckets;

	int gssEdgeBucketCount;
	int* gssEdgeBuckets;

	int popElementBucketCount;
	int* popElementBuckets;

	int descriptorBucketCount;
	int* descriptorBuckets;

	int testRepeatElementBucketCount;
  int* testRepeatElementBuckets;

	int clusterElementBucketCount;
  int* clusterElementBuckets;

	int hashResult;

#if 0
  // Some 8-bit versions
	void hash(int hashBucketCount, int a, int b) {
    hashResult = 0;
    hashResult = hashResult * hashPrime + ( a       | 0xFF);
    hashResult = hashResult * hashPrime + ((a >> 8 )| 0xFF);
    hashResult = hashResult * hashPrime + ((a >> 16)| 0xFF);
    hashResult = hashResult * hashPrime + ((a >> 24)| 0xFF);

    hashResult = hashResult * hashPrime + ( b       | 0xFF);
    hashResult = hashResult * hashPrime + ((b >> 8 )| 0xFF);
    hashResult = hashResult * hashPrime + ((b >> 16)| 0xFF);
    hashResult = hashResult * hashPrime + ((b >> 24)| 0xFF);

    if (hashResult < 0) hashResult = -hashResult;
    hashResult %= hashBucketCount;
	}

	void hash(int hashBucketCount, int a, int b, int c) {
    hashResult = 0;
    hashResult = hashResult * hashPrime + ( a       | 0xFF);
    hashResult = hashResult * hashPrime + ((a >> 8 )| 0xFF);
    hashResult = hashResult * hashPrime + ((a >> 16)| 0xFF);
    hashResult = hashResult * hashPrime + ((a >> 24)| 0xFF);

    hashResult = hashResult * hashPrime + ( b       | 0xFF);
    hashResult = hashResult * hashPrime + ((b >> 8 )| 0xFF);
    hashResult = hashResult * hashPrime + ((b >> 16)| 0xFF);
    hashResult = hashResult * hashPrime + ((b >> 24)| 0xFF);

    hashResult = hashResult * hashPrime + ( c       | 0xFF);
    hashResult = hashResult * hashPrime + ((c >> 8 )| 0xFF);
    hashResult = hashResult * hashPrime + ((c >> 16)| 0xFF);
    hashResult = hashResult * hashPrime + ((c >> 24)| 0xFF);

    if (hashResult < 0) hashResult = -hashResult;
    hashResult %= hashBucketCount;
	}

	void hash(int hashBucketCount, int a, int b, int c, int d) {
    hashResult = 0;
    hashResult = hashResult * hashPrime + ( a       | 0xFF);
    hashResult = hashResult * hashPrime + ((a >> 8 )| 0xFF);
    hashResult = hashResult * hashPrime + ((a >> 16)| 0xFF);
    hashResult = hashResult * hashPrime + ((a >> 24)| 0xFF);

    hashResult = hashResult * hashPrime + ( b       | 0xFF);
    hashResult = hashResult * hashPrime + ((b >> 8 )| 0xFF);
    hashResult = hashResult * hashPrime + ((b >> 16)| 0xFF);
    hashResult = hashResult * hashPrime + ((b >> 24)| 0xFF);

    hashResult = hashResult * hashPrime + ( c       | 0xFF);
    hashResult = hashResult * hashPrime + ((c >> 8 )| 0xFF);
    hashResult = hashResult * hashPrime + ((c >> 16)| 0xFF);
    hashResult = hashResult * hashPrime + ((c >> 24)| 0xFF);

    hashResult = hashResult * hashPrime + ( d       | 0xFF);
    hashResult = hashResult * hashPrime + ((d >> 8 )| 0xFF);
    hashResult = hashResult * hashPrime + ((d >> 16)| 0xFF);
    hashResult = hashResult * hashPrime + ((d >> 24)| 0xFF);

    if (hashResult < 0) hashResult = -hashResult;
    hashResult %= hashBucketCount;
	}
#endif

#if 0
  // splice hashfunctions
	void hash(int hashBucketCount, int a, int b) {
		hashResult = a ^ (b << 8);

    if (hashResult < 0) hashResult = -hashResult;

		hashResult %= hashBucketCount;
	}

	void hash(int hashBucketCount, int a, int b, int c) {
		hashResult = a ^ (b << 8) ^ (c << 16);

    if (hashResult < 0) hashResult = -hashResult;

		hashResult %= hashBucketCount;
	}

	void hash(int hashBucketCount, int a, int b, int c, int d) {
		hashResult = a ^ (b << 6) ^ (c << 12) ^ (d << 18);

    if (hashResult < 0) hashResult = -hashResult;

		hashResult %= hashBucketCount;
	}
#endif

#if 0
  // multiplicative hash functions
	void hash(int hashBucketCount, int a, int b) {
		hashResult = a;
		hashResult = b + hashPrime * hashResult;

    if (hashResult < 0) hashResult = -hashResult;

		hashResult %= hashBucketCount;
	}

	void hash(int hashBucketCount, int a, int b, int c) {
		hashResult = a;
		hashResult = b + hashPrime * hashResult;
		hashResult = c + hashPrime * hashResult;


    if (hashResult < 0) hashResult = -hashResult;

		hashResult %= hashBucketCount;
	}

	void hash(int hashBucketCount, int a, int b, int c, int d) {
		hashResult = a;
		hashResult = b + hashPrime * hashResult;
		hashResult = c + hashPrime * hashResult;
		hashResult = d + hashPrime * hashResult;

    if (hashResult < 0) hashResult = -hashResult;

		hashResult %= hashBucketCount;
	}

#endif

#if 0
  // CRC hash functions
	void hash(int hashBucketCount, int a, int b) {
		hashResult = a;

    unsigned high7 = hashResult >> 25;
    hashResult = (hashResult << 7) | high7;

		hashResult ^= b;

    if (hashResult < 0) hashResult = -hashResult;

		hashResult %= hashBucketCount;
	}

	void hash(int hashBucketCount, int a, int b, int c) {
		hashResult = a;

    unsigned high7 = hashResult >> 25;
    hashResult = (hashResult << 7) | high7;

		hashResult ^= b;

    high7 = hashResult >> 25;
    hashResult = (hashResult << 7) | high7;

		hashResult ^= c;

    if (hashResult < 0) hashResult = -hashResult;

		hashResult %= hashBucketCount;
	}

	void hash(int hashBucketCount, int a, int b, int c, int d) {
		hashResult = a;

    unsigned high7 = hashResult >> 25;
    hashResult = (hashResult << 7) | high7;

		hashResult ^= b;

    high7 = hashResult >> 25;
    hashResult = (hashResult << 7) | high7;

		hashResult ^= c;

    high7 = hashResult >> 25;
    hashResult = (hashResult << 7) | high7;

		hashResult ^= d;

    if (hashResult < 0) hashResult = -hashResult;

		hashResult %= hashBucketCount;
	}
#endif

#if 0
  // plain shift hash functions for 64-bits
	void hash(int hashBucketCount, int a, int b) {
		hashResult = (a ^ (b<<32));
    if (hashResult < 0) hashResult = -hashResult;
    hashResult%= hashBucketCount;
	}

	void hash(int hashBucketCount, int a, int b, int c) {
		hashResult = ((a ^ (b<<20)) ^ (c<<40)) ^ (c >> 12);
    if (hashResult < 0) hashResult = -hashResult;
    hashResult%= hashBucketCount;
	}

	void hash(int hashBucketCount, int a, int b, int c, int d) {
		hashResult = ((a ^ (b<<16)) ^ (c<<32) ^ (d<<48)) ^ (d >> 16);
    if (hashResult < 0) hashResult = -hashResult;
    hashResult%= hashBucketCount;
	}
#endif

#if 0
  // Dan Bernstein 2
	void hash(int hashBucketCount, int a, int b) {
		hashResult = 5381;
    hashResult = ((hashResult << 5) + hashResult) ^ a;
    hashResult = ((hashResult << 5) + hashResult) ^ b;
    if (hashResult < 0) hashResult = -hashResult;
    hashResult%= hashBucketCount;
	}

	void hash(int hashBucketCount, int a, int b, int c) {
		hashResult = 5381;
    hashResult = ((hashResult << 5) + hashResult) ^ a;
    hashResult = ((hashResult << 5) + hashResult) ^ b;
    hashResult = ((hashResult << 5) + hashResult) ^ c;
    if (hashResult < 0) hashResult = -hashResult;
    hashResult%= hashBucketCount;
	}

	void hash(int hashBucketCount, int a, int b, int c, int d) {
		hashResult = 5381;
    hashResult = ((hashResult << 5) + hashResult) ^ a;
    hashResult = ((hashResult << 5) + hashResult) ^ b;
    hashResult = ((hashResult << 5) + hashResult) ^ c;
    hashResult = ((hashResult << 5) + hashResult) ^ d;
    if (hashResult < 0) hashResult = -hashResult;
    hashResult%= hashBucketCount;
	}
#endif

#if 1
  // Knuth style multiplier hash functions for 64-bits
	void hash(int hashBucketCount, int a, int b) {
		hashResult = (a + (b*hashPrime));
    if (hashResult < 0) hashResult = -hashResult;
    hashResult%= hashBucketCount;
	}

	void hash(int hashBucketCount, int a, int b, int c) {
		hashResult = ((a + (b*hashPrime)) + (c*hashPrime));
    if (hashResult < 0) hashResult = -hashResult;
    hashResult%= hashBucketCount;
	}

	void hash(int hashBucketCount, int a, int b, int c, int d) {
		hashResult = ((a + (b*hashPrime)) + (c*hashPrime) + (d*hashPrime));
    if (hashResult < 0) hashResult = -hashResult;
    hashResult%= hashBucketCount;
	}
#endif

	/**************************************************************************
	 * find functions: pool information left in these members
	 **************************************************************************/
	int findIndex; // Combined index
	int findBlockIndex; // top part of index
	int findOffset; // bottom part of index
	int* findBlock; // reference to block containing this index
	int findLoadOffset; // offset to first unused field

  bool findWithFlags(int *hashBuckets, int hashBucketCount, int allocationSize, int a, int b, int c) {
    hash(hashBucketCount, a, b, c);

    findIndex = hashBuckets[hashResult];
    do {
      findBlockIndex = findIndex >> poolAddressOffset;
      findOffset = findIndex & poolAddressMask;
      findBlock = pool[findBlockIndex];

      if (abs(a) == abs(findBlock[findOffset + 1]) && abs(b) == abs(findBlock[findOffset + 2])
          && abs(c) == abs(findBlock[findOffset + 3])) {
#if defined(TRACEFIND)
  findDiagnostic("findWithFlags3", hashBuckets, hashBucketCount, allocationSize, a, b, c, true);
#endif
        return true;
      }
      hashCollisions++;
      findIndex = findBlock[findOffset]; // Step to next
    } while (findIndex != 0);

    hashCollisions--; // If we got to here, then we fell off the end of the chain which will be one more seek than we really want to record
    #if defined(TRACEFIND)
    findDiagnostic("findWithFlags3", hashBuckets, hashBucketCount, allocationSize, a, b, c, false);
    #endif

    if (allocationSize != 0) {
      allocate(allocationSize);
      findOffset = poolOffsetTop - allocationSize;
      findBlockIndex = poolBlockTop;
      findBlock = pool[findBlockIndex];
      findIndex = (findBlockIndex << poolAddressOffset) | findOffset;
      findLoadOffset = findOffset;

      findBlock[findOffset] = hashBuckets[hashResult];
      hashBuckets[hashResult] = findIndex;

      findBlock[++findLoadOffset] = abs(a);
      findBlock[++findLoadOffset] = abs(b);
      findBlock[++findLoadOffset] = abs(c);
    }
    return false;
  }

	bool find(int* hashBuckets, int hashBucketCount,
			int allocationSize, int a, int b) {
		hash(hashBucketCount, a, b);

		findIndex = hashBuckets[hashResult];
		do {
			findBlockIndex = findIndex >> poolAddressOffset;
		findOffset = findIndex & poolAddressMask;
		findBlock = pool[findBlockIndex];

		if (a == findBlock[findOffset + 1]
				&& b == findBlock[findOffset + 2]) {
			#if defined(TRACE)
				findDiagnostic("find2", hashBuckets, hashBucketCount,
						allocationSize, a, b, true);
      #endif
			return true;
		}
      hashCollisions++;
  		findIndex = findBlock[findOffset]; // Step to next
		} while (findIndex != 0);

    hashCollisions--; // If we got to here, then we fell off the end of the chain which will be one more seek than we really want to record
		#if defined(TRACE)
			findDiagnostic("find2", hashBuckets, hashBucketCount, allocationSize, a, b,
					false);
    #endif

		if (allocationSize != 0) {
			allocate(allocationSize);
			findOffset = poolOffsetTop - allocationSize;
			findBlockIndex = poolBlockTop;
			findBlock = pool[findBlockIndex];
			findIndex = (findBlockIndex << poolAddressOffset) | findOffset;
			findLoadOffset = findOffset;

			findBlock[findOffset] = hashBuckets[hashResult];
			hashBuckets[hashResult] = findIndex;

			findBlock[++findLoadOffset] = a;
			findBlock[++findLoadOffset] = b;
		}
		return false;
	}

	bool find(int* hashBuckets, int hashBucketCount,
			int allocationSize, int a, int b, int c) {
		hash(hashBucketCount, a, b, c);

		findIndex = hashBuckets[hashResult];
		do {
			findBlockIndex = findIndex >> poolAddressOffset;
			findOffset = findIndex & poolAddressMask;
			findBlock = pool[findBlockIndex];

			if (a == findBlock[findOffset + 1]
					&& b == findBlock[findOffset + 2]
							&& c == findBlock[findOffset + 3]) {
				#if defined(TRACEFIND)
					findDiagnostic(hashBuckets, hashBucketCount,
							allocationSize, a, b, true);
        #endif
				return true;
			}
      hashCollisions++;
			findIndex = findBlock[findOffset]; // Step to next
		} while (findIndex != 0);

    hashCollisions--; // If we got to here, then we fell off the end of the chain which will be one more seek than we really want to record
		#if defined(TRACEFIND)
			findDiagnostic(hashBuckets, hashBucketCount, allocationSize, a, b,
					false);
    #endif

		if (allocationSize != 0) {
			allocate(allocationSize);
			findOffset = poolOffsetTop - allocationSize;
			findBlockIndex = poolBlockTop;
			findBlock = pool[findBlockIndex];
			findIndex = (findBlockIndex << poolAddressOffset) | findOffset;
			findLoadOffset = findOffset;

			findBlock[findOffset] = hashBuckets[hashResult];
			hashBuckets[hashResult] = findIndex;

			findBlock[++findLoadOffset] = a;
			findBlock[++findLoadOffset] = b;
			findBlock[++findLoadOffset] = c;
		}
		return false;
	}

	bool find(int* hashBuckets, int hashBucketCount,
			int allocationSize, int a, int b, int c, int d) {
		hash(hashBucketCount, a, b, c, d);

		findIndex = hashBuckets[hashResult];
		do {
			findBlockIndex = findIndex >> poolAddressOffset;
			findOffset = findIndex & poolAddressMask;
			findBlock = pool[findBlockIndex];

			if (a == findBlock[findOffset + 1]
					&& b == findBlock[findOffset + 2]
							&& c == findBlock[findOffset + 3]
									&& d == findBlock[findOffset + 4]) {
				#if defined(TRACEFIND)
					findDiagnostic(hashBuckets, hashBucketCount,
							allocationSize, a, b, true);
        #endif
				return true;
			}
      hashCollisions++;
			findIndex = findBlock[findOffset]; // Step to next
		} while (findIndex != 0);

    hashCollisions--; // If we got to here, then we fell off the end of the chain which will be one more seek than we really want to record
		#if defined(TRACEFIND)
			findDiagnostic(hashBuckets, hashBucketCount, allocationSize, a, b,
					false);
    #endif

		if (allocationSize != 0) {
			allocate(allocationSize);
			findOffset = poolOffsetTop - allocationSize;
			findBlockIndex = poolBlockTop;
			findBlock = pool[findBlockIndex];
			findIndex = (findBlockIndex << poolAddressOffset) | findOffset;
			findLoadOffset = findOffset;

			findBlock[findOffset] = hashBuckets[hashResult];
			hashBuckets[hashResult] = findIndex;

			findBlock[++findLoadOffset] = a;
			findBlock[++findLoadOffset] = b;
			findBlock[++findLoadOffset] = c;
			findBlock[++findLoadOffset] = d;
		}
		return false;
	}

	/**************************************************************************
	 * Diagnostic output functions
	 **************************************************************************/
	void hashTablePrintSPPFNode(int el) {
    if (el == 0)
      printf("nullElement");
    else
      printf("(%s, %i, %i)", artLabelInternalStrings[abs(poolGet(el+1))], poolGet(el+2), poolGet(el+3));
	}

	void hashTablePrintSPPFPackNode(int el) {
    if (el == 0)
      printf("nullElement");
    else
		printf("(%s, %i)", artLabelInternalStrings[poolGet(el+2)], poolGet(el+3));
	}

	void hashTablePrintGSSNode(int el) {
    if (el == 0)
      printf("nullElement");
    else
		printf("(%s, %i)", artLabelInternalStrings[poolGet(el+1)], poolGet(el+2));
	}

	void hashTablePrintGSSEdge(int el) {
    if (el == 0)
      printf("nullElement");
    else {
      printf("(");
      hashTablePrintSPPFNode(poolGet(el+1));
      printf(", ");
      hashTablePrintGSSNode(poolGet(el+2));
      printf("-->");
      hashTablePrintGSSNode(poolGet(el+3));
      printf(")");
    }
	}

	void hashTablePrintPopElement(int el) {
    if (el == 0)
      printf("nullElement");
    else {
      printf("(");
      printf("%d", poolGet(el + 1)); // Just print address, since this could be a nonterminal or a GSS node depending on mode
      printf(", %d", poolGet(el + 2)); // Zero, or current token index
      hashTablePrintSPPFNode(poolGet(el + 3));
      printf(")");
    }
  }

	void hashTablePrintDescriptor(int el) {
    if (el == 0)
      printf("nullElement");
    else {
      printf("(");
      printf("%s, ", artLabelInternalStrings[abs(poolGet(el+1))]);
      printf("%i", poolGet(el+2));
//      hashTablePrintGSSNode(poolGet(el+2));
      printf(", %i, ", poolGet(el+3));
      hashTablePrintSPPFNode(poolGet(el+4));
      printf(")");
    }
  }

	void hashTablePrintTestRepeatElement(int el) {
    if (el == 0)
      printf("nullElement");
    else {
      printf("(");
      printf("%s, ", artLabelInternalStrings[abs(poolGet(el+1))]);
      printf("%i", poolGet(el+2));
//      hashTablePrintGSSNode(poolGet(el+2));
      printf(", %i, ", poolGet(el+3));
      hashTablePrintSPPFNode(poolGet(el+4));
      printf(")");
    }
	}

	void hashTablePrintClusterElement(int el) {
    if (el == 0)
      printf("nullElement");
    else {
      int cardinality = 0;

      for (int i = poolGet(el + clusterElement_nodeList); i != 0; i = poolGet(i + gssNode_pop_clusterElementList))
        cardinality++;

      printf("(");
      printf("%s", artLabelInternalStrings[abs(poolGet(el + clusterElement_label))]);
      printf(", %i", poolGet(el + clusterElement_index));
      printf(")\",%i,\"", cardinality);
      for (int i = poolGet(el + clusterElement_nodeList); i != 0; i = poolGet(i + gssNode_pop_clusterElementList))
        printf("->%i", i);
      printf(", %i", poolGet(el + clusterElement_inEdgeList));
      printf(", %i", poolGet(el + clusterElement_popList));
    }
	}

  void hashTablePrintClusterInEdge(int el) {
    if (el == 0)
      printf("nullElement");
    else {
      printf("(");
      hashTablePrintGSSNode(poolGet(el + clusterInEdge_source));
      printf(", ");
      hashTablePrintSPPFNode(poolGet(el + clusterInEdge_sppfNode));
      printf(")");
    }
  }

  void hashTablePrintClusterPopElement(int el) {
    if (el == 0)
      printf("nullElement");
    else {
      printf("(");
      hashTablePrintSPPFNode(poolGet(el));
      printf(", %i", poolGet(el + 1));
      printf(")");
    }
  }

	void hashTablePrintElementRaw(int* hashBuckets, int el) {
		printf("%i:[", el);
		for (int i = 0; i < hashTableElementSize(hashBuckets); i++)
			printf("%s%i", i == 0 ? "" : ",", poolGet(el + i));
		printf("]");
	}

	void hashTablePrintElementFormatted(int* hashBuckets, int el) {
		if (hashBuckets == sppfNodeBuckets)
			hashTablePrintSPPFNode(el);
		if (hashBuckets == sppfPackNodeBuckets)
			hashTablePrintSPPFPackNode(el);
		if (hashBuckets == gssNodeBuckets)
			hashTablePrintGSSNode(el);
		if (hashBuckets == gssEdgeBuckets)
			hashTablePrintGSSEdge(el);
		if (hashBuckets == popElementBuckets)
			hashTablePrintPopElement(el);
		if (hashBuckets == descriptorBuckets)
			hashTablePrintDescriptor(el);
		if (hashBuckets == testRepeatElementBuckets)
			hashTablePrintTestRepeatElement(el);
		if (hashBuckets == clusterElementBuckets)
			hashTablePrintClusterElement(el);
	}

	const char* hashTableName(int* hashBuckets) {
		if (hashBuckets == sppfNodeBuckets)
			return "sppfNode";
		if (hashBuckets == sppfPackNodeBuckets)
			return "sppfPackNode";
		if (hashBuckets == gssNodeBuckets)
			return "gssNode";
		if (hashBuckets == gssEdgeBuckets)
			return "gssEdge";
		if (hashBuckets == popElementBuckets)
			return "popElement";
		if (hashBuckets == descriptorBuckets)
			return "descriptor";
		if (hashBuckets == testRepeatElementBuckets)
			return "testRepeatElement";
		if (hashBuckets == clusterElementBuckets)
			return "clusterElement";

		return "???";
	}

	int hashTableBucketCount(int* hashBuckets) {
		if (hashBuckets == sppfNodeBuckets)
			return sppfNodeBucketCount;
		if (hashBuckets == sppfPackNodeBuckets)
			return sppfPackNodeBucketCount;
		if (hashBuckets == gssNodeBuckets)
			return gssNodeBucketCount;
		if (hashBuckets == gssEdgeBuckets)
			return gssEdgeBucketCount;
		if (hashBuckets == popElementBuckets)
			return popElementBucketCount;
		if (hashBuckets == descriptorBuckets)
			return descriptorBucketCount;
		if (hashBuckets == testRepeatElementBuckets)
			return testRepeatElementBucketCount;
		if (hashBuckets == clusterElementBuckets)
			return clusterElementBucketCount;

		return 0;
	}

	int hashTableElementSize(int* hashBuckets) {
		if (hashBuckets == sppfNodeBuckets)
			return sppfNode_SIZE;
		if (hashBuckets == sppfPackNodeBuckets)
			return sppfPackNode_SIZE;
		if (hashBuckets == gssNodeBuckets)
			return gssNode_SIZE;
		if (hashBuckets == gssEdgeBuckets)
			return gssEdge_SIZE;
		if (hashBuckets == popElementBuckets)
			return popElement_SIZE;
		if (hashBuckets == descriptorBuckets)
			return descriptor_SIZE;
		if (hashBuckets == testRepeatElementBuckets)
			return testRepeatElement_SIZE;
		if (hashBuckets == clusterElementBuckets)
			return clusterElement_SIZE;

		return 0;
	}

	void hashTablePrint(int* hashBuckets) {
		printf("Hash table print for %s\n",
				hashTableName(hashBuckets));
		for (int i = 0; i < hashTableBucketCount(hashBuckets); i++) {
			if (hashBuckets[i] != 0) {
				printf("Bucket %i: ", i);
				for (int poolElement = hashBuckets[i]; poolElement != 0; poolElement = poolGet(poolElement)) {
					hashTablePrintElementRaw(hashBuckets, poolElement);
					hashTablePrintElementFormatted(hashBuckets, poolElement);
				}
				printf("\n");
			}
		}
	}

	public: void hashTablePrintAll() {
		hashTablePrint(sppfNodeBuckets);
		hashTablePrint(sppfPackNodeBuckets);
		hashTablePrint(gssNodeBuckets);
		hashTablePrint(gssEdgeBuckets);
		hashTablePrint(popElementBuckets);
		hashTablePrint(descriptorBuckets);
		hashTablePrint(testRepeatElementBuckets);
		hashTablePrint(clusterElementBuckets);
	}

	void findDiagnostic(char* msg, int* hashBuckets, int hashBucketCount,
			int allocationSize, int a, int b, bool found) {
		  printf("findDiagnostic(%s: %s[%i, %i] %i, %i) - %sfound\n",
		  msg, hashTableName(hashBuckets), hashBucketCount, allocationSize, a,
	    b, found ? "" : "not ");
	}

  /**
   * Getters, setters and iterators
   */

   public: int sppfRoot() {
    return rootSPPFNode;
  }

  public: int sppfPackNodeLeftChild(int element) {
    int leftChildLabel = sppfPackNodeLeftChildLabel(element);
    if (leftChildLabel == ART_L__DUMMY)
      return 0;
    else
      return lookupSPPF(leftChildLabel, sppfNodeLeftExtent(sppfPackNodeParent(element)), sppfPackNodePivot(element));
  }

  public: int sppfPackNodeRightChild(int element) {
    return lookupSPPF(sppfPackNodeRightChildLabel(element), sppfPackNodePivot(element), sppfNodeRightExtent(sppfPackNodeParent(element)));
  }

  public: int gssRoot() {
    return rootGSSNode;
  }

 public:  int sppfNodeLabel(int element) {
    return abs(poolGet(element + sppfNode_label));
  } // Negative if visited


  public:  int sppfNodeLeftExtent(int element) {
    return poolGet(element + sppfNode_leftExtent);
  }


  public:  int sppfNodeRightExtent(int element) {
    return poolGet(element + sppfNode_rightExtent);
  }


  public:  int sppfNodePackNodeList(int element) {
    return abs(poolGet(element + sppfNode_packNodeList));
  } // Negative if selected

  /* Symbol nodes may be visited or selected */

  public:  bool sppfNodeVisited(int element) {
    return poolGet(abs(element) + sppfNode_label) < 0;
  }


  public:  void sppfNodeResetVisited(int element) {
    poolSet(abs(element) + sppfNode_label, abs(poolGet(abs(element) + sppfNode_label)));
  }


  public:  void sppfNodeSetVisited(int element) {
    poolSet(abs(element) + sppfNode_label, -abs(poolGet(abs(element) + sppfNode_label)));
  }

  public: void sppfResetVisitedFlags() {
    for (int element = sppfNodeFirst(); element != 0; element = sppfNodeNext())
      sppfNodeResetVisited(element);
  }


  public:  bool sppfNodeSelected(int element) {
    return poolGet(abs(element) + sppfNode_packNodeList) <= 0;
  }


  public:  void sppfNodeResetSelected(int element) {
    poolSet(abs(element) + sppfNode_packNodeList, abs(poolGet(abs(element) + sppfNode_packNodeList)));
  }


  public:  void sppfNodeSetSelected(int element) {
    poolSet(abs(element) + sppfNode_packNodeList, -abs(poolGet(abs(element) + sppfNode_packNodeList)));
  }

  /*
   * Iterate over all SPPF nodes independent of linking
   */
  private:int sppfIteratorBucket;
  private:int sppfIteratorElement;


  public:  int sppfNodeFirst() {
    sppfIteratorBucket = -1;
    sppfIteratorElement = 0;
    return sppfNodeNext();
  }


  public:  int sppfNodeNext() {
    if (sppfIteratorElement != 0) sppfIteratorElement = poolGet(abs(sppfIteratorElement)); // Go to next element in chain

    if (sppfIteratorElement == 0) // Increment past the empty buckets
      do {
        if (++sppfIteratorBucket >= sppfNodeBucketCount) return 0;

      } while ((sppfIteratorElement = abs(sppfNodeBuckets[sppfIteratorBucket])) == 0);

    // if (TRACE) printf(, "sppfNodeNext returns %i\n", sppfIteratorElement);

    return sppfIteratorElement;
  }


  public: int findRightmostLeftExtent() {
    int rightmostLeftExtent = 0;

    for (int element = sppfNodeFirst(); element != 0; element = sppfNodeNext())
      if (sppfNodeLeftExtent(element) > rightmostLeftExtent) rightmostLeftExtent = sppfNodeLeftExtent(element);

    return rightmostLeftExtent;
  }


  public:  int sppfNodeArity(int element) {
    int arity = 0;
    for (int tmp = sppfNodePackNodeList(element); tmp != 0; tmp = sppfPackNodePackNodeList(tmp))
      arity++;
    return arity;
  };


  public:  int sppfPackNodeParent(int element) {
    return poolGet(element + sppfPackNode_parent);
  }


  public:  int sppfPackNodeLabel(int element) {
    return abs(poolGet(element + sppfPackNode_label));
  } // Negative if visited


  public:  int sppfPackNodePivot(int element) {
    return poolGet(element + sppfPackNode_pivot);
  }


  public:  int sppfPackNodeLeftChildLabel(int element) {
    return abs(poolGet(element + sppfPackNode_leftChildLabel));
  } // Negative if suppressed


  public:  int sppfPackNodeRightChildLabel(int element) {
    return abs(poolGet(element + sppfPackNode_rightChildLabel));
  } // Negative if selected


  public:  int sppfPackNodePackNodeList(int element) {
    return poolGet(element + sppfPackNode_packNodeList);
  }

  /* Pack nodes may be suppressed or selected */

  public:  bool sppfPackNodeSuppressed(int element) {
    return poolGet(element + sppfPackNode_leftChildLabel) < 0;
  }


  public:  void sppfPackNodeResetSuppressed(int element) {
    poolSet(element + sppfPackNode_leftChildLabel, abs(poolGet(element + sppfPackNode_leftChildLabel)));
  }


  public:  void sppfPackNodeSetSuppressed(int element) {
    poolSet(element + sppfPackNode_leftChildLabel, -abs(poolGet(element + sppfPackNode_leftChildLabel)));
  }


  public:  bool sppfPackNodeSelected(int element) {
    return poolGet(element + sppfPackNode_rightChildLabel) < 0;
  }


  public:  void sppfPackNodeResetSelected(int element) {
    poolSet(element + sppfPackNode_rightChildLabel, abs(poolGet(element + sppfPackNode_rightChildLabel)));
  }


  public:  void sppfPackNodeSetSelected(int element) {
    poolSet(element + sppfPackNode_rightChildLabel, -abs(poolGet(element + sppfPackNode_rightChildLabel)));
  }


  public:  int gssNodeLabel(int element) {
    return abs(poolGet(element + gssNode_label));
  }


  public:  int gssNodeLevel(int element) {
    return poolGet(element + gssNode_level);
  }


  public:  int gssNodeEdgeList(int element) {
    return poolGet(element + gssNode_edgeList);
  }

  public:  int gssNodePopElementList(int element) {
    return poolGet(element + gssNode_pop_clusterElementList);
  }


  public:  int gssEdgeSPPFNode(int element) {
    return poolGet(element + gssEdge_sppfNode);
  }


  public:  int gssEdgeSource(int element) {
    return poolGet(element + gssEdge_source);
  }


  public:  int gssEdgeDestination(int element) {
    return poolGet(element + gssEdge_destination);
  }


  public:  int gssEdgeEdgeList(int element) {
    return poolGet(element + gssEdge_edgeList);
  }

  /**
   * Iterate over all GSS nodes independent of linking
   */
  private:int gssNodeIteratorBucket;
  private:int gssNodeIteratorElement;


  public:  int gssNodeFirst() {
    gssNodeIteratorBucket = gssNodeIteratorElement = 0;
    return gssNodeNext();
  }


  public:  int gssNodeNext() {
    if (gssNodeIteratorElement != 0) gssNodeIteratorElement = poolGet(gssNodeIteratorElement);
    if (gssNodeIteratorElement == 0) for (gssNodeIteratorBucket++; gssNodeIteratorBucket < gssNodeBucketCount; gssNodeIteratorBucket++)
      if (gssNodeBuckets[gssNodeIteratorBucket] != 0) {
        gssNodeIteratorElement = gssNodeBuckets[gssNodeIteratorBucket];
        break;
      }

    return gssNodeIteratorElement;
  }

  /* Iterate over all GSS edges independent of linking */
  private:int gssEdgeIteratorBucket;
  private:int gssEdgeIteratorElement;


  public:  int gssEdgeFirst() {
    gssEdgeIteratorBucket = gssEdgeIteratorElement = 0;
    return gssEdgeNext();
  }


  public:  int gssEdgeNext() {
    if (gssEdgeIteratorElement != 0) gssEdgeIteratorElement = poolGet(gssEdgeIteratorElement);
    if (gssEdgeIteratorElement == 0) for (gssEdgeIteratorBucket++; gssEdgeIteratorBucket < gssEdgeBucketCount; gssEdgeIteratorBucket++)
      if (gssEdgeBuckets[gssEdgeIteratorBucket] != 0) {
        gssEdgeIteratorElement = gssEdgeBuckets[gssEdgeIteratorBucket];
        break;
      }

    return gssEdgeIteratorElement;
  }


	/**************************************************************************
	 * The standard GLL support functions
	 *************************************************************************/
  int lookupSPPF(int label, int leftExtent, int rightExtent) {
    // Note - we use findWithFlags to allow successful lookup whilst flags are in use

    bool found = findWithFlags(sppfNodeBuckets, sppfNodeBucketCount, 0, label, leftExtent, rightExtent);
    #if defined(STATISTICS)
      incSPPFNodeFinds();
    #endif
    #if defined(TRACE)
      printf("lookupSPPF");
      hashTablePrintSPPFNode(findIndex);
      printf(" - %sfound %i\n", found ? "" : "not ", findIndex);
    #endif
    return findIndex;
  }

	int findSPPFInitial(int label, int leftExtent, int rightExtent) {
#if defined(TRACE)
		bool found =
#endif
    find(sppfNodeBuckets, sppfNodeBucketCount,
				sppfNode_SIZE, label, leftExtent, rightExtent);

#if defined(STATISTICS)
    incSPPFNodeFinds();
#endif

		#if defined(TRACE)
      printf("findSPPFInitial ");
      hashTablePrintSPPFNode(findIndex);
      printf(" - %sfound %i\n", found ? "" : "not ", findIndex);
    #endif
		return findIndex;
	}

	int findSPPFEpsilon(int currentTokenIndex) {
#if defined(TRACE)
		bool found =
#endif
    find(sppfNodeBuckets, sppfNodeBucketCount,
				sppfNode_SIZE, ART_L__EPSILON, currentTokenIndex,
				currentTokenIndex);

#if defined(STATISTICS)
    incSPPFNodeFinds();
#endif

		#if defined(TRACE)
			printf("findSPPFEpsilon ");
			hashTablePrintSPPFNode(findIndex);
      printf(" - %sfound %i\n", found ? "" : "not ", findIndex);
    #endif
		return findIndex;
	}

	int findSPPFTerminal(int label, int currentTokenIndex) {
#if defined(TRACE)
		bool found =
#endif
    find(sppfNodeBuckets, sppfNodeBucketCount,
				sppfNode_SIZE, label, currentTokenIndex, currentTokenIndex + 1);

#if defined(STATISTICS)
    incSPPFNodeFinds();
#endif

		#if defined(TRACE)
			printf("findSPPFTerminal ");
			hashTablePrintSPPFNode(findIndex);
      printf(" - %sfound %i\n", found ? "" : "not ", findIndex);
    #endif
		return findIndex;
	}

	int findSPPF(int label, int leftChild, int rightChild) {
		// sppfNODE findSPPF(L, i, j)
		// y := lookupSPPF(L, i, j) // Returns NULL if (L, i, j) is not in the
		// SPPF, otherwise returns the SPPF node labelled (L, i, j)
		// if y = NULL then y := addtoSPPF(L, i, j) fi
		// return y

		#if defined(TRACE)
      printf("findSPPF (%s, ", artLabelInternalStrings[label]);
      hashTablePrintSPPFNode(leftChild);
      printf(", ");
      hashTablePrintSPPFNode(rightChild);
      printf(")\n");
    #endif


		if (fiRL[label]) {
			#if defined(TRACE)
				printf("Returning rightChild\n");
      #endif
			return rightChild;
		}

		// Set up parameters
		int leftExtent = (leftChild == dummySPPFNode ? poolGet(rightChild
				+ sppfNode_leftExtent) : poolGet(leftChild
						+ sppfNode_leftExtent));
		int newSPPFNodeLabel;

		if (eoOPL[label])
			newSPPFNodeLabel = eoR_pL[label] ? lhsL[label] : pL[label];
			else
				newSPPFNodeLabel = eoRL[label] ? lhsL[label] : aL[label];

				// Find the SPPF node
#if defined(TRACE)
    		bool found =
#endif
        find(sppfNodeBuckets, sppfNodeBucketCount,
						sppfNode_SIZE, newSPPFNodeLabel, leftExtent, poolGet(rightChild
								+ sppfNode_rightExtent));

#if defined(STATISTICS)
        incSPPFNodeFinds();
#endif

				#if defined(TRACE)
					printf("findSPPF ");
					hashTablePrintSPPFNode(findIndex);
					printf(" - %sfound %i\n", found ? "" : "not ", findIndex);
        #endif

				int newSPPFNode = findIndex;

				// Add a pack node if necessary
				bool packNodeFound = find(sppfPackNodeBuckets,
						sppfPackNodeBucketCount, sppfPackNode_SIZE, newSPPFNode, label,
						poolGet(rightChild + sppfNode_leftExtent));

#if defined(STATISTICS)
        sppfPackNodeFinds++;
#endif

				if (!packNodeFound) {
					// Fill in fields in this newly created pack node and link to parent
					// 1: left child label
					pool[findBlockIndex][++findLoadOffset] = poolGet(leftChild
							+ sppfNode_label);
					// 2: right child label
					pool[findBlockIndex][++findLoadOffset] = poolGet(rightChild
							+ sppfNode_label);
					// 3: right sibling in pack node list taken from parent
					int parentPackNodeListIndex = newSPPFNode + sppfNode_packNodeList;
					pool[findBlockIndex][++findLoadOffset] = poolGet(parentPackNodeListIndex);
					// and finally point parent packNodeList at the new packNode
					poolSet(parentPackNodeListIndex, findIndex);
				}

				#if defined(TRACE)
					printf("findPackNode ");
					hashTablePrintSPPFPackNode(findIndex);
					printf(" - %sfound %i\n", found ? "" : "not ", findIndex);
        #endif

				return newSPPFNode;
	}

	int findSPPFClosure(int parentLabel, int childLabel,
			int currentTokenIndex) {

#if defined(TRACE)
		bool found =
#endif
     find(sppfNodeBuckets, sppfNodeBucketCount,
				sppfNode_SIZE, parentLabel, currentTokenIndex,
				currentTokenIndex);

#if defined(STATISTICS)
      incSPPFNodeFinds();
#endif

		#if defined(TRACE)
			printf("findSPPFClosure ");
			hashTablePrintSPPFNode(findIndex);
			printf(" - %sfound %i\n", found ? "" : "not ", findIndex);
    #endif

		int newSPPFNode = findIndex;

		// if there is no pack node labelled (L, i), the make one and add an
		// epsilon node as a child
		if (!find(sppfPackNodeBuckets, sppfPackNodeBucketCount,
				sppfPackNode_SIZE, newSPPFNode, childLabel, currentTokenIndex)) {
			// Fill in fields in this newly created pack node and link to parent
			// 1: left child label
			pool[findBlockIndex][++findLoadOffset] = ART_L__DUMMY;
			// 2: right child label
			pool[findBlockIndex][++findLoadOffset] = ART_L__EPSILON;
			// 3: right sibling in pack node list taken from parent
			int parentPackNodeListIndex = newSPPFNode + sppfNode_packNodeList;
			pool[findBlockIndex][++findLoadOffset] = poolGet(parentPackNodeListIndex);
			// and finally point parent packNodeList at the new packNode
			poolSet(parentPackNodeListIndex, findIndex);

			findSPPFEpsilon(currentTokenIndex);  // find counted in findSPPFEpsilon
		}
#if defined(STATISTICS)
      sppfPackNodeFinds++;
#endif

		return newSPPFNode;
	}

	int findGSS(int stackTopLabel, int stackTop, int currentToken,
			int currentsppfNode) {
    /* Trace output - introduce ourselves */
    #if defined(TRACE)
      printf("findGSS (%s, ", artLabelInternalStrings[stackTopLabel]);
      hashTablePrintGSSNode(stackTop);
      printf(", %i, ", currentToken);
      hashTablePrintSPPFNode(currentSPPFNode);
      printf(")");
    #endif

    // v := lookupGSS(L, i) // Returns NULL if (L, i) is not in the GSS,
    // otherwise returns the GSS node labelled (L, i)
    // if v = NULL then v := addtoGSS(L, i) fi
    //
    // if there is not an edge from v to u labelled w then
    // create an edge from v to u labelled w
    // for each (v, z) in P do add(L, u, z.rightExtent, getNodeP(L, w, z))
    // od
    // fi
    // return v

    /*
     * 1A. We are pushing the current return context onto the stack. A return context is a label to return to, and the current input index at th epoint of the
     * call.
     *
     * In a GSS, there are multiple stacks, and one of them might already contain the contex.
     *
     * The find() function looks to see if an element exists, and if not it makes one. Either way, the findIndex variable contains the address of the elemeny
     */
    bool nodeFound = find(gssNodeBuckets, gssNodeBucketCount, gssNode_SIZE, stackTopLabel, currentToken);
    #if defined(STATISTICS)
       gssNodeFinds++;
    #endif

    /* Trace output - report result of find() */
    #if defined(TRACE)
      printf(" - %sfound %i\n", nodeFound ? "" : "not ", findIndex);
    #endif

    int newGSSNode = findIndex;

    /*
     * 1B. Except for the root node (which is a special case) a pushed context needs to be connected to its predecessor on the stack We don't just immediately
     * make a new edge, because this connection may itself already exist, so we use find again on the edges table to avoid replicating edges
     */
    if (stackTop != 0) {
      bool edgeFound = find(gssEdgeBuckets, gssEdgeBucketCount, gssEdge_SIZE, currentSPPFNode, newGSSNode, stackTop);
      #if defined(STATISTICS)
        gssEdgeFinds++;
      #endif

      if (!edgeFound) {
        poolSet(findIndex + gssEdge_edgeList, poolGet(newGSSNode + gssNode_edgeList));
        poolSet(newGSSNode + gssNode_edgeList, findIndex);
      }

      /* Trace output - report result of find() */
      #if defined(TRACE)
        printf("findGSSEdge ");
        hashTablePrintGSSEdge(findIndex);
        printf(" - %sfound %i\n", edgeFound ? "" : "not ", findIndex);
    #endif

      /*
       * 2A. Contingent pop processing
       *
       * Here's the hard bit. For pushed elements that were already in the GSS, their associated production instances may already have been processed, in which
       * a pop will already have been executed on the node. These pops are remembered for each node in a linked list hanging off of each gss node and also in a
       * hash table which allows global checks to be done efficiently.
       *
       * If we have added a new edge to an old node, then we must check the pop set and restart the contexts for any pops that have already been processed using
       * this node
       *
       * Here's a thought: delay pops as long as possible to keep the lists short. Why not separate R into two parts: R1 holds descriptors for code fragments
       * that do not include a pop() call at the end, and R2 holds the descriptors whose code does finish with a pop(). Decsriptor fetch then becomes while R2
       * non empty { extract R2; while R1 non empty { extract R1 } }
       */

      /*
       * There's some rework if the control flow here compared to the version in the paper. Contingent pops can only be needed if we added a new edge to an old
       * GSS node. That means, if the node is new, no contingent processing (because the contingent list must certainly be empty. Also, if the node AND the edge
       * are old then the pops will have been done for that edge and there's no more to do at this stage.
       *
       * So only need to do contingent processing if the node was found and the edge was not.
       */
      /* Trace output - introduce pop processing */
      #if defined(TRACE)
        printf("Start of contingent pop processing for GSS node ");
        hashTablePrintGSSNode(newGSSNode);
        printf("\n");
    #endif

      if (nodeFound && !edgeFound) {

        /*
         * 2B walk down the linked list creating derivationNodes and descriptors which restart the popped context
         */
        for (int poppedElement = poolGet(newGSSNode + gssNode_pop_clusterElementList); poppedElement != 0; poppedElement = poolGet(poppedElement
            + popElement_popElementList)) {
          int derivationNode = findSPPF(stackTopLabel, currentsppfNode, poolGet(poppedElement + popElement_sppfNode));
          findDescriptor(stackTopLabel, stackTop, poolGet(poolGet(poppedElement + popElement_sppfNode) + sppfNode_rightExtent), derivationNode);
          #if defined(STATISTICS)
          contingentPops++;
          #endif
          // AJ Opt - derivationNode IS poolGet(poppedElement + popElement_sppfNode!
        }

      }
      /* Trace output - wrap up pop processing */
      #if defined(TRACE)
        printf("End of contingent pop processing for GSS node ");
        hashTablePrintGSSNode(newGSSNode);
        printf("\n");
    #endif

    }
    return newGSSNode;
	}

	void pop(int stackTop, int currentTokenIndex, int currentsppfNode) {
		// pop(u, i, z)
		// if (not u = u_0) then
		// insert(u,z) into P
		//
		// for each edge (u, w, v)
		// y := lookupSPPF(u.label, w, z)
		// findDescriptor(u.label, v, i, y)

		if (stackTop == rootGSSNode) {
			#if defined(TRACE)
				printf("pop (");
				hashTablePrintGSSNode(stackTop);
				printf(", %i, ", currentTokenIndex);
				hashTablePrintSPPFNode(currentSPPFNode);
				printf(") - pop of root node - returning\n");
      #endif
			return;
		}

		bool found = find(popElementBuckets, popElementBucketCount, popElement_SIZE, stackTop, currentTokenIndex, currentsppfNode);

#if defined(STATISTICS)
    popElementFinds++;
#endif

		int popElement;
		#if defined(TRACE)
			popElement = findIndex;

			printf("pop ");
			hashTablePrintPopElement(popElement);
			printf(" - %sfound %i\n", found ? "" : "not ", findIndex);
    #endif

		if (!found) {
			#if defined(TRACE)
				printf("Adding popElement to GSSNode\n");
      #endif
			poolSet(findIndex + popElement_popElementList, poolGet(stackTop + gssNode_pop_clusterElementList));
			poolSet(stackTop + gssNode_pop_clusterElementList, findIndex);
		}

		for (int outEdge = poolGet(stackTop + gssNode_edgeList); outEdge != 0; outEdge = poolGet(outEdge + gssEdge_edgeList)) {
    #if defined(TRACE)
        printf("Popping GSSEdge %i ", outEdge);
        hashTablePrintGSSEdge(outEdge);
        printf("\n");
    #endif

    #if defined(STATISTICS)
      primaryPops++;
    #endif

			int derivationNode = findSPPF(poolGet(stackTop + gssNode_label), poolGet(outEdge
					+ gssEdge_sppfNode), currentsppfNode);
			findDescriptor(poolGet(stackTop + gssNode_label), poolGet(outEdge
					+ gssEdge_destination), currentTokenIndex, derivationNode);
		}
		#if defined(TRACE)
			printf("Exiting pop ");
			hashTablePrintPopElement(popElement);
			printf("\n");
    #endif
	}

  int findGSSClustered(int clusterNonTerminal, int clusterIndex, int currentToken, int currentsppfNode) {
    // (iii-4imp) findGSSNodeReduced4(L, k, i, w) (* Adrian's cluster implementation *)
    // (* Find (lookup, and if necessary create) the clusters for the nonterminal to be called and for the LHS nonterminal *)
    // let slot(L) = !B ::= _ !A . _
    // c = findCluster(A, i)
    // d = findCluster(B, k)
    //
    // (* Make the GSS node v, add it to the nodelist of c, and add to v any inedges that have already been created for c *)
    // if lookupGSSNode(L, i) = null
    // v = createGSSNode(L, i)
    // add v to the node list of c
    // (* This loop creates actual GSS edges; it can be omitted without breaking the algorithm because the cluster inedge captures the information *)
    // for all inedges to c (!f, !x, _)
    // createGSSedge(f, x, v)
    //
    // (* Add the specific edge for this push; and add this to the LHS cluster inedge list *)

    // let !u' be the first element on the nodelist of d
    // tmp lookupGSSEdge(v, w, u')

    // !! suppressed !! if (tmp) {

    // add (v, w) to the inedge list of d

    // (* This loop creates actual GSS edges; it can be omitted without breaking the algorithm because the cluster inedge captures the information *)
    // for all u != u' in node list of d  ; start at successor of first element u'
    // createGSSedge(v, w, u)
    //
    // (* Look for contingent pops, and create associated descriptors *)
    // for all !z on pop list of c
    // findDescriptor(L, k, z.rightExtent, lookupSPPfNode(L, w, z))

    #if defined(TRACE)
      printf("findGSSClustered(%s, %i, %i, ", artLabelInternalStrings[clusterNonTerminal], clusterIndex, currentToken);
      hashTablePrintSPPFNode(currentSPPFNode);
      printf(")\n");
    #endif

    // (* Find (lookup, and if necessary create) the clusters for the nonterminal to be called and for the LHS nonterminal *)
    // let slot(L) = !B ::= _ !A . _
    // c = findCluster(A, i)
    // d = findCluster(B, k)
    // Let L be for the form B ::= \tau A . \mu; identify labels A and B
    int B = lhsL[clusterNonTerminal];
    int A = artSlotInstanceOfs[clusterNonTerminal];

    bool clusterAFound = find(clusterElementBuckets, clusterElementBucketCount, clusterElement_SIZE, A, currentToken);
    int clusterAElement = findIndex;
    #if defined(TRACE)
      printf("findClusterElement for ");
      hashTablePrintClusterElement(clusterAElement);
      printf(" - %sfound %i\n", clusterAFound ? "" : "not ", clusterAElement);
    #endif
    #if defined(STATISTICS)
      clusterElementFinds++;
    #endif

    bool clusterBFound = find(clusterElementBuckets, clusterElementBucketCount, clusterElement_SIZE, B, clusterIndex);
    int clusterBElement = findIndex;

    #if defined(TRACE)
      printf("findClusterElement for lhs");
      hashTablePrintClusterElement(clusterBElement);
      printf(" - %sfound %i\n", clusterBFound ? "" : "not ", clusterBElement);
    #endif

    #if defined(STATISTICS)
      clusterElementFinds++;
    #endif

    // (* Make the GSS node v, add it to the nodelist of c, and add to v any inedges that have already been created for c *)
    // if lookupGSSNode(L, i) = null
    // v = createGSSNode(L, i)
    // add v to the node list of c
    // (* This loop creates actual GSS edges; it can be omitted without breaking the algorithm because the cluster inedge captures the information *)
    // for all inedges to c (!f, !x, _)
    // createGSSedge(f, x, v)
    //
    bool gssNodeFound = find(gssNodeBuckets, gssNodeBucketCount, gssNode_SIZE, clusterNonTerminal, currentToken);
    int newGSSNode = findIndex;

    #if defined(TRACE)
      printf("findGSSNode ");
      hashTablePrintGSSNode(newGSSNode);
      printf(" - %sfound %i\n", gssNodeFound ? "" : "not ", newGSSNode);
    #endif

    #if defined(STATISTICS)
      gssNodeFinds++;
    #endif

    // If the GSS node was new, link it into its cluster
    int oldStackTop = poolGet(clusterAElement + clusterElement_nodeList);

    if (!gssNodeFound) {
      poolSet(newGSSNode + popElement_popElementList, oldStackTop);
      poolSet(clusterAElement + clusterElement_nodeList, newGSSNode);

    #if defined(TRACE)
      printf("Start of cluster A inEdge iteration\n");
    #endif

    for (int inEdge = poolGet(clusterAElement + clusterElement_inEdgeList); inEdge != 0; inEdge = poolGet(inEdge + clusterInEdge_inEdgeList)) {

      #if defined(TRACE)
        printf("\nIterating over inedge list for cluster ");
        hashTablePrintClusterElement(clusterAElement);
        printf(" to inedge ");
        hashTablePrintClusterInEdge(inEdge);
        printf("\n");
      #endif

      int inEdgeSourceNode = poolGet(inEdge + clusterInEdge_source);

      bool edgeFound = find(gssEdgeBuckets, gssEdgeBucketCount, gssEdge_SIZE, poolGet(inEdge + clusterInEdge_sppfNode), inEdgeSourceNode, newGSSNode);
      int newEdge = findIndex;

      /* Trace output - report result of find() */
      #if defined(TRACE)
        printf("Iterating over existing cluster inedges: findGSSEdge ");
        hashTablePrintGSSEdge(newEdge);
        printf(" - %sfound %i\n", edgeFound ? "" : "not ", newEdge);
      #endif

      #if defined(STATISTICS)
        gssEdgeFinds++;
      #endif

      if (!edgeFound) {
        poolSet(newEdge + gssEdge_edgeList, poolGet(inEdgeSourceNode + gssNode_edgeList));
        poolSet(inEdgeSourceNode + gssNode_edgeList, newEdge);
      }
    }

    #if defined(TRACE)
      printf("End of cluster A inEdge iteration\n");
    #endif

    }

    // (* Add the specific edge for this push; and add this to the LHS cluster inedge list *)
    // !! Now suppressed !! let !u' be the first element on the nodelist of d
    // !! Now suppressed !! if lookupGSSEdge(v, w, u') = null
    // add (v, w) to the inedge list of d
    // (* This loop creates actual GSS edges; it can be omitted without breaking the algorithm because the cluster inedge captures the information *)
    // for all u in node list of d
    // createGSSedge(v, w, u)

    int firstClusterNode = poolGet(clusterBElement + clusterElement_nodeList);

    bool specificEdgeFound = find(gssEdgeBuckets, gssEdgeBucketCount, gssEdge_SIZE, currentSPPFNode, newGSSNode, firstClusterNode);
    int newSpecificEdge = findIndex;

    /* Trace output - report result of find() */
    #if defined(TRACE)
      printf("Checking specific edge for first cluster node: findGSSEdge ");
      hashTablePrintGSSEdge(newSpecificEdge);
      printf(" - %sfound %i\n", specificEdgeFound ? "" : "not ", newSpecificEdge);
    #endif

    #if defined(STATISTICS)
      gssEdgeFinds++;
    #endif


//    if (!specificEdgeFound) {
      // Link the newly created edge into the edge list of the new gssnode
      poolSet(newSpecificEdge + gssEdge_edgeList, poolGet(newGSSNode + gssNode_edgeList));
      poolSet(newGSSNode + gssNode_edgeList, newSpecificEdge);

      // Add (v, w) to inedge list of d
      allocateAndLoad(clusterInEdge_SIZE, newGSSNode, currentSPPFNode);
      int inEdgeElement = findIndex;

      poolSet(inEdgeElement + clusterInEdge_inEdgeList, poolGet(clusterBElement + clusterElement_inEdgeList));
      poolSet(clusterBElement + clusterElement_inEdgeList, inEdgeElement);

      #if defined(TRACE)
        printf("Start of cluster B node iteration\n");
      #endif
      // Add physical edges to GSS for the rest of the nodes in cluster B
      for (int clusterNode = poolGet(firstClusterNode + gssNode_pop_clusterElementList); clusterNode != 0; clusterNode = poolGet(clusterNode
          + gssNode_pop_clusterElementList)) {

        bool clusterEdgeFound = find(gssEdgeBuckets, gssEdgeBucketCount, gssEdge_SIZE, currentSPPFNode, newGSSNode, clusterNode);
        int newClusterEdge = findIndex;

        /* Trace output - report result of find() */
        #if defined(TRACE)
          printf("Adding cluster edge: findGSSEdge ");
          hashTablePrintGSSEdge(newClusterEdge);
          printf(" - %sfound %i\n", clusterEdgeFound ? "" : "not ", newClusterEdge);
        #endif

        #if defined(STATISTICS)
          gssEdgeFinds++;
        #endif


        // Link the newly found edge into the edge list of the cluster node
        if (!clusterEdgeFound) {
          poolSet(newClusterEdge + gssEdge_edgeList, poolGet(newGSSNode + gssNode_edgeList));
          poolSet(newGSSNode + gssNode_edgeList, newClusterEdge);
        }

      }
      #if defined(TRACE)
        printf("End of cluster B node iteration\n");
      #endif
//    }
    // (* Look for contingent pops, and create associated descriptors *)
    // for all !z on pop list of c
    // findDescriptor(L, k, z.rightExtent, lookupSPPfNode(L, w, z))
    #if defined(TRACE)
      printf("Start of contingent pop processing\n");
    #endif

    for (int clusterPopElement = poolGet(clusterAElement + clusterElement_popList); clusterPopElement != 0; clusterPopElement = poolGet(clusterPopElement
        + clusterPopElement_popList)) {

      #if defined(TRACE)
        printf("Contingent pop iterated to clusterPopElement %i ", clusterPopElement);
        hashTablePrintClusterPopElement(clusterPopElement);
        printf("\n");
      #endif

      int popSPPFNode = poolGet(clusterPopElement + clusterPopElement_sppfNode);

      #if defined(TRACE)
        printf("Contingent pop using SPPF node %i ", popSPPFNode);
        hashTablePrintSPPFNode(popSPPFNode);
        printf("\n");
      #endif

      int derivationNode = findSPPF(clusterNonTerminal, currentsppfNode, popSPPFNode);
      findDescriptor(clusterNonTerminal, clusterIndex, poolGet(popSPPFNode + sppfNode_rightExtent), derivationNode);
      #if defined(STATISTICS)
        contingentPops++;
      #endif
    }
    #if defined(TRACE)
      printf("End of contingent pop processing\n");
    #endif

    return currentToken; // A bit kludgy - reduced descriptors do not require a return and C_u = C_I could be set in the template
  };

  int findGSSClusteredInitial(int stackTopLabel, int stackTop, int currentToken, int currentsppfNode) {

    // (* Find (lookup, and if necessary create) the clusters for the nonterminal to be called and for the LHS nonterminal *)
    // let slot(L) = !B ::= _ !A . _
    // c = findCluster(A, i)
    //
    // (* Make the GSS node v, add it to the nodelist of c, and add to v any inedges that have already been created for c *)
    // if lookupGSSNode(L, i) = null
    // v = createGSSNode(L, i)
    // add v to the node list of d

    #if defined(TRACE)
      printf("findGSSClusteredInitial(%s, %i, %i, ", artLabelInternalStrings[stackTopLabel], stackTop, currentToken);
      hashTablePrintSPPFNode(currentSPPFNode);
      printf(")\n");
    #endif

    int A = startSymbolLabel;

    bool clusterAFound = find(clusterElementBuckets, clusterElementBucketCount, clusterElement_SIZE, A, currentToken);
    int clusterAElement = findIndex;
    #if defined(TRACE)
      printf("findClusterElement ");
      hashTablePrintClusterElement(clusterAElement);
      printf(" - %sfound %i\n", clusterAFound ? "" : "not ", clusterAElement);
    #endif

    #if defined(STATISTICS)
      clusterElementFinds++;
    #endif

    bool gssNodeFound = find(gssNodeBuckets, gssNodeBucketCount, gssNode_SIZE, stackTopLabel, currentToken);
    int newGSSNode = findIndex;

    #if defined(TRACE)
      printf("findGSSNode (%s, %i)", artLabelInternalStrings[stackTopLabel], currentToken);
      printf(" - %sfound %i\n", gssNodeFound ? "" : "not ", newGSSNode);
    #endif

    #if defined(STATISTICS)
      gssNodeFinds++;
    #endif

    // If the GSS node was new, link it into its cluster
    int oldStackTop = poolGet(clusterAElement + clusterElement_nodeList);

    if (!gssNodeFound) {
      poolSet(newGSSNode + popElement_popElementList, oldStackTop);
      poolSet(clusterAElement + clusterElement_nodeList, newGSSNode);
    }

    return currentToken; // A bit kludgy - reduced descriptors do not require a return and C_u = C_I could be set in the template
  };

  void popClustered(int nonterminal, int k, int currentTokenIndex, int currentsppfNode) {
    // if (A, k, z) \not\in P {
    // insert (A, k, z) into P
    // c = findCluster(A, k)
    // for each GSS node u = ( (!L = _ ::= _ A . _), k) {
    // for each edge (u, !w, !v) {
    // findDescriptor_add(L, v.level, i, getSPPFNode(L, w, z))
    // add z to poplist of c

    #if defined(TRACE)
      printf("popClustered(%s, %i, %i, ", artLabelInternalStrings[nonterminal], k, currentTokenIndex);
      hashTablePrintSPPFNode(currentSPPFNode);
      printf(")\n");
    #endif

    bool popFound = find(popElementBuckets, popElementBucketCount, popElement_SIZE, nonterminal, k, currentsppfNode);
    int popIndex = findIndex;

    /* Trace output - report result of find() */
    #if defined(TRACE)
      printf("findpopElement ");
      hashTablePrintPopElement(popIndex);
      printf(" - %sfound %i\n", popFound ? "" : "not ", popIndex);
    #endif

    #if defined(STATISTICS)
      popElementFinds++;
    #endif

    if (popFound) {
      #if defined(TRACE)
        printf("Immediate return from popClustered\n");
      #endif
      return;
    }

    // Find our cluster c
    bool clusterFound = find(clusterElementBuckets, clusterElementBucketCount, clusterElement_SIZE, nonterminal, k);
    int clusterElement = findIndex;
    #if defined(TRACE)
      printf("findClusterElement for pop ");
      hashTablePrintClusterElement(clusterElement);
      printf(" - %sfound %i \n", clusterFound ? "" : "not ", clusterElement);
    #endif

    #if defined(STATISTICS)
      clusterElementFinds++;
    #endif

    // Iterate over all GSS nodes in this cluster
    for (int clusterNode = poolGet(clusterElement + clusterElement_nodeList); clusterNode != 0; clusterNode = poolGet(clusterNode
        + gssNode_pop_clusterElementList)) {
      // Iterate over all of the edges in this GSS node
      #if defined(TRACE)
        printf("popClustered iterating cluster node list to GSS node %i ", clusterNode);
        hashTablePrintGSSNode(clusterNode);
        printf("\n");
      #endif

      for (int outEdge = poolGet(clusterNode + gssNode_edgeList); outEdge != 0; outEdge = poolGet(outEdge + gssEdge_edgeList)) {
        #if defined(TRACE)
          printf("Popping GSSEdge %i ", outEdge);
          hashTablePrintGSSEdge(outEdge);
          printf("\n");
        #endif

        #if defined(STATISTICS)
        primaryPops++;
        #endif

        int derivationNode = findSPPF(poolGet(clusterNode + gssNode_label), poolGet(outEdge + gssEdge_sppfNode), currentsppfNode);
        int outEdgeDestination = poolGet(outEdge + gssEdge_destination);
        int clusterLevel = poolGet(outEdgeDestination + gssNode_level);
        findDescriptor(poolGet(clusterNode + clusterElement_label), clusterLevel, currentTokenIndex, derivationNode);
      }
    }

    // add pop element to cluster popList
    // Allocate pop element and head insert on cluster poplist
    allocateAndLoad(clusterPopElement_SIZE, currentSPPFNode);
    int popElement = findIndex;

    #if defined(TRACE)
      printf("popClustered allocated clusterPopElement %i ", popElement);
      hashTablePrintClusterPopElement(popElement);
      printf(")\n");
    #endif

    poolSet(popElement + clusterPopElement_popList, poolGet(clusterElement + clusterElement_popList));
    poolSet(clusterElement + clusterElement_popList, popElement);

    #if defined(TRACE)
      printf("Exiting popClustered(%s, %i, %i)\n", artLabelInternalStrings[nonterminal], k, currentTokenIndex);
    #endif
  }

	void findDescriptor(int restartLabel, int gssNode, int currentTokenIndex, int sppfNode) {
    // findDescriptor_add(L, u, i, w)
    // if (L, u, i, w) \not\in U then
    // insert(L, u, i, w) into both U and R
    bool found = find(descriptorBuckets, descriptorBucketCount, descriptor_SIZE, restartLabel, gssNode, currentTokenIndex, sppfNode);
    #if defined(STATISTICS)
     descriptorFinds++;
    #endif

    #if defined(TRACE)
      printf("findDescriptor ");
      hashTablePrintDescriptor(findIndex);
      printf(" - %sfound %i\n", found ? "" : "not ", findIndex);
    #endif

    if (!found) {
      bool processingPoppingDescriptor = popD[restartLabel];

      if (FIFODescriptors) { // Insert at tail new code
        if (processingPoppingDescriptor) {
          if (poppingDescriptorsToBeProcessed == 0) { // Special case of empty list - no sentinel
            pool[findBlockIndex][++findLoadOffset] = poppingDescriptorsToBeProcessed;
            poppingDescriptorsToBeProcessed = findIndex;
            poppingDescriptorsToBeProcessedTail = findIndex;
          } else {
            poolSet(poppingDescriptorsToBeProcessedTail + descriptor_descriptorList, findIndex);
            pool[findBlockIndex][++findLoadOffset] = 0;
            poppingDescriptorsToBeProcessedTail = findIndex;
          }
        } else {
          if (nonpoppingDescriptorsToBeProcessed == 0) { // Special case of empty list - no sentinel
            pool[findBlockIndex][++findLoadOffset] = nonpoppingDescriptorsToBeProcessed;
            nonpoppingDescriptorsToBeProcessed = findIndex;
            nonpoppingDescriptorsToBeProcessedTail = findIndex;
          } else {
            poolSet(nonpoppingDescriptorsToBeProcessedTail + descriptor_descriptorList, findIndex);
            pool[findBlockIndex][++findLoadOffset] = 0;
            nonpoppingDescriptorsToBeProcessedTail = findIndex;
          }
        }
      } else { // Insert at head - old code
        if (processingPoppingDescriptor) {
          pool[findBlockIndex][++findLoadOffset] = poppingDescriptorsToBeProcessed;
          poppingDescriptorsToBeProcessed = findIndex;
        } else {
          pool[findBlockIndex][++findLoadOffset] = nonpoppingDescriptorsToBeProcessed;
          nonpoppingDescriptorsToBeProcessed = findIndex;
        }
      }
    }
	}

  void findDescriptorClustered(int restartLabel, int gssNode, int currentTokenIndex, int sppfNode) {
    findDescriptor(restartLabel, gssNode, currentTokenIndex, sppfNode);
  };

	bool testRepeat(int regexpLabel, int stackTop,
			int currentTokenIndex, int derivationNode) {
		// bool testRepeat(T, u, i, w)
		// if (T, u, i, w) \in TR return true else {
		// insert (T, u, i, w) into TR
		// return false
		// }
		bool found = find(testRepeatElementBuckets,
				testRepeatElementBucketCount, testRepeatElement_SIZE,
				regexpLabel, stackTop, currentTokenIndex, derivationNode);

#if defined(STATISTICS)
    testRepeatElementFinds++;
#endif

		#if defined(TRACE)
			printf("testRepeat ");
			hashTablePrintTestRepeatElement(findIndex);
			printf(" - %sfound %i\n", found ? "" : "not ", findIndex);
    #endif

		return found;
	}

	void checkAcceptance() {
		#if defined(TRACE)
			printf("checkAcceptance\n");
    #endif

		inLanguage = find(sppfNodeBuckets, sppfNodeBucketCount, 0, startSymbolLabel, 0,
				inputLength - 1);

    #if defined(STATISTICS)
      incSPPFNodeFinds();
    #endif

    if (inLanguage)
      rootSPPFNode = findIndex;
    else {
      rootSPPFNode = 0;

      int rightmost = findRightmostLeftExtent();
      parseError(inputToCharacterStringMap[rightmost]);
    }
	}

	/**************************************************************************
	 * Lexical functions
	 *************************************************************************/
  private:
  int longestLength;
  int longestToken;

  int characterStringInputTest(char c, int characterStringInputIndex) {
    if (characterStringInput[characterStringInputIndex] == c)
      return 1;
    else
      return 0;
  }

  public:
  virtual void lexPreparseWhitespaceInstances() = 0;

  virtual void lexBuiltinInstances() = 0;

  void lexPreparseWhitespace() {
    int start;
    do {
      start = characterStringInputIndex;

      lexPreparseWhitespaceInstances();

    } while (characterStringInputIndex != start);
  }

  void updateLongestLength(int length, int tokenIndex) {
    if (length > longestLength) {
      longestLength = length;
      longestToken = tokenIndex;
    }
  }

	void matchLongestRaw() {
		longestLength = 0;

    if (characterStringInput[characterStringInputIndex] == '\0') {
      updateLongestLength(1, ART_L__EOS);
      return;
    }

    //Note: case insensitive ONLY!!
    for (int tokenIndex = artFirstTerminalLabel; tokenIndex < ART_L__EPSILON; tokenIndex++) {
			if (strncmp(&characterStringInput[characterStringInputIndex], artLabelStrings[tokenIndex], strlen(artLabelStrings[tokenIndex])) != 0)
				continue;

      updateLongestLength(strlen(artLabelStrings[tokenIndex]), tokenIndex);
		}

    lexBuiltinInstances();

		if (longestLength == 0) {
			printf("Error: at input position %i lexer found unexpected character %c\n",
					characterStringInputIndex, characterStringInput[characterStringInputIndex]);
			return;
		}
	}


  /*
   * Tokenise String rawInput into int[] input
   */
   const char *cc;
   const char getch(){
     return *cc++;
   }
   void skipSpace() {
     while (isspace(*cc))
       cc++;
   }
   int hasNextInt(){
     skipSpace();
     return isdigit(*cc);
   }
   int nextInt(){
     skipSpace();
     int ret = 0;
     while(isdigit(*cc))
      ret = ret * 10 + (*cc++ - '0');
     return ret;
   }

const char *strndup (const char *s, size_t n)
{
  char *result;
  size_t len = strlen (s);

  if (n < len)
    len = n;

  result = (char *) malloc (len + 1);
  if (!result)
    return 0;

  result[len] = '\0';
  return (const char *) memcpy (result, s, len);
}


   const char *nextLineTrim(){
     skipSpace();
     const char *start = cc;

     while (*cc != '\n')
       cc++;

     return strndup(start, cc-start);
   }

   void* newBlock(int size) {
     int *ret = new int[size];
     memset(ret, 0, size * sizeof(int));
     return ret;
   }

   void requireInt() {
     if (!hasNextInt()) {
        printf("lexical set file not in correct format: integer expected\n");
        exit(1);
      }
   }

   void lexLexicalSets() {
    int*** triples; // Indexed as leftExtent, token, rightExtent

    cc =characterStringInput;
    requireInt();
    inputLength = nextInt();

    triples = (int***) newBlock(inputLength + 1);

    while (hasNextInt()) {
      int leftExtent, rightExtent;
      requireInt();
      leftExtent = nextInt();
      requireInt();
      rightExtent = nextInt();
      const char* tokenName = nextLineTrim();
      int tokenNumber;

      for (tokenNumber = 1; tokenNumber < ART_L__EPSILON; tokenNumber++)
        if (strcmp(artLabelStrings[tokenNumber],tokenName) == 0) break;

      if (tokenNumber == ART_L__EPSILON) {
        printf("lexical set file is not consistent with parsing grammar - unable to find token '%s'\n", tokenName);
        exit(1);
      }

      if (triples[leftExtent] == NULL) triples[leftExtent] = (int**) newBlock(ART_L__EPSILON);
      if (triples[leftExtent][tokenNumber] == NULL) triples[leftExtent][tokenNumber] = (int*) newBlock(inputLength + 1);
      triples[leftExtent][tokenNumber][rightExtent] = 1;
    }

    triples[inputLength] = (int**) newBlock(ART_L__EPSILON);
    triples[inputLength][ART_L__EOS] = (int*) newBlock(inputLength + 1);
    triples[inputLength][ART_L__EOS][inputLength] = 1;

    // Size the set buffers - we have to scan right over the sets array which is ugly
    int successorSetsIndex = 1; // Keep the first element at zero so that inputSets[i] = 0 looks like an empty set for all i
    for (int leftExtent = inputLength - 1; leftExtent >= 0; leftExtent--)
      if (triples[leftExtent] != NULL) { // Are there any triple (leftExtent, a, i) ?
        successorSetsIndex++; // Space for cardinality ofthis slice
        for (int tokenNumber = 0; tokenNumber < ART_L__EPSILON; tokenNumber++)
          // Iterate over all possible tokens
          if (triples[leftExtent][tokenNumber] != NULL) { // are there any triples (leftExtent, tokenNumber, i)?
            successorSetsIndex += 3; // Space for a, i and cardinality of successors
            for (int rightExtent = 0; rightExtent < inputLength; rightExtent++)
              // Iterate over all possible right extents
              if (triples[leftExtent][tokenNumber][rightExtent] != 0) { // Is there a triple (leftExtent, tokenNumber, rightExtent)?
                // Now add 2 for each token, j pair
                for (int successorTokenNumber = 0; successorTokenNumber < ART_L__EPSILON; successorTokenNumber++)
                  if (triples[rightExtent] != NULL && triples[rightExtent][successorTokenNumber] != NULL) { // Is there a pair (rightExtent,
                                                                                                            // successorTokenNumber)?
                    successorSetsIndex += 2;
                  }
              }
          }
      }

    inputSetBuffer = (int*) newBlock(successorSetsIndex);
    inputSets = (int*) newBlock(inputLength + 1);

    // Scan the input sets array in reverse i order, constructing the sets as we go
    successorSetsIndex = 1; // Keep the first element at zero so that inputSets[i] = 0 looks like an empty set for all i
    for (int leftExtent = inputLength - 1; leftExtent >= 0; leftExtent--)
      // Iterate from right to left
      if (triples[leftExtent] != NULL) { // Are there any triple (leftExtent, a, i) ?
        inputSets[leftExtent] = successorSetsIndex++; // Point inputSets index at cardinality for this slice
        for (int tokenNumber = 0; tokenNumber < ART_L__EPSILON; tokenNumber++)
          // Iterate over all possible tokens
          if (triples[leftExtent][tokenNumber] != NULL) { // are there any triples (leftExtent, tokenNumber, i)?
            inputSetBuffer[successorSetsIndex++] = tokenNumber; // If so, load (leftExtent, tokenNumber) to this successorSet
            inputSetBuffer[successorSetsIndex++] = leftExtent;
            int cardinalitySlot = successorSetsIndex++; // Leave a space for the successor cardinality - default initialisation sets K = 0
            inputSetBuffer[inputSets[leftExtent]]++; // Bump slice cardinality for this slice
            for (int rightExtent = 0; rightExtent < inputLength; rightExtent++)
              // Iterate over all possible right extents
              if (triples[leftExtent][tokenNumber][rightExtent] != 0) { // Is there a triple (leftExtent, tokenNumber, rightExtent)?
                // Now fold in the addresses of all pairs for rightExtent (which have already been computed)
                int successorIndex = inputSets[rightExtent] + 1; // Set successorIndex up to point to first pair in successor state
                for (int successorElement = 0; successorElement < inputSetBuffer[inputSets[rightExtent]]; successorElement++) { // Iterate over all pairs
                                                                                                                                // starting at rightExtent
                  inputSetBuffer[successorSetsIndex++] = inputSetBuffer[successorIndex++]; // Copy the token and the left extent across
                  inputSetBuffer[successorSetsIndex++] = inputSetBuffer[successorIndex++];
                  inputSetBuffer[cardinalitySlot]++; // Bump successor cardinality
                  successorIndex += 2 * inputSetBuffer[successorIndex] + 1; // Jump past successor cardinality slot and the successors themselves
                }
              }
          }
      }
    writeSuccessorSets("artSuccessorSet.txt", triples);
  }

  void writeSuccessorSets(const char* fileName, int*** triples) {
    for (int i = 0; i < inputLength; i++)
      printf("inputSets[%d]  = %d\n", i, inputSets[i]);

      for (int temp = 0; temp < inputLength; temp++)
        printf("%d %d\n", temp, inputSetBuffer[temp]);

      // Uncomment this to enable output of triples

      // printf("%d\n", triples.length - 1);
      // for (int leftExtent = 0; leftExtent < triples.length; leftExtent++)
      // if (triples[leftExtent] != NULL) for (int tokenNumber = 0; tokenNumber < triples[leftExtent].length; tokenNumber++)
      // if (triples[leftExtent][tokenNumber] != NULL) for (int rightExtent = 0; rightExtent < triples[leftExtent][tokenNumber].length; rightExtent++)
      // if (triples[leftExtent][tokenNumber][rightExtent] != 0) printf("%d %d %s%n", leftExtent, rightExtent, artLabelStrings[tokenNumber]);

      for (int leftExtent = 0; leftExtent < inputLength - 1; leftExtent++) {
        int sliceCardinality = inputSetBuffer[inputSets[leftExtent]];
        int inputSetBufferIndex = inputSets[leftExtent] + 1;
        printf("%d: ", inputSetBufferIndex);
        for (int element = 0; element < sliceCardinality; element++) {
          printf("(%d %s) ->", inputSetBuffer[inputSetBufferIndex + 1], artLabelStrings[inputSetBuffer[inputSetBufferIndex]]);
          inputSetBufferIndex += 2;
          int successorCardinality = inputSetBuffer[inputSetBufferIndex++];
          for (int successor = 0; successor < successorCardinality; successor++) {
            printf(" (%d %s)", inputSetBuffer[inputSetBufferIndex + 1], artLabelStrings[inputSetBuffer[inputSetBufferIndex]]);
            inputSetBufferIndex += 2;
          }
          printf(" .\n");
        }
      }
  }

  void lexLongestMatch() {
    bool suppressWhitespace;

    characterStringInputIndex = currentInputIndex = 0;
    suppressWhitespace = false;
    do {
      if (!suppressWhitespace) lexPreparseWhitespace();
      matchLongestRaw();
      if (longestLength == 0)
        return; // On lex error, return

      suppressWhitespace = artKindOfs[longestToken] == ART_K_CHARACTER_TERMINAL;
      characterStringInputIndex += longestLength;
      currentInputIndex++;
    } while (longestToken != ART_L__EOS);

    inputLength = currentInputIndex;
    inputSets = (int*) newBlock(inputLength);
    const int sliceSize = 5;
    inputSetBuffer = (int*) newBlock(inputLength * sliceSize);

    for (int i = 0; i < inputLength; i++) {
      inputSets[i] = i * sliceSize;
      inputSetBuffer[i * sliceSize + 0] = 1; // Cardinality must be one for this lexer model
      inputSetBuffer[i * sliceSize + 1] = 666; // Space for token
      inputSetBuffer[i * sliceSize + 2] = i; // Left extent is i
      inputSetBuffer[i * sliceSize + 3] = 1; // Successor cardinality is one (except for $)
      inputSetBuffer[i * sliceSize + 4] = ((i + 1) * sliceSize) + 1; // Reference to successor pair
    }

    inputToCharacterStringMap = (int*) newBlock(inputLength);

    characterStringInputIndex = currentInputIndex = 0;
    suppressWhitespace = false;
    do {
      if (!suppressWhitespace) lexPreparseWhitespace();
      inputToCharacterStringMap[currentInputIndex] = characterStringInputIndex;
      matchLongestRaw();
      suppressWhitespace = artKindOfs[longestToken] == ART_K_CHARACTER_TERMINAL;
      characterStringInputIndex += longestLength;
      inputSetBuffer[(currentInputIndex * sliceSize) + 1] = longestToken;
      currentInputIndex++;
    } while (longestToken != ART_L__EOS);

    // writeSuccessorSets("lexLongestMatchAsSets.txt", NULL);
  }

  int artBuiltin_OCAML_LABEL_NAME(int characterStringInputIndex) { // This is like ID, but allows ` and ' characters internally
    int startIndex = characterStringInputIndex;
    if (isalpha(characterStringInput[characterStringInputIndex]) || characterStringInput[characterStringInputIndex] == '_')
      while (isalnum(characterStringInput[characterStringInputIndex]) || characterStringInput[characterStringInputIndex] == '_'
          || characterStringInput[characterStringInputIndex] == '`' || characterStringInput[characterStringInputIndex] == '\'')
        characterStringInputIndex++;

    return characterStringInputIndex - startIndex;
  }

  // These functions should be replaced by boolean lookup tables for efficiency
  bool artIsOCAML_OPERATOR_CHAR(int characterStringInputIndex) {
    return characterStringInput[characterStringInputIndex] == '!' || characterStringInput[characterStringInputIndex] == '$'
        || characterStringInput[characterStringInputIndex] == '%' || characterStringInput[characterStringInputIndex] == '&'
        || characterStringInput[characterStringInputIndex] == '*' || characterStringInput[characterStringInputIndex] == '+'
        || characterStringInput[characterStringInputIndex] == '-' || characterStringInput[characterStringInputIndex] == '.'
        || characterStringInput[characterStringInputIndex] == '/' || characterStringInput[characterStringInputIndex] == ':'
        || characterStringInput[characterStringInputIndex] == '<' || characterStringInput[characterStringInputIndex] == '='
        || characterStringInput[characterStringInputIndex] == '>' || characterStringInput[characterStringInputIndex] == '?'
        || characterStringInput[characterStringInputIndex] == '@' || characterStringInput[characterStringInputIndex] == '^'
        || characterStringInput[characterStringInputIndex] == '|' || characterStringInput[characterStringInputIndex] == '~';
  }

  bool artIsOCAML_PREFIX_SYMBOL_INITIAL_CHAR(int characterStringInputIndex) {
    return characterStringInput[characterStringInputIndex] == '!' || characterStringInput[characterStringInputIndex] == '?'
        || characterStringInput[characterStringInputIndex] == '~';
  }

  bool artIsOCAML_INFIX_SYMBOL_INITIAL_CHAR(int characterStringInputIndex) {
    return characterStringInput[characterStringInputIndex] == '=' || characterStringInput[characterStringInputIndex] == '<'
        || characterStringInput[characterStringInputIndex] == '>' || characterStringInput[characterStringInputIndex] == '@'
        || characterStringInput[characterStringInputIndex] == '^' || characterStringInput[characterStringInputIndex] == '|'
        || characterStringInput[characterStringInputIndex] == '&' || characterStringInput[characterStringInputIndex] == '+'
        || characterStringInput[characterStringInputIndex] == '-' || characterStringInput[characterStringInputIndex] == '*'
        || characterStringInput[characterStringInputIndex] == '/' || characterStringInput[characterStringInputIndex] == '$'
        || characterStringInput[characterStringInputIndex] == '%';
  }

  int artBuiltin_OCAML_INFIX_SYMBOL(int characterStringInputIndex) {
    if (!artIsOCAML_INFIX_SYMBOL_INITIAL_CHAR(characterStringInputIndex)) return 0;

    int startIndex = characterStringInputIndex;

    characterStringInputIndex++;

    while (artIsOCAML_OPERATOR_CHAR(characterStringInputIndex))
      characterStringInputIndex++;

    return characterStringInputIndex - startIndex;
  }

  int artBuiltin_OCAML_PREFIX_SYMBOL(int characterStringInputIndex) {
    if (!artIsOCAML_PREFIX_SYMBOL_INITIAL_CHAR(characterStringInputIndex)) return 0;

    int startIndex = characterStringInputIndex;

    characterStringInputIndex++;

    while (artIsOCAML_OPERATOR_CHAR(characterStringInputIndex))
      characterStringInputIndex++;

    return characterStringInputIndex - startIndex;
  }

  int artBuiltin_ID(int characterStringInputIndex) {
    int startIndex = characterStringInputIndex;

    if (isalpha(characterStringInput[characterStringInputIndex]) || characterStringInput[characterStringInputIndex] == '_')
      while (isalnum(characterStringInput[characterStringInputIndex]) || characterStringInput[characterStringInputIndex] == '_')
        characterStringInputIndex++;

    return characterStringInputIndex - startIndex;
  }

  int artBuiltin_INTEGER(int characterStringInputIndex) {
    int startIndex = characterStringInputIndex;

    /* Check for hexadecimal introducer */
    bool hex = (characterStringInput[characterStringInputIndex] == '0' && (characterStringInput[characterStringInputIndex + 1] == 'x' ||
                characterStringInput[characterStringInputIndex + 1] == 'X'));

    if (hex) characterStringInputIndex += 2; // Skip over hex introducer

    /* Now collect decimal or hex digits */
    while ((hex ? isxdigit(characterStringInput[characterStringInputIndex]) : isdigit(characterStringInput[characterStringInputIndex])))
      characterStringInputIndex++;

    return characterStringInputIndex - startIndex;
  }

  int artBuiltin_REAL(int characterStringInputIndex) {
    int startIndex = characterStringInputIndex;

    if (!isdigit(characterStringInput[characterStringInputIndex])) // Reals must contain at least one leading digit
      return characterStringInputIndex - startIndex;

    while (isdigit(characterStringInput[characterStringInputIndex]))
      characterStringInputIndex++;

    if (characterStringInput[characterStringInputIndex] != '.'
        || (characterStringInput[characterStringInputIndex] == '.' && !isdigit(characterStringInput[characterStringInputIndex + 1])))
      return characterStringInputIndex - startIndex;

    characterStringInputIndex++; // skip .

    while (isdigit(characterStringInput[characterStringInputIndex]))
      characterStringInputIndex++;

    if (characterStringInput[characterStringInputIndex] == 'e' || characterStringInput[characterStringInputIndex] == 'E') {
      characterStringInputIndex++;

      while (isdigit(characterStringInput[characterStringInputIndex]))
        characterStringInputIndex++;
    }

    return characterStringInputIndex - startIndex;
  }

  int artBuiltin_CHAR_SQ(int characterStringInputIndex) {

    if (characterStringInput[characterStringInputIndex] != '\'') return 0;

    int startIndex = characterStringInputIndex;

    characterStringInputIndex++;

    if (characterStringInput[characterStringInputIndex] == '\\') characterStringInputIndex++;

    characterStringInputIndex++;

    if (characterStringInput[characterStringInputIndex] != '\'') return 0;

    characterStringInputIndex++; // skip past final delimiter

    return characterStringInputIndex - startIndex;
  }

  int artBuiltin_CHAR_BQ(int characterStringInputIndex) {
    if (characterStringInput[characterStringInputIndex] != '`') return 0;

    int startIndex = characterStringInputIndex;

    if (characterStringInput[characterStringInputIndex] != '\\') {
      if (characterStringInput[characterStringInputIndex + 1] == '0'
          && (characterStringInput[characterStringInputIndex + 2] == 'x' || characterStringInput[characterStringInputIndex + 2] == 'X')
          && isxdigit(characterStringInput[characterStringInputIndex + 3])
          && isxdigit(characterStringInput[characterStringInputIndex + 4])
          )
        characterStringInputIndex += 5;
      else
        characterStringInputIndex += 2;
    }

    return characterStringInputIndex - startIndex;
  }

  int artBuiltin_STRING_SQ(int characterStringInputIndex) {
    if (characterStringInput[characterStringInputIndex] != '\'') return 0;

    int startIndex = characterStringInputIndex;

    do {
      if (characterStringInput[characterStringInputIndex] == '\\') characterStringInputIndex++;

      characterStringInputIndex++;
    } while (characterStringInput[characterStringInputIndex] != '\'' && characterStringInput[characterStringInputIndex] != '\0');

    if (characterStringInput[characterStringInputIndex] == '\0') {
      printf("Fatal - unterminated STRING_SQ at %i\n", startIndex);
      exit(1);
    }

    characterStringInputIndex++; // skip past final delimiter

    return characterStringInputIndex - startIndex;
  }

  int artBuiltin_STRING_DQ(int characterStringInputIndex) {
    if (characterStringInput[characterStringInputIndex] != '"') return 0;

    int startIndex = characterStringInputIndex;

    do {
      if (characterStringInput[characterStringInputIndex] == '\\') characterStringInputIndex++;
      characterStringInputIndex++;
    } while (characterStringInput[characterStringInputIndex] != '"' && characterStringInput[characterStringInputIndex] != '\0');

    if (characterStringInput[characterStringInputIndex] == '\0') {
      printf("Fatal - unterminated STRING_DQ at %i\n", startIndex);
      exit(1);
    }

    characterStringInputIndex++; // skip past final delimiter

    return characterStringInputIndex - startIndex;
  }

  int artBuiltin_STRING_BQ(int characterStringInputIndex) {
    if (characterStringInput[characterStringInputIndex] != '`') return 0;

    int startIndex = characterStringInputIndex;

    do {
      if (characterStringInput[characterStringInputIndex] == '\\') characterStringInputIndex++;

      characterStringInputIndex++;
    } while (characterStringInput[characterStringInputIndex] != '`' && characterStringInput[characterStringInputIndex] != '\0');

    if (characterStringInput[characterStringInputIndex] == '\0') {
      printf("Fatal - unterminated STRING_BQ at %i\n", startIndex);
      exit(1);
    }

    characterStringInputIndex++; // skip past final delimiter

    return characterStringInputIndex - startIndex;
  }

  int artBuiltin_STRING_BB(int characterStringInputIndex) {
    if (!((characterStringInput[characterStringInputIndex] == '[') && (characterStringInput[characterStringInputIndex + 1] == '['))) return 0;

    int startIndex = characterStringInputIndex;

    do {
      if (characterStringInput[characterStringInputIndex] == '\\') characterStringInputIndex++;
      characterStringInputIndex++;
    } while (!((characterStringInput[characterStringInputIndex] == ']') && (characterStringInput[characterStringInputIndex + 1] == ']'))
        && characterStringInput[characterStringInputIndex] != '\0');

    if (characterStringInput[characterStringInputIndex] == '\0') {
      printf("Fatal - unterminated STRING_BB at %i\n", startIndex);
      exit(1);
    }

    characterStringInputIndex++;
    characterStringInputIndex++; // skip past final delimiter

    return characterStringInputIndex - startIndex;
  }

  int artBuiltin_WHITESPACE(int characterStringInputIndex) {
    int startIndex = characterStringInputIndex;

    while (characterStringInput[characterStringInputIndex] != '\0' && (isspace(characterStringInput[characterStringInputIndex])))
      characterStringInputIndex++;

    return characterStringInputIndex - startIndex;
  }

  int artBuiltin_COMMENT_NEST_ART(int characterStringInputIndex) {
    if (!((characterStringInput[characterStringInputIndex] == '(') && (characterStringInput[characterStringInputIndex + 1] == '*'))) return 0;

    int nestingLevel = 1;

    int startIndex = characterStringInputIndex;

    if (characterStringInput[characterStringInputIndex] == '(' && characterStringInput[characterStringInputIndex + 1] == '*') {
      characterStringInputIndex += 2;

      while (nestingLevel > 0) {

        if (characterStringInput[characterStringInputIndex] == '\0') break;

        if (characterStringInput[characterStringInputIndex] == '(' && characterStringInput[characterStringInputIndex + 1] == '*') {
          characterStringInputIndex += 2;
          nestingLevel++;
        } else if (characterStringInput[characterStringInputIndex] == '*' && characterStringInput[characterStringInputIndex + 1] == ')') {
          characterStringInputIndex += 2;
          nestingLevel--;
        } else
          characterStringInputIndex++;
      }
    }

    if (characterStringInput[characterStringInputIndex] == '\0') {
      printf("Fatal - unterminated COMMENT_NEST_ART at %i\n", startIndex);
      exit(1);
    }

    return characterStringInputIndex - startIndex;
  }

  int artBuiltin_COMMENT_BLOCK_C(int characterStringInputIndex) {
    if (!((characterStringInput[characterStringInputIndex] == '/') && (characterStringInput[characterStringInputIndex + 1] == '*'))) return 0;

    int startIndex = characterStringInputIndex;

    if (characterStringInput[characterStringInputIndex] == '/' && characterStringInput[characterStringInputIndex + 1] == '*') {
      characterStringInputIndex += 2;

      while (true) {
        if (characterStringInput[characterStringInputIndex] == '\0') break;

        if (characterStringInput[characterStringInputIndex] == '*' && characterStringInput[characterStringInputIndex + 1] == '/') {
          characterStringInputIndex += 2;
          break;
        }

        characterStringInputIndex++;
      }
    }

    if (characterStringInput[characterStringInputIndex] == '\0') {
      printf("Fatal - unterminated COMMENT_BLOCK_C at %i\n", startIndex);
      exit(1);
    }

    return characterStringInputIndex - startIndex;
  }

  int artBuiltin_COMMENT_LINE_C(int characterStringInputIndex) {
    if (!((characterStringInput[characterStringInputIndex] == '/') && (characterStringInput[characterStringInputIndex + 1] == '/'))) return 0;

    int startIndex = characterStringInputIndex;

    if (characterStringInput[characterStringInputIndex] == '/' && characterStringInput[characterStringInputIndex + 1] == '/')
      while (characterStringInput[characterStringInputIndex] != '\0' && characterStringInput[characterStringInputIndex] != '\n')
        characterStringInputIndex++;

    return characterStringInputIndex - startIndex;
  }

    void parseError(int errorPosition) {
			printf("Error: at input position %i parser found unexpected symbol\n", errorPosition);
  }

	/**************************************************************************
	 * Timer methods
	 *************************************************************************/
	void startClock(){
#if defined(NANOSECOND)
    if (clock_gettime(CLOCK_MONOTONIC, &startTime_CLOCK_MONOTONIC) != 0)
      printf("!!! Error in timer function\n");
    if (clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &startTime_CLOCK_PROCESS_CPUTIME_ID) != 0)
      printf("!!! Error in timer function\n");
#endif
#if defined(RUSAGE)
  if (getrusage(RUSAGE_SELF, &startUsage) != 0)
    printf("!!! Error in getrusage() function\n");
#endif
    startTime = clock();
  }

	void stopClock() {
#if defined(RUSAGE)
  rusage usage;

  if (getrusage(RUSAGE_SELF, &stopUsage) != 0)
    printf("!!! Error in getrusage() function\n");
#endif

#if defined(NANOSECOND)
    if (clock_gettime(CLOCK_MONOTONIC, &stopTime_CLOCK_MONOTONIC) != 0)
      printf("!!! Error in timer function\n");
    if (clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &stopTime_CLOCK_PROCESS_CPUTIME_ID) != 0)
      printf("!!! Error in timer function\n");
#endif
    stopTime = clock();
  }

	/**************************************************************************
	 * Table initialisation
	 *************************************************************************/
	void setIntArray(int* array, int lo, int hi) {
	  for (int tmp = lo; tmp < hi; tmp++) array[tmp] = tmp;
	}

	void setIntArray(artLabel* array, int lo, enum artLabel hi) {
	  for (int tmp = lo; tmp < (int) hi; tmp++) array[tmp] = (enum artLabel) tmp;
	}

	void setIntArray(int * array, int lo, int hi, int value) {
		for (int tmp = lo; tmp < hi; tmp++) array[tmp] = value;
	}

	void setIntArray(enum artFold * array, int lo, int hi, int value) {
		for (int tmp = lo; tmp < hi; tmp++) array[tmp] = (enum artFold) value;
	}

	void setStringArray(const char** array, int lo, int hi, const char* value) {
		for (int tmp = lo; tmp < hi; tmp++) array[tmp] = value;
	}

	void setBoolArray(bool * array, int lo, int hi, bool value) {
		for (int tmp = lo; tmp < hi; tmp++) array[tmp] = value;
	}


	/**************************************************************************
	 * Descriptor management methods
	 *************************************************************************/
	bool noDescriptors() { return nonpoppingDescriptorsToBeProcessed == 0 && poppingDescriptorsToBeProcessed == 0; }

	void unloadDescriptor() {
    // Nonpopping descriptors have priority over popping descriptors
    bool processingPoppingDescriptor = nonpoppingDescriptorsToBeProcessed == 0;

    if (processingPoppingDescriptor) {
      currentDescriptor = poppingDescriptorsToBeProcessed;
      poppingDescriptors++;
    }
    else {
      currentDescriptor = nonpoppingDescriptorsToBeProcessed;
      nonpoppingDescriptors++;
    }


    #if defined(TRACE)
      printf("\n******\n\nProcessing descriptor ");
      hashTablePrintDescriptor(currentDescriptor);
      printf("\n");
    #endif

    int* descriptorPoolBlock = pool[currentDescriptor >> poolAddressOffset];
    int descriptorOffset = currentDescriptor & poolAddressMask;

    currentRestartLabel = descriptorPoolBlock[descriptorOffset + descriptor_label];
    currentInputIndex = descriptorPoolBlock[descriptorOffset + descriptor_inputIndex];
    currentInputPairReference = inputSets[currentInputIndex] + 1;
    currentGSSNode = descriptorPoolBlock[descriptorOffset + descriptor_gssNode];
    currentSPPFNode = descriptorPoolBlock[descriptorOffset + descriptor_sppfNode];

    if (processingPoppingDescriptor)
      poppingDescriptorsToBeProcessed = descriptorPoolBlock[descriptorOffset + descriptor_descriptorList];
    else
      nonpoppingDescriptorsToBeProcessed = descriptorPoolBlock[descriptorOffset + descriptor_descriptorList];
	}

	void unloadDescriptorMGLL() {
    // Nonpopping descriptors have priority over popping descriptors
    bool processingPoppingDescriptor = nonpoppingDescriptorsToBeProcessed == 0;

    if (processingPoppingDescriptor) {
      currentDescriptor = poppingDescriptorsToBeProcessed;
      poppingDescriptors++;
    }
    else {
      currentDescriptor = nonpoppingDescriptorsToBeProcessed;
      nonpoppingDescriptors++;
    }


    #if defined(TRACE)
      printf("\n******\n\nProcessing descriptor ");
      hashTablePrintDescriptor(currentDescriptor);
      printf("\n");
    #endif

    int* descriptorPoolBlock = pool[currentDescriptor >> poolAddressOffset];
    int descriptorOffset = currentDescriptor & poolAddressMask;

    currentRestartLabel = descriptorPoolBlock[descriptorOffset + descriptor_label];
    currentInputIndex = descriptorPoolBlock[descriptorOffset + descriptor_inputIndex];
    currentGSSNode = descriptorPoolBlock[descriptorOffset + descriptor_gssNode];
    currentSPPFNode = descriptorPoolBlock[descriptorOffset + descriptor_sppfNode];

    if (processingPoppingDescriptor)
      poppingDescriptorsToBeProcessed = descriptorPoolBlock[descriptorOffset + descriptor_descriptorList];
    else
      nonpoppingDescriptorsToBeProcessed = descriptorPoolBlock[descriptorOffset + descriptor_descriptorList];
	}

/**************************************************************************
 * User accessible functions
 *************************************************************************/
public:
/**
   * Public parser access
   */
  bool getInLanguage() {
    return inLanguage;
  }

  int getInputLength() {
    return inputLength;
  }

  long getPrimaryPops() {
    return primaryPops;
  }

  long getContingentPops() {
    return contingentPops;
  }

  long getPoppingDescriptors() {
    return poppingDescriptors;
  }

  long getNonpoppingDescriptors() {
    return nonpoppingDescriptors;
  }

  double getRunTime() {
    return ((double) stopTime - (double) startTime) / CLOCKS_PER_SEC;
  }

  const char* getGrammarName() {
    return grammarName;
  }

  int getStartSymbolLabel() {
    return startSymbolLabel;
  }

  const char* getBuildOptions() {
    return buildOptions;
  }

  int getLabelKind(int label) {
    return artKindOfs[label];
  }

  int getLabelUserName(int label) {
    return artUserNameOfs[label];
  }

  int getFirstUnusedLabel() {
    return artFirstUnusedLabel;
  }

  int nonterminalLabel(const char* nonterminalName) {
    for (int s = 0; s < getFirstUnusedLabel(); s++)
      if (artKindOfs[s] == ART_K_NONTERMINAL && strcmp(artLabelStrings[s], nonterminalName) == 0) return s;

    return ART_L__EOS;
  }

const char* getLabelString(int label) {
    return artLabelStrings[label];
  }

  const char* getLabelInternalString(int label) {
    return artLabelInternalStrings[label];
  }

  virtual void parseGenerated(const char* characterString, int startLabel) = 0;

  public:

  void parse(char* inputString, int nonterminalLabel) {
    if (getLabelKind(nonterminalLabel) != ART_K_NONTERMINAL) {
      text->printf(TL_FATAL, "Error: parse start label %i is not a nonterminal\n", nonterminalLabel);
    } else {
      initialise();
      parseGenerated(inputString, nonterminalLabel);
    }
  }

  void parse(char* inputString, char* nonterminalName) {
    if (nonterminalName == NULL)
      parse(inputString);
    else
      parse(inputString, nonterminalLabel(nonterminalName));
  };

  void parse(char* inputString) {
    parse(inputString, defaultStartSymbolLabel);
  };

/**************************************************************************
 * Constructor; initialise pool and hash tables
 *************************************************************************/
public:
GLLHashPool() {
  pool = NULL;
}

#if defined(STATISTICS)
private:
  unsigned long computeHistogram(GLLHistogram** histogram, int *buckets, int bucketCount) {
    *histogram = new GLLHistogram();
    unsigned long cardinality = 0;
    for (int bucket = 0; bucket < bucketCount; bucket++) {
      unsigned chainLength = 0;
      for (int element = buckets[bucket]; element != 0; element = poolGet(element)) {
        chainLength++;
        cardinality += 1;
      }

      ( *histogram )->update(chainLength);
      overallHistogram->update(chainLength);
    }
    return cardinality;
  }
#endif

  private: void computeSPPFStatistics() {
    for (int bucket = 0; bucket < sppfNodeBucketCount; bucket++) {
      for (int element = sppfNodeBuckets[bucket]; element != 0; element = poolGet(element)) {
        int sppfNodeLabel = poolGet(element + sppfNode_label);

        switch (artKindOfs[sppfNodeLabel]) {
        case ART_K_ILLEGAL:
          sppfOtherNodes++;
          break;
        case ART_K_EOS:
          sppfOtherNodes++;
          break;
        case ART_K_EPSILON:
          sppfEpsilonNodes++;
          break;
        case ART_K_BUILTIN_TERMINAL:
          sppfTerminalNodes++;
          break;
        case ART_K_CHARACTER_TERMINAL:
          sppfTerminalNodes++;
          break;
        case ART_K_CASE_SENSITIVE_TERMINAL:
          sppfTerminalNodes++;
          break;
        case ART_K_CASE_INSENSITIVE_TERMINAL:
          sppfTerminalNodes++;
          break;
        case ART_K_NONTERMINAL:
          sppfNonterminalNodes++;
          break;
        case ART_K_INTERMEDIATE:
          sppfIntermediateNodes++;
          break;
        case ART_K_END_OF_RULE:
          sppfOtherNodes++;
          break;
        case ART_K_DO_FIRST:
          sppfOtherNodes++;
          break;
        case ART_K_OPTIONAL:
          sppfOtherNodes++;
          break;
        case ART_K_POSITIVE_CLOSURE:
          sppfOtherNodes++;
          break;
        case ART_K_KLEENE_CLOSURE:
          sppfOtherNodes++;
          break;
        }

        int sppfPackNodeFirst = abs(poolGet(element + sppfNode_packNodeList));

        if (sppfPackNodeFirst != 0 && poolGet(sppfPackNodeFirst + sppfPackNode_packNodeList) != 0) sppfAmbiguityNodes++;
      }
    }
  }

public:
  void computeStatistics() {
#if defined(STATISTICS)
    overallCardinality += sppfNodeCardinality = computeHistogram(&sppfNodeHistogram, sppfNodeBuckets, sppfNodeBucketCount);
    overallCardinality += sppfPackNodeCardinality = computeHistogram(&sppfPackNodeHistogram, sppfPackNodeBuckets, sppfPackNodeBucketCount);
    overallCardinality += gssNodeCardinality = computeHistogram(&gssNodeHistogram, gssNodeBuckets, gssNodeBucketCount);
    overallCardinality += gssEdgeCardinality = computeHistogram(&gssEdgeHistogram, gssEdgeBuckets, gssEdgeBucketCount);
    overallCardinality += popElementCardinality = computeHistogram(&popElementHistogram, popElementBuckets, popElementBucketCount);
    overallCardinality += descriptorCardinality = computeHistogram(&descriptorHistogram, descriptorBuckets, descriptorBucketCount);
    overallCardinality += testRepeatElementCardinality = computeHistogram(&testRepeatElementHistogram, testRepeatElementBuckets, testRepeatElementBucketCount);
    overallCardinality += clusterElementCardinality = computeHistogram(&clusterElementHistogram, clusterElementBuckets, clusterElementBucketCount);

    computeSPPFStatistics();
#endif
  };


private:
  void initialise() {
  inputSets = NULL;

  startSymbolLabel = 0;
  renderKind = renderKindIllegal;
  hashMult = 0.5 * sqrt(5 - 1);
  hashMultInt = (int) hashMult + 0.5;
  poppingDescriptorsToBeProcessed = nonpoppingDescriptorsToBeProcessed =0;
	if (pool == NULL) {
    poolBlockCount = poolBlockInitialCount;
  	pool = new int*[poolBlockCount];
    memset(pool, 0, poolBlockCount * sizeof(int*));
  	pool[0] = new int[poolBlockSize];
    memset(pool[0], 0, poolBlockSize * sizeof(int));

    sppfNodeBucketCount = sppfNodeBucketInitialCount;
    sppfNodeBuckets = new int[sppfNodeBucketInitialCount];
    memset(sppfNodeBuckets, 0, sppfNodeBucketInitialCount * sizeof(int));

    sppfPackNodeBucketCount = sppfPackNodeBucketInitialCount;
    sppfPackNodeBuckets = new int[sppfPackNodeBucketInitialCount];
    memset(sppfPackNodeBuckets, 0, sppfPackNodeBucketInitialCount * sizeof(int));

    gssNodeBucketCount = gssNodeBucketInitialCount;
    gssNodeBuckets = new int[gssNodeBucketInitialCount];
    memset(gssNodeBuckets, 0, gssNodeBucketInitialCount * sizeof(int));

    gssEdgeBucketCount = gssEdgeBucketInitialCount;
    gssEdgeBuckets = new int[gssEdgeBucketInitialCount];
    memset(gssEdgeBuckets, 0, gssEdgeBucketInitialCount * sizeof(int));

    popElementBucketCount = popElementBucketInitialCount;
    popElementBuckets = new int[popElementBucketInitialCount];
    memset(popElementBuckets, 0, popElementBucketInitialCount * sizeof(int));

    descriptorBucketCount = descriptorBucketInitialCount;
    descriptorBuckets = new int[descriptorBucketInitialCount];
    memset(descriptorBuckets, 0, descriptorBucketInitialCount * sizeof(int));

    testRepeatElementBucketCount = testRepeatElementBucketInitialCount;
    testRepeatElementBuckets = new int[testRepeatElementBucketInitialCount];
    memset(testRepeatElementBuckets, 0, testRepeatElementBucketInitialCount * sizeof(int));

    clusterElementBucketCount = clusterElementBucketInitialCount;
    clusterElementBuckets = new int[clusterElementBucketInitialCount];
    memset(clusterElementBuckets, 0, clusterElementBucketInitialCount * sizeof(int));
  }

  // Clear tables

	poolBlockTop = 0;
	poolOffsetTop = 2; // Block 0, offsets 0 and 1 reserved for 'not found' and illegal values
	pool[0][1] = -1; // Defensive programming: make the first label element illegal to catch address zero errors

  rootSPPFNode = rootGSSNode = 0;
  primaryPops = 0;
  contingentPops = 0;
  poppingDescriptors = 0;
  nonpoppingDescriptors = 0;
  overallHistogram = new GLLHistogram();
  overallCardinality = 0;

  sppfNodeHistogram = NULL;
  sppfNodeCardinality = 0;
  sppfNodeFinds = 0;

  sppfPackNodeHistogram = NULL;
  sppfPackNodeCardinality = 0;
  sppfPackNodeFinds = 0;

  gssNodeHistogram = NULL;
  gssNodeCardinality = 0;
  gssNodeFinds = 0;

  gssEdgeHistogram = NULL;
  gssEdgeCardinality = 0;
  gssEdgeFinds = 0;

  popElementHistogram = NULL;
  popElementCardinality = 0;
  popElementFinds = 0;

  descriptorHistogram = NULL;
  descriptorCardinality = 0;
  descriptorFinds = 0;

  testRepeatElementHistogram = NULL;
  testRepeatElementCardinality = 0;
  testRepeatElementFinds = 0;

  clusterElementHistogram = NULL;
  clusterElementCardinality = 0;
  clusterElementFinds = 0;

  sppfEpsilonNodes = 0;
  sppfTerminalNodes = 0;
  sppfNonterminalNodes = 0;
  sppfIntermediateNodes = 0;
  sppfOtherNodes = 0;
  sppfAmbiguityNodes = 0;

  primaryPops = 0;
  contingentPops = 0;
  poppingDescriptors = 0;
  nonpoppingDescriptors = 0;

  hashCollisions = 0;
  hashTableResizes = 0;

  softPageFaults = -1;
  hardPageFaults = -1;

	startTime = 0;
  stopTime = 0;

#if defined(NANOSECOND)
	startTime_CLOCK_MONOTONIC.tv_sec = 0;
  startTime_CLOCK_MONOTONIC.tv_nsec = 0;
	stopTime_CLOCK_MONOTONIC.tv_sec = 0;
  stopTime_CLOCK_MONOTONIC.tv_nsec = 0;

	startTime_CLOCK_MONOTONIC.tv_sec = 0;
  startTime_CLOCK_MONOTONIC.tv_nsec = 0;
	stopTime_CLOCK_MONOTONIC.tv_sec = 0;
  stopTime_CLOCK_MONOTONIC.tv_nsec = 0;
#endif

}

    /**
   * Rendering
   */
  private: FILE *renderFile;

  private: int renderKind;

private: const char* renderGraphPrelude(bool landscape) {
    return landscape ? "graph:{\n" "layoutalgorithm:tree\n" "splines:yes\n" "orientation:left_to_right\n"
        "edge.arrowsize:7\n" "edge.thickness:1\n" "display_edge_labels:yes\n" "arrowmode:free\n" "node.borderwidth:1\n" :

        "graph:{\n" "layoutalgorithm:tree\n" "splines:yes\n" "orientation:top_to_bottom\n"
        "edge.arrowsize:7\n" "edge.thickness:1\n" "display_edge_labels:yes\n" "arrowmode:free\n" "node.borderwidth:1\n";
  }

  private: const char* renderGraphPostlude() {
    return "}\n";
  }

  private: void renderGSSNodeTitle(int element) {
    fprintf(renderFile, "%i: %i %s", element, gssNodeLevel(element), artLabelInternalStrings[gssNodeLabel(element)]);
  }

  private: void renderGSSNode(int element) {
    renderCount++;
    fprintf(renderFile, "node:{shape:box color:white level:%i horizontal_order:%i title:\"", gssNodeLevel(element));
    renderGSSNodeTitle(element);
    fprintf(renderFile, "\"}\n");
  }

  private: void renderGSSEdge(int element) {
    fprintf(renderFile, "backedge:{sourcename:\"");
    renderGSSNodeTitle(gssEdgeSource(element));
    fprintf(renderFile, "\" targetname:\"");
    renderGSSNodeTitle(gssEdgeDestination(element));
    fprintf(renderFile, "\" label:\"");
    renderSPPFNodeTitle(gssEdgeSPPFNode(element));
    fprintf(renderFile, "\"}\n");
  }

  private: void renderSPPFNodeTitle(int element) {
    fprintf(renderFile, "%i: %i,%i %s",
    element, sppfNodeLeftExtent(element), sppfNodeRightExtent(element), artLabelInternalStrings[sppfNodeLabel(element)]);
  }

  private: void renderSPPFPackNodeTitle(int element) {
    int parent = sppfPackNodeParent(element);

    fprintf(renderFile, "%i: %i %s",
      element, sppfPackNodePivot(element),
      artLabelInternalStrings[sppfPackNodeLabel(element)]);
  }

  private: void renderSPPFNode(int element, int level) {
    renderCount++;
    const char* colour = "white";
    const char* borderColor = level == -1 ? "red" : "black";

    if (sppfNodeSelected(element)) colour = "cyan";
    if (sppfNodeArity(element) > 1) colour = "orange";

    fprintf(renderFile, "node:{shape:ellipse bordercolor:%s color:%s level:%i horizontal_order:%i title:\"", borderColor, colour, level, renderCount);
    renderSPPFNodeTitle(element);
    fprintf(renderFile, "\"}\n");
  }

  private: void renderSPPFPackNode(int element, int level) {
    renderCount++;
    const char* colour = "white";
    const char* borderColor = level == -1 ? "red" : "black";

    if (sppfPackNodeSuppressed(element)) colour = "red";
    if (sppfPackNodeSelected(element)) colour = "cyan";

    fprintf(renderFile, "node:{shape:box bordercolor:%s color:%s level:%i horizontal_order:%i title:\"", borderColor, colour, level, renderCount);
    renderSPPFPackNodeTitle(element);
    fprintf(renderFile, "\"}\n");
  }

  private: void renderSPPFEdge(int parent, bool parentIsPack, int child, bool childIsPack, const char* colour) {
//    printf("Rendering SPPF edge from %i to %i\n", parent, child);

    fprintf(renderFile,"edge:{sourcename:\"");

    if (parentIsPack)
      renderSPPFPackNodeTitle(parent);
    else
      renderSPPFNodeTitle(parent);
    fprintf(renderFile,"\" targetname:\"");
    if (childIsPack)
      renderSPPFPackNodeTitle(child);
    else
      renderSPPFNodeTitle(child);

    fprintf(renderFile,"\"color: %s}\n", colour);
  }

  private: bool elementIsVisible(int element, bool elementIsPack) {
    switch (renderKind) {
    case renderKindDerivation:
      if (elementIsPack) return false;

      if (!sppfNodeSelected(element)) return false;

      return true;

    case renderKindSPPF:
      if (elementIsPack) return sppfNodeArity(sppfPackNodeParent(element)) > 1;

      return true;

    default:
      return true;
    }
  }

  private: bool elementIsRecursable(int element, bool elementIsPack) {
    switch (renderKind) {
    case renderKindDerivation:
      if (elementIsPack)
        return sppfPackNodeSelected(element);
      else
        return sppfNodeSelected(element);

    default:
      return true;
    }
  }

  private: void renderRec(int element, int parent, bool parentIsPack, int level) {
/*
   printf("renderRec() at element %i level %i with parent %i %s; %svisited, %sselected\n", element, level, parent, parentIsPack ?
      "PACK" :
   "NOT PACK", sppfNodeVisited(element) ? "" : "not ", sppfNodeSelected(element) ? "" : "not ");
*/
    if (elementIsVisible(element, false) && parent != 0) renderSPPFEdge(parent, parentIsPack, element, false, level == -1 ? "red" : "black");

    if (sppfNodeVisited(element)) return;

    sppfNodeSetVisited(element);
    int newParent = parent;
    bool newParentIsPack = parentIsPack;

    if (elementIsVisible(element, false)) {
      renderSPPFNode(element, level);
      newParent = element;
      newParentIsPack = false;
    }

    if (elementIsRecursable(element, false)) {
      for (int tmp = sppfNodePackNodeList(element); tmp != 0; tmp = sppfPackNodePackNodeList(tmp)) {
        if (elementIsVisible(tmp, true)) {
          renderSPPFPackNode(tmp, level == -1 ? level : level + 1);
          renderSPPFEdge(element, false, tmp, true, level == -1 ? "red" : "black"); // we can never have pack nodes visible unless their parent is visible
          newParent = tmp;
          newParentIsPack = true;
        }
        if (elementIsRecursable(tmp, true)) {
          if (sppfPackNodeLeftChild(tmp) != 0) renderRec(sppfPackNodeLeftChild(tmp), newParent, newParentIsPack, level == -1 ? level: level + 2);
          renderRec(sppfPackNodeRightChild(tmp), newParent, newParentIsPack, level == -1 ? level : level + 2);
        }
      }
    }
  }

  private: int renderCount;

  public: void render(const char* filename, int renderKind) {
    sppfResetVisitedFlags();
    this->renderKind = renderKind;
    renderFile = fopen(filename, "w");
    renderCount = 0;
    fprintf(renderFile, "%s", renderGraphPrelude(renderKind == renderKindGSS));

    if (renderKind == renderKindGSS){
      // Add dummy GSS root node
      fprintf(renderFile, "node:{level:0 horizontal_order:0 title:\"");
      renderGSSNodeTitle(rootGSSNode);
      fprintf(renderFile, "\"}\n");

      for (int tmp = gssNodeFirst(); tmp != 0; tmp = gssNodeNext())
        renderGSSNode(tmp);
      for (int tmp = gssEdgeFirst(); tmp != 0; tmp = gssEdgeNext())
        renderGSSEdge(tmp);
    } else {
      renderRec(sppfRoot(), 0, false, 0);
      if (renderKind == renderKindSPPFFull)
        for (int element = sppfNodeFirst(); element != 0; element = sppfNodeNext())
          renderRec(element, 0, false, -1);
    }

    fprintf(renderFile, renderGraphPostlude());
    fclose(renderFile);
    sppfResetVisitedFlags();
  }
};

