(* Generated by ebnf2bnf V2.00 from 'iso7q.ebf' Aug 13 2003 21:57:26 *)

(*
This is a version os ahiso7q.gtb in which all the non-terminals have
been terminalised including the immediate ones. 

*)

actual_parameter ::= ~expression |
                     ~procedure_ID .

actual_parameter_list ::= '(' ~actual_parameter ~actual_parameter_list_1 ')' .

actual_parameter_list_1 ::= # |
                            ~actual_parameter_list_1 ',' ~actual_parameter .

adding_operator ::= '+' |
                    '-' |
                    'or' .

apostrophe_image ::= '\"' .

array_type ::= 'array' '[' ~index_type ~array_type_2 ']' 'of' ~component_type .

array_type_2 ::= # |
                 ~array_type_2 ',' ~index_type .

assignment_statement ::= ~assignment_statement_3 ':=' ~expression .

assignment_statement_3 ::= ~variable_access |
                           ~function_ID .

base_type ::= ~ordinal_type .

block ::= ~label_declaration_part ~constant_definition_part ~type_definition_part ~variable_declaration_part ~procedure_and_function_declaration_part ~statement_part .

Boolean_expression ::= ~expression .

bound_ID ::= ~ID .

case_constant ::= ~constant .

case_constant_list ::= ~case_constant ~case_constant_list_4 .

case_constant_list_4 ::= # |
                         ~case_constant_list_4 ',' ~case_constant .

case_index ::= ~expression .

case_list_element ::= ~case_constant_list ':' ~statement .

case_statement ::= 'case' ~case_index 'of' ~case_list_element ~case_statement_5 ~case_statement_6 'end' .

case_statement_5 ::= # |
                     ~case_statement_5 ';' ~case_list_element .

case_statement_6 ::= # |
                     ';' .

character_string ::= 'STRING' .

component_type ::= ~type_denoter .

component_variable ::= ~indexed_variable |
                       ~field_designator .

compound_statement ::= 'begin' ~statement_sequence 'end' .

conditional_statement ::= ~if_statement |
                          ~case_statement .

conformant_array_parameter_specification ::= ~value_conformant_array_specification |
                                             ~variable_conformant_array_specification .

conformant_array_schema ::= ~packed_conformant_array_schema |
                            ~unpacked_conformant_array_schema .

constant ::= ~constant_7 ~constant_8 |
             ~character_string .

constant_7 ::= # |
               ~sign .

constant_8 ::= ~unsigned_number |
               ~constant_ID .

constant_definition ::= ~ID '=' constant .

constant_definition_part ::= ~constant_definition_part_9 .

constant_definition_part_9 ::= # |
                               'const' ~constant_definition ';' ~constant_definition_part_10 .

constant_definition_part_10 ::= # |
                                ~constant_definition_part_10 ~constant_definition ';' .

constant_ID ::= 'constant_ID' .

control_variable ::= ~entire_variable .

digit ::= 'digit' .

digit_sequence ::= 'INTEGER' .

directive ::= 'ID' .

domain_type ::= ~type_ID .

else_part ::= 'else' ~statement .

entire_variable ::= ~variable_ID .

enumerated_type ::= '(' ~ID_list ')' .

expression ::= ~simple_expression ~expression_11 .

expression_11 ::= # |
                  ~relational_operator ~simple_expression .

factor ::= ~variable_access |
           ~unsigned_constant |
           ~function_designator |
           ~set_constructor |
           '(' ~expression ')' |
           'not' ~factor .

field_designator ::= ~variable_access '.' ~field_specifier |
                     ~field_designator_ID .

field_designator_ID ::= 'field_designator_ID' .

field_ID ::= 'field_ID' .

field_list ::= ~field_list_12 |
               ~fixed_part ';' |
               ~fixed_part ';' ~variant_part |
               ~fixed_part ';' ~variant_part ';' |
               ~variant_part ~field_list_13 .

field_list_12 ::= # |
                  ~fixed_part .

field_list_13 ::= # |
                  ';' .

field_specifier ::= ~field_ID .

file_type ::= 'file' 'of' ~component_type .

final_value ::= ~expression .

fixed_part ::= ~record_section |
               ~fixed_part ';' ~record_section .

for_statement ::= 'for' ~control_variable ':=' ~initial_value ~for_statement_14 final_value 'do' ~statement .

for_statement_14 ::= 'to' |
                     'downto' .

formal_parameter_list ::= '(' ~formal_parameter_section ~formal_parameter_list_15 ')' .

formal_parameter_list_15 ::= # |
                             ~formal_parameter_list_15 ';' ~formal_parameter_section .

formal_parameter_section ::= ~value_parameter_specification |
                             ~variable_parameter_specification |
                             ~procedural_parameter_specification |
                             ~functional_parameter_specification .

fractional_part ::= ~digit_sequence .

function_block ::= ~block .

function_declaration ::= ~function_heading ';' ~directive |
                         ~function_identification ';' ~function_block |
                         ~function_heading ';' ~function_block .

function_designator ::= ~function_ID ~function_designator_16 .

function_designator_16 ::= # |
                           ~actual_parameter_list .

function_heading ::= 'function' ~ID ~function_heading_17 ':' ~result_type .

function_heading_17 ::= # |
                        ~formal_parameter_list .

function_identification ::= 'function' ~function_ID .

function_ID ::= 'function_ID' .

functional_parameter_specification ::= ~function_heading .

goto_statement ::= 'goto' ~label .

ID ::= 'ID' .

ID_list ::= ~ID ~ID_list_18 .

ID_list_18 ::= # |
               ~ID_list_18 ',' ~ID .

if_statement ::= 'if' ~Boolean_expression 'then' ~statement ~if_statement_19 .

if_statement_19 ::= # |
                    ~else_part .

index_expression ::= ~expression .

index_type ::= ~ordinal_type .

index_type_specification ::= ~ID '..' ~ID ':' ~ordinal_type_ID .

indexed_variable ::= ~variable_access '[' ~index_expression ~indexed_variable_20 ']' .

indexed_variable_20 ::= # |
                        ~indexed_variable_20 ',' ~index_expression .

initial_value ::= ~expression .

label ::= ~digit_sequence .

label_declaration_part ::= ~label_declaration_part_21 .

label_declaration_part_21 ::= # |
                              'label' ~label ~label_declaration_part_22 ';' .

label_declaration_part_22 ::= # |
                              ~label_declaration_part_22 ',' ~label .

letter ::= 'letter' .

member_designator ::= ~expression ~member_designator_23 .

member_designator_23 ::= # |
                         ~member_designator_23 '..' ~expression .

multiplying_operator ::= '*' |
                         '/' |
                         'div' |
                         'mod' |
                         'and' .

new_ordinal_type ::= ~enumerated_type |
                     ~subrange_type .

new_pointer_type ::= '^' ~domain_type .

new_structured_type ::= ~new_structured_type_24 ~unpacked_structured_type .

new_structured_type_24 ::= # |
                           'packed' .

new_type ::= ~new_ordinal_type |
             ~new_structured_type |
             ~new_pointer_type .

ordinal_type ::= ~new_ordinal_type |
                 ~ordinal_type_ID .

ordinal_type_ID ::= ~type_ID .

packed_conformant_array_schema ::= 'packed' 'array' '[' ~index_type_specification ']' 'of' ~type_ID .

pointer_type ::= ~new_pointer_type |
                 ~pointer_type_ID .

pointer_type_ID ::= ~type_ID .

procedural_parameter_specification ::= ~procedure_heading .

procedure_and_function_declaration_part ::= ~procedure_and_function_declaration_part_25 .

procedure_and_function_declaration_part_25 ::= # |
                                               ~procedure_and_function_declaration_part_25 ~procedure_and_function_declaration_part_26 ';' .

procedure_and_function_declaration_part_26 ::= ~procedure_declaration |
                                               ~function_declaration .

procedure_and_function_heading_part ::= ~procedure_and_function_heading_part_27 ';' .

procedure_and_function_heading_part_27 ::= ~procedure_heading |
                                           ~function_heading .

procedure_block ::= ~block .

procedure_declaration ::= ~procedure_heading ';' ~directive |
                          ~procedure_identification ';' ~procedure_block |
                          ~procedure_heading ';' ~procedure_block .

procedure_heading ::= 'procedure' ~ID ~procedure_heading_28 .

procedure_heading_28 ::= # |
                         ~formal_parameter_list .

procedure_identification ::= 'procedure' ~procedure_ID .

procedure_ID ::= 'procedure_ID' .

procedure_statement ::= ~procedure_ID ~procedure_statement_29 |
                        'read' ~read_parameter_list |
                        'readln'~readln_parameter_list |
                        'write' ~write_parameter_list |
                        'writeln' ~writeln_parameter_list .

procedure_statement_29 ::= # |
                           ~actual_parameter_list .

program ::= program_heading ';' ~program_block .

program_block ::= ~block .

program_heading ::= 'program' ~ID ~program_heading_30 .

program_heading_30 ::= # |
                       '(' ~program_parameters ')' .

program_parameters ::= ~ID_list .

read_parameter_list ::= '(' ~variable_access ~read_parameter_list_31 ')' .

read_parameter_list_31 ::= # |
                           ~read_parameter_list_31 ',' ~variable_access .

readln_parameter_list ::= ~readln_parameter_list_32 .

readln_parameter_list_32 ::= # |
                             '(' ~variable_access ~readln_parameter_list_33 ')' .

readln_parameter_list_33 ::= # |
                             ~readln_parameter_list_33 ',' ~variable_access .

real_type_ID ::= ~type_ID .

record_section ::= ~ID_list ':' ~type_denoter .

record_type ::= 'record' ~field_list 'end' .

record_variable_list ::= ~variable_access ~record_variable_list_34 .

record_variable_list_34 ::= # |
                            ~record_variable_list_34 ',' ~variable_access .

relational_operator ::= '=' |
                        '<>' |
                        '<' |
                        '>' |
                        '<=' |
                        '>=' |
                        'in' .

repeat_statement ::= 'repeat' ~statement_sequence 'until' ~Boolean_expression .

repetitive_statement ::= ~repeat_statement |
                         ~while_statement |
                         ~for_statement .

result_type ::= ~simple_type_ID .

scale_factor ::= ~signed_integer .

set_constructor ::= '[' ~set_constructor_35 ']' .

set_constructor_35 ::= # |
                       ~member_designator ~set_constructor_36 .

set_constructor_36 ::= # |
                       ~set_constructor_36 ',' ~member_designator .

set_type ::= 'set' 'of' ~base_type .

sign ::= '+' |
         '-' .

signed_integer ::= ~signed_integer_37 ~unsigned_integer .

signed_integer_37 ::= # |
                      ~sign .

signed_number ::= ~signed_integer |
                  ~signed_real .

signed_real ::= ~signed_real_38 ~unsigned_real .

signed_real_38 ::= # |
                   ~sign .

simple_expression ::= ~term ~simple_expression_39 |
                      ~sign ~term ~simple_expression_40 .

simple_expression_39 ::= # |
                         ~simple_expression_39 ~adding_operator term .

simple_expression_40 ::= # |
                         ~simple_expression_40 ~adding_operator term .

simple_statement ::= ~simple_statement_41 |
                     ~procedure_statement |
                     ~goto_statement .

simple_statement_41 ::= # |
                        ~assignment_statement .

simple_type ::= ~ordinal_type |
                ~real_type_ID .

simple_type_ID ::= ~type_ID .

statement ::= ~statement_42 ~statement_43 .

statement_42 ::= # |
                 ~label ':' .

statement_43 ::= ~simple_statement |
                 ~structured_statement .

statement_part ::= ~compound_statement .

statement_sequence ::= ~statement ~statement_sequence_44 .

statement_sequence_44 ::= # |
                          ~statement_sequence_44 ';' ~statement .

string_character ::= 'one_of_a_set_of_implementation_defined_characters' .

string_element ::= ~apostrophe_image |
                   ~string_character .

structured_statement ::= ~compound_statement |
                         ~conditional_statement |
                         ~repetitive_statement |
                         ~with_statement .

structured_type ::= ~new_structured_type |
                    ~structured_type_ID .

structured_type_ID ::= ~type_ID .

subrange_type ::= ~constant '..' ~constant .

tag_field ::= 'tag_field' .

tag_type ::= ~ordinal_type_ID .

term ::= ~factor ~term_45 .

term_45 ::= # |
            ~term_45 ~multiplying_operator ~factor .

type_definition ::= ~ID '=' ~type_denoter .

type_definition_part ::= ~type_definition_part_46 .

type_definition_part_46 ::= # |
                            'type' ~type_definition ';' ~type_definition_part_47 .

type_definition_part_47 ::= # |
                            ~type_definition_part_47 ~type_definition ';' .

type_denoter ::= ~type_ID |
                 ~new_type .

type_ID ::= 'type_ID' .

unpacked_conformant_array_schema ::= 'array' '[' ~index_type_specification ~unpacked_conformant_array_schema_48 ']' 'of' ~unpacked_conformant_array_schema_49 .

unpacked_conformant_array_schema_48 ::= # |
                                        ~unpacked_conformant_array_schema_48 ';' ~index_type_specification .

unpacked_conformant_array_schema_49 ::= ~type_ID |
                                        ~conformant_array_schema .

unpacked_structured_type ::= ~array_type |
                             ~record_type |
                             ~set_type |
                             ~file_type .

unsigned_constant ::= ~unsigned_number |
                      ~character_string |
                      'nil' |
                      ~constant_ID .

unsigned_integer ::= ~digit_sequence .

unsigned_number ::= ~unsigned_integer |
                    ~unsigned_real .

unsigned_real ::= 'REAL' .

value_conformant_array_specification ::= ~ID_list ':' ~conformant_array_schema .

value_parameter_specification ::= ~ID_list ':' ~type_ID .

variable_access ::= ~entire_variable |
                    ~component_variable |
                    ~variable_access '^' .

variable_conformant_array_specification ::= 'var' ~ID_list ':' ~conformant_array_schema .

variable_declaration ::= ~ID_list ':' ~type_denoter .

variable_declaration_part ::= ~variable_declaration_part_50 .

variable_declaration_part_50 ::= # |
                                 'var' ~variable_declaration ';' ~variable_declaration_part_51 .

variable_declaration_part_51 ::= # |
                                 ~variable_declaration_part_51 ~variable_declaration ';' .

variable_ID ::= 'variable_ID' .

variable_parameter_specification ::= 'var' ~ID_list ':' ~type_ID .

variant ::= ~case_constant_list ':' '(' ~field_list ')' .

variant_part ::= 'case' ~variant_selector 'of' ~variant |
                 ~variant_part ';' ~variant .

variant_selector ::= ~variant_selector_52 ~tag_type .

variant_selector_52 ::= # |
                        ~tag_field ':' .

while_statement ::= 'while' ~Boolean_expression 'do' ~statement .

with_statement ::= 'with' ~record_variable_list 'do' ~statement .

write_parameter ::= ~expression ~write_parameter_53 .

write_parameter_53 ::= # |
                       ':' ~expression ~write_parameter_54 .

write_parameter_54 ::= # |
                       ':' ~expression .

writeln_parameter_list ::= ~writeln_parameter_list_55 .

writeln_parameter_list_55 ::= # |
                              '(' ~write_parameter ~writeln_parameter_list_56 ')' .

writeln_parameter_list_56 ::= # |
                              ~writeln_parameter_list_56 ',' ~write_parameter .

write_parameter_list ::= '(' ~write_parameter ~write_parameter_list_57 ')' .

write_parameter_list_57 ::= # |
                            ~write_parameter_list_57 ',' ~write_parameter .

(
(*
this_grammar := grammar[program] (*64308, 52271*)
this_grammar := grammar[block] (*64290, 52259*)
this_grammar := grammar[type_denoter] (* 448, 381 *)
this_grammar := grammar[field_list] (* 220, 186 *)
this_grammar := grammar[compound_statement] (* 62359,50631 *)
this_grammar := grammar[statement_sequence] (* 62356,50630 *)
this_grammar := grammar[statement] (* 31177,25314 *)
this_grammar := grammar[formal_parameter_list] (* 92, 66*)
this_grammar := grammar[variable_access] (* 1889, 1534 *)
this_grammar := grammar[expression] (* 935,759 *)
this_grammar := grammar[factor] (* 53,42 *)
*)

(* full ah trie  288,116 *)

(* test.eas? *)

STRINGquad := "
program ID ( ID , ID ) ; 
var ID , ID , ID , ID : type_ID ; 
ID : type_ID ; 
procedure ID ( ID : type_ID ; var ID : type_ID ) ; 
begin 
variable_ID := variable_ID + INTEGER ; 
while function_ID ( ( variable_ID * variable_ID ) - variable_ID ) > REAL do 
variable_ID := variable_ID - ( ( ( variable_ID * variable_ID ) - variable_ID ) / ( REAL * variable_ID ) ) 
end ; 
procedure ID ( ID , ID , ID : type_ID ; var ID : type_ID ) ; 
var ID , ID : type_ID ; 
begin 
variable_ID := variable_ID * variable_ID - INTEGER * variable_ID * variable_ID ; 
procedure_ID ( variable_ID , variable_ID ) ; 
variable_ID := ( - variable_ID + variable_ID ) / ( INTEGER * variable_ID ) ; 
end ; 
procedure ID ( ID , ID , ID : type_ID ; var ID : type_ID ; var ID : type_ID ) ; 
begin 
if variable_ID * variable_ID < INTEGER * variable_ID * variable_ID then 
begin 
variable_ID := constant_ID ; 
variable_ID := - INTEGER ; 
end 
else 
begin 
procedure_ID ( variable_ID , variable_ID , variable_ID , variable_ID ) ; 
variable_ID := constant_ID ; 
end ; 
end ; 
begin 
write ( STRING ) ; 
readln ( variable_ID ) ; 
write ( STRING ) ; 
readln ( variable_ID ) ; 
write ( STRING ) ; 
readln ( variable_ID ) ; 
write ( STRING ) ; 
procedure_ID ( variable_ID , variable_ID , variable_ID , variable_ID , variable_ID ) ; 
if variable_ID = constant_ID then 
writeln ( STRING ) 
else writeln ( STRING , variable_ID : INTEGER : INTEGER , STRING ) 
end 
"

(* full5 *)

STRINGview := "
program ID ( ID , ID ) ; 
const ID = INTEGER ; 
ID = INTEGER ; 
ID = INTEGER ; 
ID = INTEGER ; 
type ID = INTEGER .. constant_ID ; 
ID = ( ID , ID , ID ) ; 
ID = array [ INTEGER .. INTEGER ] of type_ID ; 
ID = INTEGER .. constant_ID ; 
ID = ( ID , ID , ID , ID ) ; 
ID = record 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
end ; 
ID = INTEGER .. constant_ID ; 
ID = ( ID , ID , ID , ID ) ; 
ID = INTEGER .. constant_ID ; 
ID = ^ type_ID ; 
ID = ^ type_ID ; 
ID = ^ type_ID ; 
ID = record 
ID : type_ID ; 
ID : type_ID ; 
end ; 
ID = record 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
end ; 
ID = record 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
end ; 
ID = ^ type_ID ; 
ID = record 
ID : type_ID ; 
ID : type_ID ; 
end ; 
ID = ^ type_ID ; 
ID = record 
ID : type_ID ; 
ID : type_ID ; 
end ; 
ID = type_ID ; 
ID = ^ type_ID ; 
ID = ^ type_ID ; 
var ID : array [ INTEGER .. constant_ID ] of type_ID ; 
ID : type_ID ; 
ID : array [ INTEGER .. constant_ID ] of type_ID ; 
ID : type_ID ; 
ID : array [ INTEGER .. constant_ID ] of type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : array [ INTEGER .. constant_ID ] of type_ID ; 
ID : array [ INTEGER .. constant_ID ] of type_ID ; 
ID : array [ INTEGER .. constant_ID ] of type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : array [ INTEGER .. constant_ID ] of type_ID ; 
function ID ( 
var ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID ; 
var ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
procedure ID ( ID : type_ID ) ; 
begin 
if variable_ID <> nil then 
begin 
procedure_ID ( variable_ID ^ . field_ID ) ; 
procedure_ID ( variable_ID ) ; 
end 
end ; 
function function_ID ; 
begin 
if variable_ID = constant_ID then 
function_ID := constant_ID 
else 
begin 
variable_ID := variable_ID + INTEGER ; 
if variable_ID = INTEGER then 
variable_ID := variable_ID 
else 
begin 
variable_ID := variable_ID [ variable_ID ] ; 
variable_ID := variable_ID - INTEGER ; 
end ; 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID [ variable_ID ] ^ . field_ID := INTEGER ; 
variable_ID [ variable_ID ] ^ . field_ID := nil ; 
function_ID := constant_ID ; 
end 
end ; 
function function_ID ; 
begin 
function_ID := constant_ID ; 
if ( variable_ID > INTEGER ) and ( variable_ID < constant_ID + INTEGER ) then 
if variable_ID [ variable_ID ] <> nil then 
begin 
procedure_ID ( variable_ID [ variable_ID ] ^ . field_ID ) ; 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID [ variable_ID ] := nil ; 
variable_ID := variable_ID + INTEGER ; 
variable_ID := variable_ID - INTEGER ; 
variable_ID [ variable_ID ] := variable_ID ; 
function_ID := constant_ID ; 
end 
end ;
"
(* 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
begin 
variable_ID := function_ID ( variable_ID , variable_ID , variable_ID ) ; 
if ( variable_ID = constant_ID ) and not variable_ID then 
begin 
variable_ID [ variable_ID ] ^ . field_ID := variable_ID [ variable_ID ] ^ . field_ID + INTEGER ; 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
procedure_ID ( variable_ID [ variable_ID ] ^ . field_ID ) ; 
variable_ID [ variable_ID ] ^ . field_ID ^ . field_ID := variable_ID ; 
variable_ID [ variable_ID ] ^ . field_ID ^ . field_ID := variable_ID ; 
end ; 
function_ID := variable_ID ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
begin 
variable_ID := function_ID ( variable_ID , variable_ID , variable_ID ) ; 
if ( variable_ID = constant_ID ) then 
if variable_ID then 
begin 
variable_ID [ variable_ID ] ^ . field_ID := variable_ID [ variable_ID ] ^ . field_ID - INTEGER ; 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
while variable_ID ^ . field_ID <> variable_ID do 
begin ; 
variable_ID := variable_ID ; 
variable_ID := variable_ID ^ . field_ID ; 
end ; 
if variable_ID = variable_ID then 
variable_ID [ variable_ID ] ^ . field_ID := variable_ID [ variable_ID ] ^ . field_ID ^ . field_ID 
else 
variable_ID ^ . field_ID := variable_ID ^ . field_ID ; 
procedure_ID ( variable_ID ) ; 
end 
else if not variable_ID then 
variable_ID := constant_ID ; 
function_ID := variable_ID ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
begin 
function_ID := constant_ID ; 
if ( variable_ID > INTEGER ) and ( variable_ID < constant_ID + INTEGER ) then 
if variable_ID [ variable_ID ] <> nil then 
begin 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
variable_ID := constant_ID ; 
while ( variable_ID <> nil ) and ( not variable_ID ) do 
begin 
if variable_ID ^ . field_ID = variable_ID then 
variable_ID := constant_ID ; 
variable_ID := variable_ID ^ . field_ID ; 
end ; 
function_ID := constant_ID ; 
end 
end ; 
function function_ID ; 
begin 
function_ID := constant_ID ; 
if ( variable_ID > INTEGER ) and ( variable_ID < constant_ID + INTEGER ) then 
if variable_ID [ variable_ID ] <> nil then 
begin 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
function_ID := constant_ID ; 
end 
end ; 
function function_ID ; 
var ID : type_ID ; 
begin 
if function_ID ( variable_ID , variable_ID ) = constant_ID then 
begin 
if variable_ID > INTEGER then 
begin 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ^ . field_ID ; 
function_ID := constant_ID ; 
end 
else 
function_ID := constant_ID ; 
end 
else 
function_ID := constant_ID ; 
end ; 
procedure ID ( ID : type_ID ) ; 
var ID : type_ID ; 
begin 
if variable_ID <> nil then 
begin 
procedure_ID ( variable_ID ^ . field_ID ) ; 
if variable_ID ^ . field_ID <> - INTEGER then 
variable_ID := function_ID ( variable_ID ^ . field_ID ) ; 
procedure_ID ( variable_ID ) ; 
end 
end ; 
procedure ID ( ID : type_ID ; ID : type_ID ) ; 
var ID : type_ID ; 
begin 
if variable_ID <> nil then 
begin 
procedure_ID ( variable_ID , variable_ID ^ . field_ID ) ; 
if ( variable_ID ^ . field_ID <> - INTEGER ) and ( variable_ID ^ . field_ID = variable_ID ) then 
begin 
variable_ID := function_ID ( variable_ID ^ . field_ID ) ; 
variable_ID ^ . field_ID := - INTEGER ; 
end ; 
end ; 
end ; 
procedure ID ( ID : type_ID ) ; 
var ID : type_ID ; 
begin 
if variable_ID <> nil then 
begin 
procedure_ID ( variable_ID ^ . field_ID ) ; 
variable_ID := function_ID ( variable_ID ^ . field_ID ) ; 
procedure_ID ( variable_ID ) ; 
end 
end ; 
function ID ( ID : type_ID ) : type_ID ; 
begin 
function_ID := constant_ID ; 
if ( variable_ID < constant_ID + INTEGER ) and ( variable_ID > INTEGER ) then 
if variable_ID [ variable_ID ] <> nil then 
function_ID := constant_ID ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
begin 
if variable_ID = constant_ID then 
function_ID := constant_ID 
else 
begin 
function_ID := constant_ID ; 
variable_ID := variable_ID + INTEGER ; 
if variable_ID = INTEGER then 
variable_ID := variable_ID 
else 
begin 
variable_ID := variable_ID [ variable_ID ] ; 
variable_ID := variable_ID - INTEGER ; 
end ; 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID [ variable_ID ] ^ . field_ID := INTEGER ; 
variable_ID [ variable_ID ] ^ . field_ID := nil ; 
procedure_ID ( variable_ID [ variable_ID ] ^ . field_ID ) ; 
variable_ID [ variable_ID ] ^ . field_ID ^ . field_ID := nil ; 
variable_ID := function_ID ( variable_ID [ variable_ID ] ^ . field_ID ^ . field_ID ) ; 
if variable_ID <> constant_ID then 
function_ID := constant_ID ; 
end ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
begin 
procedure_ID ( variable_ID [ variable_ID ] ^ . field_ID ^ . field_ID ) ; 
procedure_ID ( variable_ID [ variable_ID ] ^ . field_ID ) ; 
variable_ID := function_ID ( variable_ID [ variable_ID ] ^ . field_ID ^ . field_ID ) ; 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID [ variable_ID ] := nil ; 
variable_ID := variable_ID + INTEGER ; 
variable_ID := variable_ID - INTEGER ; 
variable_ID [ variable_ID ] := variable_ID ; 
function_ID := constant_ID ; 
end 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
begin 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
while variable_ID ^ . field_ID <> nil do 
variable_ID := variable_ID ^ . field_ID ; 
procedure_ID ( variable_ID ^ . field_ID ) ; 
variable_ID := variable_ID ^ . field_ID ; 
variable_ID := function_ID ( variable_ID ^ . field_ID ) ; 
if variable_ID = constant_ID then 
begin 
variable_ID [ variable_ID ] ^ . field_ID := variable_ID [ variable_ID ] ^ . field_ID + INTEGER ; 
variable_ID ^ . field_ID := nil ; 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID - INTEGER ; 
function_ID := constant_ID ; 
end 
else 
procedure_ID ( variable_ID ) ; 
end ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
begin 
function_ID := constant_ID ; 
variable_ID := variable_ID + INTEGER ; 
variable_ID := variable_ID + INTEGER ; 
if function_ID ( variable_ID ) then 
begin 
if ( variable_ID <= INTEGER ) or ( variable_ID > variable_ID [ variable_ID ] ^ . field_ID ) or 
( variable_ID <= INTEGER ) or ( variable_ID > variable_ID [ variable_ID ] ^ . field_ID ) then 
begin 
function_ID := constant_ID 
end 
else 
begin 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
for variable_ID := INTEGER to variable_ID do 
variable_ID := variable_ID ^ . field_ID ; 
variable_ID := function_ID ( variable_ID , variable_ID ^ . field_ID ) ; 
if variable_ID = constant_ID then 
begin 
function_ID := constant_ID ; 
procedure_ID ( variable_ID , variable_ID [ variable_ID ] ^ . field_ID ) ; 
end ; 
end ; 
end ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID , ID : type_ID ; 
begin 
variable_ID := constant_ID ; 
if ( variable_ID < INTEGER ) or ( variable_ID >= variable_ID [ variable_ID ] ^ . field_ID ) then 
variable_ID := constant_ID 
else 
begin 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
if variable_ID = constant_ID then 
begin 
variable_ID := function_ID ( variable_ID , variable_ID , variable_ID ) ; 
if variable_ID <> constant_ID then 
begin 
variable_ID [ variable_ID ] ^ . field_ID := variable_ID [ variable_ID ] ^ . field_ID - INTEGER ; 
variable_ID := variable_ID - INTEGER ; 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
variable_ID := nil ; 
while variable_ID ^ . field_ID <> nil do 
begin 
variable_ID := variable_ID ; 
variable_ID := variable_ID ^ . field_ID ; 
end ; 
procedure_ID ( variable_ID ) ; 
variable_ID ^ . field_ID := nil 
end 
end ; 
end ; 
function_ID := variable_ID ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
function ID ( ID : type_ID ; ID : type_ID ) : type_ID ; 
var 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) <> constant_ID then 
function_ID := constant_ID 
else 
begin 
if function_ID ( variable_ID ^ . field_ID ) <> constant_ID then 
begin 
variable_ID := function_ID ( variable_ID ) ; 
function_ID := constant_ID 
end 
else 
begin 
while function_ID ( variable_ID , variable_ID ) = constant_ID do 
begin 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
end ; 
while function_ID ( variable_ID , variable_ID ) = constant_ID do 
begin 
variable_ID := function_ID ( variable_ID , variable_ID ^ . field_ID ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
end ; 
variable_ID := function_ID ( variable_ID ) ; 
end ; 
end ; 
end ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
begin 
variable_ID := variable_ID + INTEGER ; 
if ( variable_ID < INTEGER ) or ( variable_ID > variable_ID [ variable_ID ] ^ . field_ID ) then 
function_ID := constant_ID 
else 
begin 
variable_ID := INTEGER ; 
if variable_ID [ variable_ID ] ^ . field_ID = nil then 
begin 
procedure_ID ( variable_ID [ variable_ID ] ^ . field_ID ) ; 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
end 
else 
begin 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
variable_ID := INTEGER ; 
while variable_ID ^ . field_ID <> nil do 
begin 
variable_ID := variable_ID + INTEGER ; 
variable_ID := variable_ID ^ . field_ID ; 
end ; 
procedure_ID ( variable_ID ^ . field_ID ) ; 
variable_ID := variable_ID ^ . field_ID ; 
end ; 
variable_ID ^ . field_ID := nil ; 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
for variable_ID := INTEGER to variable_ID do 
variable_ID := variable_ID ^ . field_ID ; 
if function_ID ( variable_ID , variable_ID ^ . field_ID ) then 
begin 
variable_ID . field_ID := variable_ID ; 
variable_ID . field_ID := variable_ID ; 
variable_ID . field_ID := variable_ID ; 
variable_ID ^ . field_ID := variable_ID ; 
variable_ID ^ . field_ID := variable_ID . field_ID ; 
function_ID := constant_ID ; 
variable_ID := variable_ID + INTEGER ; 
end ; 
end ; 
end ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
begin 
function_ID := constant_ID ; 
variable_ID := - INTEGER ; 
if function_ID ( variable_ID . field_ID ) then 
begin 
variable_ID := variable_ID [ variable_ID . field_ID ] ^ . field_ID ; 
while ( variable_ID ^ . field_ID <> nil ) and ( variable_ID . field_ID > INTEGER ) do 
begin 
variable_ID := variable_ID ^ . field_ID ; 
variable_ID . field_ID := variable_ID . field_ID - INTEGER ; 
end ; 
if variable_ID . field_ID = INTEGER then 
begin 
if variable_ID ^ . field_ID = variable_ID . field_ID then 
begin 
if function_ID ( variable_ID , variable_ID ^ . field_ID ) = constant_ID then 
begin 
variable_ID := function_ID ( variable_ID , variable_ID ^ . field_ID ) ; 
function_ID := constant_ID ; 
variable_ID := variable_ID - INTEGER ; 
end 
else 
begin 
variable_ID := function_ID ( variable_ID ^ . field_ID ) ; 
function_ID := constant_ID ; 
variable_ID ^ . field_ID := - INTEGER ; 
end ; 
end ; 
end ; 
end ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
begin 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
variable_ID := INTEGER ; 
variable_ID := constant_ID ; 
while ( variable_ID <> nil ) and ( variable_ID ) do 
begin 
write ( STRING , variable_ID : INTEGER , STRING ) ; 
variable_ID := function_ID ( variable_ID , variable_ID , variable_ID ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
while variable_ID = constant_ID do 
begin 
write ( variable_ID : INTEGER , STRING ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
end ; 
if variable_ID = constant_ID then 
variable_ID := constant_ID ; 
writeln ; 
variable_ID := variable_ID + INTEGER ; 
variable_ID := variable_ID ^ . field_ID ; 
end ; 
if variable_ID then 
function_ID := constant_ID ; 
end 
end ; 
function ID ( ID : type_ID ) : type_ID ; 
begin 
case variable_ID of 
constant_ID : 
function_ID := constant_ID ; 
constant_ID : 
function_ID := constant_ID ; 
constant_ID : 
function_ID := constant_ID ; 
constant_ID : 
function_ID := constant_ID ; 
end ; 
end ; 
function ID ( ID : type_ID ) : type_ID ; 
begin 
function_ID := constant_ID ; 
if ( variable_ID > INTEGER ) and ( variable_ID < constant_ID + INTEGER ) then 
if variable_ID [ variable_ID ] <> nil then 
function_ID := constant_ID ; 
end ; 
function ID ( ID : type_ID ) : type_ID ; 
begin 
function_ID := constant_ID ; 
if ( variable_ID > INTEGER ) and ( variable_ID < constant_ID + INTEGER ) then 
if variable_ID [ variable_ID ] <> nil then 
function_ID := constant_ID ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
begin 
if variable_ID >= constant_ID then 
function_ID := constant_ID 
else 
begin 
variable_ID := function_ID ( function_ID ( variable_ID ) ) ; 
if variable_ID = constant_ID then 
begin 
variable_ID := variable_ID + INTEGER ; 
variable_ID := INTEGER ; 
while variable_ID [ variable_ID ] <> nil do 
variable_ID := variable_ID + INTEGER ; 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID [ variable_ID ] ^ := variable_ID ; 
end ; 
function_ID := variable_ID ; 
end ; 
end ; 
function function_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
begin 
function_ID := function_ID ( function_ID ( variable_ID [ variable_ID ] ^ ) ) ; 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID [ variable_ID ] := nil ; 
variable_ID := variable_ID - INTEGER ; 
end ; 
end ; 
function function_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
function_ID := 
function_ID ( function_ID ( variable_ID , variable_ID , variable_ID [ variable_ID ] ^ ) ) ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
begin 
variable_ID := function_ID ( variable_ID , variable_ID , variable_ID [ variable_ID ] ^ ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
variable_ID := function_ID ( variable_ID ) ; 
while ( variable_ID = constant_ID ) and ( variable_ID = constant_ID ) do 
begin 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
end ; 
if ( variable_ID = constant_ID ) and ( variable_ID = constant_ID ) then 
function_ID := constant_ID 
else 
variable_ID := function_ID ( variable_ID ) ; 
end ; 
end ; 
function function_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
function_ID := function_ID ( function_ID ( variable_ID [ variable_ID ] ^ ) ) ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
begin 
function_ID := constant_ID ; 
if ( function_ID ( variable_ID ) ) and ( variable_ID < constant_ID + INTEGER ) then 
begin 
variable_ID := INTEGER ; 
while variable_ID [ variable_ID ] <> nil do 
variable_ID := variable_ID + INTEGER ; 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID := function_ID ( function_ID ( 
variable_ID [ variable_ID ] ^ , variable_ID , variable_ID [ variable_ID ] ^ ) ) ; 
function_ID := variable_ID ; 
if variable_ID = constant_ID then 
variable_ID := variable_ID + INTEGER 
else 
begin 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID [ variable_ID ] := nil ; 
end ; 
end ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
begin 
variable_ID := function_ID ( function_ID ( 
variable_ID , variable_ID [ variable_ID ] ^ ) ) ; 
function_ID := variable_ID ; 
if variable_ID <> constant_ID then 
begin 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID [ variable_ID ] := nil ; 
variable_ID := variable_ID - INTEGER ; 
end ; 
end ; 
end ; 
procedure ID ( ID : type_ID ; ID : type_ID ; ID : type_ID ) ; 
var 
ID : type_ID ; 
procedure ID ( ID : type_ID ; ID : type_ID ) ; 
var 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
begin 
variable_ID := function_ID ( variable_ID , variable_ID , variable_ID ) ; 
if ( variable_ID = - INTEGER ) then 
variable_ID := variable_ID ; 
variable_ID := function_ID ( variable_ID , variable_ID , variable_ID ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
while variable_ID = constant_ID do 
begin 
if ( variable_ID <> variable_ID ) then 
procedure_ID ( variable_ID , variable_ID ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
end ; 
end ; 
begin 
if ( variable_ID <> variable_ID ) then 
variable_ID := - INTEGER 
else 
variable_ID := - INTEGER ; 
procedure_ID ( INTEGER , variable_ID ) ; 
end ; 
procedure ID ( ID : type_ID ; ID : type_ID ; ID : type_ID ; 
ID : type_ID ; ID : type_ID ) ; 
var 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
procedure ID ( ID : type_ID ) ; 
begin 
writeln ; 
writeln ( STRING , variable_ID ) ; 
end ; 
begin 
write ( STRING , variable_ID : INTEGER ) ; 
variable_ID := function_ID ( variable_ID , variable_ID , variable_ID ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
if ( variable_ID ) then 
variable_ID [ INTEGER * variable_ID - INTEGER ] := STRING 
else 
variable_ID [ INTEGER * variable_ID - INTEGER ] := STRING ; 
while ( variable_ID = constant_ID ) do 
begin 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
procedure_ID ( variable_ID , variable_ID , variable_ID + INTEGER , variable_ID <> constant_ID , variable_ID ) ; 
variable_ID := variable_ID ; 
variable_ID := variable_ID ; 
for variable_ID := INTEGER to variable_ID do 
write ( STRING ) ; 
end ; 
procedure_ID ( variable_ID ) ; 
end ; 
procedure ID ( ID : type_ID ) ; 
var 
ID : type_ID ; 
ID : type_ID ; 
begin 
for variable_ID := INTEGER to INTEGER do 
variable_ID [ variable_ID ] := STRING ; 
procedure_ID ( variable_ID , INTEGER , INTEGER , constant_ID , variable_ID ) ; 
end ; 
procedure ID ; 
var ID : type_ID ; 
ID : type_ID ; 
begin 
variable_ID := function_ID ( variable_ID ) ; 
if ( variable_ID = constant_ID ) then 
begin 
writeln ( STRING , variable_ID ) ; 
variable_ID [ variable_ID ] := constant_ID ; 
end 
else writeln ( STRING ) ; 
end ; 
procedure ID ; 
var ID , ID , ID : type_ID ; 
begin 
writeln ( STRING ) ; 
readln ( variable_ID ) ; 
writeln ( STRING ) ; 
readln ( variable_ID ) ; 
writeln ( STRING ) ; 
readln ( variable_ID ) ; 
if ( variable_ID [ variable_ID ] = constant_ID ) and ( variable_ID [ variable_ID ] = constant_ID ) then 
begin 
procedure_ID ( variable_ID , variable_ID , variable_ID ) ; 
writeln ( STRING , variable_ID , STRING , variable_ID , STRING , variable_ID ) ; 
end 
else writeln ( STRING ) 
end ; 
procedure ID ; 
var ID : type_ID ; 
ID : type_ID ; 
begin 
writeln ( STRING ) ; 
readln ( variable_ID ) ; 
variable_ID := function_ID ( variable_ID ) ; 
if ( variable_ID = constant_ID ) then 
begin 
writeln ( STRING , variable_ID , STRING ) ; 
variable_ID [ variable_ID ] := constant_ID ; 
end 
else writeln ( STRING ) ; 
end ; 
procedure ID ; 
var ID : type_ID ; 
ID : type_ID ; 
begin 
writeln ( STRING ) ; 
readln ( variable_ID ) ; 
if ( variable_ID [ variable_ID ] = constant_ID ) then writeln ( STRING ) 
else procedure_ID ( variable_ID ) ; 
end ; 
function ID : type_ID ; 
begin 
writeln ; 
writeln ( STRING ) ; 
writeln ( STRING ) ; 
writeln ( STRING ) ; 
writeln ( STRING ) ; 
writeln ( STRING ) ; 
writeln ; 
repeat 
writeln ( STRING ) ; 
readln ( variable_ID ) ; 
until variable_ID in [ INTEGER , INTEGER , INTEGER , INTEGER , INTEGER ] ; 
function_ID := variable_ID ; 
end ; 
begin 
variable_ID := INTEGER ; 
variable_ID := INTEGER ; 
variable_ID := INTEGER ; 
variable_ID := INTEGER ; 
variable_ID := INTEGER ; 
repeat 
variable_ID := function_ID ; 
case variable_ID of INTEGER 
: procedure_ID ; INTEGER 
: procedure_ID ; INTEGER 
: procedure_ID ; INTEGER 
: procedure_ID ; INTEGER 
: ; 
end ; 
until variable_ID = INTEGER ; 
end  
"

(* full4? *)

STRINGite := "
program ID ( ID , ID ) ; 
const ID = INTEGER ; 
ID = INTEGER ; 
ID = INTEGER ; 
ID = INTEGER ; 
type ID = INTEGER .. constant_ID ; 
ID = ( ID , ID , ID ) ; 
ID = array [ INTEGER .. INTEGER ] of type_ID ; 
ID = INTEGER .. constant_ID ; 
ID = ( ID , ID , ID , ID ) ; 
ID = record 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
end ; 
ID = INTEGER .. constant_ID ; 
ID = ( ID , ID , ID , ID ) ; 
ID = INTEGER .. constant_ID ; 
ID = ^ type_ID ; 
ID = ^ type_ID ; 
ID = ^ type_ID ; 
ID = record 
ID : type_ID ; 
ID : type_ID ; 
end ; 
ID = record 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
end ; 
ID = record 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
end ; 
ID = ^ type_ID ; 
ID = record 
ID : type_ID ; 
ID : type_ID ; 
end ; 
ID = ^ type_ID ; 
ID = record 
ID : type_ID ; 
ID : type_ID ; 
end ; 
ID = type_ID ; 
ID = ^ type_ID ; 
ID = ^ type_ID ; 
var ID : array [ INTEGER .. constant_ID ] of type_ID ; 
ID : type_ID ; 
ID : array [ INTEGER .. constant_ID ] of type_ID ; 
ID : type_ID ; 
ID : array [ INTEGER .. constant_ID ] of type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : array [ INTEGER .. constant_ID ] of type_ID ; 
ID : array [ INTEGER .. constant_ID ] of type_ID ; 
ID : array [ INTEGER .. constant_ID ] of type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : array [ INTEGER .. constant_ID ] of type_ID ; 
function ID ( 
var ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID ; 
var ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
procedure ID ( ID : type_ID ) ; 
begin 
if variable_ID <> nil then 
begin 
procedure_ID ( variable_ID ^ . field_ID ) ; 
procedure_ID ( variable_ID ) ; 
end 
else ; 
end ; 
function function_ID ; 
begin 
if variable_ID = constant_ID then 
function_ID := constant_ID 
else 
begin 
variable_ID := variable_ID + INTEGER ; 
if variable_ID = INTEGER then 
variable_ID := variable_ID 
else 
begin 
variable_ID := variable_ID [ variable_ID ] ; 
variable_ID := variable_ID - INTEGER ; 
end ; 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID [ variable_ID ] ^ . field_ID := INTEGER ; 
variable_ID [ variable_ID ] ^ . field_ID := nil ; 
function_ID := constant_ID ; 
end 
end ; 
function function_ID ; 
begin 
function_ID := constant_ID ; 
if ( variable_ID > INTEGER ) and ( variable_ID < constant_ID + INTEGER ) then 
if variable_ID [ variable_ID ] <> nil then 
begin 
procedure_ID ( variable_ID [ variable_ID ] ^ . field_ID ) ; 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID [ variable_ID ] := nil ; 
variable_ID := variable_ID + INTEGER ; 
variable_ID := variable_ID - INTEGER ; 
variable_ID [ variable_ID ] := variable_ID ; 
function_ID := constant_ID ; 
end 
else 
else ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
begin 
variable_ID := function_ID ( variable_ID , variable_ID , variable_ID ) ; 
if ( variable_ID = constant_ID ) and not variable_ID then 
begin 
variable_ID [ variable_ID ] ^ . field_ID := variable_ID [ variable_ID ] ^ . field_ID + INTEGER ; 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
procedure_ID ( variable_ID [ variable_ID ] ^ . field_ID ) ; 
variable_ID [ variable_ID ] ^ . field_ID ^ . field_ID := variable_ID ; 
variable_ID [ variable_ID ] ^ . field_ID ^ . field_ID := variable_ID ; 
end 
else ; 
function_ID := variable_ID ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
begin 
variable_ID := function_ID ( variable_ID , variable_ID , variable_ID ) ; 
if ( variable_ID = constant_ID ) then 
if variable_ID then 
begin 
variable_ID [ variable_ID ] ^ . field_ID := variable_ID [ variable_ID ] ^ . field_ID - INTEGER ; 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
while variable_ID ^ . field_ID <> variable_ID do 
begin ; 
variable_ID := variable_ID ; 
variable_ID := variable_ID ^ . field_ID ; 
end ; 
if variable_ID = variable_ID then 
variable_ID [ variable_ID ] ^ . field_ID := variable_ID [ variable_ID ] ^ . field_ID ^ . field_ID 
else 
variable_ID ^ . field_ID := variable_ID ^ . field_ID ; 
procedure_ID ( variable_ID ) ; 
end 
else if not variable_ID then 
variable_ID := constant_ID else else ; 
function_ID := variable_ID ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
begin 
function_ID := constant_ID ; 
if ( variable_ID > INTEGER ) and ( variable_ID < constant_ID + INTEGER ) then 
if variable_ID [ variable_ID ] <> nil then 
begin 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
variable_ID := constant_ID ; 
while ( variable_ID <> nil ) and ( not variable_ID ) do 
begin 
if variable_ID ^ . field_ID = variable_ID then 
variable_ID := constant_ID else ; 
variable_ID := variable_ID ^ . field_ID ; 
end ; 
function_ID := constant_ID ; 
end 
else 
else ; 
end ; 
function function_ID ; 
begin 
function_ID := constant_ID ; 
if ( variable_ID > INTEGER ) and ( variable_ID < constant_ID + INTEGER ) then 
if variable_ID [ variable_ID ] <> nil then 
begin 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
function_ID := constant_ID ; 
end 
else else ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
begin 
if function_ID ( variable_ID , variable_ID ) = constant_ID then 
begin 
if variable_ID > INTEGER then 
begin 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ^ . field_ID ; 
function_ID := constant_ID ; 
end 
else 
function_ID := constant_ID ; 
end 
else 
function_ID := constant_ID ; 
end ; 
procedure ID ( ID : type_ID ) ; 
var ID : type_ID ; 
begin 
if variable_ID <> nil then 
begin 
procedure_ID ( variable_ID ^ . field_ID ) ; 
if variable_ID ^ . field_ID <> - INTEGER then 
variable_ID := function_ID ( variable_ID ^ . field_ID ) else ; 
procedure_ID ( variable_ID ) ; 
end 
else ; 
end ; 
procedure ID ( ID : type_ID ; ID : type_ID ) ; 
var ID : type_ID ; 
begin 
if variable_ID <> nil then 
begin 
procedure_ID ( variable_ID , variable_ID ^ . field_ID ) ; 
if ( variable_ID ^ . field_ID <> - INTEGER ) and ( variable_ID ^ . field_ID = variable_ID ) then 
begin 
variable_ID := function_ID ( variable_ID ^ . field_ID ) ; 
variable_ID ^ . field_ID := - INTEGER ; 
end 
else ; 
end 
else ; 
end ; 
procedure ID ( ID : type_ID ) ; 
var ID : type_ID ; 
begin 
if variable_ID <> nil then 
begin 
procedure_ID ( variable_ID ^ . field_ID ) ; 
variable_ID := function_ID ( variable_ID ^ . field_ID ) ; 
procedure_ID ( variable_ID ) ; 
end 
else ; 
end ; 
function ID ( ID : type_ID ) : type_ID ; 
begin 
function_ID := constant_ID ; 
if ( variable_ID < constant_ID + INTEGER ) and ( variable_ID > INTEGER ) then 
if variable_ID [ variable_ID ] <> nil then 
function_ID := constant_ID 
else 
else ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
begin 
if variable_ID = constant_ID then 
function_ID := constant_ID 
else 
begin 
function_ID := constant_ID ; 
variable_ID := variable_ID + INTEGER ; 
if variable_ID = INTEGER then 
variable_ID := variable_ID 
else 
begin 
variable_ID := variable_ID [ variable_ID ] ; 
variable_ID := variable_ID - INTEGER ; 
end ; 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID [ variable_ID ] ^ . field_ID := INTEGER ; 
variable_ID [ variable_ID ] ^ . field_ID := nil ; 
procedure_ID ( variable_ID [ variable_ID ] ^ . field_ID ) ; 
variable_ID [ variable_ID ] ^ . field_ID ^ . field_ID := nil ; 
variable_ID := function_ID ( variable_ID [ variable_ID ] ^ . field_ID ^ . field_ID ) ; 
if variable_ID <> constant_ID then 
function_ID := constant_ID 
else ; 
end ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
begin 
procedure_ID ( variable_ID [ variable_ID ] ^ . field_ID ^ . field_ID ) ; 
procedure_ID ( variable_ID [ variable_ID ] ^ . field_ID ) ; 
variable_ID := function_ID ( variable_ID [ variable_ID ] ^ . field_ID ^ . field_ID ) ; 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID [ variable_ID ] := nil ; 
variable_ID := variable_ID + INTEGER ; 
variable_ID := variable_ID - INTEGER ; 
variable_ID [ variable_ID ] := variable_ID ; 
function_ID := constant_ID ; 
end 
else ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
begin 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
while variable_ID ^ . field_ID <> nil do 
variable_ID := variable_ID ^ . field_ID ; 
procedure_ID ( variable_ID ^ . field_ID ) ; 
variable_ID := variable_ID ^ . field_ID ; 
variable_ID := function_ID ( variable_ID ^ . field_ID ) ; 
if variable_ID = constant_ID then 
begin 
variable_ID [ variable_ID ] ^ . field_ID := variable_ID [ variable_ID ] ^ . field_ID + INTEGER ; 
variable_ID ^ . field_ID := nil ; 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID - INTEGER ; 
function_ID := constant_ID ; 
end 
else 
procedure_ID ( variable_ID ) ; 
end 
else ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
begin 
function_ID := constant_ID ; 
variable_ID := variable_ID + INTEGER ; 
variable_ID := variable_ID + INTEGER ; 
if function_ID ( variable_ID ) then 
begin 
if ( variable_ID <= INTEGER ) or ( variable_ID > variable_ID [ variable_ID ] ^ . field_ID ) or 
( variable_ID <= INTEGER ) or ( variable_ID > variable_ID [ variable_ID ] ^ . field_ID ) then 
begin 
function_ID := constant_ID 
end 
else 
begin 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
for variable_ID := INTEGER to variable_ID do 
variable_ID := variable_ID ^ . field_ID ; 
variable_ID := function_ID ( variable_ID , variable_ID ^ . field_ID ) ; 
if variable_ID = constant_ID then 
begin 
function_ID := constant_ID ; 
procedure_ID ( variable_ID , variable_ID [ variable_ID ] ^ . field_ID ) ; 
end 
else ; 
end ; 
end 
else ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID , ID : type_ID ; 
begin 
variable_ID := constant_ID ; 
if ( variable_ID < INTEGER ) or ( variable_ID >= variable_ID [ variable_ID ] ^ . field_ID ) then 
variable_ID := constant_ID 
else 
begin 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
if variable_ID = constant_ID then 
begin 
variable_ID := function_ID ( variable_ID , variable_ID , variable_ID ) ; 
if variable_ID <> constant_ID then 
begin 
variable_ID [ variable_ID ] ^ . field_ID := variable_ID [ variable_ID ] ^ . field_ID - INTEGER ; 
variable_ID := variable_ID - INTEGER ; 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
variable_ID := nil ; 
while variable_ID ^ . field_ID <> nil do 
begin 
variable_ID := variable_ID ; 
variable_ID := variable_ID ^ . field_ID ; 
end ; 
procedure_ID ( variable_ID ) ; 
variable_ID ^ . field_ID := nil 
end 
else ; 
end 
else ; 
end ; 
function_ID := variable_ID ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
function ID ( ID : type_ID ; ID : type_ID ) : type_ID ; 
var 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) <> constant_ID then 
function_ID := constant_ID 
else 
begin 
if function_ID ( variable_ID ^ . field_ID ) <> constant_ID then 
begin 
variable_ID := function_ID ( variable_ID ) ; 
function_ID := constant_ID 
end 
else 
begin 
while function_ID ( variable_ID , variable_ID ) = constant_ID do 
begin 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
end ; 
while function_ID ( variable_ID , variable_ID ) = constant_ID do 
begin 
variable_ID := function_ID ( variable_ID , variable_ID ^ . field_ID ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
end ; 
variable_ID := function_ID ( variable_ID ) ; 
end ; 
end ; 
end ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
begin 
variable_ID := variable_ID + INTEGER ; 
if ( variable_ID < INTEGER ) or ( variable_ID > variable_ID [ variable_ID ] ^ . field_ID ) then 
function_ID := constant_ID 
else 
begin 
variable_ID := INTEGER ; 
if variable_ID [ variable_ID ] ^ . field_ID = nil then 
begin 
procedure_ID ( variable_ID [ variable_ID ] ^ . field_ID ) ; 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
end 
else 
begin 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
variable_ID := INTEGER ; 
while variable_ID ^ . field_ID <> nil do 
begin 
variable_ID := variable_ID + INTEGER ; 
variable_ID := variable_ID ^ . field_ID ; 
end ; 
procedure_ID ( variable_ID ^ . field_ID ) ; 
variable_ID := variable_ID ^ . field_ID ; 
end ; 
variable_ID ^ . field_ID := nil ; 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
for variable_ID := INTEGER to variable_ID do 
variable_ID := variable_ID ^ . field_ID ; 
if function_ID ( variable_ID , variable_ID ^ . field_ID ) then 
begin 
variable_ID . field_ID := variable_ID ; 
variable_ID . field_ID := variable_ID ; 
variable_ID . field_ID := variable_ID ; 
variable_ID ^ . field_ID := variable_ID ; 
variable_ID ^ . field_ID := variable_ID . field_ID ; 
function_ID := constant_ID ; 
variable_ID := variable_ID + INTEGER ; 
end 
else ; 
end ; 
end 
else ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
begin 
function_ID := constant_ID ; 
variable_ID := - INTEGER ; 
if function_ID ( variable_ID . field_ID ) then 
begin 
variable_ID := variable_ID [ variable_ID . field_ID ] ^ . field_ID ; 
while ( variable_ID ^ . field_ID <> nil ) and ( variable_ID . field_ID > INTEGER ) do 
begin 
variable_ID := variable_ID ^ . field_ID ; 
variable_ID . field_ID := variable_ID . field_ID - INTEGER ; 
end ; 
if variable_ID . field_ID = INTEGER then 
begin 
if variable_ID ^ . field_ID = variable_ID . field_ID then 
begin 
if function_ID ( variable_ID , variable_ID ^ . field_ID ) = constant_ID then 
begin 
variable_ID := function_ID ( variable_ID , variable_ID ^ . field_ID ) ; 
function_ID := constant_ID ; 
variable_ID := variable_ID - INTEGER ; 
end 
else 
begin 
variable_ID := function_ID ( variable_ID ^ . field_ID ) ; 
function_ID := constant_ID ; 
variable_ID ^ . field_ID := - INTEGER ; 
end ; 
end 
else 
end 
else ; 
end 
else ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
begin 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
variable_ID := INTEGER ; 
variable_ID := constant_ID ; 
while ( variable_ID <> nil ) and ( variable_ID ) do 
begin 
write ( STRING , variable_ID : INTEGER , STRING ) ; 
variable_ID := function_ID ( variable_ID , variable_ID , variable_ID ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
while variable_ID = constant_ID do 
begin 
write ( variable_ID : INTEGER , STRING ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
end ; 
if variable_ID = constant_ID then 
variable_ID := constant_ID 
else ; 
writeln ; 
variable_ID := variable_ID + INTEGER ; 
variable_ID := variable_ID ^ . field_ID ; 
end ; 
if variable_ID then 
function_ID := constant_ID 
else ; 
end 
else ; 
end ; 
function ID ( ID : type_ID ) : type_ID ; 
begin 
case variable_ID of 
constant_ID : 
function_ID := constant_ID ; 
constant_ID : 
function_ID := constant_ID ; 
constant_ID : 
function_ID := constant_ID ; 
constant_ID : 
function_ID := constant_ID ; 
end ; 
end ; 
function ID ( ID : type_ID ) : type_ID ; 
begin 
function_ID := constant_ID ; 
if ( variable_ID > INTEGER ) and ( variable_ID < constant_ID + INTEGER ) then 
if variable_ID [ variable_ID ] <> nil then 
function_ID := constant_ID 
else else ; 
end ; 
function ID ( ID : type_ID ) : type_ID ; 
begin 
function_ID := constant_ID ; 
if ( variable_ID > INTEGER ) and ( variable_ID < constant_ID + INTEGER ) then 
if variable_ID [ variable_ID ] <> nil then 
function_ID := constant_ID 
else else ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
begin 
if variable_ID >= constant_ID then 
function_ID := constant_ID 
else 
begin 
variable_ID := function_ID ( function_ID ( variable_ID ) ) ; 
if variable_ID = constant_ID then 
begin 
variable_ID := variable_ID + INTEGER ; 
variable_ID := INTEGER ; 
while variable_ID [ variable_ID ] <> nil do 
variable_ID := variable_ID + INTEGER ; 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID [ variable_ID ] ^ := variable_ID ; 
end else ; 
function_ID := variable_ID ; 
end ; 
end ; 
function function_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
begin 
function_ID := function_ID ( function_ID ( variable_ID [ variable_ID ] ^ ) ) ; 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID [ variable_ID ] := nil ; 
variable_ID := variable_ID - INTEGER ; 
end else ; 
end ; 
function function_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
function_ID := 
function_ID ( function_ID ( variable_ID , variable_ID , variable_ID [ variable_ID ] ^ ) ) 
else ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
begin 
variable_ID := function_ID ( variable_ID , variable_ID , variable_ID [ variable_ID ] ^ ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
variable_ID := function_ID ( variable_ID ) ; 
while ( variable_ID = constant_ID ) and ( variable_ID = constant_ID ) do 
begin 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
end ; 
if ( variable_ID = constant_ID ) and ( variable_ID = constant_ID ) then 
function_ID := constant_ID 
else 
variable_ID := function_ID ( variable_ID ) ; 
end else ; 
end ; 
function function_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
function_ID := function_ID ( function_ID ( variable_ID [ variable_ID ] ^ ) ) else ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
begin 
function_ID := constant_ID ; 
if ( function_ID ( variable_ID ) ) and ( variable_ID < constant_ID + INTEGER ) then 
begin 
variable_ID := INTEGER ; 
while variable_ID [ variable_ID ] <> nil do 
variable_ID := variable_ID + INTEGER ; 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID := function_ID ( function_ID ( 
variable_ID [ variable_ID ] ^ , variable_ID , variable_ID [ variable_ID ] ^ ) ) ; 
function_ID := variable_ID ; 
if variable_ID = constant_ID then 
variable_ID := variable_ID + INTEGER 
else 
begin 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID [ variable_ID ] := nil ; 
end ; 
end else ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
begin 
variable_ID := function_ID ( function_ID ( 
variable_ID , variable_ID [ variable_ID ] ^ ) ) ; 
function_ID := variable_ID ; 
if variable_ID <> constant_ID then 
begin 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID [ variable_ID ] := nil ; 
variable_ID := variable_ID - INTEGER ; 
end else ; 
end else ; 
end ; 
procedure ID ( ID : type_ID ; ID : type_ID ; ID : type_ID ) ; 
var 
ID : type_ID ; 
procedure ID ( ID : type_ID ; ID : type_ID ) ; 
var 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
begin 
variable_ID := function_ID ( variable_ID , variable_ID , variable_ID ) ; 
if ( variable_ID = - INTEGER ) then 
variable_ID := variable_ID else ; 
variable_ID := function_ID ( variable_ID , variable_ID , variable_ID ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
while variable_ID = constant_ID do 
begin 
if ( variable_ID <> variable_ID ) then 
procedure_ID ( variable_ID , variable_ID ) else ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
end ; 
end ; 
begin 
if ( variable_ID <> variable_ID ) then 
variable_ID := - INTEGER 
else 
variable_ID := - INTEGER ; 
procedure_ID ( INTEGER , variable_ID ) ; 
end ; 
procedure ID ( ID : type_ID ; ID : type_ID ; ID : type_ID ; 
ID : type_ID ; ID : type_ID ) ; 
var 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
procedure ID ( ID : type_ID ) ; 
begin 
writeln ; 
writeln ( STRING , variable_ID ) ; 
end ; 
begin 
write ( STRING , variable_ID : INTEGER ) ; 
variable_ID := function_ID ( variable_ID , variable_ID , variable_ID ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
if ( variable_ID ) then 
variable_ID [ INTEGER * variable_ID - INTEGER ] := STRING 
else 
variable_ID [ INTEGER * variable_ID - INTEGER ] := STRING ; 
while ( variable_ID = constant_ID ) do 
begin 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
procedure_ID ( variable_ID , variable_ID , variable_ID + INTEGER , variable_ID <> constant_ID , variable_ID ) ; 
variable_ID := variable_ID ; 
variable_ID := variable_ID ; 
for variable_ID := INTEGER to variable_ID do 
write ( STRING ) ; 
end ; 
procedure_ID ( variable_ID ) ; 
end ; 
procedure ID ( ID : type_ID ) ; 
var 
ID : type_ID ; 
ID : type_ID ; 
begin 
for variable_ID := INTEGER to INTEGER do 
variable_ID [ variable_ID ] := STRING ; 
procedure_ID ( variable_ID , INTEGER , INTEGER , constant_ID , variable_ID ) ; 
end ; 
procedure ID ; 
var ID : type_ID ; 
ID : type_ID ; 
begin 
variable_ID := function_ID ( variable_ID ) ; 
if ( variable_ID = constant_ID ) then 
begin 
writeln ( STRING , variable_ID ) ; 
variable_ID [ variable_ID ] := constant_ID ; 
end 
else writeln ( STRING ) ; 
end ; 
procedure ID ; 
var ID , ID , ID : type_ID ; 
begin 
writeln ( STRING ) ; 
readln ( variable_ID ) ; 
writeln ( STRING ) ; 
readln ( variable_ID ) ; 
writeln ( STRING ) ; 
readln ( variable_ID ) ; 
if ( variable_ID [ variable_ID ] = constant_ID ) and ( variable_ID [ variable_ID ] = constant_ID ) then 
begin 
procedure_ID ( variable_ID , variable_ID , variable_ID ) ; 
writeln ( STRING , variable_ID , STRING , variable_ID , STRING , variable_ID ) ; 
end 
else writeln ( STRING ) 
end ; 
procedure ID ; 
var ID : type_ID ; 
ID : type_ID ; 
begin 
writeln ( STRING ) ; 
readln ( variable_ID ) ; 
variable_ID := function_ID ( variable_ID ) ; 
if ( variable_ID = constant_ID ) then 
begin 
writeln ( STRING , variable_ID , STRING ) ; 
variable_ID [ variable_ID ] := constant_ID ; 
end 
else writeln ( STRING ) ; 
end ; 
procedure ID ; 
var ID : type_ID ; 
ID : type_ID ; 
begin 
writeln ( STRING ) ; 
readln ( variable_ID ) ; 
if ( variable_ID [ variable_ID ] = constant_ID ) then writeln ( STRING ) 
else procedure_ID ( variable_ID ) ; 
end ; 
function ID : type_ID ; 
begin 
writeln ; 
writeln ( STRING ) ; 
writeln ( STRING ) ; 
writeln ( STRING ) ; 
writeln ( STRING ) ; 
writeln ( STRING ) ; 
writeln ; 
repeat 
writeln ( STRING ) ; 
readln ( variable_ID ) ; 
until variable_ID in [ INTEGER , INTEGER , INTEGER , INTEGER , INTEGER ] ; 
function_ID := variable_ID ; 
end ; 
begin 
variable_ID := INTEGER ; 
variable_ID := INTEGER ; 
variable_ID := INTEGER ; 
variable_ID := INTEGER ; 
variable_ID := INTEGER ; 
repeat 
variable_ID := function_ID ; 
case variable_ID of INTEGER 
: procedure_ID ; INTEGER 
: procedure_ID ; INTEGER 
: procedure_ID ; INTEGER 
: procedure_ID ; INTEGER 
: ; 
end ; 
until variable_ID = INTEGER ; 
end 
"

eSTRING := "
program ID ; 
begin 
write ( STRING ) ; 
end 
"

fSTRING := "
program ID ; 
begin
variable_ID := INTEGER * ( INTEGER + INTEGER ) ; 
write ( STRING ) ; 
write ( STRING ) ; 
variable_ID := INTEGER * ( INTEGER + INTEGER ) ; 
variable_ID := INTEGER * ( INTEGER + INTEGER ) ; 
write ( STRING ) ; 
write ( STRING ) ; 
variable_ID := INTEGER * ( INTEGER + INTEGER ) ; 
end 
"
*)
(* Main script *)

gdg_file := open["gdg.vcg"]
nfa_file := open["nfa.vcg"]
dfa_file := open["dfa.vcg"]
table_file := open["lr1.tbl"]
table_export_file := open["lr1.tbx"]
ssg_file := open["ssg.vcg"]

write["\n" gtb_version " processing '" gtb_main_file_name "' on " date_time "\n\n"]

this_grammar := grammar[program]
(*
write[this_grammar] 
*)

(* gtb v1.4 *)
(*
nfa := fsa[this_grammar lr_1]
add_nullable_accepting_states[nfa]
write[nfa_file nfa]

dfa := subset_construction[nfa]
write[dfa_file dfa]

(* table := resolved_parse_table[dfa] *)
table := parse_table[dfa]

write[table_file table]

export[table_export_file table]

(*
import[table_import_file table] 

export[table_export_file_new table]
*)

lr_parse[table STRINGview]

ssg := tomita_1_nullable_accepts_parse[table STRINGview]

(* ssg := tomita_1_parse[table eSTRING] *)
(* write[ssg_file ssg] *)

write["\n" CPU_time " CPU seconds elapsed\n\n"]
*)

(* gtb v2 *)
(*
(*
this_gdg := gdg[this_grammar]
write[gdg_file this_gdg]
close[gdg_file]
*)

(* write_concise[this_grammar] *)


this_nfa := nfa[this_grammar lr 1 terminal_lookahead_sets singleton_lookahead_sets] 

add_nullable_accepting_states[nfa] 
(*write[nfa_file nfa] *)

this_dfa := dfa[this_nfa] 

(* write[dfa_file this_dfa] *)

(*table := resolved_parse_table[this_dfa]*)
table := parse_table[this_dfa]
(*write[table_file table]*)

(*export_concise[table_export_file table]*)
(*export[table_export_file table]*)
*)

(* AH bits *)

tilde[this_grammar terminal]

prefix_grammar := ah_automaton[this_grammar] 
(* write[prefix_grammar] *)

this_ah_table := ah_table[this_grammar]

write["\n" CPU_time " CPU seconds elapsed\n\n"]


ah_recognise[this_ah_table STRINGview]


write["\n" CPU_time " CPU seconds elapsed\n\n"]

)