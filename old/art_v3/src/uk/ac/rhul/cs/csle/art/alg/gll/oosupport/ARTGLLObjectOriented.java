/******************************************************************************
 * GLLObjectOriented.java
 * 
 * An abstract class which defines concrete support methods for GLL parsers
 * generated by the ART tool.
 * 
 * In this version we use the 'obvious' OO approach
 * 
 * (c) Adrian Johnstone 2013
 *****************************************************************************/
package uk.ac.rhul.cs.csle.art.alg.gll.oosupport;

import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.HashMap;
import java.util.Map;

public abstract class ARTGLLObjectOriented extends ARTGLLSupportOO {
	private static final int hashPrime = 31;
	private static final int hashMult = 101;

	class SppfNode {
		private int label;
		private int leftExtent;
		private int rightExtent;
		private Map < SppfPackNode, SppfPackNode > sppfPackNodes = new HashMap < SppfPackNode, SppfPackNode >();	
		private boolean visited, selected;

		boolean visited() { return visited; }
		void resetVisited() { visited = false; }
		void setVisited() { visited = true; }

		boolean selected() { return selected; }
		void resetSelected() { selected = false; }
		void setSelected() { selected = true; }

		int label() { return label; }
		int leftExtent() { return leftExtent; }
		int rightExtent() { return rightExtent; }
		Map < SppfPackNode, SppfPackNode > sppfPackNodes() { return sppfPackNodes; } 	

		public boolean equals(Object thatPar) {
			if ( !(thatPar instanceof SppfNode) ) return false;

			SppfNode that = (SppfNode) thatPar;

			return label == that.label && leftExtent == that.leftExtent && rightExtent == that.rightExtent;
		}

		public int hashCode()  {
			int hashNumber = hashPrime;

			hashNumber = label + hashPrime * hashMult; 
			hashNumber = leftExtent + hashPrime * hashMult; 
			hashNumber = rightExtent + hashPrime * hashMult; 

			return  hashNumber;
		}

		public String toString() {
			return /*"@" + this.hashCode() +*/ "(" + artLabelStrings[label] + ", " + leftExtent + ", " + rightExtent + ")";
		}

		SppfNode(int label, int leftExtent, int rightExtent) { this.label = label; this.leftExtent = leftExtent; this.rightExtent = rightExtent; }
	}

	class SppfPackNode {
		private int label;
		private int pivot;
		private SppfNode leftChild;
		private SppfNode rightChild;
		private boolean visited, selected, suppressed;

		boolean visited() { return visited; }
		void resetVisited() { visited = false; }
		void setVisited() { visited = true; }

		boolean selected() { return selected; }
		void resetSelected() { selected = false; }
		void setSelected() { selected = true; }

		boolean suppressed() { return suppressed; }
		void resetSuppressed() { suppressed = false; }
		void setSuppressed() { suppressed = true; }

		int label() { return label; }
		int pivot() { return pivot;}	
		SppfNode leftChild() { return leftChild; }
		void setLeftChild(SppfNode leftChild) { this.leftChild = leftChild; }
		SppfNode rightChild() { return rightChild; }
		void setRightChild(SppfNode rightChild) { this.rightChild = rightChild; }

		public boolean equals(Object thatPar) {
			if ( !(thatPar instanceof SppfPackNode) ) return false;

			SppfPackNode that = (SppfPackNode) thatPar;

			return label == that.label && pivot == that.pivot;
		}

		public int hashCode()  {
			int hashNumber = hashPrime;

			hashNumber = label + hashPrime * hashMult; 
			hashNumber = pivot + hashPrime * hashMult; 

			return  hashNumber;
		}

		public String toString() {
			return /* "@" + this.hashCode() + */ "(" + artLabelStrings[label] + ", " + pivot + ")";
		}

		public SppfPackNode(int label, int pivot)  {
			this.label = label;
			this.pivot = pivot;
		}
	}

	class GssNode {
		private int label;
		private int level;
		private Map < GssEdge, GssEdge > gssEdges = new HashMap < GssEdge, GssEdge >();	
		private Map < PopElement, PopElement > popElements = new HashMap < PopElement, PopElement >();	

		int label() { return label; }
		int level() { return level;}
		Map < GssEdge, GssEdge > gssEdges() { return gssEdges; }
		Map < PopElement, PopElement > popElements() { return popElements; }

		public boolean equals(Object thatPar) {
			if ( !(thatPar instanceof GssNode) ) return false;

			GssNode that = (GssNode) thatPar;

			return label == that.label && level == that.level;
		}

		public int hashCode()  {
			int hashNumber = hashPrime;

			hashNumber = label + hashPrime * hashMult; 
			hashNumber = level + hashPrime * hashMult; 

			return  hashNumber;
		}

		public String toString() {
			return /*"@" + this.hashCode() + */ "(" + artLabelStrings[label] + ", " + level + ")";
		}

		GssNode(int label, int level) { this.label = label; this.level = level; }
	}

	class GssEdge {
		private GssNode destination;
		private SppfNode sppfNode;

		GssNode destination() { return destination; }
		SppfNode sppfNode() { return sppfNode; }

		public boolean equals(Object thatPar) {
			if ( !(thatPar instanceof GssEdge) ) return false;

			GssEdge that = (GssEdge) thatPar;

			return destination == that.destination && sppfNode == that.sppfNode;
		}

		public int hashCode()  {
			int hashNumber = hashPrime;

			hashNumber = destination.hashCode() + hashPrime * hashMult; 
			hashNumber = sppfNode.hashCode() + hashPrime * hashMult; 

			return  hashNumber;
		}

		public String toString() {
			return /* "@" + this.hashCode() + */ "(" + destination + ", " + sppfNode + ")";
		}

		GssEdge(GssNode destination, SppfNode sppfNode) { this.destination = destination; this.sppfNode = sppfNode; }
	}

	class PopElement  {
		private GssNode gssNode;
		private SppfNode sppfNode;

		GssNode gssNode() { return gssNode; }
		SppfNode sppfNode() { return sppfNode; }

		public boolean equals(Object thatPar) {
			if ( !(thatPar instanceof PopElement) ) return false;

			PopElement that = (PopElement) thatPar;

			return gssNode == that.gssNode && sppfNode == that.sppfNode;
		}

		public int hashCode()  {
			int hashNumber = hashPrime;

			hashNumber = gssNode.hashCode() + hashPrime * hashMult; 
			hashNumber = sppfNode.hashCode() + hashPrime * hashMult; 

			return  hashNumber;
		}

		public String toString() {
			return /* "@" + this.hashCode() + */ "(" + gssNode + ", " + sppfNode + ")";
		}

		PopElement(GssNode gssNode, SppfNode sppfNode) { this.gssNode = gssNode; this.sppfNode = sppfNode; }
	}

	class Descriptor {
		private int label;
		private GssNode gssNode;
		private int inputIndex;
		private SppfNode sppfNode;

		int label() { return label; }
		GssNode gssNode() { return gssNode; }
		int inputIndex() {return inputIndex; }
		SppfNode sppfNode() { return sppfNode; }

		public boolean equals(Object thatPar) {
			if ( !(thatPar instanceof Descriptor) ) return false;

			Descriptor that = (Descriptor) thatPar;

			return label == that.label && gssNode == that.gssNode && inputIndex == that.inputIndex && sppfNode == that.sppfNode;
		}

		public int hashCode()  {
			int hashNumber = hashPrime;

			hashNumber = label + hashPrime * hashMult; 
			hashNumber = gssNode.hashCode() + hashPrime * hashMult; 
			hashNumber = inputIndex + hashPrime * hashMult; 
			hashNumber = sppfNode.hashCode() + hashPrime * hashMult; 

			return  hashNumber;
		}

		public String toString() {
			return /* "@" + this.hashCode() + */ "(" + artLabelStrings[label] + ", " + gssNode + ", " + inputIndex + ", " + sppfNode + ")";
		}

		Descriptor(int label, GssNode gssNode, int inputIndex, SppfNode sppfNode) {
			this.label = label;
			this.gssNode = gssNode;
			this.inputIndex = inputIndex;
			this.sppfNode = sppfNode;
		}
	}

	class TestRepeatElement {
		private int label;
		private GssNode gssNode;
		private int inputIndex;
		private SppfNode sppfNode;

		public boolean equals(Object thatPar) {
			if ( !(thatPar instanceof TestRepeatElement) ) return false;

			TestRepeatElement that = (TestRepeatElement) thatPar;

			return label == that.label && gssNode == that.gssNode && inputIndex == that.inputIndex && sppfNode == that.sppfNode;
		}

		public int hashCode()  {
			int hashNumber = hashPrime;

			hashNumber = label + hashPrime * hashMult; 
			hashNumber = gssNode.hashCode() + hashPrime * hashMult; 
			hashNumber = inputIndex + hashPrime * hashMult;
			hashNumber = sppfNode.hashCode() + hashPrime * hashMult; 
			return  hashNumber;
		}

		public String toString() {
			return /* "@" + this.hashCode() + */ "(" + label + ", " + gssNode + ", " + inputIndex + ", " + sppfNode + ")";
		}

		TestRepeatElement(int label, GssNode gssNode, int inputIndex, SppfNode sppfNode) {
			this.label = label;
			this.gssNode = gssNode;
			this.inputIndex = inputIndex;
			this.sppfNode = sppfNode;
		}
	}

	/**************************************************************************
	 * Parser global variables
	 *************************************************************************/
	protected SppfNode rootSPPFNode;
	protected SppfNode dummySPPFNode;
	protected GssNode rootGSSNode;

	protected Descriptor currentDescriptor;
	protected int currentRestartLabel;
	protected SppfNode currentSPPFNode;
	protected SppfNode currentSPPFRightChildNode;
	protected GssNode currentGSSNode;
	protected SppfNode temporarySPPFNode;

	protected int[] foldL;
	protected int[] lhsL;
	protected int[] pL;
	protected int[] aL;
	protected boolean[] fiRL;
	protected boolean[] eoOPL;
	protected boolean[] eoRL;
	protected boolean[] eoR_pL;

	Map <SppfNode, SppfNode> sppfNodes = new HashMap <SppfNode, SppfNode>();	
	Map <GssNode, GssNode> gssNodes = new HashMap <GssNode, GssNode>();	
	Map <Descriptor, Descriptor> descriptors = new LinkedHashMap <Descriptor, Descriptor>();	
	Map <TestRepeatElement, TestRepeatElement> testRepeatElements = new HashMap <TestRepeatElement, TestRepeatElement>();	

	LinkedList<Descriptor> descriptorsToBeProcessed = new LinkedList <Descriptor>();
	
	/**************************************************************************
	 * Descriptor management methods
	 *************************************************************************/
	protected SppfNode sppfRoot() {return rootSPPFNode; }
	protected GssNode gssRoot() {return rootGSSNode; }

	/**************************************************************************
	 * The standard GLL support functions
	 *************************************************************************/
	protected SppfNode findSPPF(int label, SppfNode leftChild, SppfNode rightChild) {
		// sppfNODE findSPPF(L, i, j)
		// y := lookupSPPF(L, i, j) // Returns NULL if (L, i, j) is not in the
		// SPPF, otherwise returns the SPPF node labelled (L, i, j)
		// if y = NULL then y := addtoSPPF(L, i, j) fi
		// return y

		if (TRACE)
			System.out.printf("findSPPF (%s, %s, %s)\n", artLabelStrings[label], leftChild.toString(), rightChild.toString());

		if (fiRL[label]) {
			if (TRACE) System.out.printf("Returning rightChild\n");
			return rightChild;
		}

		// Set up parameters
		int leftExtent = (leftChild == dummySPPFNode ? rightChild.leftExtent() : leftChild.leftExtent());
		int newSPPFNodeLabel;

		if (eoOPL[label])
			newSPPFNodeLabel = (eoR_pL[label] ? lhsL[label] : pL[label]);
		else
			newSPPFNodeLabel = (eoRL[label] ? lhsL[label] : aL[label]);

		// Find the SPPF node
		SppfNode key = new SppfNode(newSPPFNodeLabel, leftExtent, rightChild.rightExtent());
		SppfNode newSPPFNode = sppfNodes.get(key);

		if (TRACE) System.out.printf("findSPPF %s - %sfound\n", key.toString(), newSPPFNode == null ? "not " : "");

		if (newSPPFNode == null) {
			sppfNodes.put(key, key);
			newSPPFNode = sppfNodes.get(key);
		}

		// Add a pack node if necessary
		SppfPackNode packKey = new SppfPackNode(label, rightChild.leftExtent());
		SppfPackNode newSPPFPackNode = newSPPFNode.sppfPackNodes().get(packKey);

		if (TRACE) System.out.printf("packNode %s - %sfound\n", packKey.toString(), newSPPFPackNode == null ? "not " : "");
		
		if (newSPPFPackNode == null) {
			newSPPFNode.sppfPackNodes().put(packKey, packKey);
			
			newSPPFPackNode = newSPPFNode.sppfPackNodes().get(packKey);
			
			newSPPFPackNode.setLeftChild(leftChild);
			newSPPFPackNode.setRightChild(rightChild);
		}

		return newSPPFNode;
	}

	protected SppfNode lookupSPPF(int label, int leftExtent, int rightExtent) {
		SppfNode key = new SppfNode(label, leftExtent, rightExtent);
		SppfNode found = sppfNodes.get(key); 
		if (TRACE) System.out.printf("lookupSPPF %s - %sfound\n", key.toString(), found == null ? "not ": "");
		
		return found;
	}

	protected SppfNode findSPPFInitial(int label, int leftExtent, int rightExtent) {
		SppfNode key = new SppfNode(label, leftExtent, rightExtent);
		SppfNode newSPPFNode = sppfNodes.get(key);

		if (TRACE) System.out.printf("findSPPFInitial %s - %sfound\n", key.toString(), newSPPFNode == null ? "not " : "");

		if (newSPPFNode == null) {
			sppfNodes.put(key, key);
			newSPPFNode = sppfNodes.get(key);
		}

		return newSPPFNode;
	}

	protected SppfNode findSPPFEpsilon(int currentTokenIndex) {
		SppfNode key = new SppfNode(ART__EPSILON, currentTokenIndex, currentTokenIndex);
		SppfNode newSPPFNode = sppfNodes.get(key);

		if (TRACE) System.out.printf("findSPPFEpsilon %s - %sfound\n", key.toString(), newSPPFNode == null ? "not " : "");

		if (newSPPFNode == null) {
			sppfNodes.put(key, key);
			newSPPFNode = sppfNodes.get(key);
		}

		return newSPPFNode;
	}

	protected SppfNode findSPPFTerminal(int label, int currentTokenIndex) {
		SppfNode key = new SppfNode(label, currentTokenIndex, currentTokenIndex + 1);
		SppfNode newSPPFNode = sppfNodes.get(key);

		if (TRACE) System.out.printf("findSPPFTerminal %s - %sfound\n", key.toString(), newSPPFNode == null ? "not " : "");

		if (newSPPFNode == null) {
			sppfNodes.put(key, key);
			newSPPFNode = sppfNodes.get(key);
		}

		return newSPPFNode;
	}

	protected SppfNode findSPPFClosure(int parentLabel, int childLabel, int currentTokenIndex) {
		SppfNode key = new SppfNode(parentLabel, currentTokenIndex, currentTokenIndex);
		SppfNode newSPPFNode = sppfNodes.get(key);

		if (TRACE) System.out.printf("findSPPFClosure %s - %sfound\n", key.toString(), newSPPFNode == null ? "not " : "");

		if (newSPPFNode == null) {
			sppfNodes.put(key, key);
			newSPPFNode = sppfNodes.get(key);
		}

		// if there is no pack node labelled (L, i), the make one and add an
		// epsilon node as a child
		SppfPackNode packKey = new SppfPackNode(childLabel, currentTokenIndex);
		SppfPackNode newSPPFPackNode = newSPPFNode.sppfPackNodes().get(packKey);

		if (TRACE) System.out.printf("packNode %s - %sfound\n", packKey.toString(), newSPPFPackNode == null ? "not " : "");
		
		if (newSPPFPackNode == null) {
			newSPPFNode.sppfPackNodes().put(packKey, packKey);
			
			newSPPFPackNode = newSPPFNode.sppfPackNodes().get(packKey);
			
			newSPPFPackNode.setLeftChild(dummySPPFNode);
			newSPPFPackNode.setRightChild(findSPPFEpsilon(currentTokenIndex));
		}

		return newSPPFNode;
	}

	protected GssNode findGSS(int stackTopLabel, GssNode stackTop, int currentToken, SppfNode currentsppfNode) {
		if (TRACE) {
			if (stackTop == null)
				System.out.printf("findGSS(%s, null, %d, null)\n", artLabelStrings[stackTopLabel], currentToken);
			else
				System.out.printf("findGSS(%s, %s, %d, %s)\n", artLabelStrings[stackTopLabel], stackTop.toString(), currentToken, currentSPPFNode.toString());
		}

		// v := lookupGSS(L, i) // Returns NULL if (L, i) is not in the GSS, 
		// otherwise returns the GSS node labelled (L, i)
		// if v = NULL then v := addtoGSS(L, i) fi
		//
		// if there is not an edge from v to u labelled w then
		// create an edge from v to u labelled w
		// for each (v, z) in P do add(L, u, z.rightExtent, getNodeP(L, w, z))
		// od
		// fi
		// return v

		GssNode key = new GssNode(stackTopLabel, currentToken);
		GssNode newGssNode = gssNodes.get(key);

		if (TRACE) System.out.printf("findGSSNode %s - %sfound\n", key.toString(), newGssNode == null ? "not " : "");

		if (newGssNode == null) {
			gssNodes.put(key, key);
			newGssNode = gssNodes.get(key);
		}

		if (stackTop != null) {
			GssEdge edgeKey = new GssEdge(stackTop, currentSPPFNode);
			GssEdge newGssEdge = newGssNode.gssEdges().get(key);

			if (TRACE) System.out.printf("findGSSEdge %s - %sfound\n", edgeKey.toString(), newGssEdge == null ? "not " : "");

			if (newGssEdge == null) {
				newGssNode.gssEdges().put(edgeKey, edgeKey);
				newGssEdge = newGssNode.gssEdges.get(key);
			}

			if (TRACE)  System.out.printf("Start of pop processing for GSS node %s\n", newGssNode.toString());

			for (Map.Entry<PopElement, PopElement> entry : newGssNode.popElements().entrySet()) {
				SppfNode derivationNode = findSPPF(stackTopLabel, currentsppfNode, entry.getValue().sppfNode());
				findDescriptor(stackTopLabel, stackTop, derivationNode.rightExtent(), derivationNode);
			}

			if (TRACE) System.out.printf("End of pop processing for GSS node %s\n", newGssNode.toString());
		}

		return newGssNode;
	}

	protected void pop(GssNode stackTop, int currentTokenIndex, SppfNode currentSppfNode) {
		// pop(u, i, z)
		// if (not u = u_0) then
		// insert(u, z) into P
		//
		// for each edge (u, w, v)
		// y := lookupSPPF(u.label, w, z)
		// findDescriptor(u.label, v, i, y)
	
		if (stackTop == rootGSSNode) {
			if (TRACE) System.out.printf("pop (%s, %d, %s)\nPop of root node - returning\n", stackTop, currentTokenIndex, currentSPPFNode);
			return;
		}

	PopElement key = new PopElement(stackTop, currentSppfNode);
		PopElement newPopElement = stackTop.popElements().get(key);

		if (TRACE) System.out.printf("pop %s - %sfound\n", key.toString(), newPopElement == null ? "not " : "");

		if (newPopElement == null) {
			if (TRACE) System.out.printf("Adding popElement to GSSNode %s\n", stackTop.toString());		
			stackTop.popElements.put(key, key);
			newPopElement =stackTop.popElements.get(key);
		}

		if (TRACE) System.out.printf("Popping GSSEdges for GSSNode %s\n", stackTop.toString());		
		for (Map.Entry<GssEdge, GssEdge> entry : stackTop.gssEdges().entrySet()) {
			if (TRACE) System.out.printf("Popping GSSEdge %s\n", entry.getValue().toString());		
			SppfNode derivationNode = findSPPF(stackTop.label(), entry.getValue().sppfNode(), currentSppfNode);
			findDescriptor(stackTop.label(), entry.getValue().destination(), currentTokenIndex, derivationNode);
		}
		if (TRACE) System.out.printf("Exiting pop(%s, %d, %s)\n", stackTop, currentTokenIndex, currentSPPFNode);
	}

	protected void findDescriptor(int restartLabel, GssNode gssNode, int currentTokenIndex, SppfNode sppfNode) {
		// findDescriptor_add(L, u, i, w)
		// if (L, u, i, w) \not\in U then
		// insert(L, u, i, w) into both U and R
		Descriptor key = new Descriptor(restartLabel, gssNode, currentTokenIndex, sppfNode);
		Descriptor found = descriptors.get(key);

		if (found == null) {
			descriptors.put(key, key);
			descriptorsToBeProcessed.addFirst(key);
		}

		if (TRACE) 
			System.out.printf("findDescriptor %s - %sfound\n", key.toString(), found == null ? "not " : "");		
	}

	protected boolean testRepeat(int regexpLabel, GssNode stackTop, int currentTokenIndex, SppfNode derivationNode) {
		// boolean testRepeat(T, u, i, w)
		// if (T, u, i, w) \in TR return true else {
		// insert (T, u, i, w) into TR
		// return false
		// }
		TestRepeatElement key = new TestRepeatElement(regexpLabel, stackTop, currentTokenIndex, derivationNode);
		TestRepeatElement found = testRepeatElements.get(key);

		if (TRACE) 
			System.out.printf("testRepeat %s - %sfound\n", key.toString(), found == null ? "not " : "");

		if (found != null) return true;

		testRepeatElements.put(key, key);
		return false;
	}

	protected void checkAcceptance(int startSymbol) { 
		rootSPPFNode = lookupSPPF(startSymbol, 0, inputLength - 1);
		inLanguage = rootSPPFNode != null;
	}

	/**************************************************************************
	 * Descriptor management methods
	 *************************************************************************/
	boolean noDescriptors() {  return descriptorsToBeProcessed.peekFirst() == null; }

	void unloadDescriptor() {
		currentDescriptor = descriptorsToBeProcessed.removeFirst();

		if (TRACE)
			System.out.printf("\n******\n\nProcessing descriptor %s\n", currentDescriptor);

		currentRestartLabel = currentDescriptor.label();

		inputIndex = currentDescriptor.inputIndex();
		currentGSSNode = currentDescriptor.gssNode();
		currentSPPFNode = currentDescriptor.sppfNode();
	}

	/**************************************************************************
	 * User accessible functions
	 *************************************************************************/
	abstract void parse(String inputString);

	/**************************************************************************
	 * Constructor; initialise pool and hash tables
	 *************************************************************************/
	ARTGLLObjectOriented() {
		startTime = System.currentTimeMillis();
	}
}
