package uk.ac.rhul.cs.csle.art.alg.gll.oosupport;
/******************************************************************************
 * GLLSupport.java
 * 
 * An abstract class which defines support methods for GLL parsers
 * generated by the ART tool.
 * 
 * (c) Adrian Johnstone 2013
 *****************************************************************************/

public abstract class ARTGLLSupport {

	/**************************************************************************
	 * Debug message control
	 *************************************************************************/
	protected static final boolean TRACE = false;

	/**************************************************************************
	 * Grammar alphabet enumeration variable elements - these are loaded with the actual values by the generated parser
	 *************************************************************************/
	protected static int ART__EOS;
	protected static int ART__EPSILON;
	protected static int ART__DUMMY;

	/**************************************************************************
	 * Parser global variables
	 *************************************************************************/
	protected String[] artLabelStrings;
	protected String[] artRDTStrings;
	protected String[] artAnnotations;
	protected int[] artPreSlots;
	protected int[] artPostSlots;
	protected int[] artInstanceOfs;
	protected boolean[] artTerminalRequiresWhiteSpace;
	protected boolean[] artTerminalCaseInsensitive;

	protected String characterString;
	protected int rawInputIndex;

	protected int[] input;
	protected int inputLength;
	protected int inputIndex;
	protected int[] inputToCharacterStringMap;
	protected int[] inputExtents;

	protected String grammarName;
	protected String startSymbolName;
	protected String buildOptions;

	protected boolean inLanguage;
	protected long startTime;
	protected long runTime = 0;

	/**************************************************************************
	 * Table initialisation
	 *************************************************************************/
	void setIntArray(int [] array, int lo, int hi) {
	  for (int tmp = lo; tmp < hi; tmp++) array[tmp] = tmp; 
	}

	void setIntArray(int [] array, int lo, int hi, int value) {
		for (int tmp = lo; tmp < hi; tmp++) array[tmp] = value; 
	}

	void setStringArray(String [] array, int lo, int hi, String value) {
		for (int tmp = lo; tmp < hi; tmp++) array[tmp] = value; 
	}

	void setBoolArray(boolean [] array, int lo, int hi, boolean value) {
		for (int tmp = lo; tmp < hi; tmp++) array[tmp] = value; 
	}

	/**************************************************************************
	 * Lexical functions
	 *************************************************************************/
	private int longestLength;
	private int longestIndex;

	boolean matchLongestRaw() {
		longestLength = 0;
		for (int tokenIndex = 1; tokenIndex < ART__EPSILON; tokenIndex++) {
			if (!characterString.regionMatches(artTerminalCaseInsensitive[tokenIndex],
					rawInputIndex, artRDTStrings[tokenIndex], 0,
					artRDTStrings[tokenIndex].length()))
				continue;

			if (artRDTStrings[tokenIndex].length() > longestLength) {
				longestLength = artRDTStrings[tokenIndex].length();
				longestIndex = tokenIndex;
			}
		}

		if (longestLength == 0) {
			System.out
			.printf("Error: at input position %d lexer found unexpected character %c\n",
					rawInputIndex, characterString.charAt(rawInputIndex));
			return false;
		}
		return true;
	}

	void skipWhitespaceRaw() {
		while (rawInputIndex < characterString.length()
				&& Character.isWhitespace(characterString.charAt(rawInputIndex)))
			rawInputIndex++;
	}

	// Tokenise String rawInput into int[] input
	protected void lexLongestMatch() {
		if (TRACE)
			System.out.printf("lexLongestMatch() - rawInput %s\n", characterString);

		rawInputIndex = inputIndex = 0;
		skipWhitespaceRaw();
		while (rawInputIndex < characterString.length()) {
			if (!matchLongestRaw()) // On lex error, return
				return;
			rawInputIndex += longestLength;
			skipWhitespaceRaw();
			inputIndex++;
		}

		inputLength = inputIndex + 1;
		input = new int[inputLength];
		inputToCharacterStringMap = new int[inputLength];
		inputExtents = new int[inputLength];

		rawInputIndex = inputIndex = 0;
		skipWhitespaceRaw();
		while (rawInputIndex < characterString.length()) {
			inputToCharacterStringMap[inputIndex] = rawInputIndex;
			matchLongestRaw();
			rawInputIndex += longestLength;
			skipWhitespaceRaw();
			inputExtents[inputIndex] = longestLength;
			input[inputIndex++] = longestIndex;			
		}

		inputToCharacterStringMap[inputIndex] = rawInputIndex;
		input[inputIndex] = ART__EOS;
		inputExtents[inputIndex] = 1;

		if (TRACE) {
			System.out.printf("lexLongestMatch() - input:\n");
			for (int i = 0; i < inputLength; i++)
				System.out.printf("%d: %d (%s)\n", i, input[i],
						artRDTStrings[input[i]]);
		}
	}

	/**************************************************************************
	 * Timer methods
	 *************************************************************************/
	void startClock(){ startTime = System.nanoTime(); }

	void stopClock() { runTime = System.nanoTime() - startTime; }


	/**************************************************************************
	 * Public members
	 *************************************************************************/
	abstract void parse(String inputString);
}
