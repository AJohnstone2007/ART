/*
 *
 * GLLSupport.java
 *
 * An abstract class which defines support methods for GLL parsers
 * generated by the ART tool.
 *
 * (c) Adrian Johnstone 2013
 */
package uk.ac.rhul.cs.csle.art.alg.gll.support;

import uk.ac.rhul.cs.csle.art.alg.ARTParserBase;
import uk.ac.rhul.cs.csle.art.lex.ARTLexerBase;
import uk.ac.rhul.cs.csle.art.lex.ARTTWEPairSet;
import uk.ac.rhul.cs.csle.art.manager.grammar.ARTGrammar;
import uk.ac.rhul.cs.csle.art.util.ARTException;
import uk.ac.rhul.cs.csle.art.util.text.ARTText;
import uk.ac.rhul.cs.csle.art.util.text.ARTTextLevel;

public abstract class ARTGLLParserBase extends ARTParserBase {
  boolean ARTLEXTRACEMGLL = false;
  protected int artWhitespaceEOSPrefixLength; // The amount of whitespace at the end of the file for acceptance handling

  // Pairs
  public int artInputPairBuffer[]; // Holds all unique input pairs; index into this buffer of a pair (a,i) is its handle in descriptors
  public int artInputPairIndex[][]; // Index of input pairs: contents of location (a, i) is the address of (a,i) in inputPair Buffer, a.k.a the pair's
                                    // handle
  public int artInputFirstPairAtLeftExtent[]; // For a given leftExtent, this holds the handle of the first pair in the inputPairBuffer. This is used as a
  public int artInputSuccessorIndex[][]; // Index of successor handles: contents of location (a, i) is the addess of first successor of (a,i)
  public int artCurrentInputPairReference; // handle for current input pair; index of this pair into inputPairBuffer
  public int artCurrentInputPairIndex; // Index into pair buffer used by parsers

  public ARTGLLParserBase(ARTGrammar artGrammar, ARTLexerBase artLexerBase) {
    super(artGrammar, artLexerBase);
  }

  /**
   * Getters, setters and iterators
   */
  abstract public int artSPPFNodeLabel(int element);

  abstract public int artSPPFNodeLeftExtent(int element);

  abstract public int artSPPFNodeRightExtent(int element);

  abstract public int artSPPFNodePackedNodeList(int element);

  // Symbol nodes may be visited or selected
  abstract public boolean artSPPFNodeVisited(int element);

  abstract public void artSPPFNodeResetVisited(int element);

  abstract public void artSPPFNodeSetVisited(int element);

  public void artSPPFResetVisitedFlags() {
    for (int element = artSPPFNodeFirst(); element != 0; element = artSPPFNodeNext())
      artSPPFNodeResetVisited(element);
  }

  abstract public boolean artSPPFNodeSelected(int element);

  abstract public void artSPPFNodeResetSelected(int element);

  abstract public void artSPPFNodeSetSelected(int element);

  abstract public int artSPPFPackedNodeParent(int element);

  abstract public int artSPPFPackedNodeLabel(int element);

  abstract public int artSPPFPackedNodePivot(int element);

  abstract public int artSPPFPackedNodeLeftChildLabel(int element);

  abstract public int artSPPFPackedNodeRightChildLabel(int element);

  abstract public int artSPPFPackedNodePackedNodeList(int element);

  // Packed nodes may be suppressed or selected
  abstract public boolean artSPPFPackedNodeSuppressed(int element);

  abstract public void artSPPFPackedNodeResetSuppressed(int element);

  abstract public void artSPPFPackedNodeSetSuppressed(int element);

  abstract public boolean artSPPFPackedNodeSelected(int element);

  abstract public void artSPPFPackedNodeResetSelected(int element);

  abstract public void artSPPFPackedNodeSetSelected(int element);

  /*
   * Iterate over all SPPF nodes independent of linking
   */
  abstract public int artSPPFNodeFirst();

  abstract public int artSPPFNodeNext();

  abstract public int artSPPFNodeArity(int element);

  abstract public int artGSSNodeLabel(int element);

  abstract public int artGSSNodeLevel(int element);

  abstract public int artGSSNodeEdgeList(int element);

  abstract public int artGSSEdgeSPPFNode(int element);

  abstract public int artGSSEdgeSource(int element);

  abstract public int artGSSEdgeDestination(int element);

  abstract public int artGSSEdgeEdgeList(int element);

  /*
   * Iterate over all GSS nodes independent of linking
   */
  abstract public int artGSSNodeFirst();

  abstract public int artGSSNodeNext();

  /* Iterate over all GSS edges independent of linking */
  abstract public int artGSSEdgeFirst();

  abstract public int artGSSEdgeNext();

  /**
   * Internal methods
   */
  protected abstract int artFindRightmostTerminalSPPFNode();

  protected void artReportParseError(int rightMostSPPFNode) throws ARTException {
    int label = artSPPFNodeLabel(rightMostSPPFNode);
    if (artLexer.artInputLength <= 1)
      throw new ARTException(ARTText.echo("Parser error: unexpected empty string ", 0, null));
    else
      throw new ARTException(ARTText.echo("Parser error: found unexpected token after " + artLabelInternalStrings[label],
          artSPPFNodeRightExtent(rightMostSPPFNode), artLexer.artInputString));
  }

  /**
   * Public lexical access
   */
  public int artLabelEOS() {
    return ARTL_EOS;
  }

  public int artLabelEpsilon() {
    return ARTL_EPSILON;
  }

  public int artLabelAnnotation() {
    return ARTL_ANNOTATION;
  }

  public int artLabelDummy() {
    return ARTL_DUMMY;
  }

  public String artLabelToString(int label) {
    return artLabelStrings[label];
  }

  /**
   * Input string manipulation
   *
   * @throws ARTException
   */
  protected String artLexeme(int leftExtent, int rightExtent) throws ARTException {
    return artlexeme(leftExtent, rightExtent, 0, 0);
  }

  protected String artlexeme(int leftExtent, int rightExtent, int leftDelimiterWidth, int rightDelimiterWidth) throws ARTException {
    // May 2016 modified to strip whitespace from front of lexeme
    artLexer.artInputIndex = leftExtent;
    artLexer.artLexicalisePreparseWhitespace();

    // System.out.println("artlexeme " + artcharacterStringInputIndex + ":" + rightExtent + " '"
    // + artcharacterStringInput.substring(artcharacterStringInputIndex, rightExtent) + "'");
    return artLexer.artInputString.substring(artLexer.artInputIndex + leftDelimiterWidth, rightExtent - rightDelimiterWidth);
  }

  protected String artLexemeAsID(int leftExtent, int rightExtent) throws ARTException {
    return artLexeme(leftExtent, rightExtent);
  }

  protected int artLexemeAsInteger(int leftExtent, int rightExtent) throws NumberFormatException, ARTException {
    return Integer.parseInt(artLexeme(leftExtent, rightExtent));
  }

  protected double artLexemeAsReal(int leftExtent, int rightExtent) throws NumberFormatException, ARTException {
    return Double.parseDouble(artLexeme(leftExtent, rightExtent));
  }

  protected String artLexemeAsRawString(int leftExtent, int rightExtent) throws ARTException {
    return artLexemeAsRawString(leftExtent, rightExtent, 1, 1);
  }

  protected String artLexemeAsRawString(int leftExtent, int rightExtent, int leftDelimiterWidth, int rightDelimiterWidth) throws ARTException {
    return artlexeme(leftExtent, rightExtent, leftDelimiterWidth, rightDelimiterWidth);
  }

  protected String artLexemeAsString(int leftExtent, int rightExtent) throws ARTException {
    return artLexemeAsString(leftExtent, rightExtent, 1, 1);
  }

  // This function is used to convert string like lexemes into ASCII strings with escape sequence replacement
  // We are passed the leftExtent and the rightExtent,
  protected String artLexemeAsString(int leftExtent, int rightExtent, int leftDelimiterWidth, int rightDelimiterWidth) throws ARTException {
    // System.err.printf("%nlexemeAsString received %d to %d |%s| with delimiter widths L=%d, R=%d%n", leftExtent, rightExtent,
    // artcharacterStringInput.substring(leftExtent, rightExtent), leftDelimiterWidth, rightDelimiterWidth);
    artLexer.artInputIndex = leftExtent;
    artLexer.artLexicalisePreparseWhitespace();

    int left = artLexer.artInputIndex + leftDelimiterWidth;
    int right;
    int count = 0;
    for (right = left; right < rightExtent - rightDelimiterWidth;) {
      count++;
      if (artLexer.artInputString.charAt(right) == '\\') {
        if (Character.isDigit(artLexer.artInputString.charAt(right + 1)))
          right += 4;
        else
          right += 2;
      } else
        right++;
    }

    // System.err.printf("%nlexemeAsString string length is %d%n", count);
    char ret[] = new char[count];
    for (int i = 0; i < count; i++)
      ret[i] = ' ';
    int retI = 0;

    for (right = left; right < rightExtent - rightDelimiterWidth;) {
      if (artLexer.artInputString.charAt(right) == '\\') {
        if (Character.isDigit(artLexer.artInputString.charAt(right + 1))) {
          ret[retI++] = (char) (artLexer.artInputString.charAt(right + 1) * 64 + artLexer.artInputString.charAt(right + 2) * 8
              + artLexer.artInputString.charAt(right + 3));
          right += 4;
        } else {
          switch (artLexer.artInputString.charAt(right + 1)) {
          case 'n':
            ret[retI++] = '\n';
            break;
          case 'r':
            ret[retI++] = '\r';
            break;
          case 't':
            ret[retI++] = '\t';
            break;
          case 'f':
            ret[retI++] = '\f';
            break;
          case '\'':
            ret[retI++] = '\'';
            break;
          case '"':
            ret[retI++] = '"';
            break;
          case '\\':
            ret[retI++] = '\\';
            break;
          }
          right += 2;
        }
      } else
        ret[retI++] = artLexer.artInputString.charAt(right++);
    }

    return new String(ret);
  }

  public String[] getArtLabelInternalStrings() {
    return artLabelInternalStrings;
  }

  public void setArtLabelInternalStrings(String[] artLabelInternalStrings) {
    this.artLabelInternalStrings = artLabelInternalStrings;
  }

  public long getArteSOSInterpretCompleteTime() {
    return arteSOSInterpretCompleteTime;
  }

  public void setArteSOSInterpretCompleteTime(long arteSOSInterpretCompleteTime) {
    this.arteSOSInterpretCompleteTime = arteSOSInterpretCompleteTime;
  }

  /*
   * Parser global variables
   */
  protected int artRootSPPFNode;
  protected int artDummySPPFNode;
  protected int artRootGSSNode;

  protected int artPoppingDescriptorsToBeProcessed;
  protected int artNonpoppingDescriptorsToBeProcessed;
  protected int artPoppingDescriptorsToBeProcessedTail;
  protected int artNonpoppingDescriptorsToBeProcessedTail;
  protected int artCurrentDescriptor;
  protected int artCurrentRestartLabel;
  protected int artCurrentSPPFNode;
  protected int artCurrentSPPFRightChildNode;
  protected int artCurrentGSSNode;
  protected int artTemporarySPPFNode;

  protected int[] artFolds;
  protected int[] artGathers;
  protected int[] artpL;
  protected int[] artaL;
  protected int[] artcolonL;
  // protected int[] artsemiColonL;
  protected boolean[] artfiRL;
  protected boolean[] artfiPCL;
  protected boolean[] arteoOPL;
  protected boolean[] arteoRL;
  protected boolean[] arteoR_pL;
  protected boolean[] artPopD;
  protected boolean[] artIsLexical;

  /**
   * Getters
   */
  public int artSPPFRoot() {
    return artRootSPPFNode;
  }

  public int artSPPFPackedNodeLeftChild(int element) {
    int leftChildLabel = artSPPFPackedNodeLeftChildLabel(element);
    if (leftChildLabel == ARTL_DUMMY)
      return 0;
    else
      return artLookupSPPF(leftChildLabel, artSPPFNodeLeftExtent(artSPPFPackedNodeParent(element)), artSPPFPackedNodePivot(element));
  }

  public int artSPPFPackedNodeRightChild(int element) {
    return artLookupSPPF(artSPPFPackedNodeRightChildLabel(element), artSPPFPackedNodePivot(element), artSPPFNodeRightExtent(artSPPFPackedNodeParent(element)));
  }

  public int artGSSRoot() {
    return artRootGSSNode;
  }

  /**
   * GLL support functions
   */
  abstract protected int artLookupSPPF(int label, int leftExtent, int rightExtent);

  abstract protected int artFindSPPFInitial(int label, int leftExtent, int rightExtent);

  abstract protected int artFindSPPFEpsilon(int currentTokenIndex);

  abstract protected int artFindSPPFTerminal(int label, int currentTokenIndex);

  abstract protected int artFindSPPFTerminal(int label, int currentTokenIndex, int tokenRightExtent); // For MGLL version

  abstract protected int artFindSPPF(int label, int leftChild, int rightChild);

  abstract protected int artFindSPPFClosure(int parentLabel, int childLabel, int currentTokenIndex);

  abstract protected int artFindSPPFBaseNode(int parentLabel, int childLabel, int currentTokenIndex);

  abstract protected int artFindGSS(int stackTopLabel, int stackTop, int currentToken, int currentsppfNode);

  abstract protected void artPop(int stackTop, int currentTokenIndex, int currentsppfNode);

  abstract protected void artFindDescriptor(int restartLabel, int gssNode, int currentTokenIndex, int sppfNode);

  abstract protected boolean artTestRepeat(int regexpLabel, int stackTop, int currentTokenIndex, int derivationNode);

  // MGLL variants
  abstract protected int artFindGSSMGLL(int stackTopLabel, int stackTop, int currentToken, int currentsppfNode);

  abstract protected void artPopMGLL(int stackTop, int currentTokenIndex, int currentsppfNode);

  // Clustered variants
  abstract protected int artFindGSSClusteredInitial(int stackTopLabel, int stackTop, int currentToken, int currentsppfNode);

  abstract protected int artFindGSSClustered(int stackTopLabel, int stackTop, int currentToken, int currentsppfNode);

  abstract protected void artPopClustered(int nonTerminal, int k, int currentTokenIndex, int currentsppfNode);

  // Note this is esentially just an un-rename - it is here as a place holder in case we need to handle descriptors differently
  protected void artFindDescriptorClustered(int restartLabel, int gssNode, int currentTokenIndex, int sppfNode) {
    artFindDescriptor(restartLabel, gssNode, currentTokenIndex, sppfNode);
  };

  abstract protected void artCheckAcceptance() throws ARTException;

  abstract boolean artNoDescriptors();

  abstract void artUnloadDescriptor();

  abstract void artUnloadDescriptorMGLL();

  abstract void artLoadDescriptorInitialMGLL();

  /**
   * Disambiguation
   */

  ARTLexerBase tweSet;

  void artDisambiguateWithinSPPFCollectTWERec(int element, boolean postUseTerminals) {
    // artText.printf("artDisambiguateWithinSPPFCollectTWERec() at node %s%n", artRenderSPPFNodeTitle(element));

    if (artSPPFNodeVisited(element)) {
      // artText.println("Already visited - aborting");
      return;
    }

    artSPPFNodeSetVisited(element);

    if (artNonterminalsDeclaredAsTerminals[artSPPFNodeLabel(element)] || (postUseTerminals && artSPPFNodePackedNodeList(element) == 0)) { // declared terminal
                                                                                                                                          // or leaf
      artText.println("located TWE set element " + artLabelStrings[artSPPFNodeLabel(element)] + ", " + artSPPFNodeLeftExtent(element) + ", "
          + artSPPFNodeRightExtent(element));
      tweSet.tweSetUpdateExactMakeLeftSet(artSPPFNodeLabel(element), artSPPFNodeLeftExtent(element), artSPPFNodeRightExtent(element));
    }

    for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp)) {
      int leftChildLabel = artSPPFPackedNodeLeftChildLabel(tmp);

      if (leftChildLabel != ARTL_DUMMY)
        artDisambiguateWithinSPPFCollectTWERec(artLookupSPPF(leftChildLabel, artSPPFNodeLeftExtent(artSPPFPackedNodeParent(tmp)), artSPPFPackedNodePivot(tmp)),
            postUseTerminals);

      artDisambiguateWithinSPPFCollectTWERec(
          artLookupSPPF(artSPPFPackedNodeRightChildLabel(tmp), artSPPFPackedNodePivot(tmp), artSPPFNodeRightExtent(artSPPFPackedNodeParent(tmp))),
          postUseTerminals);
    }

  }

  boolean artDisambiguateWithinSPPFSuppressRec(int element, boolean postUseTerminals) {
    // artText.printf("artDisambiguateWithinSPPFSuppressRec() at node %s%n", artRenderSPPFNodeTitle(element));

    if (tweSet.isIn(artSPPFNodeLabel(element), artSPPFNodeLeftExtent(element), artSPPFNodeRightExtent(element))) {
      artText.println("located TWE set element " + artLabelStrings[artSPPFNodeLabel(element)] + ", " + artSPPFNodeLeftExtent(element) + ", "
          + artSPPFNodeRightExtent(element));
      if (tweSet.isSuppressed(artSPPFNodeLabel(element), artSPPFNodeLeftExtent(element), artSPPFNodeRightExtent(element))) {
        artText.println("Marked as suppressed in TWE set");
        return true;
      }
    }

    if (artSPPFNodePackedNodeList(element) == 0) return false; // For leaf cells that are not in the TWEset

    if (!artSPPFNodeVisited(element)) { // rcurse for unvisited nodes

      artSPPFNodeSetVisited(element);

      // Now check suppressed bits across all packed node children
      for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp)) {
        boolean anySuppressed = false;

        int leftChildLabel = artSPPFPackedNodeLeftChildLabel(tmp);

        if (leftChildLabel != ARTL_DUMMY) if (artDisambiguateWithinSPPFSuppressRec(
            artLookupSPPF(leftChildLabel, artSPPFNodeLeftExtent(artSPPFPackedNodeParent(tmp)), artSPPFPackedNodePivot(tmp)), postUseTerminals))
          anySuppressed = true;

        if (artDisambiguateWithinSPPFSuppressRec(
            artLookupSPPF(artSPPFPackedNodeRightChildLabel(tmp), artSPPFPackedNodePivot(tmp), artSPPFNodeRightExtent(artSPPFPackedNodeParent(tmp))),
            postUseTerminals))
          anySuppressed = true;

        if (anySuppressed) artSPPFPackedNodeSetSuppressed(tmp);
      }
    }

    // Even if visited, we must recompute allSupressed since it is not stored anywhere
    boolean allSuppressed = true;
    for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp))
      if (!artSPPFPackedNodeSuppressed(tmp)) allSuppressed = false;
    return allSuppressed;
  }

  int symbolNodeCount, intermediateNodeCount, packedNodeCount, ambiguousNodeCount;

  void summaryStatisticsRec(int element) {
    // artText.printf("summaryStatisticsRec() at node %s%n", artRenderSPPFNodeTitle(element));

    if (artSPPFNodeVisited(element)) {
      // artText.println("Already visited - aborting");
      return;
    }

    artSPPFNodeSetVisited(element);

    if (artKindOfs[artSPPFNodeLabel(element)] == ARTK_INTERMEDIATE)
      intermediateNodeCount++;
    else
      symbolNodeCount++;

    int unsuppressedPackedNodes = 0;
    for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp))
      if (!artSPPFPackedNodeSuppressed(tmp)) unsuppressedPackedNodes++;

    if (unsuppressedPackedNodes > 1) ambiguousNodeCount++;

    for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp)) {
      if (artSPPFPackedNodeSuppressed(tmp)) continue;

      packedNodeCount++;

      int leftChildLabel = artSPPFPackedNodeLeftChildLabel(tmp);

      if (leftChildLabel != ARTL_DUMMY)
        summaryStatisticsRec(artLookupSPPF(leftChildLabel, artSPPFNodeLeftExtent(artSPPFPackedNodeParent(tmp)), artSPPFPackedNodePivot(tmp)));

      summaryStatisticsRec(
          artLookupSPPF(artSPPFPackedNodeRightChildLabel(tmp), artSPPFPackedNodePivot(tmp), artSPPFNodeRightExtent(artSPPFPackedNodeParent(tmp))));
    }
  }

  void summaryStatistics() {
    artSPPFResetVisitedFlags();
    symbolNodeCount = intermediateNodeCount = packedNodeCount = ambiguousNodeCount = 0;
    if (artSPPFRoot() != 0) summaryStatisticsRec(artSPPFRoot());
    artSPPFResetVisitedFlags();
    System.out.printf("%s symbol nodes, %s intermediate nodes, %s packed nodes to a total of %s SPPF nodes with %s ambiguous nodes\n", symbolNodeCount,
        intermediateNodeCount, packedNodeCount, symbolNodeCount + intermediateNodeCount + packedNodeCount, ambiguousNodeCount);
  }

  int countSentencesAmbiguityCount;

  class SentenceTrieNode {
    int token;
    SentenceTrieNode sibling, child;

    public SentenceTrieNode(int token, SentenceTrieNode sibling) {
      this.token = token;
      this.sibling = sibling;
    }

    SentenceTrieNode findChild(int token) {
      for (SentenceTrieNode tmp = child; tmp.sibling != null; tmp = tmp.sibling)
        if (tmp.token == token) return tmp;

      child = new SentenceTrieNode(token, child);

      return child;
    }
  }

  void countSentencesRec(int element, SentenceTrieNode trieNode) {
    // artText.printf("countSentencesRec() at node %s%n", artRenderSPPFNodeTitle(element));
    SentenceTrieNode newTrieNode = trieNode;
    if (artSPPFNodeVisited(element)) {
      // artText.println("Already visited - aborting");
      return;
    }

    artSPPFNodeSetVisited(element);

    int unsuppressedPackedNodes = 0;

    for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp)) {
      if (artSPPFPackedNodeSuppressed(tmp)) continue;
      unsuppressedPackedNodes++;

      int leftChildLabel = artSPPFPackedNodeLeftChildLabel(tmp);

      if (leftChildLabel != ARTL_DUMMY)
        countSentencesRec(artLookupSPPF(leftChildLabel, artSPPFNodeLeftExtent(artSPPFPackedNodeParent(tmp)), artSPPFPackedNodePivot(tmp)), newTrieNode);

      countSentencesRec(artLookupSPPF(artSPPFPackedNodeRightChildLabel(tmp), artSPPFPackedNodePivot(tmp), artSPPFNodeRightExtent(artSPPFPackedNodeParent(tmp))),
          newTrieNode);
    }

    if (unsuppressedPackedNodes > 1) countSentencesAmbiguityCount++;
  }

  void countSentences() {
    countSentencesAmbiguityCount = 0;
    artSPPFResetVisitedFlags();
    if (artSPPFRoot() != 0) countSentencesRec(artSPPFRoot(), new SentenceTrieNode(0, null));
    artSPPFResetVisitedFlags();
    System.out.println("Whilst counting sentences, found " + countSentencesAmbiguityCount + " ambiguous nodes");
  }

  @Override
  public ARTLexerBase artDisambiguateWithinSPPF(boolean postUseTerminals, boolean postLongestWithin, boolean postLongestAcross, boolean postPriority) {
    System.out.println("\n** Summary SPPF statistics before postparse disambiguation");
    summaryStatistics();

    System.out.println("\n** Commencing SPPF traversal to collect TWESet");
    tweSet = new ARTLexerBase(artHigher, artLonger, artLexer.artInputString, ARTL_EOS, artLabelInternalStrings, postLongestWithin, postLongestAcross,
        postPriority);

    // Normalise the TWE set by putting an empty set into each null position
    for (int i = 0; i < tweSet.tweSet.length; i++)
      if (tweSet.tweSet[i] == null) tweSet.tweSet[i] = new ARTTWEPairSet();
    // System.out.println("SPPF-derived TWE set initial state");
    // tweSet.printTWESetForSPPFTraverser();

    artSPPFResetVisitedFlags(); // probably redundant, but still
    if (artSPPFRoot() != 0) artDisambiguateWithinSPPFCollectTWERec(artSPPFRoot(), postUseTerminals);

    System.out.println("\n** Running suppressors and computinglexicalisations on SPPF derived TWE set");
    tweSet.runSuppressors();
    tweSet.computeLexerData();
    artSPPFResetVisitedFlags();

    artDisambiguateWithinSPPFSuppressRec(artSPPFRoot(), postUseTerminals);

    System.out.println("\n** Summary SPPF statistics after postparse disambiguation");
    summaryStatistics();

    countSentences();

    return tweSet;
  }

  private void artDisambiguateRightmostRec(int element) {
    // text.printf(TextLevel.TRACE, "disambiguateRightmostRec() at node %d %s%n", element, sppfNodeTitle(element, false));

    if (artSPPFNodeVisited(element)) {
      // text.println(TextLevel.TRACE, "Already visited - aborting");
      return;
    }

    artSPPFNodeSetVisited(element);

    int rightmostPivotElement = 0;
    int rightmostPivotValue = -1;

    for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp)) {
      // artText.printf("Rightmost-testing pack node node %d%n", tmp);
      if (artSPPFPackedNodePivot(tmp) > rightmostPivotValue) {
        rightmostPivotElement = tmp;
        rightmostPivotValue = artSPPFPackedNodePivot(tmp);
      }
    }

    for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp)) {
      // artText.printf("Suppress-testing pack node node %d%n", tmp);
      if (tmp != rightmostPivotElement) {
        // artText.printf("Suppressing pack node %d under symbol node %d%n", tmp, element);
        artSPPFPackedNodeSetSuppressed(tmp);
      }
    }

    for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp)) {
      int leftChildLabel = artSPPFPackedNodeLeftChildLabel(tmp);

      if (leftChildLabel != ARTL_DUMMY)
        artDisambiguateRightmostRec(artLookupSPPF(leftChildLabel, artSPPFNodeLeftExtent(artSPPFPackedNodeParent(tmp)), artSPPFPackedNodePivot(tmp)));

      artDisambiguateRightmostRec(
          artLookupSPPF(artSPPFPackedNodeRightChildLabel(tmp), artSPPFPackedNodePivot(tmp), artSPPFNodeRightExtent(artSPPFPackedNodeParent(tmp))));
    }
  }

  @Override
  public void artDisambiguateRightmost() {
    if (artSPPFRoot() != 0) artDisambiguateRightmostRec(artSPPFRoot());
    artSPPFResetVisitedFlags();
  }

  /*
   * Derivation selection and construction
   */
  private void artDerivationSelectFirstRec(int element) {
    // artText.printf("SelectFirstDerivationRec() at node %d%n", element);

    if (artSPPFNodeVisited(element)) {
      // artText.println("Already visited - aborting");
      return;
    }

    artSPPFNodeSetVisited(element);
    artSPPFNodeSetSelected(element);

    for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp))
      if (!artSPPFPackedNodeSuppressed(tmp)) {
        artSPPFPackedNodeSetSelected(tmp);
        // artText.printf("Selecting element %d%n", tmp);
        int leftChild = artSPPFPackedNodeLeftChild(tmp);
        if (leftChild != 0) artDerivationSelectFirstRec(leftChild);
        artDerivationSelectFirstRec(artSPPFPackedNodeRightChild(tmp));
        break;
      }
  }

  @Override
  public void artDerivationSelectFirst() {
    artSPPFResetVisitedFlags();
    artDerivationSelectFirstRec(artSPPFRoot());
    artSPPFResetVisitedFlags();
    artDerivationSelectCompleteTime = artReadClock();
  }

  private boolean artIsAmbiguousRec(int element) {
    // text.printf(TextLevel.TRACE, "isAmbiguousRec() at node %d%n", element);
    boolean ret = false;

    if (artSPPFNodeVisited(element)) {
      // text.println(TextLevel.TRACE, "Already visited - aborting");
      return ret;
    }

    artSPPFNodeSetVisited(element);

    int unsuppressedPackedNodeCount = 0;
    for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp))
      if (!artSPPFPackedNodeSuppressed(tmp)) {
        if (++unsuppressedPackedNodeCount > 1) ret = true;
        int leftChild = artSPPFPackedNodeLeftChild(tmp);
        if (leftChild != 0) ret |= artIsAmbiguousRec(leftChild);
        ret |= artIsAmbiguousRec(artSPPFPackedNodeRightChild(tmp));
      }
    return ret;
  }

  @Override
  public boolean artIsAmbiguous() {
    artSPPFResetVisitedFlags();
    boolean ret = artIsAmbiguousRec(artSPPFRoot());
    artSPPFResetVisitedFlags();
    return ret;
  }

  private void artDerivationSelectAllRec(int element) {
    // text.printf(TextLevel.TRACE, "selectFirstDerivationRec() at node %d%n", element);

    if (artSPPFNodeVisited(element)) {
      // text.println(TextLevel.TRACE, "Already visited - aborting");
      return;
    }

    artSPPFNodeSetVisited(element);
    artSPPFNodeSetSelected(element);

    for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp))
      if (!artSPPFPackedNodeSuppressed(tmp)) {
        artSPPFPackedNodeSetSelected(tmp);
        int leftChild = artSPPFPackedNodeLeftChild(tmp);
        if (leftChild != 0) artDerivationSelectAllRec(leftChild);
        artDerivationSelectAllRec(artSPPFPackedNodeRightChild(tmp));
      }
  }

  @Override
  public void artDerivationSelectAll() {
    artSPPFResetVisitedFlags();
    artDerivationSelectAllRec(artSPPFRoot());
    artSPPFResetVisitedFlags();
  }

  private void artDerivationSelectNextRec(int element) {
    /* Not yet implemented */
  }

  @Override
  public boolean artDerivationSelectNext() {
    artSPPFResetVisitedFlags();
    artDerivationSelectNextRec(artSPPFRoot());
    artSPPFResetVisitedFlags();
    return false;
  }

  /**********************************************/

  private int artRenderKind = artRenderKindIllegal;

  private final String artSymbolNodeStyle = "";
  private final String artPackedNodeStyle = "style=rounded";
  private final String artIntermediateNodeStyle = "style=filled fillcolor=grey90";
  private final String artDerivationNodeStyle = "";

  private final String artSuppressedStyle = "color=red";
  private final String artSuppressedInTWEStyle = "color=orange";
  private final String artInTWEStyle = "color=green3";
  private final String artSelectedStyle = "color=blue";

  private void artRenderSPPFNode(ARTText text, String title, String label, String style) {
    if (style != null) // In the new style, we only need to render nodes with non-default styles
      text.println("\"" + title + "\"[" + style + (label != null ? (" label = \"" + label + "\"") : "") + "]");
  }

  private void artRenderSPPFEdge(ARTText text, String elementLabel, String parentLabel) {
    text.println("\"" + parentLabel + "\"->\"" + elementLabel + "\"");
  }

  private boolean artElementIsVisible(int element, boolean elementIsPacked) {
    switch (artRenderKind) {
    case artRenderKindDerivation:
      if (elementIsPacked) return false;

      if (!artSPPFNodeSelected(element)) return false;

      if (artKindOfs[artSPPFNodeLabel(element)] == ARTK_INTERMEDIATE) return false;

      return true;

    case artRenderKindSPPF:
      if (!elementIsPacked) return true;

      return artSPPFNodeArity(artSPPFPackedNodeParent(element)) > 1;

    default:
      return true;
    }
  }

  private boolean artElementIsRecursable(int element, boolean elementIsPacked) {
    switch (artRenderKind) {
    case artRenderKindDerivation:
      if (elementIsPacked)
        return artSPPFPackedNodeSelected(element);
      else
        return artSPPFNodeSelected(element);

    default:
      return true;
    }
  }

  private String artRenderSPPFNodeTitle(int element) {
    return /* element + ":" + */ getArtLabelInternalStrings()[artSPPFNodeLabel(element)] + "  " + artSPPFNodeLeftExtent(element) + ","
        + artSPPFNodeRightExtent(element);
  }

  private String artRenderSPPFPackedNodeTitle(int element) {
    return element + ":" + getArtLabelInternalStrings()[artSPPFPackedNodeLabel(element)] + "  " + artSPPFPackedNodePivot(element);
  }

  private String artRenderGSSNodeTitle(int element) {
    return artGSSNodeLevel(element) + " " + getArtLabelInternalStrings()[artGSSNodeLabel(element)];
  }

  private void artRenderSPPFRec(ARTText text, int element, int parent, boolean parentIsPacked, int level, ARTLexerBase tweSet) {
    if (artElementIsVisible(element, false) && parent != 0)
      artRenderSPPFEdge(text, artRenderSPPFNodeTitle(element), parentIsPacked ? artRenderSPPFPackedNodeTitle(parent) : artRenderSPPFNodeTitle(parent));

    if (artSPPFNodeVisited(element)) return;

    artSPPFNodeSetVisited(element);
    int newParent = parent;
    boolean newParentIsPacked = parentIsPacked;

    if (artElementIsVisible(element, false)) {
      String style = artKindOfs[artSPPFNodeLabel(element)] == ARTK_INTERMEDIATE ? artIntermediateNodeStyle : artSymbolNodeStyle;
      if (artRenderKind == artRenderKindDerivation || artRenderKind == artRenderKindDerivationFull) style = artDerivationNodeStyle;

      if (tweSet != null) if (tweSet.isIn(artSPPFNodeLabel(element), artSPPFNodeLeftExtent(element), artSPPFNodeRightExtent(element)))
        if (tweSet.isSuppressed(artSPPFNodeLabel(element), artSPPFNodeLeftExtent(element), artSPPFNodeRightExtent(element)))
        style += (" " + artSuppressedInTWEStyle);
        else
        style += (" " + artInTWEStyle);

      artRenderSPPFNode(text, artRenderSPPFNodeTitle(element), null, style);
      newParent = element;
      newParentIsPacked = false;
    }

    if (artElementIsRecursable(element, false)) {
      for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp)) {
        if (artElementIsVisible(tmp, true)) {
          artRenderSPPFNode(text, artRenderSPPFPackedNodeTitle(tmp), "" + artRenderSPPFPackedNodeTitle(tmp)/* artSPPFPackedNodePivot(tmp) */,
              artSPPFPackedNodeSelected(tmp) ? artPackedNodeStyle + " " + artSelectedStyle
                  : (artSPPFPackedNodeSuppressed(tmp) ? artPackedNodeStyle + " " + artSuppressedStyle : artPackedNodeStyle));

          // we can never have pack nodes visible unless their parent is visible
          artRenderSPPFEdge(text, artRenderSPPFPackedNodeTitle(tmp), artRenderSPPFNodeTitle(element));

          newParent = tmp;
          newParentIsPacked = true;
        }
        if (artElementIsRecursable(tmp, true)) {
          if (artSPPFPackedNodeLeftChild(tmp) != 0)
            artRenderSPPFRec(text, artSPPFPackedNodeLeftChild(tmp), newParent, newParentIsPacked, level == -1 ? level : level + 2, tweSet);
          artRenderSPPFRec(text, artSPPFPackedNodeRightChild(tmp), newParent, newParentIsPacked, level == -1 ? level : level + 2, tweSet);
        }
      }
    }
  }

  @Override
  public void artRenderSPPF(ARTText text, int renderKind, ARTLexerBase tweSet) {
    this.artRenderKind = renderKind;

    if (renderKind == artRenderKindGSS) {
      artRenderSPPFNode(text, artRenderGSSNodeTitle(artRootGSSNode), null, "");
      for (int tmp = artGSSNodeFirst(); tmp != 0; tmp = artGSSNodeNext())
        artRenderSPPFNode(text, null, artRenderGSSNodeTitle(tmp), "");
      for (int tmp = artGSSEdgeFirst(); tmp != 0; tmp = artGSSEdgeNext())
        artRenderSPPFEdge(text, artRenderGSSNodeTitle(artGSSEdgeDestination(tmp)), artRenderGSSNodeTitle(artGSSEdgeSource(tmp)));
    } else if (renderKind == artRenderKindDerivation || renderKind == artRenderKindDerivationFull) {
      artRenderSPPFRec(text, artSPPFRoot(), 0, false, 0, tweSet);
    } else {
      artSPPFResetVisitedFlags();
      artRenderSPPFRec(text, artSPPFRoot(), 0, false, 0, tweSet);
      if (renderKind == artRenderKindSPPFFull)
        for (int element = artSPPFNodeFirst(); element != 0; element = artSPPFNodeNext())
          artRenderSPPFRec(text, element, 0, false, -1, tweSet);
      else if (renderKind == artRenderKindSPPF) artRenderSPPFRec(text, artSPPFRoot(), 0, false, 0, tweSet);
      artSPPFResetVisitedFlags();
    }
  }

  @Override
  public void artParse(String inputString) throws ARTException {
    artParse(inputString, artDefaultStartSymbolLabel);
  }

  @Override
  public void artParse(String inputString, String nonterminalName) throws ARTException {
    if (nonterminalName == null)
      artParse(inputString);
    else
      artParse(inputString, artGetNonterminalLabel(nonterminalName));
  }

  abstract protected void artInitialise();

  abstract protected void artParseBody(String inputString, int nonterminalLabel) throws ARTException;

  protected void artParse(String inputString, int nonterminalLabel) throws ARTException {
    artIsInLanguage = false;

    if (artKindOfs != null && artKindOfs[nonterminalLabel] != ARTK_NONTERMINAL) {
      throw new ARTException("Error: parse start label " + nonterminalLabel + " is not a nonterminal");
    } else {
      artInitialise();
      artParseBody(inputString, nonterminalLabel);
      if (artInadmissable) if (ARTTRACE) artTraceText.println(this.getClass() + " called on EBNF grammar aborting");
    }
  }

  /* Support for TWE sets belowthis line */
  protected class ARTRightExtentNode {
    public int rightExtent;
    public ARTRightExtentNode next;

    ARTRightExtentNode(int rightExtent, ARTRightExtentNode next) {
      this.rightExtent = rightExtent;
      this.next = next;
    }
  }

  private boolean artContains(int rightExtent, ARTRightExtentNode list) {
    while (list != null)
      if (list.rightExtent == rightExtent)
        return true;
      else
        list = list.next;
    return false;
  }

  protected ARTRightExtentNode[][] artTriples; // Indexed as leftExtent, token, rightExtent
  // shortcut to access the elements in classical GLL
  public int artInputSuccessorBuffer[]; // Holds runs of successor handles; each run is terminated by -1

  private void artLexBuildTriplesFromTWESet() throws ARTException {
    // First dimension is the index into the input
    // Second dimension is the token
    // Third dimension is the sequence of right extents
    artTriples = new ARTRightExtentNode[artLexer.artInputLength + 1][];
    int indexedTWESet[][][] = artLexer.lexicaliseToIndexedTWESet(artLexer.artInputString);
    for (int i = 0; i < indexedTWESet.length; i++) {
      if (artTriples[i] == null) artTriples[i] = new ARTRightExtentNode[artLexer.artTokenMax];
      for (int token = 0; token < indexedTWESet[i].length; token++)
        for (int jIndex = 0; jIndex < indexedTWESet[i][token].length; jIndex++)
          artTriples[i][token] = new ARTRightExtentNode(indexedTWESet[i][token][jIndex], artTriples[i][token]);
    }
  }

  private void artLexBuildTriplesFromSimpleStringUsingLongestMatch() throws ARTException {
    if (ARTLEXTRACEMGLL) artText.printf(ARTTextLevel.TRACE, "lexLongestMatch() - rawInput:%n****%n%s%n****%n", artLexer.artInputString);

    // Constants representing the length of the dimensions; in Java these are not required since we could interrogate the array objects, but we want
    // compatibility with C and non-OO lanuages
    artTriples = new ARTRightExtentNode[artLexer.artInputLength + 1][];

    boolean suppressWhitespace = true;
    int leftExtent;

    artLexer.artInputIndex = 0;
    do {
      leftExtent = artLexer.artInputIndex;
      if (suppressWhitespace) artLexer.artLexicalisePreparseWhitespace();
      if (ARTLEXTRACEMGLL) artText.printf(ARTTextLevel.TRACE, "lexLongestMatch() - skipped whitespace %d:%d '%s'%n", leftExtent, artLexer.artInputIndex,
          artLexer.artInputString.substring(leftExtent, artLexer.artInputIndex));
      artLexer.artMatchLongestRaw();
      if (ARTLEXTRACEMGLL) artText.printf(ARTTextLevel.TRACE, "lexLongestMatch() - matched %s %d:%d%n****%n%s%n****%n",
          artLabelInternalStrings[artLexer.artLongestToken], artLexer.artInputIndex, artLexer.artInputIndex + artLexer.artLongestLength,
          artLexer.artInputString.substring(artLexer.artInputIndex, artLexer.artInputIndex + artLexer.artLongestLength));
      suppressWhitespace = artKindOfs[artLexer.artLongestToken] != ARTGLLParserBase.ARTK_CHARACTER_TERMINAL;
      if (artTriples[leftExtent] == null) artTriples[leftExtent] = new ARTRightExtentNode[artLexer.artTokenMax];
      if (!artContains(artLexer.artInputIndex, artTriples[leftExtent][artLexer.artLongestToken]))
        artTriples[leftExtent][artLexer.artLongestToken] = new ARTRightExtentNode(artLexer.artInputIndex, artTriples[leftExtent][artLexer.artLongestToken]); // Head
      // insert new
      // extent
    } while (artLexer.artLongestToken != ARTGLLParserBase.ARTL_EOS);
    artWhitespaceEOSPrefixLength = artLexer.artInputLength - leftExtent;
  }

  private void artPrintTriples() {
    if (artTriples == null) return;
    // Now print out the triples
    for (int i = 0; i < artTriples.length; i++) {
      if (artTriples[i] != null) {
        System.out.print(i + ": ");
        for (int t = 0; t < artTriples[i].length; t++)
          for (ARTRightExtentNode n = artTriples[i][t]; n != null; n = n.next)
            System.out.println(t + ", " + n.rightExtent);
      }
    }
  }

  private void artLexBuildSuccessorSets() {
    // Populate the visible data structures which represnet the \Chi_{a,i} sets using the triples array, which may be discarded after this phase
    // These are the data structures to be constructed:
    // int InputPairBuffer[]; // Holds all unique input pairs; index into this buffer of a pair (a,i) is its handle in descriptors
    // int InputPairIndex[][]; // Index of input pairs: contents of location (a, i) is the address of (a,i) in InputPair Buffer, a.k.a the pair's handle
    // int InputInitialPairBuffer[]; // Holds pair handles for state 0
    // int inputSuccessorPairs[][][]; //Blocks of successor pairs for each (a, i) - these are the \Chi_{a,i} sets from the paper as lists of pair handles

    // Enumerate unique pairs
    int pairCardinality = 0;
    for (int leftExtent = 0; leftExtent < artLexer.artInputLength + 1; leftExtent++)
      if (artTriples[leftExtent] != null) for (int tokenNumber = 0; tokenNumber < artLexer.artTokenMax; tokenNumber++)
        if (artTriples[leftExtent][tokenNumber] != null) pairCardinality++;

    // Construct sparse map from pairs to integers and store pairs in pairs buffer; create InputSuccessorIndex as we go
    artInputPairBuffer = new int[pairCardinality * 2];
    artInputPairIndex = new int[artLexer.artInputLength + 1][];
    artInputFirstPairAtLeftExtent = new int[artLexer.artInputLength + 1];
    artInputSuccessorIndex = new int[artLexer.artInputLength + 1][];
    pairCardinality = 0;
    for (int leftExtent = 0; leftExtent < artLexer.artInputLength + 1; leftExtent++) {
      if (artTriples[leftExtent] == null) continue;
      artInputPairIndex[leftExtent] = new int[artLexer.artTokenMax];
      artInputSuccessorIndex[leftExtent] = new int[artLexer.artTokenMax];
      artInputFirstPairAtLeftExtent[leftExtent] = pairCardinality; // This index is used by classical GLL to fetch tokens from the input pair buffer
      for (int tokenNumber = 0; tokenNumber < artLexer.artTokenMax; tokenNumber++) {
        if (artTriples[leftExtent][tokenNumber] == null) continue; // There are no instances of this token leaving this position
        artInputPairIndex[leftExtent][tokenNumber] = pairCardinality;
        artInputPairBuffer[pairCardinality++] = tokenNumber;
        artInputPairBuffer[pairCardinality++] = leftExtent;
        if (ARTLEXTRACEMGLL) System.out.printf("Loaded pair (%s,%d) to inputPairBuffer[%d]\n", artLabelStrings[tokenNumber], leftExtent,
            artInputPairIndex[leftExtent][tokenNumber]);
      }
    }

    // Enumerate successorBuffer
    int successorBufferCardinality = 0;
    if (artTriples[0] != null) for (int tokenNumber = 0; tokenNumber < artLexer.artTokenMax; tokenNumber++)
      if (artTriples[0][tokenNumber] != null) {
        if (ARTLEXTRACEMGLL) System.out.printf("Initial pair search found token %s\n", artLabelStrings[tokenNumber]);
        successorBufferCardinality++;
      }

    successorBufferCardinality++; // leave a space for the terminating -1

    if (ARTLEXTRACEMGLL) System.out.printf("Initial pair cardinality: %d\n", successorBufferCardinality);

    // Now add in the cardinalities of the successor blocks
    for (int leftExtent = 0; leftExtent < artLexer.artInputLength + 1; leftExtent++) {
      if (artTriples[leftExtent] == null) continue; // There are no tokens leaving this leftExtent position

      for (int tokenNumber = 0; tokenNumber < artLexer.artTokenMax; tokenNumber++) {
        if (artTriples[leftExtent][tokenNumber] == null) continue; // There are no instances of this token leaving this leftExtent position

        if (ARTLEXTRACEMGLL) System.out.printf("Counting successors for pair(%s, %d)\n", artLabelStrings[tokenNumber], leftExtent);
        successorBufferCardinality++; // leave a space for the terminating -1

        for (ARTRightExtentNode tmp = artTriples[leftExtent][tokenNumber]; tmp != null; tmp = tmp.next) {
          int rightExtent = tmp.rightExtent;

          if (ARTLEXTRACEMGLL) System.out.printf("Pair(%s, %d) has rightExtent %d\n", artLabelStrings[tokenNumber], leftExtent, rightExtent);

          // Now scan destination state for all of its tokens
          if (artTriples[rightExtent] != null) // There may be no out edges at all; certain for the last state
            for (int successorTokenNumber = 0; successorTokenNumber < artLexer.artTokenMax; successorTokenNumber++) {
              if (artTriples[rightExtent][successorTokenNumber] == null) continue;
              successorBufferCardinality++;
              if (ARTLEXTRACEMGLL) System.out.printf("Pair(%s, %d) has successor (%s, %d)\n", artLabelStrings[tokenNumber], leftExtent,
                  artLabelStrings[successorTokenNumber], rightExtent);
            }
        }
      }
    }

    if (ARTLEXTRACEMGLL) System.out.printf("Successor buffer cardinality: %d\n", successorBufferCardinality);

    // Allocate successor buffer
    artInputSuccessorBuffer = new int[successorBufferCardinality];

    // Load successorBuffer with initial pairs
    successorBufferCardinality = 0;
    if (artTriples[0] != null) for (int tokenNumber = 0; tokenNumber < artLexer.artTokenMax; tokenNumber++)
      if (artTriples[0][tokenNumber] != null) artInputSuccessorBuffer[successorBufferCardinality++] = artInputPairIndex[0][tokenNumber];

    artInputSuccessorBuffer[successorBufferCardinality++] = -1; // Terminate initial block

    // Load successorBuffer with successor blocks, indexing as we go
    for (int leftExtent = 0; leftExtent < artLexer.artInputLength + 1; leftExtent++) {
      if (artTriples[leftExtent] == null) continue; // There are no tokens leaving this leftExtent position

      for (int tokenNumber = 0; tokenNumber < artLexer.artTokenMax; tokenNumber++) {
        if (artTriples[leftExtent][tokenNumber] == null) continue; // There are no instances of this token leaving this leftExtent position

        artInputSuccessorIndex[leftExtent][tokenNumber] = successorBufferCardinality;

        if (ARTLEXTRACEMGLL) System.out.printf("Loading successors for pair(%s, %d) to successorBufferlocation \n", artLabelStrings[tokenNumber], leftExtent);

        for (ARTRightExtentNode tmp = artTriples[leftExtent][tokenNumber]; tmp != null; tmp = tmp.next) {
          int rightExtent = tmp.rightExtent;

          // Now scan destination state for all of its tokens
          if (artTriples[rightExtent] != null) // There may be no out edges at all; certain for the last state
            for (int successorTokenNumber = 0; successorTokenNumber < artLexer.artTokenMax; successorTokenNumber++) {
              if (artTriples[rightExtent][successorTokenNumber] == null) continue;
              artInputSuccessorBuffer[successorBufferCardinality++] = artInputPairIndex[rightExtent][successorTokenNumber];

              if (ARTLEXTRACEMGLL) System.out.printf("Loaded pair(%s, %d) successor (%s, %d) to InputSuccessorBuffer[%d]\n", artLabelStrings[tokenNumber],
                  leftExtent, artLabelStrings[successorTokenNumber], rightExtent, successorBufferCardinality - 1);
            }
        }
        artInputSuccessorBuffer[successorBufferCardinality++] = -1; // Terminate initial block
      }
    }

    // Dump successorBuffer
    if (ARTLEXTRACEMGLL) {
      for (int i = 0; artInputSuccessorBuffer[i] != -1; i++)
        System.out.printf("Initial pair [%d](%s, %d)\n", i, artLabelStrings[artInputPairBuffer[artInputSuccessorBuffer[i]]],
            artInputPairBuffer[artInputSuccessorBuffer[i] + 1]);

      for (int leftExtent = 0; leftExtent < artLexer.artInputLength + 1; leftExtent++) {
        if (artInputSuccessorIndex[leftExtent] == null) continue; // There are no tokens leaving this leftExtent position

        for (int tokenNumber = 0; tokenNumber < artLexer.artTokenMax; tokenNumber++) {
          if (artInputSuccessorIndex[leftExtent][tokenNumber] == 0) continue; // There are no instances of this token leaving this leftExtent position
          for (int i = artInputSuccessorIndex[leftExtent][tokenNumber]; artInputSuccessorBuffer[i] != -1; i++)
            System.out.printf("Pair (%s, %d) has successor %d:(%s, %d)\n", artLabelStrings[tokenNumber], leftExtent, i,
                artLabelStrings[artInputPairBuffer[artInputSuccessorBuffer[i]]], artInputPairBuffer[artInputSuccessorBuffer[i] + 1]);
        }
      }
    }
  }

  public void artLexDump(String string) {// dump pair buffer
    if (artInputPairBuffer == null) return;
    for (int i = 0; i < artInputPairBuffer.length - 2; i += 2)
      System.out.printf("%d: %d %s %s\n", i, artInputPairBuffer[i + 1], artLabelStrings[artInputPairBuffer[i]],
          artLexer.artInputString.substring(artInputPairBuffer[i + 1], artInputPairBuffer[i + 3]).trim());
  }

  // This is the lexer interface used by classicial GLL
  public void artLexicaliseUsingLongestMatch(String stringInput) throws ARTException {
    artLexer.artInputString = stringInput + "\0";
    artLexer.artLoadInputArray(stringInput);
    artLexer.artInputLength = artLexer.artInputString.length();
    artLexer.artTokenMax = ARTGLLParserBase.ARTL_EPSILON;
    // artLexBuildTriplesFromTWESet();
    // System.out.println("Triples from the new lexer");
    // artPrintTriples();
    artTriples = null;
    artLexBuildTriplesFromSimpleStringUsingLongestMatch();
    // System.out.println("Triples from the old lexer");
    artLexBuildSuccessorSets();
    // artLexDump("lexical dump");
  }

}
