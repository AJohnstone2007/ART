\documentclass[11pt]{article}
\usepackage{boxedminipage}
\usepackage{rhulcase}
\usepackage{upquote}
\parskip 2ex
\newcommand{\lc}{{\rm L\kern-2.5pt C}}
\newenvironment{codebox}{\par\noindent\scriptsize\begin{boxedminipage}[t]{\textwidth}\vspace*{1ex}\par}{\end{boxedminipage}\par\vspace*{1ex}\par\noindent}
\newcommand{\art}{{\rm A\kern -2pt R\kern -2,2pt T}}
\newenvironment{smallcodebox}{\footnotesize\begin{boxedminipage}[t]{6cm}\vspace*{1ex}\par}{\end{boxedminipage}}
\newenvironment{smallercodebox}{\footnotesize\begin{boxedminipage}[t]{5cm}\vspace*{1ex}\par}{\end{boxedminipage}}
\begin{document}

\section{Introduction}
\art\ (Ambiguity Resolved Translation) is a tool for writing translators
based on general Context Free Grammars (CFG). This tutorial and mini-manual is
intended for \art\ $\alpha$-testers.

An \art\ text comprises one or more modules which together specify a CFG
written in an extended Backus Naur Form (EBNF). If the grammar is
valid, \art\ will write out C++ source code for a GLL-style parser for
that grammar. This generated parser must be compiled and linked to a
set of support classes if it is to be executed. {\em Older versions of \art\
have generated Java parsers and Java will be supported again in a
near-future version. It is a few days work to add a new output
language to \art.}

The \art\ syntax also provides: (i) disambiguation annotations to allow
a preferred derivation to be selected, (ii) Tear-Insert-Fold
operations which specify rewrites on the selected derivation tree, and
(iii) inline semantic actions written in the \lc\ language which may be
executed as a side effect of a single top-down, left-to-right
traversal of a derivation tree.

A variety of diagnostic and documentation output files are optionally
created during a run of the \art\ tool; tree and graph outputs may be
visualised using the VCG and AiSEE tools.

\section{ART features}
ART rules are written in an EBNF, the full syntax of which is described in
Section~\ref{rules} below.

Rules may be grouped into modules which have associated {\em import
  expressions} by which rules in other modules may be referenced or
cloned. Each module may also have a start nonterminal and a whitespace
convention. The first module encountered in an ART specification is
the {\em main} module; its start nonterminal is taken to be the start
nonterminal for the generated parser, and unreachable productions are
deleted. The rules by which grammars are constructed from modular
fragments are described in Section~\ref{modularity} below.

Closure operations may be rewritten using new left- or right-recursive
nonterminals. Rules may also be optionally rewritten by {\em
  multiplying out} in which expressions of the form
\verb+X ::= a (b | c) d+ are expanded to
\verb+X ::= a b d | a c d+. Taken together, closure rewriting and
multiplying out provide conversion of EBNF grammars to BNF grammar.

Rules may also be optionally internally rewritten by {\em syntactic
  left factoring} in which rules of the \verb+X ::= a b d | a c d+ are
factorised to \verb+X ::= a ( b d | c d)+. GLL parsers often run
faster with left factored rules. Parser generated by ART using this
transformation still produce derivations in the original grammar,
though the parse forests produced during parsing use the factorised
grammar. {\em The current version of ART produces a derivation in the
  factorised grammar.}

ART produces a {\em Grammar Dependency Graph} (GDG) and a {\em Module
  Dependency graph} (MDG) that may be rendered using the VCG tool to
display dependencies. {\em Module Dependency Graphs are not currently
  implemented}.

ART parsers construct parse {\em forests} which represent the
(potentially infinite) set of derivation trees. In practice,
applications usually desire a single derivation tree. Disambiguation
annotations in the ART specification allow the user to specify which
derivation to select. {\em At present, no disambiguation operators may
  be used; ART generated parsers select an implementation dependent
  tree.}

ART rules may be annotated with {\em Tear-Insert-Fold} operators which
specify local transformations of the disambiguated derivation
tree. The syntax and semantics of TIF operations is described in
Section~\ref{TIF} below. Parsers for TIF annotated grammars can
produce much more compact output trees, suitable for use as abstract
syntax or compiler intermediate forms.  {\em TIF annotations are
  presently stored in the generated parser, but nothing
  further is done with them.}

A grammar describing the trees produced by the TIF-modified parser,
the so-called {\em TIF Transformed Grammar} (TTG) is output with the
generated parser. In effect, strings in the language if the unmodified
grammar are parsed, but derivation trees in the TTG are produced. The
effect of TIF annotation on the TTG are described in Section~\ref{TIF}
below.  {\em TTG's are not presently output}

ART specifications may contain inline semantic actions. {\em Semantic
  actions are presently stored in the generated parser, but nothing
  further is done with them.}

A future version of ART may support simple context-free tree rewriting
based on equational specifications.


\section{A first tutorial}
In this section, we shall build and run a parser for a small grammar.

\paragraph{Step 1}
To use \art, you need the following files:
\begin{itemize}
\item an \art\ executable: {\tt art.exe} on Windows,
\item {\tt artTest.cpp} the standard test harness, or your own application code,
\item {\tt artgllsupport.cpp} an implementation of the top level GLL support functions,
\item {\tt artgllstructures.cpp} a hash coded implementation of the data structures maintained by the support functions,
\item {\tt artgllbase.h},
\item {\tt artgllstructures.h}.
\end{itemize}

We shall assume that the executable resides with other system executables (i.e. in a directory that forms part of the operating system path) and that the other files are in the directory {\tt art/}

The current (V2.x) versions of \art\ are written in C++ and make use of
the RDP LL(1) parser generator and libraries. \art\ and RDP build
successfully on MacOS, Linux and Windows using GCC and Clang (the LLVM
C++ compiler), and should build cleanly under other C++
compilers. {\em Future versions will be written in Java and will be
independent of RDP.}


\paragraph{Step 2}
As a first example, create a file {\tt small.art} which contains the following productions:
\begin{quote}
\begin{verbatim}
S ::= 'a' X 'c' ;
X ::= 'b' X ;
X ::= # ;
\end{verbatim}
\end{quote}

This grammar matches strings of the form {\tt ac}, {\tt abc}, {\tt
  abbc}, \ldots. 
\paragraph{Step 3}
Create a file {\tt small.str} which contains
\begin{quote}
\begin{verbatim}
abbbc
\end{verbatim}
\end{quote}

\art\ BNF productions comprise a left-hand-side (LHS) nonterminal name,
the expands-to symbol {\tt ::=} and either the symbol for the empty
sequence \verb+#+ or a sequence of nonterminal names and terminals.
{\em In the current version of \art, each production must be terminated
  by a semicolon; this will be dropped in a future release.}

By default, the start symbol for the grammar is the first LHS
nonterminal encountered. Alternate productions for the same
nonterminal may be grouped using the {\tt |} operator: this grammar
matches the same language.

\begin{quote}
\begin{verbatim}
S ::= 'a' X 'c' ;
X ::= 'b' X | # ;
\end{verbatim}
\end{quote}

\paragraph{Step 4}
Generate the parser using a command of the form
\begin{quote}
\begin{verbatim}
art small.art
\end{verbatim}
\end{quote}

This will create the files \verb+artgllgenerated.cpp+ and
\verb+artgllgenerated.h+, and print the following onto the console
\begin{quote}
\begin{verbatim}
******: Warning - production for nonterminal 'S' found with no 
preceding header: creating default major name
******: 0 errors and 1 warning
\end{verbatim}
\end{quote}
The warning arises because we have omitted the module header which is
used to specify whitespace conventions, start symbols and imports. It
may be ignored at this stage.

\paragraph{Step 5}
The parser can be compiled and linked against the standard test harness using a command like:
\begin{quote}
\small
\hspace*{-3cm}
\verb!g++ -Iart ART\artTest.cpp artGLLGenerated.cpp ART\artGLLStructures.cpp \ART\artGLLSupport.cpp!
\end{quote}

\paragraph{Step 6}
Now run the compiled parser against the test string
\begin{quote}
\begin{verbatim}
arttest small.str
\end{verbatim}
\end{quote}
which generates this output:
\begin{quote}
\begin{verbatim}
accept, small.art,  staticGoToDespatch, ART__.S, small.str, 5, 0
\end{verbatim}
\end{quote}
The seven fields are: accept/reject, grammar source file name, build
options, start symbol name, string source file name, string length and
runtime in CPU seconds.
\paragraph{Step 7}
Change the test string file {\tt small.str} to contain
\begin{quote}
\begin{verbatim}
abbba
\end{verbatim}
\end{quote}
and run the parser again with \verb+arttest small.str+. The string is rejected:
\begin{quote}
\begin{verbatim}
0: 1   a
1: 2   b
2: 2   b
3: 2   b
4: 1   a
Reject: longest putative derivation consumed 4 tokens
reject, small.art,  staticGoToDespatch, ART__.S, small.str, 5, 0
\end{verbatim}
\end{quote}
The test harness prints out the test string, and the length of the
longest partial parse that was constructed\,---\, with many grammars
this will indicate the point at which the syntax error occurs.

\paragraph{Step 8}
Adding a module header will suppress the warning message when \art\
runs. The simplest header specifies a module name and a start
symbol. Modify {\tt small.art} by adding a header declaring a module
{\tt M} with start symbol {\tt S}:
\begin{quote}
\begin{verbatim}
M()(S)
S ::= 'a' X 'c' ;
X ::= 'b' X ;
X ::= # ;
\end{verbatim}
\end{quote}
and rebuild and rerun the parser.
\paragraph{Step 9}
\art generates extensive supplementary information when run with the
{\tt -v} command line option.
\begin{codebox}
\begin{verbatim}
Symbol table

   0: $                          END_OF_STRING
   1: 'a'                        CASE_SENSITIVE_TERMINAL
   2: 'b'                        CASE_SENSITIVE_TERMINAL
   3: 'c'                        CASE_SENSITIVE_TERMINAL
   4: #                          EPSILON
   5: M.S                        NONTERMINAL defined reachable
   6: M.X                        NONTERMINAL defined reachable
   7: M                          MAJOR defined whitespace import undefined

Grammar: start symbol M.S
M.S ::=
   'a' M.X 'c' ;

M.X ::=
   'b' M.X |
   # ;


Grammar has 2 active nonterminals, 3 productions, longest production has 3 elements

Productions per nonterminal histogram
1: 1 50.00
2: 1 50.00

Elements per production histogram
0: 1 33.33
2: 1 33.33
3: 1 33.33

Merged sets

1: 1
2: 2
3: 2, 3
4: 3
5: 0
\end{verbatim}
\end{codebox}

\paragraph{Step 10}
\art\ generated parsers will output more extensive statistical
information when compiled with {\tt STATISTICS} macro defined.

\begin{codebox}
\begin{verbatim}
accept, small.art, staticGoToDespatch, M.S, small.str, 5, 0,
tokens/second, 0, GSS nodes, 5, GSS edges, 4, Sum |Ui|, 10, max |Ui|, 5, 
SPPF nonPnodes, 12, SPPF Pnodes, 6, SPPF edges, 17, Pop elements, 4, 
testRepeat elements, 0, testRepeatCount, 0, findDescriptorCount, 10, 
popCount, 5, findGSSNodeCount, 5, findSPPFNodeECount, 1,
findSPPFNodeTCount, 5, findSPPFNodeCount, 10, findSPPFNodeSkipLoopCount, 0
\end{verbatim}
\end{codebox}

\paragraph{Step 11} 
\art generated parsers will output trace information
showing the construction of the GLL data structures when compiled with
{\tt TRACE} macro defined.

\begin{codebox}
\begin{verbatim}
Input length 5 characters: abbbc
Token string:
a
b
b
b
c
End of token string
findGSSNode---create() with empty stackTop - not found
findDescriptor---add(restartLabel = \art__DESPATCH, stackTop = (\art__$, 0),
 currentToken index = 0, derivationNode = (\art__DUMMY, 0, 0) - not found
findDescriptor---add(restartLabel = M__S_4, stackTop = (\art__$, 0),
 currentToken index = 0, derivationNode = (\art__DUMMY, 0, 0) - not found
Processing descriptor at level 0 (restartLabel = M__S_4, currentToken index 0,
 GSSnode (\art__$,0))
findSPPFNode---getNodeT(terminalLabel = 'a', currentToken Index = 0) - not found
findSPPFNode---getNode(label = M__S_6, leftChild = (\art__DUMMY, 0, 0),
 rightChild = (a, 0, 1) - returning rightChild from labelM__S_6
findGSSNode---create(stackTopLabel = M__S_8, stackTop = (\art__$, 0),
 currentToken index = 1) - not found
Adding GSS edge from (M__S_8, 1) to (\art__$, 0) labelled (a, 0, 1)
popElement iterator returns NULL
findDescriptor---add(restartLabel = M__X_13, stackTop = (M__S_8, 1),
 currentToken index = 1, derivationNode = (\art__DUMMY, 0, 0) - not found
Processing descriptor at level 1 (restartLabel = M__X_13, currentToken index 1,
 GSSnode (M__S_8,1))
findSPPFNode---getNodeT(terminalLabel = 'b', currentToken Index = 1) - not found

...


Processing descriptor at level 4 (restartLabel = M__S_8, currentToken index 4,
 GSSnode (\art__$,0))
findSPPFNode---getNodeT(terminalLabel = 'c', currentToken Index = 4) - not found
findSPPFNode---getNode(label = M__S_10, leftChild = (M__S_8, 0, 4),
 rightChild = (c, 4, 5) - not found
Adding pack node
pop(stackTop = (\art__$, 0) , currentToken index = 5,
 currentDerivationNode = (M__S_2, 0, 5))
Processing descriptor at level 0 (restartLabel = \art__DESPATCH,
 currentToken index 0, GSSnode (\art__$,0))
\end{verbatim}
\end{codebox}


\begin{codebox}
\begin{verbatim}
Hash table dump

GSS node (\art__$, 0)
GSS node (M__S_8, 1)
GSS node (M__X_17, 2)
GSS node (M__X_17, 3)
GSS node (M__X_17, 4)
SPPF node (a, 0, 1)
SPPF node (b, 1, 2)
SPPF node (b, 2, 3)
SPPF node (b, 3, 4)
SPPF node (c, 4, 5)
SPPF node (#, 4, 4)
SPPF node (M__S_2, 0, 5)
SPPF node (M__S_8, 0, 4)
SPPF node (M__X_11, 1, 4)
SPPF node (M__X_11, 2, 4)
SPPF node (M__X_11, 3, 4)
SPPF node (M__X_11, 4, 4)
Pack node (M__S_10, 4, M__S_8, c)
Pack node (M__S_8, 1, a, M__X_11)
Pack node (M__X_17, 2, b, M__X_11)
Pack node (M__X_17, 3, b, M__X_11)
Pack node (M__X_17, 4, b, M__X_11)
Pack node (M__X_19, 4, \art__DUMMY, #)
Pop element ( (M__S_8, 1) (M__X_11, 1, 4))
Pop element ( (M__X_17, 2) (M__X_11, 2, 4))
Pop element ( (M__X_17, 3) (M__X_11, 3, 4))
Pop element ( (M__X_17, 4) (M__X_11, 4, 4))
Descriptor (M__S_4, (\art__$, 0), a, (\art__DUMMY, 0, 0))
GSS edge from (M__S_8, 1) to (\art__$, 0) (a, 0, 1)
Descriptor (M__S_8, (\art__$, 0), c, (M__S_8, 0, 4))
GSS edge from (M__X_17, 2) to (M__S_8, 1) (b, 1, 2)
GSS edge from (M__X_17, 3) to (M__X_17, 2) (b, 2, 3)
GSS edge from (M__X_17, 4) to (M__X_17, 3) (b, 3, 4)
Descriptor (M__X_13, (M__S_8, 1), b, (\art__DUMMY, 0, 0))
Descriptor (M__X_13, (M__X_17, 2), b, (\art__DUMMY, 0, 0))
Descriptor (M__X_13, (M__X_17, 3), b, (\art__DUMMY, 0, 0))
Descriptor (M__X_17, (M__S_8, 1), c, (M__X_11, 1, 4))
Descriptor (M__X_17, (M__X_17, 2), c, (M__X_11, 2, 4))
Descriptor (M__X_17, (M__X_17, 3), c, (M__X_11, 3, 4))
Descriptor (M__X_19, (M__X_17, 4), c, (\art__DUMMY, 0, 0))
Descriptor (\art__DESPATCH, (\art__$, 0), a, (\art__DUMMY, 0, 0))
\end{verbatim}
\end{codebox}

\section{\art\ CFG rule syntax}
\label{rules}
\art grammars are written in a modularised extended BNF with
annotations to specify disambiguation, derivation tree rewriting using
the TIFF formalism and semantic actions. In this section we describe
the syntax of \art's EBNF.

\subsection{Nonterminals}


\subsection{Terminals}
\art\ provides three kinds of terminal symbol. A character-level
terminal is written as a back quote followed by a single printing
character or escape sequence: \verb+`a+ represents the letter {\tt a}
and \verb+`\n+ represents the newline character. The full complement
of ANSI-C style escape sequences may be used within terminals to
denote non-printing characters.

Normally, character level terminals are only used at lexical
level. Keywords are denoted by strings delimited by single quotes like
\verb+'this'+. In detail, a keyword \verb+'xyz'+ is shorthand for the
sequence \verb+`x `y `z WS+ where \verb+WS+ is a whitespace
nonterminal which by default matches zero or more space, tab or
newline characters.

Case-insensitive keywords are written \verb+"thus"+, which is a shorthand for \verb+(`t|`T)(`h|`H)(`u|`U)(`s|`S) WS+.
\subsection{Rules}
\section{Modularity}
\label{modularity}
\section{Disambiguation}
\label{disambiguation}
\section{TIF-based tree and grammar rewriting}
\label{TIF}
\section{Semantic actions}
\label{semantics}
\appendix
\section{An overview of \art\ V2 internals}
\art\ uses eleven phases to build the generated parsers and other
outputs. The general flow is that a {\em Rewritten Derivation Tree}
produced in phase zero by an RDP generated front end is further rewritten
in phases 1--4 to handle some defaults and some optional
optimisations. In phase 5 the modules are resolved into a single
context free grammar represented by an {\em Intermediate Form Tree}
(IFT). Phases 6 and 7 then compute various attributes into the IFT
(such as first and follow sets). Phase 8-10 then traverse the
decorated IFT outputting grammar and module dependency graphs,
a GLL parser and a TIF Transformed Grammar (TTG) respectively.

At the end of each tree rework phase a VCG file is output which may be
used with the VCG or AISee tools to visualise the trees.

\paragraph{Phase 0}
\art\ uses an RDP generated front end, the specification for which is
in source file {\tt artparse.bnf}, and the C source code for which is
in source file {\tt artparse.cpp}.  The front end checks the input
files for syntax errors and constructs a Rewritten Derivation Tree
(RDT) which it passes to function {\tt artPostParse()}, which is in source file {\tt artaux.cpp}.

\paragraph{Phase 1}
If no main module header has been specified by the user, a default
module header is created in the RDT, then the command line options are
checked for semantic validity. The main symbol table
{\tt symbols} which holds the grammar symbols and a subsidiary symbol
table {\tt mergedSets} which holds bit vector sets are created.

\noindent{\em Output file:} {\tt artrdtraw.vcg} showing the RDT as constructed by the RDP-generated front end.
\paragraph{Phase 2}
Various semantic checks and rewrites are performed on the raw RDT in
phase 2 to produce the `cooked' RDT: {\tt @} operators are eliminated;
postfix expressions {\tt x?}, {\tt x*} and {\tt x+} are rewritten to
{\tt (x)?}, {\tt (x)*} and {\tt (x)+} respectively; and each node is
given a {\em kind} value which specifies its type symbolically
(for instance LHS and RHS nonterminals receive different kinds).

Output file: {\tt artrdcooked.vcg} showing the RDT after phase 2 operations.

\paragraph{Phase 3}
The module resolution algorithm is used to induce a Context Free
Grammar from the modular specification, reconciling import expressions
and constructing a new tree called the {\em Intermediate Form Tree}
(IFT).

\noindent{\em Output file:} {\tt artinduced.vcg} showing the initial IFT before attribute computations.

\paragraph{Phase 6}
If the {\tt -m} (multiplyOut) option is set, phase 3 recursively
multiplies out top level parentheses and optionals: recursive in the sense that
\verb+x(a (b|c)| d)y+ will be rewritten to
\verb+x a b y | x a c y | x d y+ and top level in the sense that
parentheses within closures \verb+()*+ and \verb!()+! are not multiplied out.

\noindent{\em Output file:} {\tt artmultipliedout.vcg} showing the RDT after phase 3 operations.
\paragraph{Phase 7}
If the {\tt -l} (leftFactor) option is set, phase 4 syntactically left factors the grammar.

\noindent{\em Output file:} {\tt artleftfactorised.vcg} showing the RDT after phase 4 operations.

\paragraph{Phase 6}
Tear names within insertions are linked to named tears, that is a
production such as \verb+X :: = Y:tname^^^ 'x' [ %tname ] ;+ will
generate a link in the IFT from the \verb+%tname+ node to the
\verb+Y:tname^^^+ node.

\noindent{\em Output file:} {\tt arttearresolved.vcg} showing the IFT with tear links.

\paragraph{Phase 7}
The GLL attributes are computed into the tree, including slot attributes, first and follow sets and guard sets.

\noindent{\em Output file:} {\tt artift.vcg} showing the IFT after all
computations. This tree is the culmination of the ART middle-end
processing and the basis for the generated parsers. If you suspect an
internal error, this tree is the best place to start looking for
unexpected values.

\paragraph{Phase 8}
Output grammar and module dependency graphs.

\noindent{\em Output files:} {\tt artgdg.vcg} and {\tt artmdg.vcg} showing the grammar and module dependency graphs.


\paragraph{Phase 9}
Traverse the IFT and compose the output generated grammar.

\noindent{\em Output files:} {\tt artgllgenerated.cpp} and {\tt artgllgenerated.h}.

\paragraph{Phase 10}
Traverse the IFT and construct a new tree representing the TTG, the
grammar that describes the Rewritten Derivation Trees that will be
produced by the generated parser.

\noindent{\em Output file:} {\tt artttg.art} and {\tt artttg.vcg}.

\section{Using the ART V3 classes}

ART V3 is a reimplementation of ART V2 in Java. The initial feature set is essentially identical, and during the bootstrap phase the goal is to achieve identical outputs from V3 as from V2. ART V3 is intended to be used as an API: command line capability is provided by two small stub class which processes command line arguments and activate the main classes. {\tt ART.java} emulates the V2 command line interface, and {\tt ARTVisual.java} opens a simple graphical user interface which provides text editor and graph display windows suitable for testing small grammars.

\subsection{ART V3 package structure}

ART V3 specific classes are in package {\tt uk.ac.rhul.cs.csle.art}.

The classes which support ART-generated parsers at runtime are in package {\tt uk.ac.rhul.cs.csle.artgll}.

Some classes from packages {\tt uk.ac.rhul.cs.csle.arttext}, {\tt uk.ac.rhul.cs.csle.arthistogram}, {\tt uk.ac.rhul.cs.csle.artgraph} and {\tt uk.ac.rhul.cs.csle.artgraphics} are used in various helper r\^oles.

\subsection{ART V3 architecture}
The architecture of ART V3 is as follows. The user application (or one of the stub classes {\tt ART} or {\tt ARTVisual} creates an instance of {\tt ARTManager}. An {\tt ARTManager} contains a parser for the V3 ART specification grammar, and maintains a set of named modules and grammars. 

Modules, represented  are created by parsing ART specifications and comprise named collections of attributed grammar rules, directives and equations from which grammars may be induced along with import and renaming rules. 


\section{\art\ feature summary}

\paragraph{Command line arguments and options}
\verb+-g<s>+ generated language: one of C++ Java ALL (default C++)\\
\verb+-o<s>+ output directory (default .)\\
\verb+-d<s>+ despatch mode: one of State StaticGoto DynamicGoto (default StaticGoto)\\
\verb+-m+    multiply out EBNF brackets () and ()?\\
\verb+-l+    left factor BNF\\
\verb+-p+    suppress follow check on pop action\\
\verb+-t+    suppress calls to testRepeat() except for closures\\
\verb+-v+    output verbose diagnostic information

\paragraph{\art\ source build options}
\verb+FACTORISE_TRACE+\\
\verb+INDUCE_TRACE+

\paragraph{Module syntax}
\verb+<-+ import-by-reference\\
\verb+<=+ import-by-clone\\
\verb+<-*+ recursive import-by-reference\\
\verb+<=* recursive import-by-clone+

\paragraph{Rule syntax}
\verb+X+ nonterminal\\
\verb+::=+ expands to\\
\verb+`x+ character terminal\\
\verb+'x'+ case sensitive terminal\\
\verb+"x"+ case insensitive terminal\\
\verb+#+ empty string\\
\verb+|+ alternate production\\
\verb+@+ iterate\\
\verb+/+ set difference\\
\verb!( )+! positive closure\\
\verb+( )*+ Kleene closure\\
\verb+( )?+ optional\\
\verb+( )+ parentheses

\paragraph{Disambiguation operators}
\paragraph{TIF operators}
\verb+^_+ no fold\\
\verb+^+ fold under\\
\verb+^^+ fold over\\
%\verb+^^^+ tear\\
\verb+[ ]+ insertion\\
\verb+:name+ name grammar atom\\
\verb+%name+ insert torn node

\paragraph{Semantic actions}
\verb+{  }+

\paragraph{Output files}
\verb+artgdg.vcg+\\
\verb+artift.vcg+\\
\verb+artinduced.vcg+\\
\verb+artleftfactorised.vcg+\\
\verb+artmultipliedout.vcg+\\
\verb+artrdtcooked.vcg+\\
\verb+artrdtraw.vcg+\\
\verb+arttearresolved.vcg+\\
\verb+art_d.vcg+\\
\verb+art_p.vcg+\\
\verb+art_z.vcg+\\
\verb+gllgss.vcg+\\
\verb+gllsppf.vcg+


\end{document}
