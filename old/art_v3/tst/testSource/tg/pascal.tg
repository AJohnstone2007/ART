iso_pascal_7185_treeview
$
program ::= program_heading ';' program_block '.' ; 

// Generated by gramex V3.0 from 'iso_pascal_7185.raw' (this build Jun  8 2012 at 15:37:41)
// Command line: C:\csle\dev\gramex\gramex.exe -p -c iso_pascal_7185.raw


(*6.7.3*)     actual_parameter ::= expression | variable_access | procedure_identifier 
                               | function_identifier ; 

(*6.7.3*)     actual_parameter_list ::= '(' actual_parameter ( ',' actual_parameter)* ')' ; 

(*6.7.2.1*)   adding_operator ::= '+' | '-'      | 'or' ; 

(*6.1.7*)     apostrophe_image ::= '"'  ; 

(*6.4.3.2*)   array_type ::= 'array' '[' index_type ( ',' index_type)* ']' 'of' component_type ; 

(*6.5.3.2*)   array_variable ::= variable_access ; 

(*6.8.2.2*)   assignment_statement ::= ( variable_access | function_identifier ) ':=' expression ; 

(*6.4.3.4*)   base_type ::= ordinal_type ; 

(*6.2.1*)     block ::= label_declaration_part constant_definition_part type_definition_part 
                      variable_declaration_part procedure_and_function_declaration_part 
                      statement_part ; 

(*6.7.2.3*)   Boolean_expression ::= expression ; 

(*6.6.3.7.1*) bound_identifier ::= identifier ; 

(*6.5.5*)     buffer_variable ::= file_variable '^'  ; 

(*6.4.3.3*)   case_constant ::= constant ; 

(*6.4.3.3*)   case_constant_list ::= case_constant ( ',' case_constant)* ; 

(*6.8.3.5*)   case_index ::= expression ; 

(*6.8.3.5*)   case_list_element ::= case_constant_list ':' statement ; 

(*6.8.3.5*)   case_statement ::= 'case' case_index 'of' case_list_element 
                               ( ';' case_list_element)* ( ';')? 'end' ; 

(*6.1.7*)     character_string ::= 'STRING' ; (* '\'' string_element ( string_element)*'\'' ; *)

(*6.4.3.2*)   component_type ::= type_denoter ; 

(*6.5.3.1*)   component_variable ::= indexed_variable | field_designator ; 

(*6.8.3.2*)   compound_statement ::= 'begin' statement_sequence 'end' ; 

(*6.8.3.3*)   conditional_statement ::= if_statement | case_statement ; 

(*6.6.3.7.1*) conformant_array_parameter_specification ::= value_conformant_array_specification 
                                                       | variable_conformant_array_specification ; 

(*6.6.3.7.1*) conformant_array_schema ::= packed_conformant_array_schema 
                                      | unpacked_conformant_array_schema ; 

(*6.3*)       constant ::= ( sign)? ( unsigned_number | constant_identifier ) 
                       | character_string ; 

(*6.3*)       constant_definition ::= identifier '=' constant ; 

(*6.2.1*)     constant_definition_part ::= ( 'const' constant_definition ';' ( constant_definition ';')*)? ; 

(*6.3*)       constant_identifier ::= 'constant_ID' ; (* identifier ; *)

(*6.8.3.9*)   control_variable ::= entire_variable ; 

(*6.1.1*)     digit ::= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' ; 

(*6.1.5*)     digit_sequence ::= digit ( digit)* ; 

(*6.1.4*)     directive ::= 'ID' ; 

(*6.4.4*)     domain_type ::= type_identifier ; 

(*6.8.3.4*)   else_part ::= 'else' statement ; 

(*6.8.2.1*)   (* empty_statement ::= #; *)

(*6.5.2*)     entire_variable ::= variable_identifier ; 

(*6.4.2.3*)   enumerated_type ::= '(' identifier_list ')' ; 

(*6.7.1*)     expression ::= simple_expression ( relational_operator simple_expression)? ; 

(*6.6.3.7.1*) (*factor > bound_identifier ; *)

(*6.7.1*)     factor (*>*) ::= variable_access | unsigned_constant | function_designator 
                     | set_constructor | '(' expression ')' | 'not' factor ; 

(*6.5.3.3*)   field_designator ::= record_variable '.' field_specifier | field_designator_identifier ; 

(*6.8.3.10*)  field_designator_identifier ::= identifier ; 

(*6.5.3.3*)   field_identifier ::= 'field_ID' ; 

(*6.4.3.3*)   field_list ::= ( ( fixed_part ( ';' variant_part)? | variant_part ) ( ';')?)? ; 

(*6.5.3.3*)   field_specifier ::= field_identifier ; 

(*6.4.3.5*)   file_type ::= 'file' 'of' component_type ; 

(*6.5.5*)     file_variable ::= variable_access ; 

(*6.8.3.9*)   final_value ::= expression ; 

(*6.4.3.3*)   fixed_part ::= record_section ( ';' record_section)* ; 

(*6.8.3.9*)   for_statement ::= 'for' control_variable ':=' initial_value ( 'to' | 'downto' ) final_value 
                              'do' statement ; 

(*6.6.3.1*)   formal_parameter_list ::= '(' formal_parameter_section ( ';' formal_parameter_section)* ')' ; 

(*6.6.3.1*)   formal_parameter_section (*>*) ::= value_parameter_specification 
                                       | variable_parameter_specification 
                                       | procedural_parameter_specification 
                                       | functional_parameter_specification ; 

(*6.6.3.7.1*) (*formal_parameter_section > conformant_array_parameter_specification ; *)

(*6.1.5*)     fractional_part ::= digit_sequence ; 

(*6.6.2*)     function_block ::= block ; 

(*6.6.2*)     function_declaration ::= function_heading ';' directive 
                                   | function_identification ';' function_block 
                                   | function_heading ';' function_block ; 

(*6.7.3*)     function_designator ::= function_identifier ( actual_parameter_list)? ; 

(*6.6.2*)     function_heading ::= 'function' identifier ( formal_parameter_list)? ':' result_type ; 

(*6.6.2*)     function_identification ::= 'function' function_identifier ; 

(*6.6.2*)     function_identifier ::= 'function_ID' ;(* identifier ; *)

(*6.6.3.1*)   functional_parameter_specification ::= function_heading ; 

(*6.8.2.4*)   goto_statement ::= 'goto' label ; 

(*6.5.4*)     identified_variable ::= pointer_variable '^'  ; 

(*6.1.3*)     identifier ::= 'ID' ;(* letter ( letter | digit)* ;*) 

(*6.4.2.3*)   identifier_list ::= identifier ( ',' identifier)* ; 

(*6.8.3.4*)   if_statement ::= 'if' Boolean_expression 'then' statement ( else_part)? ; 

(*6.5.3.2*)   index_expression ::= expression ; 

(*6.4.3.2*)   index_type ::= ordinal_type ; 

(*6.6.3.7.1*) index_type_specification ::= identifier '..' identifier ':' ordinal_type_identifier ; 

(*6.5.3.2*)   indexed_variable ::= array_variable '[' index_expression ( ',' index_expression)* ']' ; 

(*6.8.3.9*)   initial_value ::= expression ; 

(*6.1.6*)     label ::= digit_sequence ; 

(*6.2.1*)     label_declaration_part ::= ( 'label' label ( ',' label)* ';')? ; 

(*6.1.1*)     letter ::= 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' 
                     | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' 
                     | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' ; 

(*6.7.1*)     member_designator ::= expression ( '..' expression)? ; 

(*6.7.2.1*)   multiplying_operator ::= '*' | '/' | 'div' | 'mod' | 'and' ; 

(*6.4.2.1*)   new_ordinal_type ::= enumerated_type | subrange_type ; 

(*6.4.4*)     new_pointer_type ::= '^'  domain_type ; 

(*6.4.3.1*)   new_structured_type ::= ( 'packed')? unpacked_structured_type ; 

(*6.4.1*)     new_type ::= new_ordinal_type | new_structured_type | new_pointer_type ; 

(*6.4.2.1*)   ordinal_type ::= new_ordinal_type | ordinal_type_identifier ; 

(*6.4.2.1*)   ordinal_type_identifier ::= type_identifier ; 

(*6.6.3.7.1*) packed_conformant_array_schema ::= 'packed' 'array' '[' index_type_specification ']' 
                                               'of' type_identifier ; 

(*6.4.4*)     pointer_type ::= new_pointer_type | pointer_type_identifier ; 

(*6.4.1*)     pointer_type_identifier ::= type_identifier ; 

(*6.5.4*)     pointer_variable ::= variable_access ; 

(*6.6.3.1*)   procedural_parameter_specification ::= procedure_heading ; 

(*6.2.1*)     procedure_and_function_declaration_part ::= ( ( procedure_declaration 
                                                      | function_declaration ) ';')* ; 

(*6.6.1*)     procedure_block ::= block ; 

(*6.6.1*)     procedure_declaration ::= procedure_heading ';' directive 
                                    | procedure_identification ';' procedure_block 
                                    | procedure_heading ';' procedure_block ; 

(*6.6.1*)     procedure_heading ::= 'procedure' identifier ( formal_parameter_list)? ; 

(*6.6.1*)     procedure_identification ::= 'procedure' procedure_identifier ; 

(*6.6.1*)     procedure_identifier ::= 'procedure_ID' | 'write' | 'writeln' | 'read' | 'readln' ;(* identifier ; *)

(*6.8.2.3*)   procedure_statement ::= procedure_identifier ( ( actual_parameter_list)? 
                                  | read_parameter_list | readln_parameter_list 
                                  | write_parameter_list | writeln_parameter_list ) ; 

(*6.10*)     // program ::= program_heading ';' program_block '.' ; 

(*6.10*)      program_block ::= block ; 

(*6.10*)      program_heading ::= 'program' identifier ( '(' program_parameter_list ')')? ; 

(*6.10*)      program_parameter_list ::= identifier_list ; 

(*6.9.1*)     read_parameter_list ::= '(' ( file_variable ',')? variable_access ( ',' variable_access)* ')' ; 

(*6.9.2*)     readln_parameter_list ::= ( '(' ( file_variable | variable_access ) 
                                      ( ',' variable_access)* ')')? ; 

(*6.4.2.1*)   real_type_identifier ::= type_identifier ; 

(*6.4.3.3*)   record_section ::= identifier_list ':' type_denoter ; 

(*6.4.3.3*)   record_type ::= 'record' field_list 'end' ; 

(*6.5.3.3*)   record_variable ::= variable_access ; 

(*6.8.3.10*)  record_variable_list ::= record_variable ( ',' record_variable)* ; 

(*6.7.2.1*)   relational_operator ::= '=' | '<>' | '<' | '>' | '<=' | '>=' | 'in' ; 

(*6.8.3.7*)   repeat_statement ::= 'repeat' statement_sequence 'until' Boolean_expression ; 

(*6.8.3.6*)   repetitive_statement ::= repeat_statement | while_statement | for_statement ; 

(*6.6.2*)     result_type ::= simple_type_identifier | pointer_type_identifier ; 

(*6.1.5*)     scale_factor ::= ( sign)? digit_sequence ; 

(*6.7.1*)     set_constructor ::= '[' ( member_designator ( ',' member_designator)*)? ']' ; 

(*6.4.3.4*)   set_type ::= 'set' 'of' base_type ; 

(*6.1.5*)     sign ::= '+' | '-'      ; 

(*6.1.5*)     signed_integer ::= ( sign)? unsigned_integer ; 

(*6.1.5*)     signed_number ::= signed_integer | signed_real ; 

(*6.1.5*)     signed_real ::= ( sign)? unsigned_real ; 

(*6.7.1*)     simple_expression ::= ( sign)? term ( adding_operator term)* ; 

(*6.8.2.1*)   simple_statement ::= (* empty_statement *) # | assignment_statement 
                               | procedure_statement | goto_statement ; 

(*6.4.2.1*)   simple_type ::= ordinal_type | real_type_identifier ; 

(*6.4.1*)     simple_type_identifier ::= type_identifier ; 

(*6.1.2*)     special_symbol ::= '+' | '-'      | '*' | '/' | '=' | '<' | '>' | '[' | ']' 
                             | '.' | ',' | ':' | ';' | '^'  | '(' | ')' 
                             | '<>' | '<=' | '>=' | ':=' | '..' | word_symbol ; 

(*6.8.1*)     statement ::= ( label ':')? ( simple_statement | structured_statement ) ; 

(*6.2.1*)     statement_part ::= compound_statement ; 

(*6.8.3.1*)   statement_sequence ::= statement ( ';' statement)* ; 

(*6.1.7*)     (*string_character ::= one_of_a_set_of_implementation_defined_characters ; *)

(*6.1.7*)     (* string_element ::= apostrophe_image | string_character ; *)

(*6.8.3.1*)   structured_statement ::= compound_statement | conditional_statement 
                                   | repetitive_statement | with_statement ; 

(*6.4.3.1*)   structured_type ::= new_structured_type | structured_type_identifier ; 

(*6.4.1*)     structured_type_identifier ::= type_identifier ; 

(*6.4.2.4*)   subrange_type ::= constant '..' constant ; 

(*6.4.3.3*)   tag_field ::= identifier ; 

(*6.4.3.3*)   tag_type ::= ordinal_type_identifier ; 

(*6.7.1*)     term ::= factor ( multiplying_operator factor)* ; 

(*6.4.1*)     type_definition ::= identifier '=' type_denoter ; 

(*6.2.1*)     type_definition_part ::= ( 'type' type_definition ';' ( type_definition ';')*)? ; 

(*6.4.1*)     type_denoter ::= type_identifier | new_type ; 

(*6.4.1*)     type_identifier ::= 'type_ID' ; (*identifier ;*) 

(*6.6.3.7.1*) unpacked_conformant_array_schema ::= 
                   'array' '[' index_type_specification ( ';' index_type_specification)* ']' 
                   'of' ( type_identifier | conformant_array_schema ) ; 

(*6.4.3.1*)   unpacked_structured_type ::= array_type | record_type | set_type | file_type ; 

(*6.7.1*)     unsigned_constant ::= unsigned_number | character_string | constant_identifier | 'nil' ; 

(*6.1.5*)     unsigned_integer ::= 'INTEGER' (* digit_sequence *) ; 

(*6.1.5*)     unsigned_number ::= unsigned_integer | unsigned_real ; 

(*6.1.5*)     unsigned_real ::= 'REAL' ; (* digit_sequence '.' fractional_part ( 'e' scale_factor)? 
                            | digit_sequence 'e' scale_factor ; *)

(*6.6.3.7.1*) value_conformant_array_specification ::= identifier_list ':' conformant_array_schema ; 

(*6.6.3.1*)   value_parameter_specification ::= identifier_list ':' type_identifier ; 

(*6.5.1*)     variable_access ::= entire_variable | component_variable | identified_variable 
                              | buffer_variable ; 

(*6.6.3.7.1*) variable_conformant_array_specification ::= 'var' identifier_list ':' conformant_array_schema ; 

(*6.5.1*)     variable_declaration ::= identifier_list ':' type_denoter ; 

(*6.2.1*)     variable_declaration_part ::= ( 'var' variable_declaration ';' ( variable_declaration ';')*)? ; 

(*6.5.2*)     variable_identifier ::= 'variable_ID' ; (* identifier ; *)

(*6.6.3.1*)   variable_parameter_specification ::= 'var' identifier_list ':' type_identifier ; 

(*6.4.3.3*)   variant ::= case_constant_list ':' '(' field_list ')' ; 

(*6.4.3.3*)   variant_part ::= 'case' variant_selector 'of' variant ( ';' variant)* ; 

(*6.4.3.3*)   variant_selector ::= ( tag_field ':')? tag_type ; 

(*6.8.3.8*)   while_statement ::= 'while' Boolean_expression 'do' statement ; 

(*6.8.3.10*)  with_statement ::= 'with' record_variable_list 'do' statement ; 

(*6.1.2*)     word_symbol ::= 'and' | 'array' | 'begin' | 'case' | 'const' | 'div' 
                          | 'do' | 'downto' | 'else' | 'end' | 'file' | 'for' 
                          | 'function' | 'goto' | 'if' | 'in' | 'label' | 'mod' 
                          | 'nil' | 'not' | 'of' | 'or' | 'packed' | 'procedure' 
                          | 'program' | 'record' | 'repeat' | 'set' | 'then' 
                          | 'to' | 'type' | 'until' | 'var' | 'while' | 'with' ; 

(*6.9.3*)     write_parameter ::= expression ( ':' expression ( ':' expression)?)? ; 

(*6.9.3*)     write_parameter_list ::= '(' ( file_variable ',')? write_parameter 
                                     ( ',' write_parameter)* ')' ; 

(*6.9.4*)     writeln_parameter_list ::= ( '(' ( file_variable | write_parameter ) 
                                       ( ',' write_parameter)* ')')? ; 
$
accept
$program ID ( ID , ID ) ; 
const ID = INTEGER ; 
ID = INTEGER ; 
ID = INTEGER ; 
ID = INTEGER ; 
type ID = INTEGER .. constant_ID ; 
ID = ( ID , ID , ID ) ; 
ID = array [ INTEGER .. INTEGER ] of type_ID ; 
ID = INTEGER .. constant_ID ; 
ID = ( ID , ID , ID , ID ) ; 
ID = record 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
end ; 
ID = INTEGER .. constant_ID ; 
ID = ( ID , ID , ID , ID ) ; 
ID = INTEGER .. constant_ID ; 
ID = ^ type_ID ; 
ID = ^ type_ID ; 
ID = ^ type_ID ; 
ID = record 
ID : type_ID ; 
ID : type_ID ; 
end ; 
ID = record 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
end ; 
ID = record 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
end ; 
ID = ^ type_ID ; 
ID = record 
ID : type_ID ; 
ID : type_ID ; 
end ; 
ID = ^ type_ID ; 
ID = record 
ID : type_ID ; 
ID : type_ID ; 
end ; 
ID = type_ID ; 
ID = ^ type_ID ; 
ID = ^ type_ID ; 
var ID : array [ INTEGER .. constant_ID ] of type_ID ; 
ID : type_ID ; 
ID : array [ INTEGER .. constant_ID ] of type_ID ; 
ID : type_ID ; 
ID : array [ INTEGER .. constant_ID ] of type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : array [ INTEGER .. constant_ID ] of type_ID ; 
ID : array [ INTEGER .. constant_ID ] of type_ID ; 
ID : array [ INTEGER .. constant_ID ] of type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : array [ INTEGER .. constant_ID ] of type_ID ; 
function ID ( 
var ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID ; 
var ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
procedure ID ( ID : type_ID ) ; 
begin 
if variable_ID <> nil then 
begin 
procedure_ID ( variable_ID ^ . field_ID ) ; 
procedure_ID ( variable_ID ) ; 
end 
end ; 
function function_ID ; 
begin 
if variable_ID = constant_ID then 
function_ID := constant_ID 
else 
begin 
variable_ID := variable_ID + INTEGER ; 
if variable_ID = INTEGER then 
variable_ID := variable_ID 
else 
begin 
variable_ID := variable_ID [ variable_ID ] ; 
variable_ID := variable_ID - INTEGER ; 
end ; 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID [ variable_ID ] ^ . field_ID := INTEGER ; 
variable_ID [ variable_ID ] ^ . field_ID := nil ; 
function_ID := constant_ID ; 
end 
end ; 
function function_ID ; 
begin 
function_ID := constant_ID ; 
if ( variable_ID > INTEGER ) and ( variable_ID < constant_ID + INTEGER ) then 
if variable_ID [ variable_ID ] <> nil then 
begin 
procedure_ID ( variable_ID [ variable_ID ] ^ . field_ID ) ; 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID [ variable_ID ] := nil ; 
variable_ID := variable_ID + INTEGER ; 
variable_ID := variable_ID - INTEGER ; 
variable_ID [ variable_ID ] := variable_ID ; 
function_ID := constant_ID ; 
end 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
begin 
variable_ID := function_ID ( variable_ID , variable_ID , variable_ID ) ; 
if ( variable_ID = constant_ID ) and not variable_ID then 
begin 
variable_ID [ variable_ID ] ^ . field_ID := variable_ID [ variable_ID ] ^ . field_ID + INTEGER ; 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
procedure_ID ( variable_ID [ variable_ID ] ^ . field_ID ) ; 
variable_ID [ variable_ID ] ^ . field_ID ^ . field_ID := variable_ID ; 
variable_ID [ variable_ID ] ^ . field_ID ^ . field_ID := variable_ID ; 
end ; 
function_ID := variable_ID ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
begin 
variable_ID := function_ID ( variable_ID , variable_ID , variable_ID ) ; 
if ( variable_ID = constant_ID ) then 
if variable_ID then 
begin 
variable_ID [ variable_ID ] ^ . field_ID := variable_ID [ variable_ID ] ^ . field_ID - INTEGER ; 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
while variable_ID ^ . field_ID <> variable_ID do 
begin ; 
variable_ID := variable_ID ; 
variable_ID := variable_ID ^ . field_ID ; 
end ; 
if variable_ID = variable_ID then 
variable_ID [ variable_ID ] ^ . field_ID := variable_ID [ variable_ID ] ^ . field_ID ^ . field_ID 
else 
variable_ID ^ . field_ID := variable_ID ^ . field_ID ; 
procedure_ID ( variable_ID ) ; 
end 
else if not variable_ID then 
variable_ID := constant_ID ; 
function_ID := variable_ID ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
begin 
function_ID := constant_ID ; 
if ( variable_ID > INTEGER ) and ( variable_ID < constant_ID + INTEGER ) then 
if variable_ID [ variable_ID ] <> nil then 
begin 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
variable_ID := constant_ID ; 
while ( variable_ID <> nil ) and ( not variable_ID ) do 
begin 
if variable_ID ^ . field_ID = variable_ID then 
variable_ID := constant_ID ; 
variable_ID := variable_ID ^ . field_ID ; 
end ; 
function_ID := constant_ID ; 
end 
end ; 
function function_ID ; 
begin 
function_ID := constant_ID ; 
if ( variable_ID > INTEGER ) and ( variable_ID < constant_ID + INTEGER ) then 
if variable_ID [ variable_ID ] <> nil then 
begin 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
function_ID := constant_ID ; 
end 
end ; 
function function_ID ; 
var ID : type_ID ; 
begin 
if function_ID ( variable_ID , variable_ID ) = constant_ID then 
begin 
if variable_ID > INTEGER then 
begin 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ^ . field_ID ; 
function_ID := constant_ID ; 
end 
else 
function_ID := constant_ID ; 
end 
else 
function_ID := constant_ID ; 
end ; 
procedure ID ( ID : type_ID ) ; 
var ID : type_ID ; 
begin 
if variable_ID <> nil then 
begin 
procedure_ID ( variable_ID ^ . field_ID ) ; 
if variable_ID ^ . field_ID <> - INTEGER then 
variable_ID := function_ID ( variable_ID ^ . field_ID ) ; 
procedure_ID ( variable_ID ) ; 
end 
end ; 
procedure ID ( ID : type_ID ; ID : type_ID ) ; 
var ID : type_ID ; 
begin 
if variable_ID <> nil then 
begin 
procedure_ID ( variable_ID , variable_ID ^ . field_ID ) ; 
if ( variable_ID ^ . field_ID <> - INTEGER ) and ( variable_ID ^ . field_ID = variable_ID ) then 
begin 
variable_ID := function_ID ( variable_ID ^ . field_ID ) ; 
variable_ID ^ . field_ID := - INTEGER ; 
end ; 
end ; 
end ; 
procedure ID ( ID : type_ID ) ; 
var ID : type_ID ; 
begin 
if variable_ID <> nil then 
begin 
procedure_ID ( variable_ID ^ . field_ID ) ; 
variable_ID := function_ID ( variable_ID ^ . field_ID ) ; 
procedure_ID ( variable_ID ) ; 
end 
end ; 
function ID ( ID : type_ID ) : type_ID ; 
begin 
function_ID := constant_ID ; 
if ( variable_ID < constant_ID + INTEGER ) and ( variable_ID > INTEGER ) then 
if variable_ID [ variable_ID ] <> nil then 
function_ID := constant_ID ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
begin 
if variable_ID = constant_ID then 
function_ID := constant_ID 
else 
begin 
function_ID := constant_ID ; 
variable_ID := variable_ID + INTEGER ; 
if variable_ID = INTEGER then 
variable_ID := variable_ID 
else 
begin 
variable_ID := variable_ID [ variable_ID ] ; 
variable_ID := variable_ID - INTEGER ; 
end ; 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID [ variable_ID ] ^ . field_ID := INTEGER ; 
variable_ID [ variable_ID ] ^ . field_ID := nil ; 
procedure_ID ( variable_ID [ variable_ID ] ^ . field_ID ) ; 
variable_ID [ variable_ID ] ^ . field_ID ^ . field_ID := nil ; 
variable_ID := function_ID ( variable_ID [ variable_ID ] ^ . field_ID ^ . field_ID ) ; 
if variable_ID <> constant_ID then 
function_ID := constant_ID ; 
end ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
begin 
procedure_ID ( variable_ID [ variable_ID ] ^ . field_ID ^ . field_ID ) ; 
procedure_ID ( variable_ID [ variable_ID ] ^ . field_ID ) ; 
variable_ID := function_ID ( variable_ID [ variable_ID ] ^ . field_ID ^ . field_ID ) ; 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID [ variable_ID ] := nil ; 
variable_ID := variable_ID + INTEGER ; 
variable_ID := variable_ID - INTEGER ; 
variable_ID [ variable_ID ] := variable_ID ; 
function_ID := constant_ID ; 
end 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
begin 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
while variable_ID ^ . field_ID <> nil do 
variable_ID := variable_ID ^ . field_ID ; 
procedure_ID ( variable_ID ^ . field_ID ) ; 
variable_ID := variable_ID ^ . field_ID ; 
variable_ID := function_ID ( variable_ID ^ . field_ID ) ; 
if variable_ID = constant_ID then 
begin 
variable_ID [ variable_ID ] ^ . field_ID := variable_ID [ variable_ID ] ^ . field_ID + INTEGER ; 
variable_ID ^ . field_ID := nil ; 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID - INTEGER ; 
function_ID := constant_ID ; 
end 
else 
procedure_ID ( variable_ID ) ; 
end ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
begin 
function_ID := constant_ID ; 
variable_ID := variable_ID + INTEGER ; 
variable_ID := variable_ID + INTEGER ; 
if function_ID ( variable_ID ) then 
begin 
if ( variable_ID <= INTEGER ) or ( variable_ID > variable_ID [ variable_ID ] ^ . field_ID ) or 
( variable_ID <= INTEGER ) or ( variable_ID > variable_ID [ variable_ID ] ^ . field_ID ) then 
begin 
function_ID := constant_ID 
end 
else 
begin 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
for variable_ID := INTEGER to variable_ID do 
variable_ID := variable_ID ^ . field_ID ; 
variable_ID := function_ID ( variable_ID , variable_ID ^ . field_ID ) ; 
if variable_ID = constant_ID then 
begin 
function_ID := constant_ID ; 
procedure_ID ( variable_ID , variable_ID [ variable_ID ] ^ . field_ID ) ; 
end ; 
end ; 
end ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID , ID : type_ID ; 
begin 
variable_ID := constant_ID ; 
if ( variable_ID < INTEGER ) or ( variable_ID >= variable_ID [ variable_ID ] ^ . field_ID ) then 
variable_ID := constant_ID 
else 
begin 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
if variable_ID = constant_ID then 
begin 
variable_ID := function_ID ( variable_ID , variable_ID , variable_ID ) ; 
if variable_ID <> constant_ID then 
begin 
variable_ID [ variable_ID ] ^ . field_ID := variable_ID [ variable_ID ] ^ . field_ID - INTEGER ; 
variable_ID := variable_ID - INTEGER ; 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
variable_ID := nil ; 
while variable_ID ^ . field_ID <> nil do 
begin 
variable_ID := variable_ID ; 
variable_ID := variable_ID ^ . field_ID ; 
end ; 
procedure_ID ( variable_ID ) ; 
variable_ID ^ . field_ID := nil 
end 
end ; 
end ; 
function_ID := variable_ID ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
function ID ( ID : type_ID ; ID : type_ID ) : type_ID ; 
var 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) <> constant_ID then 
function_ID := constant_ID 
else 
begin 
if function_ID ( variable_ID ^ . field_ID ) <> constant_ID then 
begin 
variable_ID := function_ID ( variable_ID ) ; 
function_ID := constant_ID 
end 
else 
begin 
while function_ID ( variable_ID , variable_ID ) = constant_ID do 
begin 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
end ; 
while function_ID ( variable_ID , variable_ID ) = constant_ID do 
begin 
variable_ID := function_ID ( variable_ID , variable_ID ^ . field_ID ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
end ; 
variable_ID := function_ID ( variable_ID ) ; 
end ; 
end ; 
end ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
begin 
variable_ID := variable_ID + INTEGER ; 
if ( variable_ID < INTEGER ) or ( variable_ID > variable_ID [ variable_ID ] ^ . field_ID ) then 
function_ID := constant_ID 
else 
begin 
variable_ID := INTEGER ; 
if variable_ID [ variable_ID ] ^ . field_ID = nil then 
begin 
procedure_ID ( variable_ID [ variable_ID ] ^ . field_ID ) ; 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
end 
else 
begin 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
variable_ID := INTEGER ; 
while variable_ID ^ . field_ID <> nil do 
begin 
variable_ID := variable_ID + INTEGER ; 
variable_ID := variable_ID ^ . field_ID ; 
end ; 
procedure_ID ( variable_ID ^ . field_ID ) ; 
variable_ID := variable_ID ^ . field_ID ; 
end ; 
variable_ID ^ . field_ID := nil ; 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
for variable_ID := INTEGER to variable_ID do 
variable_ID := variable_ID ^ . field_ID ; 
if function_ID ( variable_ID , variable_ID ^ . field_ID ) then 
begin 
variable_ID . field_ID := variable_ID ; 
variable_ID . field_ID := variable_ID ; 
variable_ID . field_ID := variable_ID ; 
variable_ID ^ . field_ID := variable_ID ; 
variable_ID ^ . field_ID := variable_ID . field_ID ; 
function_ID := constant_ID ; 
variable_ID := variable_ID + INTEGER ; 
end ; 
end ; 
end ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
begin 
function_ID := constant_ID ; 
variable_ID := - INTEGER ; 
if function_ID ( variable_ID . field_ID ) then 
begin 
variable_ID := variable_ID [ variable_ID . field_ID ] ^ . field_ID ; 
while ( variable_ID ^ . field_ID <> nil ) and ( variable_ID . field_ID > INTEGER ) do 
begin 
variable_ID := variable_ID ^ . field_ID ; 
variable_ID . field_ID := variable_ID . field_ID - INTEGER ; 
end ; 
if variable_ID . field_ID = INTEGER then 
begin 
if variable_ID ^ . field_ID = variable_ID . field_ID then 
begin 
if function_ID ( variable_ID , variable_ID ^ . field_ID ) = constant_ID then 
begin 
variable_ID := function_ID ( variable_ID , variable_ID ^ . field_ID ) ; 
function_ID := constant_ID ; 
variable_ID := variable_ID - INTEGER ; 
end 
else 
begin 
variable_ID := function_ID ( variable_ID ^ . field_ID ) ; 
function_ID := constant_ID ; 
variable_ID ^ . field_ID := - INTEGER ; 
end ; 
end ; 
end ; 
end ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
begin 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
variable_ID := INTEGER ; 
variable_ID := constant_ID ; 
while ( variable_ID <> nil ) and ( variable_ID ) do 
begin 
write ( STRING , variable_ID : INTEGER , STRING ) ; 
variable_ID := function_ID ( variable_ID , variable_ID , variable_ID ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
while variable_ID = constant_ID do 
begin 
write ( variable_ID : INTEGER , STRING ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
end ; 
if variable_ID = constant_ID then 
variable_ID := constant_ID ; 
writeln ; 
variable_ID := variable_ID + INTEGER ; 
variable_ID := variable_ID ^ . field_ID ; 
end ; 
if variable_ID then 
function_ID := constant_ID ; 
end 
end ; 
function ID ( ID : type_ID ) : type_ID ; 
begin 
case variable_ID of 
constant_ID : 
function_ID := constant_ID ; 
constant_ID : 
function_ID := constant_ID ; 
constant_ID : 
function_ID := constant_ID ; 
constant_ID : 
function_ID := constant_ID ; 
end ; 
end ; 
function ID ( ID : type_ID ) : type_ID ; 
begin 
function_ID := constant_ID ; 
if ( variable_ID > INTEGER ) and ( variable_ID < constant_ID + INTEGER ) then 
if variable_ID [ variable_ID ] <> nil then 
function_ID := constant_ID ; 
end ; 
function ID ( ID : type_ID ) : type_ID ; 
begin 
function_ID := constant_ID ; 
if ( variable_ID > INTEGER ) and ( variable_ID < constant_ID + INTEGER ) then 
if variable_ID [ variable_ID ] <> nil then 
function_ID := constant_ID ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
begin 
if variable_ID >= constant_ID then 
function_ID := constant_ID 
else 
begin 
variable_ID := function_ID ( function_ID ( variable_ID ) ) ; 
if variable_ID = constant_ID then 
begin 
variable_ID := variable_ID + INTEGER ; 
variable_ID := INTEGER ; 
while variable_ID [ variable_ID ] <> nil do 
variable_ID := variable_ID + INTEGER ; 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID [ variable_ID ] ^ := variable_ID ; 
end ; 
function_ID := variable_ID ; 
end ; 
end ; 
function function_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
begin 
function_ID := function_ID ( function_ID ( variable_ID [ variable_ID ] ^ ) ) ; 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID [ variable_ID ] := nil ; 
variable_ID := variable_ID - INTEGER ; 
end ; 
end ; 
function function_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
function_ID := 
function_ID ( function_ID ( variable_ID , variable_ID , variable_ID [ variable_ID ] ^ ) ) ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
begin 
variable_ID := function_ID ( variable_ID , variable_ID , variable_ID [ variable_ID ] ^ ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
variable_ID := function_ID ( variable_ID ) ; 
while ( variable_ID = constant_ID ) and ( variable_ID = constant_ID ) do 
begin 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
end ; 
if ( variable_ID = constant_ID ) and ( variable_ID = constant_ID ) then 
function_ID := constant_ID 
else 
variable_ID := function_ID ( variable_ID ) ; 
end ; 
end ; 
function function_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
function_ID := function_ID ( function_ID ( variable_ID [ variable_ID ] ^ ) ) ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
begin 
function_ID := constant_ID ; 
if ( function_ID ( variable_ID ) ) and ( variable_ID < constant_ID + INTEGER ) then 
begin 
variable_ID := INTEGER ; 
while variable_ID [ variable_ID ] <> nil do 
variable_ID := variable_ID + INTEGER ; 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID := function_ID ( function_ID ( 
variable_ID [ variable_ID ] ^ , variable_ID , variable_ID [ variable_ID ] ^ ) ) ; 
function_ID := variable_ID ; 
if variable_ID = constant_ID then 
variable_ID := variable_ID + INTEGER 
else 
begin 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID [ variable_ID ] := nil ; 
end ; 
end ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
begin 
variable_ID := function_ID ( function_ID ( 
variable_ID , variable_ID [ variable_ID ] ^ ) ) ; 
function_ID := variable_ID ; 
if variable_ID <> constant_ID then 
begin 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID [ variable_ID ] := nil ; 
variable_ID := variable_ID - INTEGER ; 
end ; 
end ; 
end ; 
procedure ID ( ID : type_ID ; ID : type_ID ; ID : type_ID ) ; 
var 
ID : type_ID ; 
procedure ID ( ID : type_ID ; ID : type_ID ) ; 
var 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
begin 
variable_ID := function_ID ( variable_ID , variable_ID , variable_ID ) ; 
if ( variable_ID = - INTEGER ) then 
variable_ID := variable_ID ; 
variable_ID := function_ID ( variable_ID , variable_ID , variable_ID ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
while variable_ID = constant_ID do 
begin 
if ( variable_ID <> variable_ID ) then 
procedure_ID ( variable_ID , variable_ID ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
end ; 
end ; 
begin 
if ( variable_ID <> variable_ID ) then 
variable_ID := - INTEGER 
else 
variable_ID := - INTEGER ; 
procedure_ID ( INTEGER , variable_ID ) ; 
end ; 
procedure ID ( ID : type_ID ; ID : type_ID ; ID : type_ID ; 
ID : type_ID ; ID : type_ID ) ; 
var 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
procedure ID ( ID : type_ID ) ; 
begin 
writeln ; 
writeln ( STRING , variable_ID ) ; 
end ; 
begin 
write ( STRING , variable_ID : INTEGER ) ; 
variable_ID := function_ID ( variable_ID , variable_ID , variable_ID ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
if ( variable_ID ) then 
variable_ID [ INTEGER * variable_ID - INTEGER ] := STRING 
else 
variable_ID [ INTEGER * variable_ID - INTEGER ] := STRING ; 
while ( variable_ID = constant_ID ) do 
begin 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
procedure_ID ( variable_ID , variable_ID , variable_ID + INTEGER , variable_ID <> constant_ID , variable_ID ) ; 
variable_ID := variable_ID ; 
variable_ID := variable_ID ; 
for variable_ID := INTEGER to variable_ID do 
write ( STRING ) ; 
end ; 
procedure_ID ( variable_ID ) ; 
end ; 
procedure ID ( ID : type_ID ) ; 
var 
ID : type_ID ; 
ID : type_ID ; 
begin 
for variable_ID := INTEGER to INTEGER do 
variable_ID [ variable_ID ] := STRING ; 
procedure_ID ( variable_ID , INTEGER , INTEGER , constant_ID , variable_ID ) ; 
end ; 
procedure ID ; 
var ID : type_ID ; 
ID : type_ID ; 
begin 
variable_ID := function_ID ( variable_ID ) ; 
if ( variable_ID = constant_ID ) then 
begin 
writeln ( STRING , variable_ID ) ; 
variable_ID [ variable_ID ] := constant_ID ; 
end 
else writeln ( STRING ) ; 
end ; 
procedure ID ; 
var ID , ID , ID : type_ID ; 
begin 
writeln ( STRING ) ; 
readln ( variable_ID ) ; 
writeln ( STRING ) ; 
readln ( variable_ID ) ; 
writeln ( STRING ) ; 
readln ( variable_ID ) ; 
if ( variable_ID [ variable_ID ] = constant_ID ) and ( variable_ID [ variable_ID ] = constant_ID ) then 
begin 
procedure_ID ( variable_ID , variable_ID , variable_ID ) ; 
writeln ( STRING , variable_ID , STRING , variable_ID , STRING , variable_ID ) ; 
end 
else writeln ( STRING ) 
end ; 
procedure ID ; 
var ID : type_ID ; 
ID : type_ID ; 
begin 
writeln ( STRING ) ; 
readln ( variable_ID ) ; 
variable_ID := function_ID ( variable_ID ) ; 
if ( variable_ID = constant_ID ) then 
begin 
writeln ( STRING , variable_ID , STRING ) ; 
variable_ID [ variable_ID ] := constant_ID ; 
end 
else writeln ( STRING ) ; 
end ; 
procedure ID ; 
var ID : type_ID ; 
ID : type_ID ; 
begin 
writeln ( STRING ) ; 
readln ( variable_ID ) ; 
if ( variable_ID [ variable_ID ] = constant_ID ) then writeln ( STRING ) 
else procedure_ID ( variable_ID ) ; 
end ; 
function ID : type_ID ; 
begin 
writeln ; 
writeln ( STRING ) ; 
writeln ( STRING ) ; 
writeln ( STRING ) ; 
writeln ( STRING ) ; 
writeln ( STRING ) ; 
writeln ; 
repeat 
writeln ( STRING ) ; 
readln ( variable_ID ) ; 
until variable_ID in [ INTEGER , INTEGER , INTEGER , INTEGER , INTEGER ] ; 
function_ID := variable_ID ; 
end ; 
begin 
variable_ID := INTEGER ; 
variable_ID := INTEGER ; 
variable_ID := INTEGER ; 
variable_ID := INTEGER ; 
variable_ID := INTEGER ; 
repeat 
variable_ID := function_ID ; 
case variable_ID of INTEGER 
: procedure_ID ; INTEGER 
: procedure_ID ; INTEGER 
: procedure_ID ; INTEGER 
: procedure_ID ; INTEGER 
: ; 
end ; 
until variable_ID = INTEGER ; 
end .$

iso_pascal_7185_quad
$

program ::= program_heading ';' program_block '.' ; 

// Generated by gramex V3.0 from 'iso_pascal_7185.raw' (this build Jun  8 2012 at 15:37:41)
// Command line: C:\csle\dev\gramex\gramex.exe -p -c iso_pascal_7185.raw


(*6.7.3*)     actual_parameter ::= expression | variable_access | procedure_identifier 
                               | function_identifier ; 

(*6.7.3*)     actual_parameter_list ::= '(' actual_parameter ( ',' actual_parameter)* ')' ; 

(*6.7.2.1*)   adding_operator ::= '+' | '-'      | 'or' ; 

(*6.1.7*)     apostrophe_image ::= '"'  ; 

(*6.4.3.2*)   array_type ::= 'array' '[' index_type ( ',' index_type)* ']' 'of' component_type ; 

(*6.5.3.2*)   array_variable ::= variable_access ; 

(*6.8.2.2*)   assignment_statement ::= ( variable_access | function_identifier ) ':=' expression ; 

(*6.4.3.4*)   base_type ::= ordinal_type ; 

(*6.2.1*)     block ::= label_declaration_part constant_definition_part type_definition_part 
                      variable_declaration_part procedure_and_function_declaration_part 
                      statement_part ; 

(*6.7.2.3*)   Boolean_expression ::= expression ; 

(*6.6.3.7.1*) bound_identifier ::= identifier ; 

(*6.5.5*)     buffer_variable ::= file_variable '^'  ; 

(*6.4.3.3*)   case_constant ::= constant ; 

(*6.4.3.3*)   case_constant_list ::= case_constant ( ',' case_constant)* ; 

(*6.8.3.5*)   case_index ::= expression ; 

(*6.8.3.5*)   case_list_element ::= case_constant_list ':' statement ; 

(*6.8.3.5*)   case_statement ::= 'case' case_index 'of' case_list_element 
                               ( ';' case_list_element)* ( ';')? 'end' ; 

(*6.1.7*)     character_string ::= 'STRING' ; (* '\'' string_element ( string_element)*'\'' ; *)

(*6.4.3.2*)   component_type ::= type_denoter ; 

(*6.5.3.1*)   component_variable ::= indexed_variable | field_designator ; 

(*6.8.3.2*)   compound_statement ::= 'begin' statement_sequence 'end' ; 

(*6.8.3.3*)   conditional_statement ::= if_statement | case_statement ; 

(*6.6.3.7.1*) conformant_array_parameter_specification ::= value_conformant_array_specification 
                                                       | variable_conformant_array_specification ; 

(*6.6.3.7.1*) conformant_array_schema ::= packed_conformant_array_schema 
                                      | unpacked_conformant_array_schema ; 

(*6.3*)       constant ::= ( sign)? ( unsigned_number | constant_identifier ) 
                       | character_string ; 

(*6.3*)       constant_definition ::= identifier '=' constant ; 

(*6.2.1*)     constant_definition_part ::= ( 'const' constant_definition ';' ( constant_definition ';')*)? ; 

(*6.3*)       constant_identifier ::= 'constant_ID' ; (* identifier ; *)

(*6.8.3.9*)   control_variable ::= entire_variable ; 

(*6.1.1*)     digit ::= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' ; 

(*6.1.5*)     digit_sequence ::= digit ( digit)* ; 

(*6.1.4*)     directive ::= 'ID' ; 

(*6.4.4*)     domain_type ::= type_identifier ; 

(*6.8.3.4*)   else_part ::= 'else' statement ; 

(*6.8.2.1*)   (* empty_statement ::= #; *)

(*6.5.2*)     entire_variable ::= variable_identifier ; 

(*6.4.2.3*)   enumerated_type ::= '(' identifier_list ')' ; 

(*6.7.1*)     expression ::= simple_expression ( relational_operator simple_expression)? ; 

(*6.6.3.7.1*) (*factor > bound_identifier ; *)

(*6.7.1*)     factor (*>*) ::= variable_access | unsigned_constant | function_designator 
                     | set_constructor | '(' expression ')' | 'not' factor ; 

(*6.5.3.3*)   field_designator ::= record_variable '.' field_specifier | field_designator_identifier ; 

(*6.8.3.10*)  field_designator_identifier ::= identifier ; 

(*6.5.3.3*)   field_identifier ::= 'field_ID' ; 

(*6.4.3.3*)   field_list ::= ( ( fixed_part ( ';' variant_part)? | variant_part ) ( ';')?)? ; 

(*6.5.3.3*)   field_specifier ::= field_identifier ; 

(*6.4.3.5*)   file_type ::= 'file' 'of' component_type ; 

(*6.5.5*)     file_variable ::= variable_access ; 

(*6.8.3.9*)   final_value ::= expression ; 

(*6.4.3.3*)   fixed_part ::= record_section ( ';' record_section)* ; 

(*6.8.3.9*)   for_statement ::= 'for' control_variable ':=' initial_value ( 'to' | 'downto' ) final_value 
                              'do' statement ; 

(*6.6.3.1*)   formal_parameter_list ::= '(' formal_parameter_section ( ';' formal_parameter_section)* ')' ; 

(*6.6.3.1*)   formal_parameter_section (*>*) ::= value_parameter_specification 
                                       | variable_parameter_specification 
                                       | procedural_parameter_specification 
                                       | functional_parameter_specification ; 

(*6.6.3.7.1*) (*formal_parameter_section > conformant_array_parameter_specification ; *)

(*6.1.5*)     fractional_part ::= digit_sequence ; 

(*6.6.2*)     function_block ::= block ; 

(*6.6.2*)     function_declaration ::= function_heading ';' directive 
                                   | function_identification ';' function_block 
                                   | function_heading ';' function_block ; 

(*6.7.3*)     function_designator ::= function_identifier ( actual_parameter_list)? ; 

(*6.6.2*)     function_heading ::= 'function' identifier ( formal_parameter_list)? ':' result_type ; 

(*6.6.2*)     function_identification ::= 'function' function_identifier ; 

(*6.6.2*)     function_identifier ::= 'function_ID' ;(* identifier ; *)

(*6.6.3.1*)   functional_parameter_specification ::= function_heading ; 

(*6.8.2.4*)   goto_statement ::= 'goto' label ; 

(*6.5.4*)     identified_variable ::= pointer_variable '^'  ; 

(*6.1.3*)     identifier ::= 'ID' ;(* letter ( letter | digit)* ;*) 

(*6.4.2.3*)   identifier_list ::= identifier ( ',' identifier)* ; 

(*6.8.3.4*)   if_statement ::= 'if' Boolean_expression 'then' statement ( else_part)? ; 

(*6.5.3.2*)   index_expression ::= expression ; 

(*6.4.3.2*)   index_type ::= ordinal_type ; 

(*6.6.3.7.1*) index_type_specification ::= identifier '..' identifier ':' ordinal_type_identifier ; 

(*6.5.3.2*)   indexed_variable ::= array_variable '[' index_expression ( ',' index_expression)* ']' ; 

(*6.8.3.9*)   initial_value ::= expression ; 

(*6.1.6*)     label ::= digit_sequence ; 

(*6.2.1*)     label_declaration_part ::= ( 'label' label ( ',' label)* ';')? ; 

(*6.1.1*)     letter ::= 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' 
                     | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' 
                     | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' ; 

(*6.7.1*)     member_designator ::= expression ( '..' expression)? ; 

(*6.7.2.1*)   multiplying_operator ::= '*' | '/' | 'div' | 'mod' | 'and' ; 

(*6.4.2.1*)   new_ordinal_type ::= enumerated_type | subrange_type ; 

(*6.4.4*)     new_pointer_type ::= '^'  domain_type ; 

(*6.4.3.1*)   new_structured_type ::= ( 'packed')? unpacked_structured_type ; 

(*6.4.1*)     new_type ::= new_ordinal_type | new_structured_type | new_pointer_type ; 

(*6.4.2.1*)   ordinal_type ::= new_ordinal_type | ordinal_type_identifier ; 

(*6.4.2.1*)   ordinal_type_identifier ::= type_identifier ; 

(*6.6.3.7.1*) packed_conformant_array_schema ::= 'packed' 'array' '[' index_type_specification ']' 
                                               'of' type_identifier ; 

(*6.4.4*)     pointer_type ::= new_pointer_type | pointer_type_identifier ; 

(*6.4.1*)     pointer_type_identifier ::= type_identifier ; 

(*6.5.4*)     pointer_variable ::= variable_access ; 

(*6.6.3.1*)   procedural_parameter_specification ::= procedure_heading ; 

(*6.2.1*)     procedure_and_function_declaration_part ::= ( ( procedure_declaration 
                                                      | function_declaration ) ';')* ; 

(*6.6.1*)     procedure_block ::= block ; 

(*6.6.1*)     procedure_declaration ::= procedure_heading ';' directive 
                                    | procedure_identification ';' procedure_block 
                                    | procedure_heading ';' procedure_block ; 

(*6.6.1*)     procedure_heading ::= 'procedure' identifier ( formal_parameter_list)? ; 

(*6.6.1*)     procedure_identification ::= 'procedure' procedure_identifier ; 

(*6.6.1*)     procedure_identifier ::= 'procedure_ID' | 'write' | 'writeln' | 'read' | 'readln' ;(* identifier ; *)

(*6.8.2.3*)   procedure_statement ::= procedure_identifier ( ( actual_parameter_list)? 
                                  | read_parameter_list | readln_parameter_list 
                                  | write_parameter_list | writeln_parameter_list ) ; 

(*6.10*)     // program ::= program_heading ';' program_block '.' ; 

(*6.10*)      program_block ::= block ; 

(*6.10*)      program_heading ::= 'program' identifier ( '(' program_parameter_list ')')? ; 

(*6.10*)      program_parameter_list ::= identifier_list ; 

(*6.9.1*)     read_parameter_list ::= '(' ( file_variable ',')? variable_access ( ',' variable_access)* ')' ; 

(*6.9.2*)     readln_parameter_list ::= ( '(' ( file_variable | variable_access ) 
                                      ( ',' variable_access)* ')')? ; 

(*6.4.2.1*)   real_type_identifier ::= type_identifier ; 

(*6.4.3.3*)   record_section ::= identifier_list ':' type_denoter ; 

(*6.4.3.3*)   record_type ::= 'record' field_list 'end' ; 

(*6.5.3.3*)   record_variable ::= variable_access ; 

(*6.8.3.10*)  record_variable_list ::= record_variable ( ',' record_variable)* ; 

(*6.7.2.1*)   relational_operator ::= '=' | '<>' | '<' | '>' | '<=' | '>=' | 'in' ; 

(*6.8.3.7*)   repeat_statement ::= 'repeat' statement_sequence 'until' Boolean_expression ; 

(*6.8.3.6*)   repetitive_statement ::= repeat_statement | while_statement | for_statement ; 

(*6.6.2*)     result_type ::= simple_type_identifier | pointer_type_identifier ; 

(*6.1.5*)     scale_factor ::= ( sign)? digit_sequence ; 

(*6.7.1*)     set_constructor ::= '[' ( member_designator ( ',' member_designator)*)? ']' ; 

(*6.4.3.4*)   set_type ::= 'set' 'of' base_type ; 

(*6.1.5*)     sign ::= '+' | '-'      ; 

(*6.1.5*)     signed_integer ::= ( sign)? unsigned_integer ; 

(*6.1.5*)     signed_number ::= signed_integer | signed_real ; 

(*6.1.5*)     signed_real ::= ( sign)? unsigned_real ; 

(*6.7.1*)     simple_expression ::= ( sign)? term ( adding_operator term)* ; 

(*6.8.2.1*)   simple_statement ::= (* empty_statement *) # | assignment_statement 
                               | procedure_statement | goto_statement ; 

(*6.4.2.1*)   simple_type ::= ordinal_type | real_type_identifier ; 

(*6.4.1*)     simple_type_identifier ::= type_identifier ; 

(*6.1.2*)     special_symbol ::= '+' | '-'      | '*' | '/' | '=' | '<' | '>' | '[' | ']' 
                             | '.' | ',' | ':' | ';' | '^'  | '(' | ')' 
                             | '<>' | '<=' | '>=' | ':=' | '..' | word_symbol ; 

(*6.8.1*)     statement ::= ( label ':')? ( simple_statement | structured_statement ) ; 

(*6.2.1*)     statement_part ::= compound_statement ; 

(*6.8.3.1*)   statement_sequence ::= statement ( ';' statement)* ; 

(*6.1.7*)     (*string_character ::= one_of_a_set_of_implementation_defined_characters ; *)

(*6.1.7*)     (* string_element ::= apostrophe_image | string_character ; *)

(*6.8.3.1*)   structured_statement ::= compound_statement | conditional_statement 
                                   | repetitive_statement | with_statement ; 

(*6.4.3.1*)   structured_type ::= new_structured_type | structured_type_identifier ; 

(*6.4.1*)     structured_type_identifier ::= type_identifier ; 

(*6.4.2.4*)   subrange_type ::= constant '..' constant ; 

(*6.4.3.3*)   tag_field ::= identifier ; 

(*6.4.3.3*)   tag_type ::= ordinal_type_identifier ; 

(*6.7.1*)     term ::= factor ( multiplying_operator factor)* ; 

(*6.4.1*)     type_definition ::= identifier '=' type_denoter ; 

(*6.2.1*)     type_definition_part ::= ( 'type' type_definition ';' ( type_definition ';')*)? ; 

(*6.4.1*)     type_denoter ::= type_identifier | new_type ; 

(*6.4.1*)     type_identifier ::= 'type_ID' ; (*identifier ;*) 

(*6.6.3.7.1*) unpacked_conformant_array_schema ::= 
                   'array' '[' index_type_specification ( ';' index_type_specification)* ']' 
                   'of' ( type_identifier | conformant_array_schema ) ; 

(*6.4.3.1*)   unpacked_structured_type ::= array_type | record_type | set_type | file_type ; 

(*6.7.1*)     unsigned_constant ::= unsigned_number | character_string | constant_identifier | 'nil' ; 

(*6.1.5*)     unsigned_integer ::= 'INTEGER' (* digit_sequence *) ; 

(*6.1.5*)     unsigned_number ::= unsigned_integer | unsigned_real ; 

(*6.1.5*)     unsigned_real ::= 'REAL' ; (* digit_sequence '.' fractional_part ( 'e' scale_factor)? 
                            | digit_sequence 'e' scale_factor ; *)

(*6.6.3.7.1*) value_conformant_array_specification ::= identifier_list ':' conformant_array_schema ; 

(*6.6.3.1*)   value_parameter_specification ::= identifier_list ':' type_identifier ; 

(*6.5.1*)     variable_access ::= entire_variable | component_variable | identified_variable 
                              | buffer_variable ; 

(*6.6.3.7.1*) variable_conformant_array_specification ::= 'var' identifier_list ':' conformant_array_schema ; 

(*6.5.1*)     variable_declaration ::= identifier_list ':' type_denoter ; 

(*6.2.1*)     variable_declaration_part ::= ( 'var' variable_declaration ';' ( variable_declaration ';')*)? ; 

(*6.5.2*)     variable_identifier ::= 'variable_ID' ; (* identifier ; *)

(*6.6.3.1*)   variable_parameter_specification ::= 'var' identifier_list ':' type_identifier ; 

(*6.4.3.3*)   variant ::= case_constant_list ':' '(' field_list ')' ; 

(*6.4.3.3*)   variant_part ::= 'case' variant_selector 'of' variant ( ';' variant)* ; 

(*6.4.3.3*)   variant_selector ::= ( tag_field ':')? tag_type ; 

(*6.8.3.8*)   while_statement ::= 'while' Boolean_expression 'do' statement ; 

(*6.8.3.10*)  with_statement ::= 'with' record_variable_list 'do' statement ; 

(*6.1.2*)     word_symbol ::= 'and' | 'array' | 'begin' | 'case' | 'const' | 'div' 
                          | 'do' | 'downto' | 'else' | 'end' | 'file' | 'for' 
                          | 'function' | 'goto' | 'if' | 'in' | 'label' | 'mod' 
                          | 'nil' | 'not' | 'of' | 'or' | 'packed' | 'procedure' 
                          | 'program' | 'record' | 'repeat' | 'set' | 'then' 
                          | 'to' | 'type' | 'until' | 'var' | 'while' | 'with' ; 

(*6.9.3*)     write_parameter ::= expression ( ':' expression ( ':' expression)?)? ; 

(*6.9.3*)     write_parameter_list ::= '(' ( file_variable ',')? write_parameter 
                                     ( ',' write_parameter)* ')' ; 

(*6.9.4*)     writeln_parameter_list ::= ( '(' ( file_variable | write_parameter ) 
                                       ( ',' write_parameter)* ')')? ; 
$
accept
$program ID ( ID , ID ) ; 
var ID , ID , ID , ID : type_ID ; 
ID : type_ID ; 
procedure ID ( ID : type_ID ; var ID : type_ID ) ; 
begin 
variable_ID := variable_ID + INTEGER ; 
while function_ID ( ( variable_ID * variable_ID ) - variable_ID ) > REAL do 
variable_ID := variable_ID - ( ( ( variable_ID * variable_ID ) - variable_ID ) / ( REAL * variable_ID ) ) 
end ; 
procedure ID ( ID , ID , ID : type_ID ; var ID : type_ID ) ; 
var ID , ID : type_ID ; 
begin 
variable_ID := variable_ID * variable_ID - INTEGER * variable_ID * variable_ID ; 
procedure_ID ( variable_ID , variable_ID ) ; 
variable_ID := ( - variable_ID + variable_ID ) / ( INTEGER * variable_ID ) ; 
end ; 
procedure ID ( ID , ID , ID : type_ID ; var ID : type_ID ; var ID : type_ID ) ; 
begin 
if variable_ID * variable_ID < INTEGER * variable_ID * variable_ID then 
begin 
variable_ID := constant_ID ; 
variable_ID := - INTEGER ; 
end 
else 
begin 
procedure_ID ( variable_ID , variable_ID , variable_ID , variable_ID ) ; 
variable_ID := constant_ID ; 
end ; 
end ; 
begin 
write ( STRING ) ; 
readln ( variable_ID ) ; 
write ( STRING ) ; 
readln ( variable_ID ) ; 
write ( STRING ) ; 
readln ( variable_ID ) ; 
write ( STRING ) ; 
procedure_ID ( variable_ID , variable_ID , variable_ID , variable_ID , variable_ID ) ; 
if variable_ID = constant_ID then 
writeln ( STRING ) 
else writeln ( STRING , variable_ID : INTEGER : INTEGER , STRING ) 
end .$




iso_pascal_7185_BNFright_treeview
$(* ART3 grammar generated by ART from 'iso_pascalV2.art' on May 13 2018 10:56:48 *)

program ::= program_heading ';' program_block '.' 

ART_C_1 ::=
   ',' actual_parameter ART_C_1 |
   # 

ART_C_10 ::=
   ',' index_expression ART_C_10 |
   # 

ART_C_11 ::=
   ',' label ART_C_11 |
   # 

ART_C_12 ::=
   # |
   procedure_declaration ';' ART_C_12 |
   function_declaration ';' ART_C_12 

ART_C_13 ::=
   ',' variable_access ART_C_13 |
   # 

ART_C_14 ::=
   ',' variable_access ART_C_14 |
   # 

ART_C_15 ::=
   ',' record_variable ART_C_15 |
   # 

ART_C_16 ::=
   ',' member_designator ART_C_16 |
   # 

ART_C_17 ::=
   adding_operator term ART_C_17 |
   # 

ART_C_18 ::=
   ';' statement ART_C_18 |
   # 

ART_C_19 ::=
   multiplying_operator factor ART_C_19 |
   # 

ART_C_2 ::=
   ',' index_type ART_C_2 |
   # 

ART_C_20 ::=
   type_definition ';' ART_C_20 |
   # 

ART_C_21 ::=
   ';' index_type_specification ART_C_21 |
   # 

ART_C_22 ::=
   variable_declaration ';' ART_C_22 |
   # 

ART_C_23 ::=
   ';' variant ART_C_23 |
   # 

ART_C_24 ::=
   ',' write_parameter ART_C_24 |
   # 

ART_C_25 ::=
   ',' write_parameter ART_C_25 |
   # 

ART_C_3 ::=
   ',' case_constant ART_C_3 |
   # 

ART_C_4 ::=
   ';' case_list_element ART_C_4 |
   # 

ART_C_5 ::=
   constant_definition ';' ART_C_5 |
   # 

ART_C_6 ::=
   digit ART_C_6 |
   # 

ART_C_7 ::=
   ';' record_section ART_C_7 |
   # 

ART_C_8 ::=
   ';' formal_parameter_section ART_C_8 |
   # 

ART_C_9 ::=
   ',' identifier ART_C_9 |
   # 

Boolean_expression ::=
   expression 

actual_parameter ::=
   expression |
   variable_access |
   procedure_identifier |
   function_identifier 

actual_parameter_list ::=
   '(' actual_parameter ART_C_1 ')' 

adding_operator ::=
   '+' |
   '-' |
   'or' 

apostrophe_image ::=
   '\"' 

array_type ::=
   'array' '[' index_type ART_C_2 ']' 'of' component_type 

array_variable ::=
   variable_access 

assignment_statement ::=
   variable_access ':=' expression |
   function_identifier ':=' expression 

base_type ::=
   ordinal_type 

block ::=
   label_declaration_part constant_definition_part type_definition_part variable_declaration_part procedure_and_function_declaration_part statement_part 

bound_identifier ::=
   identifier 

buffer_variable ::=
   file_variable '^' 

case_constant ::=
   constant 

case_constant_list ::=
   case_constant ART_C_3 

case_index ::=
   expression 

case_list_element ::=
   case_constant_list ':' statement 

case_statement ::=
   'case' case_index 'of' case_list_element ART_C_4 'end' |
   'case' case_index 'of' case_list_element ART_C_4 ';' 'end' 

character_string ::=
   'STRING' 

component_type ::=
   type_denoter 

component_variable ::=
   indexed_variable |
   field_designator 

compound_statement ::=
   'begin' statement_sequence 'end' 

conditional_statement ::=
   if_statement |
   case_statement 

conformant_array_parameter_specification ::=
   value_conformant_array_specification |
   variable_conformant_array_specification 

conformant_array_schema ::=
   packed_conformant_array_schema |
   unpacked_conformant_array_schema 

constant ::=
   character_string |
   unsigned_number |
   constant_identifier |
   sign unsigned_number |
   sign constant_identifier 

constant_definition ::=
   identifier '=' constant 

constant_definition_part ::=
   # |
   'const' constant_definition ';' ART_C_5 

constant_identifier ::=
   'constant_ID' 

control_variable ::=
   entire_variable 

digit ::=
   '0' |
   '1' |
   '2' |
   '3' |
   '4' |
   '5' |
   '6' |
   '7' |
   '8' |
   '9' 

digit_sequence ::=
   digit ART_C_6 

directive ::=
   'ID' 

domain_type ::=
   type_identifier 

else_part ::=
   'else' statement 

entire_variable ::=
   variable_identifier 

enumerated_type ::=
   '(' identifier_list ')' 

expression ::=
   simple_expression |
   simple_expression relational_operator simple_expression 

factor ::=
   variable_access |
   unsigned_constant |
   function_designator |
   set_constructor |
   '(' expression ')' |
   'not' factor 

field_designator ::=
   record_variable '.' field_specifier |
   field_designator_identifier 

field_designator_identifier ::=
   identifier 

field_identifier ::=
   'field_ID' 

field_list ::=
   # |
   variant_part |
   variant_part ';' |
   fixed_part |
   fixed_part ';' |
   fixed_part ';' variant_part |
   fixed_part ';' variant_part ';' 

field_specifier ::=
   field_identifier 

file_type ::=
   'file' 'of' component_type 

file_variable ::=
   variable_access 

final_value ::=
   expression 

fixed_part ::=
   record_section ART_C_7 

for_statement ::=
   'for' control_variable ':=' initial_value 'to' final_value 'do' statement |
   'for' control_variable ':=' initial_value 'downto' final_value 'do' statement 

formal_parameter_list ::=
   '(' formal_parameter_section ART_C_8 ')' 

formal_parameter_section ::=
   value_parameter_specification |
   variable_parameter_specification |
   procedural_parameter_specification |
   functional_parameter_specification 

fractional_part ::=
   digit_sequence 

function_block ::=
   block 

function_declaration ::=
   function_heading ';' directive |
   function_identification ';' function_block |
   function_heading ';' function_block 

function_designator ::=
   function_identifier |
   function_identifier actual_parameter_list 

function_heading ::=
   'function' identifier ':' result_type |
   'function' identifier formal_parameter_list ':' result_type 

function_identification ::=
   'function' function_identifier 

function_identifier ::=
   'function_ID' 

functional_parameter_specification ::=
   function_heading 

goto_statement ::=
   'goto' label 

identified_variable ::=
   pointer_variable '^' 

identifier ::=
   'ID' 

identifier_list ::=
   identifier ART_C_9 

if_statement ::=
   'if' Boolean_expression 'then' statement |
   'if' Boolean_expression 'then' statement else_part 

index_expression ::=
   expression 

index_type ::=
   ordinal_type 

index_type_specification ::=
   identifier '..' identifier ':' ordinal_type_identifier 

indexed_variable ::=
   array_variable '[' index_expression ART_C_10 ']' 

initial_value ::=
   expression 

label ::=
   digit_sequence 

label_declaration_part ::=
   # |
   'label' label ART_C_11 ';' 

letter ::=
   'a' |
   'b' |
   'c' |
   'd' |
   'e' |
   'f' |
   'g' |
   'h' |
   'i' |
   'j' |
   'k' |
   'l' |
   'm' |
   'n' |
   'o' |
   'p' |
   'q' |
   'r' |
   's' |
   't' |
   'u' |
   'v' |
   'w' |
   'x' |
   'y' |
   'z' 

member_designator ::=
   expression |
   expression '..' expression 

multiplying_operator ::=
   '*' |
   '/' |
   'div' |
   'mod' |
   'and' 

new_ordinal_type ::=
   enumerated_type |
   subrange_type 

new_pointer_type ::=
   '^' domain_type 

new_structured_type ::=
   unpacked_structured_type |
   'packed' unpacked_structured_type 

new_type ::=
   new_ordinal_type |
   new_structured_type |
   new_pointer_type 

ordinal_type ::=
   new_ordinal_type |
   ordinal_type_identifier 

ordinal_type_identifier ::=
   type_identifier 

packed_conformant_array_schema ::=
   'packed' 'array' '[' index_type_specification ']' 'of' type_identifier 

pointer_type ::=
   new_pointer_type |
   pointer_type_identifier 

pointer_type_identifier ::=
   type_identifier 

pointer_variable ::=
   variable_access 

procedural_parameter_specification ::=
   procedure_heading 

procedure_and_function_declaration_part ::=
   ART_C_12 

procedure_block ::=
   block 

procedure_declaration ::=
   procedure_heading ';' directive |
   procedure_identification ';' procedure_block |
   procedure_heading ';' procedure_block 

procedure_heading ::=
   'procedure' identifier |
   'procedure' identifier formal_parameter_list 

procedure_identification ::=
   'procedure' procedure_identifier 

procedure_identifier ::=
   'procedure_ID' |
   'write' |
   'writeln' |
   'read' |
   'readln' 

procedure_statement ::=
   procedure_identifier read_parameter_list |
   procedure_identifier readln_parameter_list |
   procedure_identifier write_parameter_list |
   procedure_identifier writeln_parameter_list |
   procedure_identifier |
   procedure_identifier actual_parameter_list 

// program ::= program_heading ';' program_block '.' 

program_block ::=
   block 

program_heading ::=
   'program' identifier |
   'program' identifier '(' program_parameter_list ')' 

program_parameter_list ::=
   identifier_list 

read_parameter_list ::=
   '(' variable_access ART_C_13 ')' |
   '(' file_variable ',' variable_access ART_C_13 ')' 

readln_parameter_list ::=
   # |
   '(' file_variable ART_C_14 ')' |
   '(' variable_access ART_C_14 ')' 

real_type_identifier ::=
   type_identifier 

record_section ::=
   identifier_list ':' type_denoter 

record_type ::=
   'record' field_list 'end' 

record_variable ::=
   variable_access 

record_variable_list ::=
   record_variable ART_C_15 

relational_operator ::=
   '=' |
   '<>' |
   '<' |
   '>' |
   '<=' |
   '>=' |
   'in' 

repeat_statement ::=
   'repeat' statement_sequence 'until' Boolean_expression 

repetitive_statement ::=
   repeat_statement |
   while_statement |
   for_statement 

result_type ::=
   simple_type_identifier |
   pointer_type_identifier 

scale_factor ::=
   digit_sequence |
   sign digit_sequence 

set_constructor ::=
   '[' ']' |
   '[' member_designator ART_C_16 ']' 

set_type ::=
   'set' 'of' base_type 

sign ::=
   '+' |
   '-' 

signed_integer ::=
   unsigned_integer |
   sign unsigned_integer 

signed_number ::=
   signed_integer |
   signed_real 

signed_real ::=
   unsigned_real |
   sign unsigned_real 

simple_expression ::=
   term ART_C_17 |
   sign term ART_C_17 

simple_statement ::=
   # |
   assignment_statement |
   procedure_statement |
   goto_statement 

simple_type ::=
   ordinal_type |
   real_type_identifier 

simple_type_identifier ::=
   type_identifier 

special_symbol ::=
   '+' |
   '-' |
   '*' |
   '/' |
   '=' |
   '<' |
   '>' |
   '[' |
   ']' |
   '.' |
   ',' |
   ':' |
   ';' |
   '^' |
   '(' |
   ')' |
   '<>' |
   '<=' |
   '>=' |
   ':=' |
   '..' |
   word_symbol 

statement ::=
   simple_statement |
   structured_statement |
   label ':' simple_statement |
   label ':' structured_statement 

statement_part ::=
   compound_statement 

statement_sequence ::=
   statement ART_C_18 

structured_statement ::=
   compound_statement |
   conditional_statement |
   repetitive_statement |
   with_statement 

structured_type ::=
   new_structured_type |
   structured_type_identifier 

structured_type_identifier ::=
   type_identifier 

subrange_type ::=
   constant '..' constant 

tag_field ::=
   identifier 

tag_type ::=
   ordinal_type_identifier 

term ::=
   factor ART_C_19 

type_definition ::=
   identifier '=' type_denoter 

type_definition_part ::=
   # |
   'type' type_definition ';' ART_C_20 

type_denoter ::=
   type_identifier |
   new_type 

type_identifier ::=
   'type_ID' 

unpacked_conformant_array_schema ::=
   'array' '[' index_type_specification ART_C_21 ']' 'of' type_identifier |
   'array' '[' index_type_specification ART_C_21 ']' 'of' conformant_array_schema 

unpacked_structured_type ::=
   array_type |
   record_type |
   set_type |
   file_type 

unsigned_constant ::=
   unsigned_number |
   character_string |
   constant_identifier |
   'nil' 

unsigned_integer ::=
   'INTEGER' 

unsigned_number ::=
   unsigned_integer |
   unsigned_real 

unsigned_real ::=
   'REAL' 

value_conformant_array_specification ::=
   identifier_list ':' conformant_array_schema 

value_parameter_specification ::=
   identifier_list ':' type_identifier 

variable_access ::=
   entire_variable |
   component_variable |
   identified_variable |
   buffer_variable 

variable_conformant_array_specification ::=
   'var' identifier_list ':' conformant_array_schema 

variable_declaration ::=
   identifier_list ':' type_denoter 

variable_declaration_part ::=
   # |
   'var' variable_declaration ';' ART_C_22 

variable_identifier ::=
   'variable_ID' 

variable_parameter_specification ::=
   'var' identifier_list ':' type_identifier 

variant ::=
   case_constant_list ':' '(' field_list ')' 

variant_part ::=
   'case' variant_selector 'of' variant ART_C_23 

variant_selector ::=
   tag_type |
   tag_field ':' tag_type 

while_statement ::=
   'while' Boolean_expression 'do' statement 

with_statement ::=
   'with' record_variable_list 'do' statement 

word_symbol ::=
   'and' |
   'array' |
   'begin' |
   'case' |
   'const' |
   'div' |
   'do' |
   'downto' |
   'else' |
   'end' |
   'file' |
   'for' |
   'function' |
   'goto' |
   'if' |
   'in' |
   'label' |
   'mod' |
   'nil' |
   'not' |
   'of' |
   'or' |
   'packed' |
   'procedure' |
   'program' |
   'record' |
   'repeat' |
   'set' |
   'then' |
   'to' |
   'type' |
   'until' |
   'var' |
   'while' |
   'with' 

write_parameter ::=
   expression |
   expression ':' expression |
   expression ':' expression ':' expression 

write_parameter_list ::=
   '(' write_parameter ART_C_24 ')' |
   '(' file_variable ',' write_parameter ART_C_24 ')' 

writeln_parameter_list ::=
   # |
   '(' file_variable ART_C_25 ')' |
   '(' write_parameter ART_C_25 ')' 

$
accept
$program ID ( ID , ID ) ; 
const ID = INTEGER ; 
ID = INTEGER ; 
ID = INTEGER ; 
ID = INTEGER ; 
type ID = INTEGER .. constant_ID ; 
ID = ( ID , ID , ID ) ; 
ID = array [ INTEGER .. INTEGER ] of type_ID ; 
ID = INTEGER .. constant_ID ; 
ID = ( ID , ID , ID , ID ) ; 
ID = record 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
end ; 
ID = INTEGER .. constant_ID ; 
ID = ( ID , ID , ID , ID ) ; 
ID = INTEGER .. constant_ID ; 
ID = ^ type_ID ; 
ID = ^ type_ID ; 
ID = ^ type_ID ; 
ID = record 
ID : type_ID ; 
ID : type_ID ; 
end ; 
ID = record 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
end ; 
ID = record 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
end ; 
ID = ^ type_ID ; 
ID = record 
ID : type_ID ; 
ID : type_ID ; 
end ; 
ID = ^ type_ID ; 
ID = record 
ID : type_ID ; 
ID : type_ID ; 
end ; 
ID = type_ID ; 
ID = ^ type_ID ; 
ID = ^ type_ID ; 
var ID : array [ INTEGER .. constant_ID ] of type_ID ; 
ID : type_ID ; 
ID : array [ INTEGER .. constant_ID ] of type_ID ; 
ID : type_ID ; 
ID : array [ INTEGER .. constant_ID ] of type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : array [ INTEGER .. constant_ID ] of type_ID ; 
ID : array [ INTEGER .. constant_ID ] of type_ID ; 
ID : array [ INTEGER .. constant_ID ] of type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : array [ INTEGER .. constant_ID ] of type_ID ; 
function ID ( 
var ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID ; 
var ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
procedure ID ( ID : type_ID ) ; 
begin 
if variable_ID <> nil then 
begin 
procedure_ID ( variable_ID ^ . field_ID ) ; 
procedure_ID ( variable_ID ) ; 
end 
end ; 
function function_ID ; 
begin 
if variable_ID = constant_ID then 
function_ID := constant_ID 
else 
begin 
variable_ID := variable_ID + INTEGER ; 
if variable_ID = INTEGER then 
variable_ID := variable_ID 
else 
begin 
variable_ID := variable_ID [ variable_ID ] ; 
variable_ID := variable_ID - INTEGER ; 
end ; 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID [ variable_ID ] ^ . field_ID := INTEGER ; 
variable_ID [ variable_ID ] ^ . field_ID := nil ; 
function_ID := constant_ID ; 
end 
end ; 
function function_ID ; 
begin 
function_ID := constant_ID ; 
if ( variable_ID > INTEGER ) and ( variable_ID < constant_ID + INTEGER ) then 
if variable_ID [ variable_ID ] <> nil then 
begin 
procedure_ID ( variable_ID [ variable_ID ] ^ . field_ID ) ; 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID [ variable_ID ] := nil ; 
variable_ID := variable_ID + INTEGER ; 
variable_ID := variable_ID - INTEGER ; 
variable_ID [ variable_ID ] := variable_ID ; 
function_ID := constant_ID ; 
end 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
begin 
variable_ID := function_ID ( variable_ID , variable_ID , variable_ID ) ; 
if ( variable_ID = constant_ID ) and not variable_ID then 
begin 
variable_ID [ variable_ID ] ^ . field_ID := variable_ID [ variable_ID ] ^ . field_ID + INTEGER ; 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
procedure_ID ( variable_ID [ variable_ID ] ^ . field_ID ) ; 
variable_ID [ variable_ID ] ^ . field_ID ^ . field_ID := variable_ID ; 
variable_ID [ variable_ID ] ^ . field_ID ^ . field_ID := variable_ID ; 
end ; 
function_ID := variable_ID ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
begin 
variable_ID := function_ID ( variable_ID , variable_ID , variable_ID ) ; 
if ( variable_ID = constant_ID ) then 
if variable_ID then 
begin 
variable_ID [ variable_ID ] ^ . field_ID := variable_ID [ variable_ID ] ^ . field_ID - INTEGER ; 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
while variable_ID ^ . field_ID <> variable_ID do 
begin ; 
variable_ID := variable_ID ; 
variable_ID := variable_ID ^ . field_ID ; 
end ; 
if variable_ID = variable_ID then 
variable_ID [ variable_ID ] ^ . field_ID := variable_ID [ variable_ID ] ^ . field_ID ^ . field_ID 
else 
variable_ID ^ . field_ID := variable_ID ^ . field_ID ; 
procedure_ID ( variable_ID ) ; 
end 
else if not variable_ID then 
variable_ID := constant_ID ; 
function_ID := variable_ID ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
begin 
function_ID := constant_ID ; 
if ( variable_ID > INTEGER ) and ( variable_ID < constant_ID + INTEGER ) then 
if variable_ID [ variable_ID ] <> nil then 
begin 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
variable_ID := constant_ID ; 
while ( variable_ID <> nil ) and ( not variable_ID ) do 
begin 
if variable_ID ^ . field_ID = variable_ID then 
variable_ID := constant_ID ; 
variable_ID := variable_ID ^ . field_ID ; 
end ; 
function_ID := constant_ID ; 
end 
end ; 
function function_ID ; 
begin 
function_ID := constant_ID ; 
if ( variable_ID > INTEGER ) and ( variable_ID < constant_ID + INTEGER ) then 
if variable_ID [ variable_ID ] <> nil then 
begin 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
function_ID := constant_ID ; 
end 
end ; 
function function_ID ; 
var ID : type_ID ; 
begin 
if function_ID ( variable_ID , variable_ID ) = constant_ID then 
begin 
if variable_ID > INTEGER then 
begin 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ^ . field_ID ; 
function_ID := constant_ID ; 
end 
else 
function_ID := constant_ID ; 
end 
else 
function_ID := constant_ID ; 
end ; 
procedure ID ( ID : type_ID ) ; 
var ID : type_ID ; 
begin 
if variable_ID <> nil then 
begin 
procedure_ID ( variable_ID ^ . field_ID ) ; 
if variable_ID ^ . field_ID <> - INTEGER then 
variable_ID := function_ID ( variable_ID ^ . field_ID ) ; 
procedure_ID ( variable_ID ) ; 
end 
end ; 
procedure ID ( ID : type_ID ; ID : type_ID ) ; 
var ID : type_ID ; 
begin 
if variable_ID <> nil then 
begin 
procedure_ID ( variable_ID , variable_ID ^ . field_ID ) ; 
if ( variable_ID ^ . field_ID <> - INTEGER ) and ( variable_ID ^ . field_ID = variable_ID ) then 
begin 
variable_ID := function_ID ( variable_ID ^ . field_ID ) ; 
variable_ID ^ . field_ID := - INTEGER ; 
end ; 
end ; 
end ; 
procedure ID ( ID : type_ID ) ; 
var ID : type_ID ; 
begin 
if variable_ID <> nil then 
begin 
procedure_ID ( variable_ID ^ . field_ID ) ; 
variable_ID := function_ID ( variable_ID ^ . field_ID ) ; 
procedure_ID ( variable_ID ) ; 
end 
end ; 
function ID ( ID : type_ID ) : type_ID ; 
begin 
function_ID := constant_ID ; 
if ( variable_ID < constant_ID + INTEGER ) and ( variable_ID > INTEGER ) then 
if variable_ID [ variable_ID ] <> nil then 
function_ID := constant_ID ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
begin 
if variable_ID = constant_ID then 
function_ID := constant_ID 
else 
begin 
function_ID := constant_ID ; 
variable_ID := variable_ID + INTEGER ; 
if variable_ID = INTEGER then 
variable_ID := variable_ID 
else 
begin 
variable_ID := variable_ID [ variable_ID ] ; 
variable_ID := variable_ID - INTEGER ; 
end ; 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID [ variable_ID ] ^ . field_ID := INTEGER ; 
variable_ID [ variable_ID ] ^ . field_ID := nil ; 
procedure_ID ( variable_ID [ variable_ID ] ^ . field_ID ) ; 
variable_ID [ variable_ID ] ^ . field_ID ^ . field_ID := nil ; 
variable_ID := function_ID ( variable_ID [ variable_ID ] ^ . field_ID ^ . field_ID ) ; 
if variable_ID <> constant_ID then 
function_ID := constant_ID ; 
end ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
begin 
procedure_ID ( variable_ID [ variable_ID ] ^ . field_ID ^ . field_ID ) ; 
procedure_ID ( variable_ID [ variable_ID ] ^ . field_ID ) ; 
variable_ID := function_ID ( variable_ID [ variable_ID ] ^ . field_ID ^ . field_ID ) ; 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID [ variable_ID ] := nil ; 
variable_ID := variable_ID + INTEGER ; 
variable_ID := variable_ID - INTEGER ; 
variable_ID [ variable_ID ] := variable_ID ; 
function_ID := constant_ID ; 
end 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
begin 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
while variable_ID ^ . field_ID <> nil do 
variable_ID := variable_ID ^ . field_ID ; 
procedure_ID ( variable_ID ^ . field_ID ) ; 
variable_ID := variable_ID ^ . field_ID ; 
variable_ID := function_ID ( variable_ID ^ . field_ID ) ; 
if variable_ID = constant_ID then 
begin 
variable_ID [ variable_ID ] ^ . field_ID := variable_ID [ variable_ID ] ^ . field_ID + INTEGER ; 
variable_ID ^ . field_ID := nil ; 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID - INTEGER ; 
function_ID := constant_ID ; 
end 
else 
procedure_ID ( variable_ID ) ; 
end ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
begin 
function_ID := constant_ID ; 
variable_ID := variable_ID + INTEGER ; 
variable_ID := variable_ID + INTEGER ; 
if function_ID ( variable_ID ) then 
begin 
if ( variable_ID <= INTEGER ) or ( variable_ID > variable_ID [ variable_ID ] ^ . field_ID ) or 
( variable_ID <= INTEGER ) or ( variable_ID > variable_ID [ variable_ID ] ^ . field_ID ) then 
begin 
function_ID := constant_ID 
end 
else 
begin 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
for variable_ID := INTEGER to variable_ID do 
variable_ID := variable_ID ^ . field_ID ; 
variable_ID := function_ID ( variable_ID , variable_ID ^ . field_ID ) ; 
if variable_ID = constant_ID then 
begin 
function_ID := constant_ID ; 
procedure_ID ( variable_ID , variable_ID [ variable_ID ] ^ . field_ID ) ; 
end ; 
end ; 
end ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID , ID : type_ID ; 
begin 
variable_ID := constant_ID ; 
if ( variable_ID < INTEGER ) or ( variable_ID >= variable_ID [ variable_ID ] ^ . field_ID ) then 
variable_ID := constant_ID 
else 
begin 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
if variable_ID = constant_ID then 
begin 
variable_ID := function_ID ( variable_ID , variable_ID , variable_ID ) ; 
if variable_ID <> constant_ID then 
begin 
variable_ID [ variable_ID ] ^ . field_ID := variable_ID [ variable_ID ] ^ . field_ID - INTEGER ; 
variable_ID := variable_ID - INTEGER ; 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
variable_ID := nil ; 
while variable_ID ^ . field_ID <> nil do 
begin 
variable_ID := variable_ID ; 
variable_ID := variable_ID ^ . field_ID ; 
end ; 
procedure_ID ( variable_ID ) ; 
variable_ID ^ . field_ID := nil 
end 
end ; 
end ; 
function_ID := variable_ID ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
function ID ( ID : type_ID ; ID : type_ID ) : type_ID ; 
var 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) <> constant_ID then 
function_ID := constant_ID 
else 
begin 
if function_ID ( variable_ID ^ . field_ID ) <> constant_ID then 
begin 
variable_ID := function_ID ( variable_ID ) ; 
function_ID := constant_ID 
end 
else 
begin 
while function_ID ( variable_ID , variable_ID ) = constant_ID do 
begin 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
end ; 
while function_ID ( variable_ID , variable_ID ) = constant_ID do 
begin 
variable_ID := function_ID ( variable_ID , variable_ID ^ . field_ID ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
end ; 
variable_ID := function_ID ( variable_ID ) ; 
end ; 
end ; 
end ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
begin 
variable_ID := variable_ID + INTEGER ; 
if ( variable_ID < INTEGER ) or ( variable_ID > variable_ID [ variable_ID ] ^ . field_ID ) then 
function_ID := constant_ID 
else 
begin 
variable_ID := INTEGER ; 
if variable_ID [ variable_ID ] ^ . field_ID = nil then 
begin 
procedure_ID ( variable_ID [ variable_ID ] ^ . field_ID ) ; 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
end 
else 
begin 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
variable_ID := INTEGER ; 
while variable_ID ^ . field_ID <> nil do 
begin 
variable_ID := variable_ID + INTEGER ; 
variable_ID := variable_ID ^ . field_ID ; 
end ; 
procedure_ID ( variable_ID ^ . field_ID ) ; 
variable_ID := variable_ID ^ . field_ID ; 
end ; 
variable_ID ^ . field_ID := nil ; 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
for variable_ID := INTEGER to variable_ID do 
variable_ID := variable_ID ^ . field_ID ; 
if function_ID ( variable_ID , variable_ID ^ . field_ID ) then 
begin 
variable_ID . field_ID := variable_ID ; 
variable_ID . field_ID := variable_ID ; 
variable_ID . field_ID := variable_ID ; 
variable_ID ^ . field_ID := variable_ID ; 
variable_ID ^ . field_ID := variable_ID . field_ID ; 
function_ID := constant_ID ; 
variable_ID := variable_ID + INTEGER ; 
end ; 
end ; 
end ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
begin 
function_ID := constant_ID ; 
variable_ID := - INTEGER ; 
if function_ID ( variable_ID . field_ID ) then 
begin 
variable_ID := variable_ID [ variable_ID . field_ID ] ^ . field_ID ; 
while ( variable_ID ^ . field_ID <> nil ) and ( variable_ID . field_ID > INTEGER ) do 
begin 
variable_ID := variable_ID ^ . field_ID ; 
variable_ID . field_ID := variable_ID . field_ID - INTEGER ; 
end ; 
if variable_ID . field_ID = INTEGER then 
begin 
if variable_ID ^ . field_ID = variable_ID . field_ID then 
begin 
if function_ID ( variable_ID , variable_ID ^ . field_ID ) = constant_ID then 
begin 
variable_ID := function_ID ( variable_ID , variable_ID ^ . field_ID ) ; 
function_ID := constant_ID ; 
variable_ID := variable_ID - INTEGER ; 
end 
else 
begin 
variable_ID := function_ID ( variable_ID ^ . field_ID ) ; 
function_ID := constant_ID ; 
variable_ID ^ . field_ID := - INTEGER ; 
end ; 
end ; 
end ; 
end ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
begin 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
variable_ID := INTEGER ; 
variable_ID := constant_ID ; 
while ( variable_ID <> nil ) and ( variable_ID ) do 
begin 
write ( STRING , variable_ID : INTEGER , STRING ) ; 
variable_ID := function_ID ( variable_ID , variable_ID , variable_ID ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
while variable_ID = constant_ID do 
begin 
write ( variable_ID : INTEGER , STRING ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
end ; 
if variable_ID = constant_ID then 
variable_ID := constant_ID ; 
writeln ; 
variable_ID := variable_ID + INTEGER ; 
variable_ID := variable_ID ^ . field_ID ; 
end ; 
if variable_ID then 
function_ID := constant_ID ; 
end 
end ; 
function ID ( ID : type_ID ) : type_ID ; 
begin 
case variable_ID of 
constant_ID : 
function_ID := constant_ID ; 
constant_ID : 
function_ID := constant_ID ; 
constant_ID : 
function_ID := constant_ID ; 
constant_ID : 
function_ID := constant_ID ; 
end ; 
end ; 
function ID ( ID : type_ID ) : type_ID ; 
begin 
function_ID := constant_ID ; 
if ( variable_ID > INTEGER ) and ( variable_ID < constant_ID + INTEGER ) then 
if variable_ID [ variable_ID ] <> nil then 
function_ID := constant_ID ; 
end ; 
function ID ( ID : type_ID ) : type_ID ; 
begin 
function_ID := constant_ID ; 
if ( variable_ID > INTEGER ) and ( variable_ID < constant_ID + INTEGER ) then 
if variable_ID [ variable_ID ] <> nil then 
function_ID := constant_ID ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
begin 
if variable_ID >= constant_ID then 
function_ID := constant_ID 
else 
begin 
variable_ID := function_ID ( function_ID ( variable_ID ) ) ; 
if variable_ID = constant_ID then 
begin 
variable_ID := variable_ID + INTEGER ; 
variable_ID := INTEGER ; 
while variable_ID [ variable_ID ] <> nil do 
variable_ID := variable_ID + INTEGER ; 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID [ variable_ID ] ^ := variable_ID ; 
end ; 
function_ID := variable_ID ; 
end ; 
end ; 
function function_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
begin 
function_ID := function_ID ( function_ID ( variable_ID [ variable_ID ] ^ ) ) ; 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID [ variable_ID ] := nil ; 
variable_ID := variable_ID - INTEGER ; 
end ; 
end ; 
function function_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
function_ID := 
function_ID ( function_ID ( variable_ID , variable_ID , variable_ID [ variable_ID ] ^ ) ) ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
begin 
variable_ID := function_ID ( variable_ID , variable_ID , variable_ID [ variable_ID ] ^ ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
variable_ID := function_ID ( variable_ID ) ; 
while ( variable_ID = constant_ID ) and ( variable_ID = constant_ID ) do 
begin 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
end ; 
if ( variable_ID = constant_ID ) and ( variable_ID = constant_ID ) then 
function_ID := constant_ID 
else 
variable_ID := function_ID ( variable_ID ) ; 
end ; 
end ; 
function function_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
function_ID := function_ID ( function_ID ( variable_ID [ variable_ID ] ^ ) ) ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
begin 
function_ID := constant_ID ; 
if ( function_ID ( variable_ID ) ) and ( variable_ID < constant_ID + INTEGER ) then 
begin 
variable_ID := INTEGER ; 
while variable_ID [ variable_ID ] <> nil do 
variable_ID := variable_ID + INTEGER ; 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID := function_ID ( function_ID ( 
variable_ID [ variable_ID ] ^ , variable_ID , variable_ID [ variable_ID ] ^ ) ) ; 
function_ID := variable_ID ; 
if variable_ID = constant_ID then 
variable_ID := variable_ID + INTEGER 
else 
begin 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID [ variable_ID ] := nil ; 
end ; 
end ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
begin 
variable_ID := function_ID ( function_ID ( 
variable_ID , variable_ID [ variable_ID ] ^ ) ) ; 
function_ID := variable_ID ; 
if variable_ID <> constant_ID then 
begin 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID [ variable_ID ] := nil ; 
variable_ID := variable_ID - INTEGER ; 
end ; 
end ; 
end ; 
procedure ID ( ID : type_ID ; ID : type_ID ; ID : type_ID ) ; 
var 
ID : type_ID ; 
procedure ID ( ID : type_ID ; ID : type_ID ) ; 
var 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
begin 
variable_ID := function_ID ( variable_ID , variable_ID , variable_ID ) ; 
if ( variable_ID = - INTEGER ) then 
variable_ID := variable_ID ; 
variable_ID := function_ID ( variable_ID , variable_ID , variable_ID ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
while variable_ID = constant_ID do 
begin 
if ( variable_ID <> variable_ID ) then 
procedure_ID ( variable_ID , variable_ID ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
end ; 
end ; 
begin 
if ( variable_ID <> variable_ID ) then 
variable_ID := - INTEGER 
else 
variable_ID := - INTEGER ; 
procedure_ID ( INTEGER , variable_ID ) ; 
end ; 
procedure ID ( ID : type_ID ; ID : type_ID ; ID : type_ID ; 
ID : type_ID ; ID : type_ID ) ; 
var 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
procedure ID ( ID : type_ID ) ; 
begin 
writeln ; 
writeln ( STRING , variable_ID ) ; 
end ; 
begin 
write ( STRING , variable_ID : INTEGER ) ; 
variable_ID := function_ID ( variable_ID , variable_ID , variable_ID ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
if ( variable_ID ) then 
variable_ID [ INTEGER * variable_ID - INTEGER ] := STRING 
else 
variable_ID [ INTEGER * variable_ID - INTEGER ] := STRING ; 
while ( variable_ID = constant_ID ) do 
begin 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
procedure_ID ( variable_ID , variable_ID , variable_ID + INTEGER , variable_ID <> constant_ID , variable_ID ) ; 
variable_ID := variable_ID ; 
variable_ID := variable_ID ; 
for variable_ID := INTEGER to variable_ID do 
write ( STRING ) ; 
end ; 
procedure_ID ( variable_ID ) ; 
end ; 
procedure ID ( ID : type_ID ) ; 
var 
ID : type_ID ; 
ID : type_ID ; 
begin 
for variable_ID := INTEGER to INTEGER do 
variable_ID [ variable_ID ] := STRING ; 
procedure_ID ( variable_ID , INTEGER , INTEGER , constant_ID , variable_ID ) ; 
end ; 
procedure ID ; 
var ID : type_ID ; 
ID : type_ID ; 
begin 
variable_ID := function_ID ( variable_ID ) ; 
if ( variable_ID = constant_ID ) then 
begin 
writeln ( STRING , variable_ID ) ; 
variable_ID [ variable_ID ] := constant_ID ; 
end 
else writeln ( STRING ) ; 
end ; 
procedure ID ; 
var ID , ID , ID : type_ID ; 
begin 
writeln ( STRING ) ; 
readln ( variable_ID ) ; 
writeln ( STRING ) ; 
readln ( variable_ID ) ; 
writeln ( STRING ) ; 
readln ( variable_ID ) ; 
if ( variable_ID [ variable_ID ] = constant_ID ) and ( variable_ID [ variable_ID ] = constant_ID ) then 
begin 
procedure_ID ( variable_ID , variable_ID , variable_ID ) ; 
writeln ( STRING , variable_ID , STRING , variable_ID , STRING , variable_ID ) ; 
end 
else writeln ( STRING ) 
end ; 
procedure ID ; 
var ID : type_ID ; 
ID : type_ID ; 
begin 
writeln ( STRING ) ; 
readln ( variable_ID ) ; 
variable_ID := function_ID ( variable_ID ) ; 
if ( variable_ID = constant_ID ) then 
begin 
writeln ( STRING , variable_ID , STRING ) ; 
variable_ID [ variable_ID ] := constant_ID ; 
end 
else writeln ( STRING ) ; 
end ; 
procedure ID ; 
var ID : type_ID ; 
ID : type_ID ; 
begin 
writeln ( STRING ) ; 
readln ( variable_ID ) ; 
if ( variable_ID [ variable_ID ] = constant_ID ) then writeln ( STRING ) 
else procedure_ID ( variable_ID ) ; 
end ; 
function ID : type_ID ; 
begin 
writeln ; 
writeln ( STRING ) ; 
writeln ( STRING ) ; 
writeln ( STRING ) ; 
writeln ( STRING ) ; 
writeln ( STRING ) ; 
writeln ; 
repeat 
writeln ( STRING ) ; 
readln ( variable_ID ) ; 
until variable_ID in [ INTEGER , INTEGER , INTEGER , INTEGER , INTEGER ] ; 
function_ID := variable_ID ; 
end ; 
begin 
variable_ID := INTEGER ; 
variable_ID := INTEGER ; 
variable_ID := INTEGER ; 
variable_ID := INTEGER ; 
variable_ID := INTEGER ; 
repeat 
variable_ID := function_ID ; 
case variable_ID of INTEGER 
: procedure_ID ; INTEGER 
: procedure_ID ; INTEGER 
: procedure_ID ; INTEGER 
: procedure_ID ; INTEGER 
: ; 
end ; 
until variable_ID = INTEGER ; 
end .$


iso_pascal_7185_BNFright_quad
$(* ART3 grammar generated by ART from 'iso_pascalV2.art' on May 13 2018 10:56:48 *)

program ::= program_heading ';' program_block '.' 


ART_C_1 ::=
   ',' actual_parameter ART_C_1 |
   # 

ART_C_10 ::=
   ',' index_expression ART_C_10 |
   # 

ART_C_11 ::=
   ',' label ART_C_11 |
   # 

ART_C_12 ::=
   # |
   procedure_declaration ';' ART_C_12 |
   function_declaration ';' ART_C_12 

ART_C_13 ::=
   ',' variable_access ART_C_13 |
   # 

ART_C_14 ::=
   ',' variable_access ART_C_14 |
   # 

ART_C_15 ::=
   ',' record_variable ART_C_15 |
   # 

ART_C_16 ::=
   ',' member_designator ART_C_16 |
   # 

ART_C_17 ::=
   adding_operator term ART_C_17 |
   # 

ART_C_18 ::=
   ';' statement ART_C_18 |
   # 

ART_C_19 ::=
   multiplying_operator factor ART_C_19 |
   # 

ART_C_2 ::=
   ',' index_type ART_C_2 |
   # 

ART_C_20 ::=
   type_definition ';' ART_C_20 |
   # 

ART_C_21 ::=
   ';' index_type_specification ART_C_21 |
   # 

ART_C_22 ::=
   variable_declaration ';' ART_C_22 |
   # 

ART_C_23 ::=
   ';' variant ART_C_23 |
   # 

ART_C_24 ::=
   ',' write_parameter ART_C_24 |
   # 

ART_C_25 ::=
   ',' write_parameter ART_C_25 |
   # 

ART_C_3 ::=
   ',' case_constant ART_C_3 |
   # 

ART_C_4 ::=
   ';' case_list_element ART_C_4 |
   # 

ART_C_5 ::=
   constant_definition ';' ART_C_5 |
   # 

ART_C_6 ::=
   digit ART_C_6 |
   # 

ART_C_7 ::=
   ';' record_section ART_C_7 |
   # 

ART_C_8 ::=
   ';' formal_parameter_section ART_C_8 |
   # 

ART_C_9 ::=
   ',' identifier ART_C_9 |
   # 

Boolean_expression ::=
   expression 

actual_parameter ::=
   expression |
   variable_access |
   procedure_identifier |
   function_identifier 

actual_parameter_list ::=
   '(' actual_parameter ART_C_1 ')' 

adding_operator ::=
   '+' |
   '-' |
   'or' 

apostrophe_image ::=
   '\"' 

array_type ::=
   'array' '[' index_type ART_C_2 ']' 'of' component_type 

array_variable ::=
   variable_access 

assignment_statement ::=
   variable_access ':=' expression |
   function_identifier ':=' expression 

base_type ::=
   ordinal_type 

block ::=
   label_declaration_part constant_definition_part type_definition_part variable_declaration_part procedure_and_function_declaration_part statement_part 

bound_identifier ::=
   identifier 

buffer_variable ::=
   file_variable '^' 

case_constant ::=
   constant 

case_constant_list ::=
   case_constant ART_C_3 

case_index ::=
   expression 

case_list_element ::=
   case_constant_list ':' statement 

case_statement ::=
   'case' case_index 'of' case_list_element ART_C_4 'end' |
   'case' case_index 'of' case_list_element ART_C_4 ';' 'end' 

character_string ::=
   'STRING' 

component_type ::=
   type_denoter 

component_variable ::=
   indexed_variable |
   field_designator 

compound_statement ::=
   'begin' statement_sequence 'end' 

conditional_statement ::=
   if_statement |
   case_statement 

conformant_array_parameter_specification ::=
   value_conformant_array_specification |
   variable_conformant_array_specification 

conformant_array_schema ::=
   packed_conformant_array_schema |
   unpacked_conformant_array_schema 

constant ::=
   character_string |
   unsigned_number |
   constant_identifier |
   sign unsigned_number |
   sign constant_identifier 

constant_definition ::=
   identifier '=' constant 

constant_definition_part ::=
   # |
   'const' constant_definition ';' ART_C_5 

constant_identifier ::=
   'constant_ID' 

control_variable ::=
   entire_variable 

digit ::=
   '0' |
   '1' |
   '2' |
   '3' |
   '4' |
   '5' |
   '6' |
   '7' |
   '8' |
   '9' 

digit_sequence ::=
   digit ART_C_6 

directive ::=
   'ID' 

domain_type ::=
   type_identifier 

else_part ::=
   'else' statement 

entire_variable ::=
   variable_identifier 

enumerated_type ::=
   '(' identifier_list ')' 

expression ::=
   simple_expression |
   simple_expression relational_operator simple_expression 

factor ::=
   variable_access |
   unsigned_constant |
   function_designator |
   set_constructor |
   '(' expression ')' |
   'not' factor 

field_designator ::=
   record_variable '.' field_specifier |
   field_designator_identifier 

field_designator_identifier ::=
   identifier 

field_identifier ::=
   'field_ID' 

field_list ::=
   # |
   variant_part |
   variant_part ';' |
   fixed_part |
   fixed_part ';' |
   fixed_part ';' variant_part |
   fixed_part ';' variant_part ';' 

field_specifier ::=
   field_identifier 

file_type ::=
   'file' 'of' component_type 

file_variable ::=
   variable_access 

final_value ::=
   expression 

fixed_part ::=
   record_section ART_C_7 

for_statement ::=
   'for' control_variable ':=' initial_value 'to' final_value 'do' statement |
   'for' control_variable ':=' initial_value 'downto' final_value 'do' statement 

formal_parameter_list ::=
   '(' formal_parameter_section ART_C_8 ')' 

formal_parameter_section ::=
   value_parameter_specification |
   variable_parameter_specification |
   procedural_parameter_specification |
   functional_parameter_specification 

fractional_part ::=
   digit_sequence 

function_block ::=
   block 

function_declaration ::=
   function_heading ';' directive |
   function_identification ';' function_block |
   function_heading ';' function_block 

function_designator ::=
   function_identifier |
   function_identifier actual_parameter_list 

function_heading ::=
   'function' identifier ':' result_type |
   'function' identifier formal_parameter_list ':' result_type 

function_identification ::=
   'function' function_identifier 

function_identifier ::=
   'function_ID' 

functional_parameter_specification ::=
   function_heading 

goto_statement ::=
   'goto' label 

identified_variable ::=
   pointer_variable '^' 

identifier ::=
   'ID' 

identifier_list ::=
   identifier ART_C_9 

if_statement ::=
   'if' Boolean_expression 'then' statement |
   'if' Boolean_expression 'then' statement else_part 

index_expression ::=
   expression 

index_type ::=
   ordinal_type 

index_type_specification ::=
   identifier '..' identifier ':' ordinal_type_identifier 

indexed_variable ::=
   array_variable '[' index_expression ART_C_10 ']' 

initial_value ::=
   expression 

label ::=
   digit_sequence 

label_declaration_part ::=
   # |
   'label' label ART_C_11 ';' 

letter ::=
   'a' |
   'b' |
   'c' |
   'd' |
   'e' |
   'f' |
   'g' |
   'h' |
   'i' |
   'j' |
   'k' |
   'l' |
   'm' |
   'n' |
   'o' |
   'p' |
   'q' |
   'r' |
   's' |
   't' |
   'u' |
   'v' |
   'w' |
   'x' |
   'y' |
   'z' 

member_designator ::=
   expression |
   expression '..' expression 

multiplying_operator ::=
   '*' |
   '/' |
   'div' |
   'mod' |
   'and' 

new_ordinal_type ::=
   enumerated_type |
   subrange_type 

new_pointer_type ::=
   '^' domain_type 

new_structured_type ::=
   unpacked_structured_type |
   'packed' unpacked_structured_type 

new_type ::=
   new_ordinal_type |
   new_structured_type |
   new_pointer_type 

ordinal_type ::=
   new_ordinal_type |
   ordinal_type_identifier 

ordinal_type_identifier ::=
   type_identifier 

packed_conformant_array_schema ::=
   'packed' 'array' '[' index_type_specification ']' 'of' type_identifier 

pointer_type ::=
   new_pointer_type |
   pointer_type_identifier 

pointer_type_identifier ::=
   type_identifier 

pointer_variable ::=
   variable_access 

procedural_parameter_specification ::=
   procedure_heading 

procedure_and_function_declaration_part ::=
   ART_C_12 

procedure_block ::=
   block 

procedure_declaration ::=
   procedure_heading ';' directive |
   procedure_identification ';' procedure_block |
   procedure_heading ';' procedure_block 

procedure_heading ::=
   'procedure' identifier |
   'procedure' identifier formal_parameter_list 

procedure_identification ::=
   'procedure' procedure_identifier 

procedure_identifier ::=
   'procedure_ID' |
   'write' |
   'writeln' |
   'read' |
   'readln' 

procedure_statement ::=
   procedure_identifier read_parameter_list |
   procedure_identifier readln_parameter_list |
   procedure_identifier write_parameter_list |
   procedure_identifier writeln_parameter_list |
   procedure_identifier |
   procedure_identifier actual_parameter_list 

// program ::= program_heading ';' program_block '.' 

program_block ::=
   block 

program_heading ::=
   'program' identifier |
   'program' identifier '(' program_parameter_list ')' 

program_parameter_list ::=
   identifier_list 

read_parameter_list ::=
   '(' variable_access ART_C_13 ')' |
   '(' file_variable ',' variable_access ART_C_13 ')' 

readln_parameter_list ::=
   # |
   '(' file_variable ART_C_14 ')' |
   '(' variable_access ART_C_14 ')' 

real_type_identifier ::=
   type_identifier 

record_section ::=
   identifier_list ':' type_denoter 

record_type ::=
   'record' field_list 'end' 

record_variable ::=
   variable_access 

record_variable_list ::=
   record_variable ART_C_15 

relational_operator ::=
   '=' |
   '<>' |
   '<' |
   '>' |
   '<=' |
   '>=' |
   'in' 

repeat_statement ::=
   'repeat' statement_sequence 'until' Boolean_expression 

repetitive_statement ::=
   repeat_statement |
   while_statement |
   for_statement 

result_type ::=
   simple_type_identifier |
   pointer_type_identifier 

scale_factor ::=
   digit_sequence |
   sign digit_sequence 

set_constructor ::=
   '[' ']' |
   '[' member_designator ART_C_16 ']' 

set_type ::=
   'set' 'of' base_type 

sign ::=
   '+' |
   '-' 

signed_integer ::=
   unsigned_integer |
   sign unsigned_integer 

signed_number ::=
   signed_integer |
   signed_real 

signed_real ::=
   unsigned_real |
   sign unsigned_real 

simple_expression ::=
   term ART_C_17 |
   sign term ART_C_17 

simple_statement ::=
   # |
   assignment_statement |
   procedure_statement |
   goto_statement 

simple_type ::=
   ordinal_type |
   real_type_identifier 

simple_type_identifier ::=
   type_identifier 

special_symbol ::=
   '+' |
   '-' |
   '*' |
   '/' |
   '=' |
   '<' |
   '>' |
   '[' |
   ']' |
   '.' |
   ',' |
   ':' |
   ';' |
   '^' |
   '(' |
   ')' |
   '<>' |
   '<=' |
   '>=' |
   ':=' |
   '..' |
   word_symbol 

statement ::=
   simple_statement |
   structured_statement |
   label ':' simple_statement |
   label ':' structured_statement 

statement_part ::=
   compound_statement 

statement_sequence ::=
   statement ART_C_18 

structured_statement ::=
   compound_statement |
   conditional_statement |
   repetitive_statement |
   with_statement 

structured_type ::=
   new_structured_type |
   structured_type_identifier 

structured_type_identifier ::=
   type_identifier 

subrange_type ::=
   constant '..' constant 

tag_field ::=
   identifier 

tag_type ::=
   ordinal_type_identifier 

term ::=
   factor ART_C_19 

type_definition ::=
   identifier '=' type_denoter 

type_definition_part ::=
   # |
   'type' type_definition ';' ART_C_20 

type_denoter ::=
   type_identifier |
   new_type 

type_identifier ::=
   'type_ID' 

unpacked_conformant_array_schema ::=
   'array' '[' index_type_specification ART_C_21 ']' 'of' type_identifier |
   'array' '[' index_type_specification ART_C_21 ']' 'of' conformant_array_schema 

unpacked_structured_type ::=
   array_type |
   record_type |
   set_type |
   file_type 

unsigned_constant ::=
   unsigned_number |
   character_string |
   constant_identifier |
   'nil' 

unsigned_integer ::=
   'INTEGER' 

unsigned_number ::=
   unsigned_integer |
   unsigned_real 

unsigned_real ::=
   'REAL' 

value_conformant_array_specification ::=
   identifier_list ':' conformant_array_schema 

value_parameter_specification ::=
   identifier_list ':' type_identifier 

variable_access ::=
   entire_variable |
   component_variable |
   identified_variable |
   buffer_variable 

variable_conformant_array_specification ::=
   'var' identifier_list ':' conformant_array_schema 

variable_declaration ::=
   identifier_list ':' type_denoter 

variable_declaration_part ::=
   # |
   'var' variable_declaration ';' ART_C_22 

variable_identifier ::=
   'variable_ID' 

variable_parameter_specification ::=
   'var' identifier_list ':' type_identifier 

variant ::=
   case_constant_list ':' '(' field_list ')' 

variant_part ::=
   'case' variant_selector 'of' variant ART_C_23 

variant_selector ::=
   tag_type |
   tag_field ':' tag_type 

while_statement ::=
   'while' Boolean_expression 'do' statement 

with_statement ::=
   'with' record_variable_list 'do' statement 

word_symbol ::=
   'and' |
   'array' |
   'begin' |
   'case' |
   'const' |
   'div' |
   'do' |
   'downto' |
   'else' |
   'end' |
   'file' |
   'for' |
   'function' |
   'goto' |
   'if' |
   'in' |
   'label' |
   'mod' |
   'nil' |
   'not' |
   'of' |
   'or' |
   'packed' |
   'procedure' |
   'program' |
   'record' |
   'repeat' |
   'set' |
   'then' |
   'to' |
   'type' |
   'until' |
   'var' |
   'while' |
   'with' 

write_parameter ::=
   expression |
   expression ':' expression |
   expression ':' expression ':' expression 

write_parameter_list ::=
   '(' write_parameter ART_C_24 ')' |
   '(' file_variable ',' write_parameter ART_C_24 ')' 

writeln_parameter_list ::=
   # |
   '(' file_variable ART_C_25 ')' |
   '(' write_parameter ART_C_25 ')' 

$
accept
$program ID ( ID , ID ) ; 
var ID , ID , ID , ID : type_ID ; 
ID : type_ID ; 
procedure ID ( ID : type_ID ; var ID : type_ID ) ; 
begin 
variable_ID := variable_ID + INTEGER ; 
while function_ID ( ( variable_ID * variable_ID ) - variable_ID ) > REAL do 
variable_ID := variable_ID - ( ( ( variable_ID * variable_ID ) - variable_ID ) / ( REAL * variable_ID ) ) 
end ; 
procedure ID ( ID , ID , ID : type_ID ; var ID : type_ID ) ; 
var ID , ID : type_ID ; 
begin 
variable_ID := variable_ID * variable_ID - INTEGER * variable_ID * variable_ID ; 
procedure_ID ( variable_ID , variable_ID ) ; 
variable_ID := ( - variable_ID + variable_ID ) / ( INTEGER * variable_ID ) ; 
end ; 
procedure ID ( ID , ID , ID : type_ID ; var ID : type_ID ; var ID : type_ID ) ; 
begin 
if variable_ID * variable_ID < INTEGER * variable_ID * variable_ID then 
begin 
variable_ID := constant_ID ; 
variable_ID := - INTEGER ; 
end 
else 
begin 
procedure_ID ( variable_ID , variable_ID , variable_ID , variable_ID ) ; 
variable_ID := constant_ID ; 
end ; 
end ; 
begin 
write ( STRING ) ; 
readln ( variable_ID ) ; 
write ( STRING ) ; 
readln ( variable_ID ) ; 
write ( STRING ) ; 
readln ( variable_ID ) ; 
write ( STRING ) ; 
procedure_ID ( variable_ID , variable_ID , variable_ID , variable_ID , variable_ID ) ; 
if variable_ID = constant_ID then 
writeln ( STRING ) 
else writeln ( STRING , variable_ID : INTEGER : INTEGER , STRING ) 
end .$



iso_pascal_7185_BNFleft_treeview
$(* ART3 grammar generated by ART from 'iso_pascalV2.art' on May 13 2018 10:57:00 *)

program ::= program_heading ';' program_block '.'

ART_C_1 ::=
   ART_C_1 ',' actual_parameter |
   # 

ART_C_10 ::=
   ART_C_10 ',' index_expression |
   # 

ART_C_11 ::=
   ART_C_11 ',' label |
   # 

ART_C_12 ::=
   # |
   ART_C_12 procedure_declaration ';' |
   ART_C_12 function_declaration ';' 

ART_C_13 ::=
   ART_C_13 ',' variable_access |
   # 

ART_C_14 ::=
   ART_C_14 ',' variable_access |
   # 

ART_C_15 ::=
   ART_C_15 ',' record_variable |
   # 

ART_C_16 ::=
   ART_C_16 ',' member_designator |
   # 

ART_C_17 ::=
   ART_C_17 adding_operator term |
   # 

ART_C_18 ::=
   ART_C_18 ';' statement |
   # 

ART_C_19 ::=
   ART_C_19 multiplying_operator factor |
   # 

ART_C_2 ::=
   ART_C_2 ',' index_type |
   # 

ART_C_20 ::=
   ART_C_20 type_definition ';' |
   # 

ART_C_21 ::=
   ART_C_21 ';' index_type_specification |
   # 

ART_C_22 ::=
   ART_C_22 variable_declaration ';' |
   # 

ART_C_23 ::=
   ART_C_23 ';' variant |
   # 

ART_C_24 ::=
   ART_C_24 ',' write_parameter |
   # 

ART_C_25 ::=
   ART_C_25 ',' write_parameter |
   # 

ART_C_3 ::=
   ART_C_3 ',' case_constant |
   # 

ART_C_4 ::=
   ART_C_4 ';' case_list_element |
   # 

ART_C_5 ::=
   ART_C_5 constant_definition ';' |
   # 

ART_C_6 ::=
   ART_C_6 digit |
   # 

ART_C_7 ::=
   ART_C_7 ';' record_section |
   # 

ART_C_8 ::=
   ART_C_8 ';' formal_parameter_section |
   # 

ART_C_9 ::=
   ART_C_9 ',' identifier |
   # 

Boolean_expression ::=
   expression 

actual_parameter ::=
   expression |
   variable_access |
   procedure_identifier |
   function_identifier 

actual_parameter_list ::=
   '(' actual_parameter ART_C_1 ')' 

adding_operator ::=
   '+' |
   '-' |
   'or' 

apostrophe_image ::=
   '\"' 

array_type ::=
   'array' '[' index_type ART_C_2 ']' 'of' component_type 

array_variable ::=
   variable_access 

assignment_statement ::=
   variable_access ':=' expression |
   function_identifier ':=' expression 

base_type ::=
   ordinal_type 

block ::=
   label_declaration_part constant_definition_part type_definition_part variable_declaration_part procedure_and_function_declaration_part statement_part 

bound_identifier ::=
   identifier 

buffer_variable ::=
   file_variable '^' 

case_constant ::=
   constant 

case_constant_list ::=
   case_constant ART_C_3 

case_index ::=
   expression 

case_list_element ::=
   case_constant_list ':' statement 

case_statement ::=
   'case' case_index 'of' case_list_element ART_C_4 'end' |
   'case' case_index 'of' case_list_element ART_C_4 ';' 'end' 

character_string ::=
   'STRING' 

component_type ::=
   type_denoter 

component_variable ::=
   indexed_variable |
   field_designator 

compound_statement ::=
   'begin' statement_sequence 'end' 

conditional_statement ::=
   if_statement |
   case_statement 

conformant_array_parameter_specification ::=
   value_conformant_array_specification |
   variable_conformant_array_specification 

conformant_array_schema ::=
   packed_conformant_array_schema |
   unpacked_conformant_array_schema 

constant ::=
   character_string |
   unsigned_number |
   constant_identifier |
   sign unsigned_number |
   sign constant_identifier 

constant_definition ::=
   identifier '=' constant 

constant_definition_part ::=
   # |
   'const' constant_definition ';' ART_C_5 

constant_identifier ::=
   'constant_ID' 

control_variable ::=
   entire_variable 

digit ::=
   '0' |
   '1' |
   '2' |
   '3' |
   '4' |
   '5' |
   '6' |
   '7' |
   '8' |
   '9' 

digit_sequence ::=
   digit ART_C_6 

directive ::=
   'ID' 

domain_type ::=
   type_identifier 

else_part ::=
   'else' statement 

entire_variable ::=
   variable_identifier 

enumerated_type ::=
   '(' identifier_list ')' 

expression ::=
   simple_expression |
   simple_expression relational_operator simple_expression 

factor ::=
   variable_access |
   unsigned_constant |
   function_designator |
   set_constructor |
   '(' expression ')' |
   'not' factor 

field_designator ::=
   record_variable '.' field_specifier |
   field_designator_identifier 

field_designator_identifier ::=
   identifier 

field_identifier ::=
   'field_ID' 

field_list ::=
   # |
   variant_part |
   variant_part ';' |
   fixed_part |
   fixed_part ';' |
   fixed_part ';' variant_part |
   fixed_part ';' variant_part ';' 

field_specifier ::=
   field_identifier 

file_type ::=
   'file' 'of' component_type 

file_variable ::=
   variable_access 

final_value ::=
   expression 

fixed_part ::=
   record_section ART_C_7 

for_statement ::=
   'for' control_variable ':=' initial_value 'to' final_value 'do' statement |
   'for' control_variable ':=' initial_value 'downto' final_value 'do' statement 

formal_parameter_list ::=
   '(' formal_parameter_section ART_C_8 ')' 

formal_parameter_section ::=
   value_parameter_specification |
   variable_parameter_specification |
   procedural_parameter_specification |
   functional_parameter_specification 

fractional_part ::=
   digit_sequence 

function_block ::=
   block 

function_declaration ::=
   function_heading ';' directive |
   function_identification ';' function_block |
   function_heading ';' function_block 

function_designator ::=
   function_identifier |
   function_identifier actual_parameter_list 

function_heading ::=
   'function' identifier ':' result_type |
   'function' identifier formal_parameter_list ':' result_type 

function_identification ::=
   'function' function_identifier 

function_identifier ::=
   'function_ID' 

functional_parameter_specification ::=
   function_heading 

goto_statement ::=
   'goto' label 

identified_variable ::=
   pointer_variable '^' 

identifier ::=
   'ID' 

identifier_list ::=
   identifier ART_C_9 

if_statement ::=
   'if' Boolean_expression 'then' statement |
   'if' Boolean_expression 'then' statement else_part 

index_expression ::=
   expression 

index_type ::=
   ordinal_type 

index_type_specification ::=
   identifier '..' identifier ':' ordinal_type_identifier 

indexed_variable ::=
   array_variable '[' index_expression ART_C_10 ']' 

initial_value ::=
   expression 

label ::=
   digit_sequence 

label_declaration_part ::=
   # |
   'label' label ART_C_11 ';' 

letter ::=
   'a' |
   'b' |
   'c' |
   'd' |
   'e' |
   'f' |
   'g' |
   'h' |
   'i' |
   'j' |
   'k' |
   'l' |
   'm' |
   'n' |
   'o' |
   'p' |
   'q' |
   'r' |
   's' |
   't' |
   'u' |
   'v' |
   'w' |
   'x' |
   'y' |
   'z' 

member_designator ::=
   expression |
   expression '..' expression 

multiplying_operator ::=
   '*' |
   '/' |
   'div' |
   'mod' |
   'and' 

new_ordinal_type ::=
   enumerated_type |
   subrange_type 

new_pointer_type ::=
   '^' domain_type 

new_structured_type ::=
   unpacked_structured_type |
   'packed' unpacked_structured_type 

new_type ::=
   new_ordinal_type |
   new_structured_type |
   new_pointer_type 

ordinal_type ::=
   new_ordinal_type |
   ordinal_type_identifier 

ordinal_type_identifier ::=
   type_identifier 

packed_conformant_array_schema ::=
   'packed' 'array' '[' index_type_specification ']' 'of' type_identifier 

pointer_type ::=
   new_pointer_type |
   pointer_type_identifier 

pointer_type_identifier ::=
   type_identifier 

pointer_variable ::=
   variable_access 

procedural_parameter_specification ::=
   procedure_heading 

procedure_and_function_declaration_part ::=
   ART_C_12 

procedure_block ::=
   block 

procedure_declaration ::=
   procedure_heading ';' directive |
   procedure_identification ';' procedure_block |
   procedure_heading ';' procedure_block 

procedure_heading ::=
   'procedure' identifier |
   'procedure' identifier formal_parameter_list 

procedure_identification ::=
   'procedure' procedure_identifier 

procedure_identifier ::=
   'procedure_ID' |
   'write' |
   'writeln' |
   'read' |
   'readln' 

procedure_statement ::=
   procedure_identifier read_parameter_list |
   procedure_identifier readln_parameter_list |
   procedure_identifier write_parameter_list |
   procedure_identifier writeln_parameter_list |
   procedure_identifier |
   procedure_identifier actual_parameter_list 

//program ::= program_heading ';' program_block '.' 

program_block ::=
   block 

program_heading ::=
   'program' identifier |
   'program' identifier '(' program_parameter_list ')' 

program_parameter_list ::=
   identifier_list 

read_parameter_list ::=
   '(' variable_access ART_C_13 ')' |
   '(' file_variable ',' variable_access ART_C_13 ')' 

readln_parameter_list ::=
   # |
   '(' file_variable ART_C_14 ')' |
   '(' variable_access ART_C_14 ')' 

real_type_identifier ::=
   type_identifier 

record_section ::=
   identifier_list ':' type_denoter 

record_type ::=
   'record' field_list 'end' 

record_variable ::=
   variable_access 

record_variable_list ::=
   record_variable ART_C_15 

relational_operator ::=
   '=' |
   '<>' |
   '<' |
   '>' |
   '<=' |
   '>=' |
   'in' 

repeat_statement ::=
   'repeat' statement_sequence 'until' Boolean_expression 

repetitive_statement ::=
   repeat_statement |
   while_statement |
   for_statement 

result_type ::=
   simple_type_identifier |
   pointer_type_identifier 

scale_factor ::=
   digit_sequence |
   sign digit_sequence 

set_constructor ::=
   '[' ']' |
   '[' member_designator ART_C_16 ']' 

set_type ::=
   'set' 'of' base_type 

sign ::=
   '+' |
   '-' 

signed_integer ::=
   unsigned_integer |
   sign unsigned_integer 

signed_number ::=
   signed_integer |
   signed_real 

signed_real ::=
   unsigned_real |
   sign unsigned_real 

simple_expression ::=
   term ART_C_17 |
   sign term ART_C_17 

simple_statement ::=
   # |
   assignment_statement |
   procedure_statement |
   goto_statement 

simple_type ::=
   ordinal_type |
   real_type_identifier 

simple_type_identifier ::=
   type_identifier 

special_symbol ::=
   '+' |
   '-' |
   '*' |
   '/' |
   '=' |
   '<' |
   '>' |
   '[' |
   ']' |
   '.' |
   ',' |
   ':' |
   ';' |
   '^' |
   '(' |
   ')' |
   '<>' |
   '<=' |
   '>=' |
   ':=' |
   '..' |
   word_symbol 

statement ::=
   simple_statement |
   structured_statement |
   label ':' simple_statement |
   label ':' structured_statement 

statement_part ::=
   compound_statement 

statement_sequence ::=
   statement ART_C_18 

structured_statement ::=
   compound_statement |
   conditional_statement |
   repetitive_statement |
   with_statement 

structured_type ::=
   new_structured_type |
   structured_type_identifier 

structured_type_identifier ::=
   type_identifier 

subrange_type ::=
   constant '..' constant 

tag_field ::=
   identifier 

tag_type ::=
   ordinal_type_identifier 

term ::=
   factor ART_C_19 

type_definition ::=
   identifier '=' type_denoter 

type_definition_part ::=
   # |
   'type' type_definition ';' ART_C_20 

type_denoter ::=
   type_identifier |
   new_type 

type_identifier ::=
   'type_ID' 

unpacked_conformant_array_schema ::=
   'array' '[' index_type_specification ART_C_21 ']' 'of' type_identifier |
   'array' '[' index_type_specification ART_C_21 ']' 'of' conformant_array_schema 

unpacked_structured_type ::=
   array_type |
   record_type |
   set_type |
   file_type 

unsigned_constant ::=
   unsigned_number |
   character_string |
   constant_identifier |
   'nil' 

unsigned_integer ::=
   'INTEGER' 

unsigned_number ::=
   unsigned_integer |
   unsigned_real 

unsigned_real ::=
   'REAL' 

value_conformant_array_specification ::=
   identifier_list ':' conformant_array_schema 

value_parameter_specification ::=
   identifier_list ':' type_identifier 

variable_access ::=
   entire_variable |
   component_variable |
   identified_variable |
   buffer_variable 

variable_conformant_array_specification ::=
   'var' identifier_list ':' conformant_array_schema 

variable_declaration ::=
   identifier_list ':' type_denoter 

variable_declaration_part ::=
   # |
   'var' variable_declaration ';' ART_C_22 

variable_identifier ::=
   'variable_ID' 

variable_parameter_specification ::=
   'var' identifier_list ':' type_identifier 

variant ::=
   case_constant_list ':' '(' field_list ')' 

variant_part ::=
   'case' variant_selector 'of' variant ART_C_23 

variant_selector ::=
   tag_type |
   tag_field ':' tag_type 

while_statement ::=
   'while' Boolean_expression 'do' statement 

with_statement ::=
   'with' record_variable_list 'do' statement 

word_symbol ::=
   'and' |
   'array' |
   'begin' |
   'case' |
   'const' |
   'div' |
   'do' |
   'downto' |
   'else' |
   'end' |
   'file' |
   'for' |
   'function' |
   'goto' |
   'if' |
   'in' |
   'label' |
   'mod' |
   'nil' |
   'not' |
   'of' |
   'or' |
   'packed' |
   'procedure' |
   'program' |
   'record' |
   'repeat' |
   'set' |
   'then' |
   'to' |
   'type' |
   'until' |
   'var' |
   'while' |
   'with' 

write_parameter ::=
   expression |
   expression ':' expression |
   expression ':' expression ':' expression 

write_parameter_list ::=
   '(' write_parameter ART_C_24 ')' |
   '(' file_variable ',' write_parameter ART_C_24 ')' 

writeln_parameter_list ::=
   # |
   '(' file_variable ART_C_25 ')' |
   '(' write_parameter ART_C_25 ')' 

$
accept
$program ID ( ID , ID ) ; 
const ID = INTEGER ; 
ID = INTEGER ; 
ID = INTEGER ; 
ID = INTEGER ; 
type ID = INTEGER .. constant_ID ; 
ID = ( ID , ID , ID ) ; 
ID = array [ INTEGER .. INTEGER ] of type_ID ; 
ID = INTEGER .. constant_ID ; 
ID = ( ID , ID , ID , ID ) ; 
ID = record 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
end ; 
ID = INTEGER .. constant_ID ; 
ID = ( ID , ID , ID , ID ) ; 
ID = INTEGER .. constant_ID ; 
ID = ^ type_ID ; 
ID = ^ type_ID ; 
ID = ^ type_ID ; 
ID = record 
ID : type_ID ; 
ID : type_ID ; 
end ; 
ID = record 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
end ; 
ID = record 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
end ; 
ID = ^ type_ID ; 
ID = record 
ID : type_ID ; 
ID : type_ID ; 
end ; 
ID = ^ type_ID ; 
ID = record 
ID : type_ID ; 
ID : type_ID ; 
end ; 
ID = type_ID ; 
ID = ^ type_ID ; 
ID = ^ type_ID ; 
var ID : array [ INTEGER .. constant_ID ] of type_ID ; 
ID : type_ID ; 
ID : array [ INTEGER .. constant_ID ] of type_ID ; 
ID : type_ID ; 
ID : array [ INTEGER .. constant_ID ] of type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : array [ INTEGER .. constant_ID ] of type_ID ; 
ID : array [ INTEGER .. constant_ID ] of type_ID ; 
ID : array [ INTEGER .. constant_ID ] of type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : array [ INTEGER .. constant_ID ] of type_ID ; 
function ID ( 
var ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID ; 
var ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
function ID ( 
var ID : type_ID ; 
ID : type_ID 
) : type_ID ; ID ; 
procedure ID ( ID : type_ID ) ; 
begin 
if variable_ID <> nil then 
begin 
procedure_ID ( variable_ID ^ . field_ID ) ; 
procedure_ID ( variable_ID ) ; 
end 
end ; 
function function_ID ; 
begin 
if variable_ID = constant_ID then 
function_ID := constant_ID 
else 
begin 
variable_ID := variable_ID + INTEGER ; 
if variable_ID = INTEGER then 
variable_ID := variable_ID 
else 
begin 
variable_ID := variable_ID [ variable_ID ] ; 
variable_ID := variable_ID - INTEGER ; 
end ; 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID [ variable_ID ] ^ . field_ID := INTEGER ; 
variable_ID [ variable_ID ] ^ . field_ID := nil ; 
function_ID := constant_ID ; 
end 
end ; 
function function_ID ; 
begin 
function_ID := constant_ID ; 
if ( variable_ID > INTEGER ) and ( variable_ID < constant_ID + INTEGER ) then 
if variable_ID [ variable_ID ] <> nil then 
begin 
procedure_ID ( variable_ID [ variable_ID ] ^ . field_ID ) ; 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID [ variable_ID ] := nil ; 
variable_ID := variable_ID + INTEGER ; 
variable_ID := variable_ID - INTEGER ; 
variable_ID [ variable_ID ] := variable_ID ; 
function_ID := constant_ID ; 
end 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
begin 
variable_ID := function_ID ( variable_ID , variable_ID , variable_ID ) ; 
if ( variable_ID = constant_ID ) and not variable_ID then 
begin 
variable_ID [ variable_ID ] ^ . field_ID := variable_ID [ variable_ID ] ^ . field_ID + INTEGER ; 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
procedure_ID ( variable_ID [ variable_ID ] ^ . field_ID ) ; 
variable_ID [ variable_ID ] ^ . field_ID ^ . field_ID := variable_ID ; 
variable_ID [ variable_ID ] ^ . field_ID ^ . field_ID := variable_ID ; 
end ; 
function_ID := variable_ID ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
begin 
variable_ID := function_ID ( variable_ID , variable_ID , variable_ID ) ; 
if ( variable_ID = constant_ID ) then 
if variable_ID then 
begin 
variable_ID [ variable_ID ] ^ . field_ID := variable_ID [ variable_ID ] ^ . field_ID - INTEGER ; 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
while variable_ID ^ . field_ID <> variable_ID do 
begin ; 
variable_ID := variable_ID ; 
variable_ID := variable_ID ^ . field_ID ; 
end ; 
if variable_ID = variable_ID then 
variable_ID [ variable_ID ] ^ . field_ID := variable_ID [ variable_ID ] ^ . field_ID ^ . field_ID 
else 
variable_ID ^ . field_ID := variable_ID ^ . field_ID ; 
procedure_ID ( variable_ID ) ; 
end 
else if not variable_ID then 
variable_ID := constant_ID ; 
function_ID := variable_ID ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
begin 
function_ID := constant_ID ; 
if ( variable_ID > INTEGER ) and ( variable_ID < constant_ID + INTEGER ) then 
if variable_ID [ variable_ID ] <> nil then 
begin 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
variable_ID := constant_ID ; 
while ( variable_ID <> nil ) and ( not variable_ID ) do 
begin 
if variable_ID ^ . field_ID = variable_ID then 
variable_ID := constant_ID ; 
variable_ID := variable_ID ^ . field_ID ; 
end ; 
function_ID := constant_ID ; 
end 
end ; 
function function_ID ; 
begin 
function_ID := constant_ID ; 
if ( variable_ID > INTEGER ) and ( variable_ID < constant_ID + INTEGER ) then 
if variable_ID [ variable_ID ] <> nil then 
begin 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
function_ID := constant_ID ; 
end 
end ; 
function function_ID ; 
var ID : type_ID ; 
begin 
if function_ID ( variable_ID , variable_ID ) = constant_ID then 
begin 
if variable_ID > INTEGER then 
begin 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ^ . field_ID ; 
function_ID := constant_ID ; 
end 
else 
function_ID := constant_ID ; 
end 
else 
function_ID := constant_ID ; 
end ; 
procedure ID ( ID : type_ID ) ; 
var ID : type_ID ; 
begin 
if variable_ID <> nil then 
begin 
procedure_ID ( variable_ID ^ . field_ID ) ; 
if variable_ID ^ . field_ID <> - INTEGER then 
variable_ID := function_ID ( variable_ID ^ . field_ID ) ; 
procedure_ID ( variable_ID ) ; 
end 
end ; 
procedure ID ( ID : type_ID ; ID : type_ID ) ; 
var ID : type_ID ; 
begin 
if variable_ID <> nil then 
begin 
procedure_ID ( variable_ID , variable_ID ^ . field_ID ) ; 
if ( variable_ID ^ . field_ID <> - INTEGER ) and ( variable_ID ^ . field_ID = variable_ID ) then 
begin 
variable_ID := function_ID ( variable_ID ^ . field_ID ) ; 
variable_ID ^ . field_ID := - INTEGER ; 
end ; 
end ; 
end ; 
procedure ID ( ID : type_ID ) ; 
var ID : type_ID ; 
begin 
if variable_ID <> nil then 
begin 
procedure_ID ( variable_ID ^ . field_ID ) ; 
variable_ID := function_ID ( variable_ID ^ . field_ID ) ; 
procedure_ID ( variable_ID ) ; 
end 
end ; 
function ID ( ID : type_ID ) : type_ID ; 
begin 
function_ID := constant_ID ; 
if ( variable_ID < constant_ID + INTEGER ) and ( variable_ID > INTEGER ) then 
if variable_ID [ variable_ID ] <> nil then 
function_ID := constant_ID ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
begin 
if variable_ID = constant_ID then 
function_ID := constant_ID 
else 
begin 
function_ID := constant_ID ; 
variable_ID := variable_ID + INTEGER ; 
if variable_ID = INTEGER then 
variable_ID := variable_ID 
else 
begin 
variable_ID := variable_ID [ variable_ID ] ; 
variable_ID := variable_ID - INTEGER ; 
end ; 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID [ variable_ID ] ^ . field_ID := INTEGER ; 
variable_ID [ variable_ID ] ^ . field_ID := nil ; 
procedure_ID ( variable_ID [ variable_ID ] ^ . field_ID ) ; 
variable_ID [ variable_ID ] ^ . field_ID ^ . field_ID := nil ; 
variable_ID := function_ID ( variable_ID [ variable_ID ] ^ . field_ID ^ . field_ID ) ; 
if variable_ID <> constant_ID then 
function_ID := constant_ID ; 
end ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
begin 
procedure_ID ( variable_ID [ variable_ID ] ^ . field_ID ^ . field_ID ) ; 
procedure_ID ( variable_ID [ variable_ID ] ^ . field_ID ) ; 
variable_ID := function_ID ( variable_ID [ variable_ID ] ^ . field_ID ^ . field_ID ) ; 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID [ variable_ID ] := nil ; 
variable_ID := variable_ID + INTEGER ; 
variable_ID := variable_ID - INTEGER ; 
variable_ID [ variable_ID ] := variable_ID ; 
function_ID := constant_ID ; 
end 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
begin 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
while variable_ID ^ . field_ID <> nil do 
variable_ID := variable_ID ^ . field_ID ; 
procedure_ID ( variable_ID ^ . field_ID ) ; 
variable_ID := variable_ID ^ . field_ID ; 
variable_ID := function_ID ( variable_ID ^ . field_ID ) ; 
if variable_ID = constant_ID then 
begin 
variable_ID [ variable_ID ] ^ . field_ID := variable_ID [ variable_ID ] ^ . field_ID + INTEGER ; 
variable_ID ^ . field_ID := nil ; 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID - INTEGER ; 
function_ID := constant_ID ; 
end 
else 
procedure_ID ( variable_ID ) ; 
end ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
begin 
function_ID := constant_ID ; 
variable_ID := variable_ID + INTEGER ; 
variable_ID := variable_ID + INTEGER ; 
if function_ID ( variable_ID ) then 
begin 
if ( variable_ID <= INTEGER ) or ( variable_ID > variable_ID [ variable_ID ] ^ . field_ID ) or 
( variable_ID <= INTEGER ) or ( variable_ID > variable_ID [ variable_ID ] ^ . field_ID ) then 
begin 
function_ID := constant_ID 
end 
else 
begin 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
for variable_ID := INTEGER to variable_ID do 
variable_ID := variable_ID ^ . field_ID ; 
variable_ID := function_ID ( variable_ID , variable_ID ^ . field_ID ) ; 
if variable_ID = constant_ID then 
begin 
function_ID := constant_ID ; 
procedure_ID ( variable_ID , variable_ID [ variable_ID ] ^ . field_ID ) ; 
end ; 
end ; 
end ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID , ID : type_ID ; 
begin 
variable_ID := constant_ID ; 
if ( variable_ID < INTEGER ) or ( variable_ID >= variable_ID [ variable_ID ] ^ . field_ID ) then 
variable_ID := constant_ID 
else 
begin 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
if variable_ID = constant_ID then 
begin 
variable_ID := function_ID ( variable_ID , variable_ID , variable_ID ) ; 
if variable_ID <> constant_ID then 
begin 
variable_ID [ variable_ID ] ^ . field_ID := variable_ID [ variable_ID ] ^ . field_ID - INTEGER ; 
variable_ID := variable_ID - INTEGER ; 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
variable_ID := nil ; 
while variable_ID ^ . field_ID <> nil do 
begin 
variable_ID := variable_ID ; 
variable_ID := variable_ID ^ . field_ID ; 
end ; 
procedure_ID ( variable_ID ) ; 
variable_ID ^ . field_ID := nil 
end 
end ; 
end ; 
function_ID := variable_ID ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
function ID ( ID : type_ID ; ID : type_ID ) : type_ID ; 
var 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) <> constant_ID then 
function_ID := constant_ID 
else 
begin 
if function_ID ( variable_ID ^ . field_ID ) <> constant_ID then 
begin 
variable_ID := function_ID ( variable_ID ) ; 
function_ID := constant_ID 
end 
else 
begin 
while function_ID ( variable_ID , variable_ID ) = constant_ID do 
begin 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
end ; 
while function_ID ( variable_ID , variable_ID ) = constant_ID do 
begin 
variable_ID := function_ID ( variable_ID , variable_ID ^ . field_ID ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
end ; 
variable_ID := function_ID ( variable_ID ) ; 
end ; 
end ; 
end ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
begin 
variable_ID := variable_ID + INTEGER ; 
if ( variable_ID < INTEGER ) or ( variable_ID > variable_ID [ variable_ID ] ^ . field_ID ) then 
function_ID := constant_ID 
else 
begin 
variable_ID := INTEGER ; 
if variable_ID [ variable_ID ] ^ . field_ID = nil then 
begin 
procedure_ID ( variable_ID [ variable_ID ] ^ . field_ID ) ; 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
end 
else 
begin 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
variable_ID := INTEGER ; 
while variable_ID ^ . field_ID <> nil do 
begin 
variable_ID := variable_ID + INTEGER ; 
variable_ID := variable_ID ^ . field_ID ; 
end ; 
procedure_ID ( variable_ID ^ . field_ID ) ; 
variable_ID := variable_ID ^ . field_ID ; 
end ; 
variable_ID ^ . field_ID := nil ; 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
for variable_ID := INTEGER to variable_ID do 
variable_ID := variable_ID ^ . field_ID ; 
if function_ID ( variable_ID , variable_ID ^ . field_ID ) then 
begin 
variable_ID . field_ID := variable_ID ; 
variable_ID . field_ID := variable_ID ; 
variable_ID . field_ID := variable_ID ; 
variable_ID ^ . field_ID := variable_ID ; 
variable_ID ^ . field_ID := variable_ID . field_ID ; 
function_ID := constant_ID ; 
variable_ID := variable_ID + INTEGER ; 
end ; 
end ; 
end ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
begin 
function_ID := constant_ID ; 
variable_ID := - INTEGER ; 
if function_ID ( variable_ID . field_ID ) then 
begin 
variable_ID := variable_ID [ variable_ID . field_ID ] ^ . field_ID ; 
while ( variable_ID ^ . field_ID <> nil ) and ( variable_ID . field_ID > INTEGER ) do 
begin 
variable_ID := variable_ID ^ . field_ID ; 
variable_ID . field_ID := variable_ID . field_ID - INTEGER ; 
end ; 
if variable_ID . field_ID = INTEGER then 
begin 
if variable_ID ^ . field_ID = variable_ID . field_ID then 
begin 
if function_ID ( variable_ID , variable_ID ^ . field_ID ) = constant_ID then 
begin 
variable_ID := function_ID ( variable_ID , variable_ID ^ . field_ID ) ; 
function_ID := constant_ID ; 
variable_ID := variable_ID - INTEGER ; 
end 
else 
begin 
variable_ID := function_ID ( variable_ID ^ . field_ID ) ; 
function_ID := constant_ID ; 
variable_ID ^ . field_ID := - INTEGER ; 
end ; 
end ; 
end ; 
end ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
begin 
variable_ID := variable_ID [ variable_ID ] ^ . field_ID ; 
variable_ID := INTEGER ; 
variable_ID := constant_ID ; 
while ( variable_ID <> nil ) and ( variable_ID ) do 
begin 
write ( STRING , variable_ID : INTEGER , STRING ) ; 
variable_ID := function_ID ( variable_ID , variable_ID , variable_ID ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
while variable_ID = constant_ID do 
begin 
write ( variable_ID : INTEGER , STRING ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
end ; 
if variable_ID = constant_ID then 
variable_ID := constant_ID ; 
writeln ; 
variable_ID := variable_ID + INTEGER ; 
variable_ID := variable_ID ^ . field_ID ; 
end ; 
if variable_ID then 
function_ID := constant_ID ; 
end 
end ; 
function ID ( ID : type_ID ) : type_ID ; 
begin 
case variable_ID of 
constant_ID : 
function_ID := constant_ID ; 
constant_ID : 
function_ID := constant_ID ; 
constant_ID : 
function_ID := constant_ID ; 
constant_ID : 
function_ID := constant_ID ; 
end ; 
end ; 
function ID ( ID : type_ID ) : type_ID ; 
begin 
function_ID := constant_ID ; 
if ( variable_ID > INTEGER ) and ( variable_ID < constant_ID + INTEGER ) then 
if variable_ID [ variable_ID ] <> nil then 
function_ID := constant_ID ; 
end ; 
function ID ( ID : type_ID ) : type_ID ; 
begin 
function_ID := constant_ID ; 
if ( variable_ID > INTEGER ) and ( variable_ID < constant_ID + INTEGER ) then 
if variable_ID [ variable_ID ] <> nil then 
function_ID := constant_ID ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
begin 
if variable_ID >= constant_ID then 
function_ID := constant_ID 
else 
begin 
variable_ID := function_ID ( function_ID ( variable_ID ) ) ; 
if variable_ID = constant_ID then 
begin 
variable_ID := variable_ID + INTEGER ; 
variable_ID := INTEGER ; 
while variable_ID [ variable_ID ] <> nil do 
variable_ID := variable_ID + INTEGER ; 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID [ variable_ID ] ^ := variable_ID ; 
end ; 
function_ID := variable_ID ; 
end ; 
end ; 
function function_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
begin 
function_ID := function_ID ( function_ID ( variable_ID [ variable_ID ] ^ ) ) ; 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID [ variable_ID ] := nil ; 
variable_ID := variable_ID - INTEGER ; 
end ; 
end ; 
function function_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
function_ID := 
function_ID ( function_ID ( variable_ID , variable_ID , variable_ID [ variable_ID ] ^ ) ) ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
begin 
variable_ID := function_ID ( variable_ID , variable_ID , variable_ID [ variable_ID ] ^ ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
variable_ID := function_ID ( variable_ID ) ; 
while ( variable_ID = constant_ID ) and ( variable_ID = constant_ID ) do 
begin 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
end ; 
if ( variable_ID = constant_ID ) and ( variable_ID = constant_ID ) then 
function_ID := constant_ID 
else 
variable_ID := function_ID ( variable_ID ) ; 
end ; 
end ; 
function function_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
function_ID := function_ID ( function_ID ( variable_ID [ variable_ID ] ^ ) ) ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
begin 
function_ID := constant_ID ; 
if ( function_ID ( variable_ID ) ) and ( variable_ID < constant_ID + INTEGER ) then 
begin 
variable_ID := INTEGER ; 
while variable_ID [ variable_ID ] <> nil do 
variable_ID := variable_ID + INTEGER ; 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID := function_ID ( function_ID ( 
variable_ID [ variable_ID ] ^ , variable_ID , variable_ID [ variable_ID ] ^ ) ) ; 
function_ID := variable_ID ; 
if variable_ID = constant_ID then 
variable_ID := variable_ID + INTEGER 
else 
begin 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID [ variable_ID ] := nil ; 
end ; 
end ; 
end ; 
function function_ID ; 
var ID : type_ID ; 
begin 
function_ID := constant_ID ; 
if function_ID ( variable_ID ) then 
begin 
variable_ID := function_ID ( function_ID ( 
variable_ID , variable_ID [ variable_ID ] ^ ) ) ; 
function_ID := variable_ID ; 
if variable_ID <> constant_ID then 
begin 
procedure_ID ( variable_ID [ variable_ID ] ) ; 
variable_ID [ variable_ID ] := nil ; 
variable_ID := variable_ID - INTEGER ; 
end ; 
end ; 
end ; 
procedure ID ( ID : type_ID ; ID : type_ID ; ID : type_ID ) ; 
var 
ID : type_ID ; 
procedure ID ( ID : type_ID ; ID : type_ID ) ; 
var 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
begin 
variable_ID := function_ID ( variable_ID , variable_ID , variable_ID ) ; 
if ( variable_ID = - INTEGER ) then 
variable_ID := variable_ID ; 
variable_ID := function_ID ( variable_ID , variable_ID , variable_ID ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
while variable_ID = constant_ID do 
begin 
if ( variable_ID <> variable_ID ) then 
procedure_ID ( variable_ID , variable_ID ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
end ; 
end ; 
begin 
if ( variable_ID <> variable_ID ) then 
variable_ID := - INTEGER 
else 
variable_ID := - INTEGER ; 
procedure_ID ( INTEGER , variable_ID ) ; 
end ; 
procedure ID ( ID : type_ID ; ID : type_ID ; ID : type_ID ; 
ID : type_ID ; ID : type_ID ) ; 
var 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
ID : type_ID ; 
procedure ID ( ID : type_ID ) ; 
begin 
writeln ; 
writeln ( STRING , variable_ID ) ; 
end ; 
begin 
write ( STRING , variable_ID : INTEGER ) ; 
variable_ID := function_ID ( variable_ID , variable_ID , variable_ID ) ; 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
if ( variable_ID ) then 
variable_ID [ INTEGER * variable_ID - INTEGER ] := STRING 
else 
variable_ID [ INTEGER * variable_ID - INTEGER ] := STRING ; 
while ( variable_ID = constant_ID ) do 
begin 
variable_ID := function_ID ( variable_ID , variable_ID ) ; 
procedure_ID ( variable_ID , variable_ID , variable_ID + INTEGER , variable_ID <> constant_ID , variable_ID ) ; 
variable_ID := variable_ID ; 
variable_ID := variable_ID ; 
for variable_ID := INTEGER to variable_ID do 
write ( STRING ) ; 
end ; 
procedure_ID ( variable_ID ) ; 
end ; 
procedure ID ( ID : type_ID ) ; 
var 
ID : type_ID ; 
ID : type_ID ; 
begin 
for variable_ID := INTEGER to INTEGER do 
variable_ID [ variable_ID ] := STRING ; 
procedure_ID ( variable_ID , INTEGER , INTEGER , constant_ID , variable_ID ) ; 
end ; 
procedure ID ; 
var ID : type_ID ; 
ID : type_ID ; 
begin 
variable_ID := function_ID ( variable_ID ) ; 
if ( variable_ID = constant_ID ) then 
begin 
writeln ( STRING , variable_ID ) ; 
variable_ID [ variable_ID ] := constant_ID ; 
end 
else writeln ( STRING ) ; 
end ; 
procedure ID ; 
var ID , ID , ID : type_ID ; 
begin 
writeln ( STRING ) ; 
readln ( variable_ID ) ; 
writeln ( STRING ) ; 
readln ( variable_ID ) ; 
writeln ( STRING ) ; 
readln ( variable_ID ) ; 
if ( variable_ID [ variable_ID ] = constant_ID ) and ( variable_ID [ variable_ID ] = constant_ID ) then 
begin 
procedure_ID ( variable_ID , variable_ID , variable_ID ) ; 
writeln ( STRING , variable_ID , STRING , variable_ID , STRING , variable_ID ) ; 
end 
else writeln ( STRING ) 
end ; 
procedure ID ; 
var ID : type_ID ; 
ID : type_ID ; 
begin 
writeln ( STRING ) ; 
readln ( variable_ID ) ; 
variable_ID := function_ID ( variable_ID ) ; 
if ( variable_ID = constant_ID ) then 
begin 
writeln ( STRING , variable_ID , STRING ) ; 
variable_ID [ variable_ID ] := constant_ID ; 
end 
else writeln ( STRING ) ; 
end ; 
procedure ID ; 
var ID : type_ID ; 
ID : type_ID ; 
begin 
writeln ( STRING ) ; 
readln ( variable_ID ) ; 
if ( variable_ID [ variable_ID ] = constant_ID ) then writeln ( STRING ) 
else procedure_ID ( variable_ID ) ; 
end ; 
function ID : type_ID ; 
begin 
writeln ; 
writeln ( STRING ) ; 
writeln ( STRING ) ; 
writeln ( STRING ) ; 
writeln ( STRING ) ; 
writeln ( STRING ) ; 
writeln ; 
repeat 
writeln ( STRING ) ; 
readln ( variable_ID ) ; 
until variable_ID in [ INTEGER , INTEGER , INTEGER , INTEGER , INTEGER ] ; 
function_ID := variable_ID ; 
end ; 
begin 
variable_ID := INTEGER ; 
variable_ID := INTEGER ; 
variable_ID := INTEGER ; 
variable_ID := INTEGER ; 
variable_ID := INTEGER ; 
repeat 
variable_ID := function_ID ; 
case variable_ID of INTEGER 
: procedure_ID ; INTEGER 
: procedure_ID ; INTEGER 
: procedure_ID ; INTEGER 
: procedure_ID ; INTEGER 
: ; 
end ; 
until variable_ID = INTEGER ; 
end .$

iso_pascal_7185_BNFleft_quad
$(* ART3 grammar generated by ART from 'iso_pascalV2.art' on May 13 2018 10:57:00 *)

program ::= program_heading ';' program_block '.'

ART_C_1 ::=
   ART_C_1 ',' actual_parameter |
   # 

ART_C_10 ::=
   ART_C_10 ',' index_expression |
   # 

ART_C_11 ::=
   ART_C_11 ',' label |
   # 

ART_C_12 ::=
   # |
   ART_C_12 procedure_declaration ';' |
   ART_C_12 function_declaration ';' 

ART_C_13 ::=
   ART_C_13 ',' variable_access |
   # 

ART_C_14 ::=
   ART_C_14 ',' variable_access |
   # 

ART_C_15 ::=
   ART_C_15 ',' record_variable |
   # 

ART_C_16 ::=
   ART_C_16 ',' member_designator |
   # 

ART_C_17 ::=
   ART_C_17 adding_operator term |
   # 

ART_C_18 ::=
   ART_C_18 ';' statement |
   # 

ART_C_19 ::=
   ART_C_19 multiplying_operator factor |
   # 

ART_C_2 ::=
   ART_C_2 ',' index_type |
   # 

ART_C_20 ::=
   ART_C_20 type_definition ';' |
   # 

ART_C_21 ::=
   ART_C_21 ';' index_type_specification |
   # 

ART_C_22 ::=
   ART_C_22 variable_declaration ';' |
   # 

ART_C_23 ::=
   ART_C_23 ';' variant |
   # 

ART_C_24 ::=
   ART_C_24 ',' write_parameter |
   # 

ART_C_25 ::=
   ART_C_25 ',' write_parameter |
   # 

ART_C_3 ::=
   ART_C_3 ',' case_constant |
   # 

ART_C_4 ::=
   ART_C_4 ';' case_list_element |
   # 

ART_C_5 ::=
   ART_C_5 constant_definition ';' |
   # 

ART_C_6 ::=
   ART_C_6 digit |
   # 

ART_C_7 ::=
   ART_C_7 ';' record_section |
   # 

ART_C_8 ::=
   ART_C_8 ';' formal_parameter_section |
   # 

ART_C_9 ::=
   ART_C_9 ',' identifier |
   # 

Boolean_expression ::=
   expression 

actual_parameter ::=
   expression |
   variable_access |
   procedure_identifier |
   function_identifier 

actual_parameter_list ::=
   '(' actual_parameter ART_C_1 ')' 

adding_operator ::=
   '+' |
   '-' |
   'or' 

apostrophe_image ::=
   '\"' 

array_type ::=
   'array' '[' index_type ART_C_2 ']' 'of' component_type 

array_variable ::=
   variable_access 

assignment_statement ::=
   variable_access ':=' expression |
   function_identifier ':=' expression 

base_type ::=
   ordinal_type 

block ::=
   label_declaration_part constant_definition_part type_definition_part variable_declaration_part procedure_and_function_declaration_part statement_part 

bound_identifier ::=
   identifier 

buffer_variable ::=
   file_variable '^' 

case_constant ::=
   constant 

case_constant_list ::=
   case_constant ART_C_3 

case_index ::=
   expression 

case_list_element ::=
   case_constant_list ':' statement 

case_statement ::=
   'case' case_index 'of' case_list_element ART_C_4 'end' |
   'case' case_index 'of' case_list_element ART_C_4 ';' 'end' 

character_string ::=
   'STRING' 

component_type ::=
   type_denoter 

component_variable ::=
   indexed_variable |
   field_designator 

compound_statement ::=
   'begin' statement_sequence 'end' 

conditional_statement ::=
   if_statement |
   case_statement 

conformant_array_parameter_specification ::=
   value_conformant_array_specification |
   variable_conformant_array_specification 

conformant_array_schema ::=
   packed_conformant_array_schema |
   unpacked_conformant_array_schema 

constant ::=
   character_string |
   unsigned_number |
   constant_identifier |
   sign unsigned_number |
   sign constant_identifier 

constant_definition ::=
   identifier '=' constant 

constant_definition_part ::=
   # |
   'const' constant_definition ';' ART_C_5 

constant_identifier ::=
   'constant_ID' 

control_variable ::=
   entire_variable 

digit ::=
   '0' |
   '1' |
   '2' |
   '3' |
   '4' |
   '5' |
   '6' |
   '7' |
   '8' |
   '9' 

digit_sequence ::=
   digit ART_C_6 

directive ::=
   'ID' 

domain_type ::=
   type_identifier 

else_part ::=
   'else' statement 

entire_variable ::=
   variable_identifier 

enumerated_type ::=
   '(' identifier_list ')' 

expression ::=
   simple_expression |
   simple_expression relational_operator simple_expression 

factor ::=
   variable_access |
   unsigned_constant |
   function_designator |
   set_constructor |
   '(' expression ')' |
   'not' factor 

field_designator ::=
   record_variable '.' field_specifier |
   field_designator_identifier 

field_designator_identifier ::=
   identifier 

field_identifier ::=
   'field_ID' 

field_list ::=
   # |
   variant_part |
   variant_part ';' |
   fixed_part |
   fixed_part ';' |
   fixed_part ';' variant_part |
   fixed_part ';' variant_part ';' 

field_specifier ::=
   field_identifier 

file_type ::=
   'file' 'of' component_type 

file_variable ::=
   variable_access 

final_value ::=
   expression 

fixed_part ::=
   record_section ART_C_7 

for_statement ::=
   'for' control_variable ':=' initial_value 'to' final_value 'do' statement |
   'for' control_variable ':=' initial_value 'downto' final_value 'do' statement 

formal_parameter_list ::=
   '(' formal_parameter_section ART_C_8 ')' 

formal_parameter_section ::=
   value_parameter_specification |
   variable_parameter_specification |
   procedural_parameter_specification |
   functional_parameter_specification 

fractional_part ::=
   digit_sequence 

function_block ::=
   block 

function_declaration ::=
   function_heading ';' directive |
   function_identification ';' function_block |
   function_heading ';' function_block 

function_designator ::=
   function_identifier |
   function_identifier actual_parameter_list 

function_heading ::=
   'function' identifier ':' result_type |
   'function' identifier formal_parameter_list ':' result_type 

function_identification ::=
   'function' function_identifier 

function_identifier ::=
   'function_ID' 

functional_parameter_specification ::=
   function_heading 

goto_statement ::=
   'goto' label 

identified_variable ::=
   pointer_variable '^' 

identifier ::=
   'ID' 

identifier_list ::=
   identifier ART_C_9 

if_statement ::=
   'if' Boolean_expression 'then' statement |
   'if' Boolean_expression 'then' statement else_part 

index_expression ::=
   expression 

index_type ::=
   ordinal_type 

index_type_specification ::=
   identifier '..' identifier ':' ordinal_type_identifier 

indexed_variable ::=
   array_variable '[' index_expression ART_C_10 ']' 

initial_value ::=
   expression 

label ::=
   digit_sequence 

label_declaration_part ::=
   # |
   'label' label ART_C_11 ';' 

letter ::=
   'a' |
   'b' |
   'c' |
   'd' |
   'e' |
   'f' |
   'g' |
   'h' |
   'i' |
   'j' |
   'k' |
   'l' |
   'm' |
   'n' |
   'o' |
   'p' |
   'q' |
   'r' |
   's' |
   't' |
   'u' |
   'v' |
   'w' |
   'x' |
   'y' |
   'z' 

member_designator ::=
   expression |
   expression '..' expression 

multiplying_operator ::=
   '*' |
   '/' |
   'div' |
   'mod' |
   'and' 

new_ordinal_type ::=
   enumerated_type |
   subrange_type 

new_pointer_type ::=
   '^' domain_type 

new_structured_type ::=
   unpacked_structured_type |
   'packed' unpacked_structured_type 

new_type ::=
   new_ordinal_type |
   new_structured_type |
   new_pointer_type 

ordinal_type ::=
   new_ordinal_type |
   ordinal_type_identifier 

ordinal_type_identifier ::=
   type_identifier 

packed_conformant_array_schema ::=
   'packed' 'array' '[' index_type_specification ']' 'of' type_identifier 

pointer_type ::=
   new_pointer_type |
   pointer_type_identifier 

pointer_type_identifier ::=
   type_identifier 

pointer_variable ::=
   variable_access 

procedural_parameter_specification ::=
   procedure_heading 

procedure_and_function_declaration_part ::=
   ART_C_12 

procedure_block ::=
   block 

procedure_declaration ::=
   procedure_heading ';' directive |
   procedure_identification ';' procedure_block |
   procedure_heading ';' procedure_block 

procedure_heading ::=
   'procedure' identifier |
   'procedure' identifier formal_parameter_list 

procedure_identification ::=
   'procedure' procedure_identifier 

procedure_identifier ::=
   'procedure_ID' |
   'write' |
   'writeln' |
   'read' |
   'readln' 

procedure_statement ::=
   procedure_identifier read_parameter_list |
   procedure_identifier readln_parameter_list |
   procedure_identifier write_parameter_list |
   procedure_identifier writeln_parameter_list |
   procedure_identifier |
   procedure_identifier actual_parameter_list 

//program ::= program_heading ';' program_block '.' 

program_block ::=
   block 

program_heading ::=
   'program' identifier |
   'program' identifier '(' program_parameter_list ')' 

program_parameter_list ::=
   identifier_list 

read_parameter_list ::=
   '(' variable_access ART_C_13 ')' |
   '(' file_variable ',' variable_access ART_C_13 ')' 

readln_parameter_list ::=
   # |
   '(' file_variable ART_C_14 ')' |
   '(' variable_access ART_C_14 ')' 

real_type_identifier ::=
   type_identifier 

record_section ::=
   identifier_list ':' type_denoter 

record_type ::=
   'record' field_list 'end' 

record_variable ::=
   variable_access 

record_variable_list ::=
   record_variable ART_C_15 

relational_operator ::=
   '=' |
   '<>' |
   '<' |
   '>' |
   '<=' |
   '>=' |
   'in' 

repeat_statement ::=
   'repeat' statement_sequence 'until' Boolean_expression 

repetitive_statement ::=
   repeat_statement |
   while_statement |
   for_statement 

result_type ::=
   simple_type_identifier |
   pointer_type_identifier 

scale_factor ::=
   digit_sequence |
   sign digit_sequence 

set_constructor ::=
   '[' ']' |
   '[' member_designator ART_C_16 ']' 

set_type ::=
   'set' 'of' base_type 

sign ::=
   '+' |
   '-' 

signed_integer ::=
   unsigned_integer |
   sign unsigned_integer 

signed_number ::=
   signed_integer |
   signed_real 

signed_real ::=
   unsigned_real |
   sign unsigned_real 

simple_expression ::=
   term ART_C_17 |
   sign term ART_C_17 

simple_statement ::=
   # |
   assignment_statement |
   procedure_statement |
   goto_statement 

simple_type ::=
   ordinal_type |
   real_type_identifier 

simple_type_identifier ::=
   type_identifier 

special_symbol ::=
   '+' |
   '-' |
   '*' |
   '/' |
   '=' |
   '<' |
   '>' |
   '[' |
   ']' |
   '.' |
   ',' |
   ':' |
   ';' |
   '^' |
   '(' |
   ')' |
   '<>' |
   '<=' |
   '>=' |
   ':=' |
   '..' |
   word_symbol 

statement ::=
   simple_statement |
   structured_statement |
   label ':' simple_statement |
   label ':' structured_statement 

statement_part ::=
   compound_statement 

statement_sequence ::=
   statement ART_C_18 

structured_statement ::=
   compound_statement |
   conditional_statement |
   repetitive_statement |
   with_statement 

structured_type ::=
   new_structured_type |
   structured_type_identifier 

structured_type_identifier ::=
   type_identifier 

subrange_type ::=
   constant '..' constant 

tag_field ::=
   identifier 

tag_type ::=
   ordinal_type_identifier 

term ::=
   factor ART_C_19 

type_definition ::=
   identifier '=' type_denoter 

type_definition_part ::=
   # |
   'type' type_definition ';' ART_C_20 

type_denoter ::=
   type_identifier |
   new_type 

type_identifier ::=
   'type_ID' 

unpacked_conformant_array_schema ::=
   'array' '[' index_type_specification ART_C_21 ']' 'of' type_identifier |
   'array' '[' index_type_specification ART_C_21 ']' 'of' conformant_array_schema 

unpacked_structured_type ::=
   array_type |
   record_type |
   set_type |
   file_type 

unsigned_constant ::=
   unsigned_number |
   character_string |
   constant_identifier |
   'nil' 

unsigned_integer ::=
   'INTEGER' 

unsigned_number ::=
   unsigned_integer |
   unsigned_real 

unsigned_real ::=
   'REAL' 

value_conformant_array_specification ::=
   identifier_list ':' conformant_array_schema 

value_parameter_specification ::=
   identifier_list ':' type_identifier 

variable_access ::=
   entire_variable |
   component_variable |
   identified_variable |
   buffer_variable 

variable_conformant_array_specification ::=
   'var' identifier_list ':' conformant_array_schema 

variable_declaration ::=
   identifier_list ':' type_denoter 

variable_declaration_part ::=
   # |
   'var' variable_declaration ';' ART_C_22 

variable_identifier ::=
   'variable_ID' 

variable_parameter_specification ::=
   'var' identifier_list ':' type_identifier 

variant ::=
   case_constant_list ':' '(' field_list ')' 

variant_part ::=
   'case' variant_selector 'of' variant ART_C_23 

variant_selector ::=
   tag_type |
   tag_field ':' tag_type 

while_statement ::=
   'while' Boolean_expression 'do' statement 

with_statement ::=
   'with' record_variable_list 'do' statement 

word_symbol ::=
   'and' |
   'array' |
   'begin' |
   'case' |
   'const' |
   'div' |
   'do' |
   'downto' |
   'else' |
   'end' |
   'file' |
   'for' |
   'function' |
   'goto' |
   'if' |
   'in' |
   'label' |
   'mod' |
   'nil' |
   'not' |
   'of' |
   'or' |
   'packed' |
   'procedure' |
   'program' |
   'record' |
   'repeat' |
   'set' |
   'then' |
   'to' |
   'type' |
   'until' |
   'var' |
   'while' |
   'with' 

write_parameter ::=
   expression |
   expression ':' expression |
   expression ':' expression ':' expression 

write_parameter_list ::=
   '(' write_parameter ART_C_24 ')' |
   '(' file_variable ',' write_parameter ART_C_24 ')' 

writeln_parameter_list ::=
   # |
   '(' file_variable ART_C_25 ')' |
   '(' write_parameter ART_C_25 ')' 

$
accept
$program ID ( ID , ID ) ; 
var ID , ID , ID , ID : type_ID ; 
ID : type_ID ; 
procedure ID ( ID : type_ID ; var ID : type_ID ) ; 
begin 
variable_ID := variable_ID + INTEGER ; 
while function_ID ( ( variable_ID * variable_ID ) - variable_ID ) > REAL do 
variable_ID := variable_ID - ( ( ( variable_ID * variable_ID ) - variable_ID ) / ( REAL * variable_ID ) ) 
end ; 
procedure ID ( ID , ID , ID : type_ID ; var ID : type_ID ) ; 
var ID , ID : type_ID ; 
begin 
variable_ID := variable_ID * variable_ID - INTEGER * variable_ID * variable_ID ; 
procedure_ID ( variable_ID , variable_ID ) ; 
variable_ID := ( - variable_ID + variable_ID ) / ( INTEGER * variable_ID ) ; 
end ; 
procedure ID ( ID , ID , ID : type_ID ; var ID : type_ID ; var ID : type_ID ) ; 
begin 
if variable_ID * variable_ID < INTEGER * variable_ID * variable_ID then 
begin 
variable_ID := constant_ID ; 
variable_ID := - INTEGER ; 
end 
else 
begin 
procedure_ID ( variable_ID , variable_ID , variable_ID , variable_ID ) ; 
variable_ID := constant_ID ; 
end ; 
end ; 
begin 
write ( STRING ) ; 
readln ( variable_ID ) ; 
write ( STRING ) ; 
readln ( variable_ID ) ; 
write ( STRING ) ; 
readln ( variable_ID ) ; 
write ( STRING ) ; 
procedure_ID ( variable_ID , variable_ID , variable_ID , variable_ID , variable_ID ) ; 
if variable_ID = constant_ID then 
writeln ( STRING ) 
else writeln ( STRING , variable_ID : INTEGER : INTEGER , STRING ) 
end .$

