(* Programming language examples *)
ansi_cpp_gtb_src
$
translation_unit ::=
  declaration_seq? ;
// Generated by gramex V3.0 from 'ansi_cpp_prd97.raw' (this build Mar 25 2012 at 13:21:48)
// Command line: C:\csle\dev\gramex\gramex.exe ansi_cpp_prd97.raw

// M()(translation_unit)

// Start of provenance

// ansi_cpp_prd97.raw - a grammar for the 1998 ANSI C++ standard language

// 1. This is the grammar summary from the 1997 Public Review Document for
// ANSI C++, cut-and-pasted from http://www.open-std.org/jtc1/sc22/open/n2356/ 
// on 30 August 2006.

// 2. There may be differences between this grammar and the one in the final 
// published standard. 

// 3. You can process this file with the gramex tool to make something close
// to a Bison input file, and use the gramconv tool to convert EBNF
// constructs to pure BNF, and to translate to a variety of other formats.

// 4. For tool and grammar downloads, see the Royal Holloway Compilers Group
// homepage under http://www.cs.rhul.ac.uk, or contact us at
// A.Johnstone@rhul.ac.uk or E.Scott@rhul.ac.uk.

// 5. Please don't change this file.

//         Adrian Johnstone and Elizabeth Scott, 24 August 2006

// End of provenance
//   ______________________________________________________________________

//   Annex 0 (informative)

//   Grammar summary                                                 [gram]

//   ______________________________________________________________________

// 1 This summary of C++ syntax is intended to be an aid to  comprehension.
//   It  is  not  an  exact  statement of the language.  In particular, the
//   grammar described here accepts a superset  of  valid  C++  constructs.
//   Disambiguation rules (_stmt.ambig_, _dcl.spec_, _class.member.lookup_)
//   must be applied to distinguish expressions  from  declarations.   Fur-
//   ther,  access  control, ambiguity, and type rules must be used to weed
//   out syntactically valid but meaningless constructs.

//   1.1  Keywords                                               [gram.key]

// 1 New context-dependent keywords are introduced into a program by  type-
//   def  (_dcl.typedef_),  namespace  (_namespace.def_),  class (_class_),
//   enumeration (_dcl.enum_), and template (_temp_) declarations.
(* Comment out lexical material 

typedef_name ::=
  identifier ;
namespace_name ::=
  original_namespace_name |
  namespace_alias ;

original_namespace_name ::=
  identifier ;

namespace_alias ::=
  identifier ;
class_name ::=
  identifier |
  template_id ;
enum_name ::=
  identifier ;
template_name ::=
  identifier |
  'Note' 'that' 'a' typedef_name 'naming' 'a' 'class' 'is' 'also' 'a' class_name |
  '(_class.name_).' ;

//   1.2  Lexical conventions                                    [gram.lex]
hex_quad ::=
  hexadecimal_digit hexadecimal_digit hexadecimal_digit hexadecimal_digit ;

universal_character_name ::=
  '\\u' hex_quad |
  '\\U' hex_quad hex_quad ;

preprocessing_token ::=
  header_name |
  identifier |
  pp_number |
  character_literal |
  string_literal |
  preprocessing_op_or_punc |
  'each' 'non-white-space' 'character' 'that' 'cannot' 'be' 'one' 'of' 'the' 'above' ;
token ::=
  identifier |
  'keyword' |
  literal |
  operator |
  'punctuator' ;
header_name ::=
  '<h-char-sequence>' |
  '\"q-char-sequence\"' ;
h_char_sequence ::=
  h_char |
  h_char_sequence h_char ;
h_char ::=
  'any' 'member' 'of' 'the' 'source' 'character' 'set' 'except' |
  new_line 'and' '>' ;
q_char_sequence ::=
  q_char |
  q_char_sequence q_char ;
q_char ::=
  'any' 'member' 'of' 'the' 'source' 'character' 'set' 'except' |
  new_line 'and' '\"' ;
pp_number ::=
  digit |
  '.' digit |
  pp_number digit |
  pp_number nondigit |
  pp_number 'e' sign |
  pp_number 'E' sign |
  pp_number '.' ;
identifier ::=
  nondigit |
  identifier nondigit |
  identifier digit ;
nondigit ::=
  universal_character_name |
  '_' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' |
  'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' |
  'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' |
  'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' ;
digit ::=
  '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' ;

preprocessing_op_or_punc ::=
  '{' | '}' | '[' | ']' | '#' | '##' | '(' | ')' |
  '<:' | ':>' | '<%' | '%>' | '%:' | '%:%:' | ';' | ':' | '...' |
  'new' | 'delete' | '?' | '::' | '.' | '.*' |
  '+' | '-' | '*' | '/' | '%' | '^' | '&' | '|' | '~' |
  '!' | '=' | '<' | '>' | '+=' | '-=' | '*=' | '/=' | '%=' |
  '^=' | '&=' | '|=' | '<<' | '>>' | '>>=' | '<<=' | '==' | '!=' |
  '<=' | '>=' | '&&' | '||' | '++' | '--' | ',' | '->*' | '->' |
  'and' | 'and_eq' | 'bitand' | 'bitor' | 'compl' | 'not' | 'not_eq' | 'or' | 'or_eq' |
  'xor' | 'xor_eq' ;

literal ::=
  integer_literal |
  character_literal |
  floating_literal |
  string_literal |
  boolean_literal ;
integer_literal ::=
  decimal_literal integer_suffix? |
  octal_literal integer_suffix? |
  hexadecimal_literal integer_suffix? ;
decimal_literal ::=
  nonzero_digit |
  decimal_literal digit ;
octal_literal ::=
  '0' |
  octal_literal octal_digit ;
hexadecimal_literal ::=
  '0x' hexadecimal_digit |
  '0X' hexadecimal_digit |
  hexadecimal_literal hexadecimal_digit ;
nonzero_digit ::=
  '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' ;
octal_digit ::=
  '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' ;
hexadecimal_digit ::=
  '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' |
  'a' | 'b' | 'c' | 'd' | 'e' | 'f' |
  'A' | 'B' | 'C' | 'D' | 'E' | 'F' ;
integer_suffix ::=
  unsigned_suffix long_suffix? |
  long_suffix unsigned_suffix? ;
unsigned_suffix ::=
  'u' | 'U' ;
long_suffix ::=
  'l' | 'L' ;
character_literal ::=
  '\'c-char-sequence\'' |
  'L\'c-char-sequence\'' ;
c_char_sequence ::=
  c_char |
  c_char_sequence c_char ;

c_char ::=
  'any' 'member' 'of' 'the' 'source' 'character' 'set' 'except' |
  'the' 'single-quote' '\',' 'backslash' '\\,' 'or' new_line 'character' |
  escape_sequence |
  universal_character_name ;
escape_sequence ::=
  simple_escape_sequence |
  octal_escape_sequence |
  hexadecimal_escape_sequence ;
simple_escape_sequence ::=
  '\\\'' | '\\\"' | '\\?' | '\\\\' |
  '\\a' | '\\b' | '\\f' | '\\n' | '\\r' | '\\t' | '\\v' ;
octal_escape_sequence ::=
  '\\' octal_digit |
  '\\' octal_digit octal_digit |
  '\\' octal_digit octal_digit octal_digit ;
hexadecimal_escape_sequence ::=
  '\\x' hexadecimal_digit |
  hexadecimal_escape_sequence hexadecimal_digit ;
floating_literal ::=
  fractional_constant exponent_part? floating_suffix? |
  digit_sequence exponent_part floating_suffix? ;
fractional_constant ::=
  digit_sequence? '.' digit_sequence |
  digit_sequence '.' ;
exponent_part ::=
  'e' sign? digit_sequence |
  'E' sign? digit_sequence ;
sign ::=
  '+' | '-' ;
digit_sequence ::=
  digit |
  digit_sequence digit ;
floating_suffix ::=
  'f' | 'l' | 'F' | 'L' ;
string_literal ::=
  '\"s-char-sequenceopt\"' |
  'L\"s-char-sequenceopt\"' ;
s_char_sequence ::=
  s_char |
  s_char_sequence s_char ;
s_char ::=
  'any' 'member' 'of' 'the' 'source' 'character' 'set' 'except' |
  'the' 'double-quote' '\",' 'backslash' '\\,' 'or' new_line 'character' |
  escape_sequence |
  universal_character_name ;
boolean_literal ::=
  'false' |
  'true' ;
*)
literal ::=
  integer_literal |
  character_literal |
  floating_literal |
  string_literal |
  boolean_literal ;

string_literal ::= 'STRING' | string_literal 'STRING' ; (* Allow C-style String catenation *)
character_literal ::= 'CHARACTER' ;
integer_literal ::= 'INTEGER' ;
floating_literal ::= 'REAL' ;
boolean_literal ::= 'true' | 'false' ;

identifier ::= 'ID' ;

//   1.3  Basic concepts                                       [gram.basic]
//translation_unit ::=
//  declaration_seq? ;

//   1.4  Expressions                                           [gram.expr]
primary_expression ::=
  literal |
  'this' |
  '::' identifier |
  '::' operator_function_id |
  '::' qualified_id |
  '(' expression ')' |
  id_expression ;

(* Comment out unexpected duplicate production
id_expression ::=
  unqualified_id |
  qualified_id ;
*)

id_expression ::=
  unqualified_id |
  qualified_id ;

unqualified_id ::=
  identifier |
  operator_function_id |
  conversion_function_id |
  '~' class_name |
  template_id ;
qualified_id ::=
  nested_name_specifier 'template'? unqualified_id ;
nested_name_specifier ::=
  class_or_namespace_name '::' nested_name_specifier? ;

class_or_namespace_name ::=
  class_name |
  namespace_name ;
postfix_expression ::=
  primary_expression |
  postfix_expression '[' expression ']' |
  postfix_expression '(' expression_list? ')' |
  simple_type_specifier '(' expression_list? ')' |
  postfix_expression '.' 'template'? '::'? id_expression |
  postfix_expression '->' 'template'? '::'? id_expression |
  postfix_expression '.' pseudo_destructor_name |
  postfix_expression '->' pseudo_destructor_name |
  postfix_expression '++' |
  postfix_expression '--' |
  'dynamic_cast' '<' type_id '>' '(' expression ')' |
  'static_cast' '<' type_id '>' '(' expression ')' |
  'reinterpret_cast' '<' type_id '>' '(' expression ')' |
  'const_cast' '<' type_id '>' '(' expression ')' |
  'typeid' '(' expression ')' |
  'typeid' '(' type_id ')' ;

expression_list ::=
  assignment_expression |
  expression_list ',' assignment_expression ;
pseudo_destructor_name ::=
  '::'? nested_name_specifier? type_name '::' '~' type_name |
  '::'? nested_name_specifier? '~' type_name ;
unary_expression ::=
  postfix_expression |
  '++' cast_expression |
  '--' cast_expression |
  unary_operator cast_expression |
  'sizeof' unary_expression |
  'sizeof' '(' type_id ')' |
  new_expression |
  delete_expression ;
unary_operator ::=
  '*' | '&' | '+' | '-' | '!' | '~' ;
new_expression ::=
  '::'? 'new' new_placement? new_type_id new_initializer? |
  '::'? 'new' new_placement? '(' type_id ')' new_initializer? ;
new_placement ::=
  '(' expression_list ')' ;
new_type_id ::=
  type_specifier_seq new_declarator? ;
new_declarator ::=
  ptr_operator new_declarator? |
  direct_new_declarator ;
direct_new_declarator ::=
  '[' expression ']' |
  direct_new_declarator '[' constant_expression ']' ;
new_initializer ::=
  '(' expression_list? ')' ;
delete_expression ::=
  '::'? 'delete' cast_expression |
  '::'? 'delete' '[' ']' cast_expression ;
cast_expression ::=
  unary_expression |
  '(' type_id ')' cast_expression ;
pm_expression ::=
  cast_expression |
  pm_expression '.*' cast_expression |
  pm_expression '->*' cast_expression ;
multiplicative_expression ::=
  pm_expression |
  multiplicative_expression '*' pm_expression |
  multiplicative_expression '/' pm_expression |
  multiplicative_expression '%' pm_expression ;
additive_expression ::=
  multiplicative_expression |
  additive_expression '+' multiplicative_expression |
  additive_expression '-' multiplicative_expression ;

shift_expression ::=
  additive_expression |
  shift_expression '<<' additive_expression |
  shift_expression '>>' additive_expression ;
relational_expression ::=
  shift_expression |
  relational_expression '<' shift_expression |
  relational_expression '>' shift_expression |
  relational_expression '<=' shift_expression |
  relational_expression '>=' shift_expression ;
equality_expression ::=
  relational_expression |
  equality_expression '==' relational_expression |
  equality_expression '!=' relational_expression ;
and_expression ::=
  equality_expression |
  and_expression '&' equality_expression ;
exclusive_or_expression ::=
  and_expression |
  exclusive_or_expression '^' and_expression ;
inclusive_or_expression ::=
  exclusive_or_expression |
  inclusive_or_expression '|' exclusive_or_expression ;
logical_and_expression ::=
  inclusive_or_expression |
  logical_and_expression '&&' inclusive_or_expression ;
logical_or_expression ::=
  logical_and_expression |
  logical_or_expression '||' logical_and_expression ;
conditional_expression ::=
  logical_or_expression |
  logical_or_expression '?' expression ':' assignment_expression ;
assignment_expression ::=
  conditional_expression |
  logical_or_expression assignment_operator assignment_expression |
  throw_expression ;
assignment_operator ::=
  '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '>>=' | '<<=' | '&=' | '^=' | '|=' ;
expression ::=
  assignment_expression |
  expression ',' assignment_expression ;
constant_expression ::=
  conditional_expression ;

//   1.5  Statements                                       [gram.stmt.stmt]
statement ::=
  labeled_statement |
  expression_statement |
  compound_statement |
  selection_statement |
  iteration_statement |
  jump_statement |
  declaration_statement |
  try_block ;

labeled_statement ::=
  identifier ':' statement |
  'case' constant_expression ':' statement |
  'default' ':' statement ;
expression_statement ::=
  expression? ';' ;
compound_statement ::=
  '{' statement_seq? '}' ;
statement_seq ::=
  statement |
  statement_seq statement ;
selection_statement ::=
  'if' '(' condition ')' statement |
  'if' '(' condition ')' statement 'else' statement |
  'switch' '(' condition ')' statement ;
condition ::=
  expression |
  type_specifier_seq declarator '=' assignment_expression ;
iteration_statement ::=
  'while' '(' condition ')' statement |
  'do' statement 'while' '(' expression ')' ';' |
  'for' '(' for_init_statement condition? ';' expression? ')' statement ;
for_init_statement ::=
  expression_statement |
  simple_declaration ;
jump_statement ::=
  'break' ';' |
  'continue' ';' |
  'return' expression? ';' |
  'goto' identifier ';' ;
declaration_statement ::=
  block_declaration ;

//   1.6  Declarations                                       [gram.dcl.dcl]
declaration_seq ::=
  declaration |
  declaration_seq declaration ;
declaration ::=
  block_declaration |
  function_definition |
  template_declaration |
  explicit_instantiation |
  explicit_specialization |
  linkage_specification |
  namespace_definition ;
block_declaration ::=
  simple_declaration |
  asm_definition |
  namespace_alias_definition |
  using_declaration |
  using_directive ;
simple_declaration ::=
  decl_specifier_seq? init_declarator_list? ';' ;

decl_specifier ::=
  storage_class_specifier |
  type_specifier |
  function_specifier |
  'friend' |
  'typedef' ;
decl_specifier_seq ::=
  decl_specifier_seq? decl_specifier ;
storage_class_specifier ::=
  'auto' |
  'register' |
  'static' |
  'extern' |
  'mutable' ;
function_specifier ::=
  'inline' |
  'virtual' |
  'explicit' ;
typedef_name ::=
  identifier ;
type_specifier ::=
  simple_type_specifier |
  class_specifier |
  enum_specifier |
  elaborated_type_specifier |
  cv_qualifier ;
simple_type_specifier ::=
  '::'? nested_name_specifier? type_name |
  'char' |
  'wchar_t' |
  'bool' |
  'short' |
  'int' |
  'long' |
  'signed' |
  'unsigned' |
  'float' |
  'double' |
  'void' ;
type_name ::=
  class_name |
  enum_name |
  typedef_name ;
elaborated_type_specifier ::=
  class_key '::'? nested_name_specifier? identifier |
  'enum' '::'? nested_name_specifier? identifier |
  'typename' '::'? nested_name_specifier identifier |
  'typename' '::'? nested_name_specifier identifier '<' template_argument_list '>' ;
enum_name ::=
  identifier ;
enum_specifier ::=
  'enum' identifier? '{' enumerator_list? '}' ;

enumerator_list ::=
  enumerator_definition |
  enumerator_list ',' enumerator_definition ;
enumerator_definition ::=
  enumerator |
  enumerator '=' constant_expression ;
enumerator ::=
  identifier ;
namespace_name ::=
  original_namespace_name |
  namespace_alias ;
original_namespace_name ::=
  identifier ;

namespace_definition ::=
  named_namespace_definition |
  unnamed_namespace_definition ;

named_namespace_definition ::=
  original_namespace_definition |
  extension_namespace_definition ;

original_namespace_definition ::=
  'namespace' identifier '{' namespace_body '}' ;

extension_namespace_definition ::=
  'namespace' original_namespace_name '{' namespace_body '}' ;

unnamed_namespace_definition ::=
  'namespace' '{' namespace_body '}' ;

namespace_body ::=
  declaration_seq? ;
namespace_alias ::=
  identifier ;

namespace_alias_definition ::=
  'namespace' identifier '=' qualified_namespace_specifier ';' ;

qualified_namespace_specifier ::=
  '::'? nested_name_specifier? namespace_name ;
using_declaration ::=
  'using' 'typename'? '::'? nested_name_specifier unqualified_id ';' |
  'using' '::' unqualified_id ';' ;
using_directive ::=
  'using' 'namespace' '::'? nested_name_specifier? namespace_name ';' ;
asm_definition ::=
  'asm' '(' string_literal ')' ';' ;
linkage_specification ::=
  'extern' string_literal '{' declaration_seq? '}' |
  'extern' string_literal declaration ;

//   1.7  Declarators                                       [gram.dcl.decl]
init_declarator_list ::=
  init_declarator |
  init_declarator_list ',' init_declarator ;
init_declarator ::=
  declarator initializer? ;
declarator ::=
  direct_declarator |
  ptr_operator declarator ;
direct_declarator ::=
  declarator_id |
  direct_declarator '(' parameter_declaration_clause ')' cv_qualifier_seq? exception_specification? |
  direct_declarator '[' constant_expression? ']' |
  '(' declarator ')' ;
ptr_operator ::=
  '*' cv_qualifier_seq? |
  '&' |
  '::'? nested_name_specifier '*' cv_qualifier_seq? ;
cv_qualifier_seq ::=
  cv_qualifier cv_qualifier_seq? ;
cv_qualifier ::=
  'const' |
  'volatile' ;
declarator_id ::=
  '::'? id_expression |
  '::'? nested_name_specifier? type_name ;
type_id ::=
  type_specifier_seq abstract_declarator? ;
type_specifier_seq ::=
  type_specifier type_specifier_seq? ;
abstract_declarator ::=
  ptr_operator abstract_declarator? |
  direct_abstract_declarator ;
direct_abstract_declarator ::=
  direct_abstract_declarator? '(' parameter_declaration_clause ')' cv_qualifier_seq? exception_specification? |
  direct_abstract_declarator? '[' constant_expression? ']' |
  '(' abstract_declarator ')' ;
parameter_declaration_clause ::=
  parameter_declaration_list? '...'? |
  parameter_declaration_list ',' '...' ;
parameter_declaration_list ::=
  parameter_declaration |
  parameter_declaration_list ',' parameter_declaration ;
parameter_declaration ::=
  decl_specifier_seq declarator |
  decl_specifier_seq declarator '=' assignment_expression |
  decl_specifier_seq abstract_declarator? |
  decl_specifier_seq abstract_declarator? '=' assignment_expression ;
function_definition ::=
  decl_specifier_seq? declarator ctor_initializer? function_body |
  decl_specifier_seq? declarator function_try_block ;

function_body ::=
  compound_statement ;

initializer ::=
  '=' initializer_clause |
  '(' expression_list ')' ;
initializer_clause ::=
  assignment_expression |
  '{' initializer_list ','? '}' |
  '{' '}' ;
initializer_list ::=
  initializer_clause |
  initializer_list ',' initializer_clause ;

//   1.8  Classes                                              [gram.class]
class_name ::=
  identifier |
  template_id ;
class_specifier ::=
  class_head '{' member_specification? '}' ;
class_head ::=
  class_key identifier? base_clause? |
  class_key nested_name_specifier identifier base_clause? ;
class_key ::=
  'class' |
  'struct' |
  'union' ;
member_specification ::=
  member_declaration member_specification? |
  access_specifier ':' member_specification? ;
member_declaration ::=
  decl_specifier_seq? member_declarator_list? ';' |
  function_definition ';'? |
  qualified_id ';' |
  using_declaration |
  template_declaration ;
member_declarator_list ::=
  member_declarator |
  member_declarator_list ',' member_declarator ;
member_declarator ::=
  declarator pure_specifier? |
  declarator constant_initializer? |
  identifier? ':' constant_expression ;
pure_specifier ::=
  '=' '0' ;
constant_initializer ::=
  '=' constant_expression ;

//   1.9  Derived classes                              [gram.class.derived]
base_clause ::=
  ':' base_specifier_list ;
base_specifier_list ::=
  base_specifier |
  base_specifier_list ',' base_specifier ;

base_specifier ::=
  '::'? nested_name_specifier? class_name |
  'virtual' access_specifier? '::'? nested_name_specifier? class_name |
  access_specifier 'virtual'? '::'? nested_name_specifier? class_name ;
access_specifier ::=
  'private' |
  'protected' |
  'public' ;

//   1.10  Special member functions                          [gram.special]
conversion_function_id ::=
  operator conversion_type_id ;
conversion_type_id ::=
  type_specifier_seq conversion_declarator? ;
conversion_declarator ::=
  ptr_operator conversion_declarator? ;
ctor_initializer ::=
  ':' mem_initializer_list ;
mem_initializer_list ::=
  mem_initializer |
  mem_initializer ',' mem_initializer_list ;
mem_initializer ::=
  mem_initializer_id '(' expression_list? ')' ;
mem_initializer_id ::=
  '::'? nested_name_specifier? class_name |
  identifier ;

//   1.11  Overloading                                          [gram.over]
operator_function_id ::=
  operator operator ;
operator ::=
  'new' | 'delete' | 'new[]' | 'delete[]' |
  '+' | '-' | '*' | '/' | '%' | '^' | '&' | '|' | '~' |
  '!' | '=' | '<' | '>' | '+=' | '-=' | '*=' | '/=' | '%=' |
  '^=' | '&=' | '|=' | '<<' | '>>' | '>>=' | '<<=' | '==' | '!=' |
  '<=' | '>=' | '&&' | '||' | '++' | '--' | ',' | '->*' | '->' |
  '()' | '[]' ;

//   1.12  Templates                                            [gram.temp]
template_declaration ::=
  'export'? 'template' '<' template_parameter_list '>' declaration ;
template_parameter_list ::=
  template_parameter |
  template_parameter_list ',' template_parameter ;
template_parameter ::=
  type_parameter |
  parameter_declaration ;
type_parameter ::=
  'class' identifier? |
  'class' identifier? '=' type_id |
  'typename' identifier? |
  'typename' identifier? '=' type_id |
  'template' '<' template_parameter_list '>' 'class' identifier? |
  'template' '<' template_parameter_list '>' 'class' identifier? '=' template_name ;

template_id ::=
  template_name '<' template_argument_list '>' ;
template_name ::=
  identifier ;
template_argument_list ::=
  template_argument |
  template_argument_list ',' template_argument ;
template_argument ::=
  assignment_expression |
  type_id |
  template_name ;
explicit_instantiation ::=
  'template' declaration ;
explicit_specialization ::=
  'template' '<' '>' declaration ;

//   1.13  Exception handling                                 [gram.except]
try_block ::=
  'try' compound_statement handler_seq ;
function_try_block ::=
  'try' ctor_initializer? function_body handler_seq ;
handler_seq ::=
  handler handler_seq? ;
handler ::=
  'catch' '(' exception_declaration ')' compound_statement ;
exception_declaration ::=
  type_specifier_seq declarator |
  type_specifier_seq abstract_declarator |
  type_specifier_seq |
  '...' ;
throw_expression ::=
  'throw' assignment_expression? ;
exception_specification ::=
  'throw' '(' type_id_list? ')' ;
type_id_list ::=
  type_id |
  type_id_list ',' type_id ;

(* Comment out preprocessor stuff 
//   1.14  Preprocessing directives                              [gram.cpp]
preprocessing_file ::=
  group? ;
group ::=
  group_part |
  group group_part ;
group_part ::=
  pp_tokens? new_line |
  if_section |
  control_line ;
if_section ::=
  if_group elif_groups? else_group? endif_line ;
if_group ::=
  '#' 'if' constant_expression new_line group? |
  '#' 'ifdef' identifier new_line group? |
  '#' 'ifndef' identifier new_line group? ;

elif_groups ::=
  elif_group |
  elif_groups elif_group ;
elif_group ::=
  '#' 'elif' constant_expression new_line group? ;
else_group ::=
  '#' 'else' new_line group? ;
endif_line ::=
  '#' 'endif' new_line ;
control_line ::=
  '#' 'include' pp_tokens new_line |
  '#' 'define' identifier replacement_list new_line |
  '#' 'define' identifier lparen 'identifier-list'? ')' replacement_list new_line |
  '#' 'undef' identifier new_line |
  '#' 'line' pp_tokens new_line |
  '#' 'error' pp_tokens? new_line |
  '#' 'pragma' pp_tokens? new_line |
  '#' new_line ;
lparen ::=
  'the' 'left-parenthesis' 'character' 'without' 'preceding' 'white-space' ;
replacement_list ::=
  pp_tokens? ;
pp_tokens ::=
  preprocessing_token |
  pp_tokens preprocessing_token ;
new_line ::=
  'the' new_line 'character' ;
*)

// End of ansi_cpp_prd97.raw
$
accept
(*gtb_src.tok*)
$char 
* ID ,  
* * ID ,  
* ID = STRING ;  

int 
ID = INTEGER ,  
ID = INTEGER ,  
ID ,  
ID ;  

int ID = INTEGER ;  

char * ID = STRING 
STRING STRING STRING STRING STRING STRING STRING STRING 
STRING STRING STRING STRING STRING STRING 
STRING 
STRING STRING STRING STRING STRING STRING STRING STRING 
STRING STRING STRING STRING STRING STRING STRING STRING 
STRING STRING STRING STRING STRING STRING STRING STRING 
STRING STRING STRING STRING STRING STRING STRING STRING 
STRING STRING STRING STRING STRING STRING STRING STRING 
STRING STRING STRING STRING STRING STRING STRING STRING 
STRING STRING STRING STRING STRING STRING STRING STRING 
STRING STRING ; 


 
static int ID = INTEGER ; 

ID * ID ; 

ID * ID ( char * ID , ID * ID ) 
{ 
if ( ID ) 
{ 
ID * ID = ( ID * ) ID ( sizeof ( ID ) , ID ) ; 
if ( ID != ID ) 
ID -> ID = ID ; 
else 
ID ( ID , ID , sizeof ( ID ) ) ; 
return ID ; 
} 
else 
return ID ; 
} 

ID * ID ( char * ID , ID * ID ) 
{ 
if ( ID ) 
{ 
ID = ( ID * ) ID ( sizeof ( ID ) , ID ) ; 
if ( ID != ID ) 
ID -> ID = ID ; 
else 
ID ( ID , ID , sizeof ( ID ) ) ; 

( ( ID * ) ID ( sizeof ( ID ) , ID , ID ) ) -> ID = INTEGER ; 
return ID ; 
} 
else 
return ID ; 
} 

ID * ID ( char * ID , ID * ID ) 
{ 
if ( ID ) 
{ 
ID * ID = ( ID * ) ID ( sizeof ( ID ) , sizeof ( ID ) , ID ) ; 
if ( ID != ID ) 
ID -> ID = ID ; 
else 
ID ( ID , ID , sizeof ( ID ) ) ; 

( ( ID * ) ID ( ID ) ) -> ID = INTEGER ; 

return ID ; 
} 
else 
return ID ; 
} 


 
static void ID ( void ) 
{ 
ID ( STRING , STRING , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , STRING , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , STRING , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , STRING , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
} 

 

ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 

 

static void ID ( void ) 
{ 
ID ( & ID , ID , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , 
ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , 
ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , 
ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , 
ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , 
ID  , ID ) ; 
ID ( & ID , ID , ID , ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID  , ID  , ID  , ID  , 
ID  , ID ) ; 
ID ( & ID , ID , ID  , ID  , ID ) ; 
ID ( & ID , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID  , ID  , ID  , ID  , 
ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID  , ID ) ; 
ID ( & ID , ID , ID  , ID  , ID  , ID  , 
ID  , ID ) ; 
ID ( & ID , ID , ID  , ID  , ID  , ID  , 
ID  , ID ) ; 
ID ( & ID , ID , ID  , ID  , ID  , ID  , 
ID  , ID ) ; 
ID ( & ID , ID , ID  , ID  , ID  , ID  , 
ID  , ID ) ; 
ID ( & ID , ID , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID  , ID ) ; 
ID ( & ID , ID , ID  , ID ) ; 
ID ( & ID , ID , ID  , ID ) ; 
ID ( & ID , ID , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID  , ID ) ; 
ID ( & ID , ID , ID , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID  , ID ) ; 
ID ( & ID , ID , ID , ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID  , ID ) ; 
ID ( & ID , ID , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , 
ID  , ID ) ; 
ID ( & ID , ID , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID ) ; 
} 

 
static void ID ( ID * ID ) ; 
static void ID ( ID * ID ) ; 
static void ID ( ID * ID ) ; 
static void ID ( ID * ID ) ; 
static void ID ( ID * ID ) ; 
static void ID ( ID * ID ) ; 
static void ID ( ID * ID ) ; 
static void ID ( ID * ID ) ; 
static void ID ( ID * ID ) ; 
static void ID ( ID * ID ) ; 
static void ID ( ID * ID ) ; 
static void ID ( ID * ID ) ; 
static void ID ( ID * ID ) ; 
static void ID ( ID * ID ) ; 
static void ID ( ID * ID ) ; 
static char * ID ( ID * ID ) ; 
static void ID ( ID * ID ) ; 
static void ID ( ID * ID ) ; 
static void ID ( ID * ID ) ; 
static char * ID ( ID * ID ) ; 
static void ID ( ID * ID ) ; 
static void ID ( ID * ID ) ; 
void ID ( ID * ID ) ; 

 
static void ID ( ID * ID ) 
{ 
{ 
if ( ID ) { ID -> ID = STRING ; ID -> ID = INTEGER ; } 
ID ( ID ) ; 
if ( ID ( ID , ID  , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
ID ( ID , & ID , & ID ) ; 
} 
} 

static void ID ( ID * ID ) 
{ 
{ 
if ( ID ) { ID -> ID = STRING ; ID -> ID = INTEGER ; } 
ID ( ID ) ; 
if ( ID ( ID , & ID , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
if ( ! ID ( ID , & ID , ID ) ) break ; 
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
ID ( ID , & ID , & ID ) ; 
} 
} 

static void ID ( ID * ID ) 
{ 
{ 
ID ( ID ( STRING , ID ) ) ; 
if ( ID ( ID , ID  , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID -> ID = ID ; ID -> ID = ID ; } 
} 
ID ( ID , & ID , & ID ) ; 
} 
} 

static void ID ( ID * ID ) 
{ 
{ 
if ( ID ( ID , & ID , ID ) ) 
{ 
if ( ID ) { ID -> ID = STRING ; ID -> ID = INTEGER ; } 
ID ( ID ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
ID ( ID , & ID , & ID ) ; 
ID ( ID , & ID , & ID ) ; 
} 
} 

static void ID ( ID * ID ) 
{ 
{ 
if ( ID ) { ID -> ID = STRING ; ID -> ID = INTEGER ; } 
ID ( ID ) ; 
if ( ID ( ID , ID  , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
ID ( ID , & ID , & ID ) ; 
} 
} 

static void ID ( ID * ID ) 
{ 
{ 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) { ID -> ID = STRING ; ID -> ID = INTEGER ; } 
ID ( ID ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) { ID -> ID = STRING ; ID -> ID = INTEGER ; } 
ID ( ID ) ; 
} 
else 
ID ( ID , & ID , & ID ) ; 
ID ( ID , & ID , & ID ) ; 
} 
} 

static void ID ( ID * ID ) 
{ 
{ 
if ( ID ) { ID -> ID = STRING ; ID -> ID = INTEGER ; } 
ID ( ID ) ; 
if ( ID ( ID , & ID , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
if ( ! ID ( ID , & ID , ID ) ) break ; 
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
ID ( ID , & ID , & ID ) ; 
} 
} 

static void ID ( ID * ID ) 
{ 
{ 
ID ( ID ( STRING , ID ) ) ; 
if ( ID ( ID , & ID , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID -> ID = ID ; ID -> ID = ID ; } 
} 
ID ( ID , & ID , & ID ) ; 
} 
} 

static void ID ( ID * ID ) 
{ 
{ 
if ( ID ) { ID -> ID = STRING ; ID -> ID = INTEGER ; } 
ID ( ID ) ; 
if ( ID ( ID , & ID , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
ID ( ID , & ID , & ID ) ; 
} 
} 

static void ID ( ID * ID ) 
{ 
{ 
if ( ID ) { ID -> ID = STRING ; ID -> ID = INTEGER ; } 
ID ( ID ) ; 
if ( ID ( ID , ID  , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
if ( ! ID ( ID , ID  , ID ) ) break ; 
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
ID ( ID , & ID , & ID ) ; 
} 
} 

static void ID ( ID * ID ) 
{ 
{ 
if ( ID ) { ID -> ID = STRING ; ID -> ID = INTEGER ; } 
ID ( ID ) ; 
if ( ID ( ID , ID  , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
if ( ! ID ( ID , ID  , ID ) ) break ; 
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
ID ( ID , & ID , & ID ) ; 
} 
} 

static void ID ( ID * ID ) 
{ 
{ 
if ( ID ) { ID -> ID = STRING ; ID -> ID = INTEGER ; } 
ID ( ID ) ; 
if ( ID ( ID , ID  , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
if ( ! ID ( ID , ID  , ID ) ) break ; 
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
ID ( ID , & ID , & ID ) ; 
} 
} 

static void ID ( ID * ID ) 
{ 
{ 
if ( ID ) { ID -> ID = STRING ; ID -> ID = INTEGER ; } 
ID ( ID ) ; 
if ( ID ( ID , & ID , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
if ( ! ID ( ID , & ID , ID ) ) break ; 
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
ID ( ID , & ID , & ID ) ; 
} 
} 

static void ID ( ID * ID ) 
{ 
{ 
if ( ID ) { ID -> ID = STRING ; ID -> ID = INTEGER ; } 
ID ( ID ) ; 
if ( ID ( ID , & ID , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
if ( ! ID ( ID , & ID , ID ) ) break ; 
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
ID ( ID , & ID , & ID ) ; 
} 
} 

static void ID ( ID * ID ) 
{ 
char * ID ; 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID -> ID = ID ( ID ) ;  
if ( ID -> ID -> ID == ID )  
{  
ID -> ID -> ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ;  
ID -> ID -> ID -> ID = ID ;  
ID -> ID -> ID = INTEGER ;  
}  
 
} 
ID ( ID , & ID , & ID ) ; 
} 
} 

static char * ID ( ID * ID ) 
{ 
char * ID ; 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID -> ID = ID ( ID ) ;  
} 
if ( ID ( ID , ID  , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
{  
while ( INTEGER ) 
{ 
ID ( ID , & ID , & ID ) ; 
{ 
ID ( ID ( STRING , ID ) ) ; 
} 
if ( ! ID ( ID , & ID , ID ) ) break ; 
} 
}  
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
ID ( ID , & ID , & ID ) ; 
} 
return ID ; 
} 

static void ID ( ID * ID ) 
{ 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID -> ID = ID ( STRING ) ;  
if ( ID -> ID -> ID == ID )  
{  
ID -> ID -> ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ;  
ID -> ID -> ID -> ID = ID ;  
ID -> ID -> ID = INTEGER ;  
}  
 
} 
ID ( ID , & ID , & ID ) ; 
} 
} 

static void ID ( ID * ID ) 
{ 
{ 
{  
while ( INTEGER ) 
{ 
ID ( ID , & ID , & ID ) ; 
{ 
if ( ID ( ID , & ID , ID ) ) 
{ 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
if ( ! ID ( ID , & ID , ID ) ) break ; 
} 
}  
ID ( ID , & ID , & ID ) ; 
} 
} 

static void ID ( ID * ID ) 
{ 
char * ID ; 
{ 
if ( ID == INTEGER ) {  
ID ( ) ;  
} 
if ( ID ) { ID -> ID = STRING ; ID -> ID = INTEGER ; } 
ID = ID ( ID ) ; 
if ( ID == INTEGER ) {  
ID ( ID ) ;  
} if ( ID == INTEGER ) {  
ID ( ID ) ;  
} 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
{  
while ( INTEGER ) 
{ 
ID ( ID , & ID , & ID ) ; 
{ 
ID ( ID ( STRING , ID ) ) ; 
} 
if ( ID -> ID != ID  ) break ; 
ID ( ) ; 
} 
}  
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID ( ) ;  
} 
ID ( ID , & ID , & ID ) ; 
} 
} 

static char * ID ( ID * ID ) 
{ 
char * ID ; 
{ 
if ( ID ( ID , ID  , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID -> ID = ID ( ID ) ;  
if ( ID -> ID -> ID == ID )  
{  
ID -> ID -> ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ;  
ID -> ID -> ID -> ID = ID ;  
ID -> ID -> ID -> ID = ID ;  
ID -> ID -> ID = INTEGER ;  
}  
 
} 
if ( ID ( ID , ID  , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
{  
while ( INTEGER ) 
{ 
ID ( ID , & ID , & ID ) ; 
{ 
ID ( ID ( STRING , ID ) ) ; 
} 
if ( ! ID ( ID , & ID , ID ) ) break ; 
} 
}  
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
ID ( ID , & ID , & ID ) ; 
} 
return ID ; 
} 

static void ID ( ID * ID ) 
{ 
{ 
if ( ID ( ID , & ID , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
ID ( ID ( STRING , ID ) ) ; 
} 
if ( ! ID ( ID , & ID , ID ) ) break ; 
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
ID ( ID , & ID , & ID ) ; 
} 
} 

static void ID ( ID * ID ) 
{ 
{ 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ( ID , & ID , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
ID ( ID ( STRING , ID ) ) ; 
} 
if ( ! ID ( ID , & ID , ID ) ) break ; 
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID , & ID , & ID ) ; 
} 
} 

void ID ( ID * ID ) 
{ 
{ 
ID ( ID ( STRING , ID ) ) ; 
if ( ID ( ID , ID  , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID == INTEGER ) {  
ID ( ) ; ID ( STRING ) ;  
} 
ID ( ID ( STRING , ID ) ) ; 
if ( ID == INTEGER ) {  
ID ( ) ;  
} 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
ID ( ID , STRING , ID ) ; 
} 
ID ( ID , & ID , & ID ) ; 
} 
} 

int ID ( int ID , char * ID [ ] ) 
{ 
ID ID , ID = ID ( ) ; 
int 
ID = INTEGER ,  
ID = INTEGER ,  
ID = INTEGER ,  
ID = INTEGER ,  

ID = INTEGER ;  

unsigned long ID = INTEGER ;  

unsigned long ID = INTEGER ;  

char * ID = ID ;  

ID * ID = ( ID * ) ID ( STRING ) ;  
ID * ID ; 

ID ( STRING STRING STRING STRING ) ; 

ID ( STRING ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 

ID = ID ( ID , ID ) ; 

 
for ( ID = INTEGER ; ID [ ID ] != ID ; ID ++ ) 
ID [ ID ] = ID ( ID [ ID ] , STRING ) ; 

if ( ID ) 
{ 
ID [ INTEGER ] = STRING ; 
ID = STRING ; 
ID [ INTEGER ] = ID ;  

} 
if ( ( ID = ID [ INTEGER ] ) == ID ) 
ID ( STRING ) ; 

if ( ID [ INTEGER ] != ID ) 
ID ( ID , STRING ) ; 
ID ( ID , INTEGER , INTEGER , ( int ) ID ) ; 
ID ( INTEGER , INTEGER , INTEGER , ID , ID ) ; 
if ( ID ) 
ID ( ) ; 
ID ( ) ; 
ID ( ) ; 
ID ( ID ) ; 
if ( ID ) 
ID ( STRING STRING STRING ) ; 
for ( ID = INTEGER ; ID <= ID ; ID ++ ) 
{ 
ID = ID == ID ; 
ID ( ID || ( ID && ID == ID ) ) ; 

for ( ID = INTEGER ; ( ID = ID [ ID ] ) != ID ; ID ++ ) 
{ 
if ( ID ( ID ) == ID ) 
ID ( STRING ) ; 

ID ( ) ; 
ID ( ) ; 

ID ( ID = ID ( STRING , ID ) ) ;  
if ( ID ( ) != INTEGER ) 
ID ( ID , STRING , ID ( ) == INTEGER ? STRING : STRING , ID ) ;  
ID ( ID , sizeof ( ID ) ) ; 
} 
} 

ID = ID [ INTEGER ] ;  

ID ( ID , ID ) ; 
if ( ID != ID ) 
{ 
ID * ID ; 

if ( * ID == STRING )  
ID = STRING ; 
ID = ID ( ( ID = ID ( ID , STRING ) ) , STRING ) ; 

if ( ID == ID ) 
ID ( ID , STRING , ID ) ; 

if ( ID ) 
ID ( ID , STRING , ID ) ; 

ID ( ID ) ; 
ID ( ID , ID , ID , ID ) ; 
ID ( ID ) ; 
ID ( ID ) ; 
} 

ID ( ID ) ; 
if ( ID ) 
{ 
ID ( INTEGER ) ; 
ID ( ) ; 

} 
ID ( ) ; 
if ( ID ) 
{ 
ID = ID ( ) ; 
ID ( ID , STRING , ( ( double ) ( ID - ID ) ) / ID ) ; 
} 
return ID ; 
} 

 
 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
 

typedef struct ID { unsigned ID ; ID ID ; } ID ; 

typedef struct ID { ID ID ; 
struct ID * ID ; 
} ID ; 

static void * ID ; 
static ID ID = ID ; 
static ID ID = ID ; 

static ID * ID ( int ID , ID * ID , ID * ID , ID * ID ) 
{ 
ID ID = { INTEGER , ID } ; 
ID * ID ; 

 
ID ( STRING , 
ID -> ID , 
ID -> ID ) ; 
ID ( ID , ID , INTEGER ) ; 
ID ( STRING ) ; 
 

ID . ID = ID -> ID ; 
ID ( & ID . ID , ID ) ; 

ID = ( ID * ) ID ( ID , & ID , ID ) ; 

if ( ID == ID )  
{ 
void * ID ; 

ID = ( ID * ) ID ( ID , 
& ID , 
sizeof ( ID ) , 
sizeof ( ID ) ) ; 

ID -> ID = ( ID * ) ID ( sizeof ( ID ) , ID -> ID ) ; 
ID -> ID -> ID . ID = ID -> ID ; 
ID ( & ID -> ID -> ID . ID , ID ) ; 

if ( ID == ID -> ID -> ID ) 
ID ( ID -> ID , ID -> ID ) ; 

ID ( & ID -> ID , ID ( ID -> ID ) ) ; 

for ( ID = ID ( ID -> ID ) ; 
ID != ID ; 
ID = ID ( ID ) ) 
{ 
ID * ID = ( ID * ) ID ( ID ) ; 
void * ID ; 

ID * ID = ( ID * ) ID ( sizeof ( ID ) , ID -> ID ) ; 

( ( ID * ) ID ( sizeof ( ID ) , ID , ID -> ID ) ) -> ID = 
ID ( ID -> ID -> ID , ID , ID ) ; 

ID -> ID . ID = ID ; 
ID ( & ID -> ID . ID , ID ) ; 

 
ID ( STRING ) ; 
ID ( ID , ID , INTEGER ) ; 
ID ( STRING ) ; 
 

for ( ID = ID ( ID ) ; 
ID != ID ; 
ID = ID ( ID ) ) 
{ 
ID * ID = ( ID * ) ID ( ID ) ; 

if ( ID -> ID -> ID != ID ) 
{ 
ID * ID = ( ID * ) ID ( sizeof ( ID ) , ID -> ID ) ; 
ID * ID = ( ID * ) ID ( sizeof ( ID ) , ID , ID ) ; 

 
ID ( STRING ) ; 
ID ( ID , ID , INTEGER ) ; 
ID ( STRING ) ; 
 

ID -> ID . ID = ID ; 
ID ( & ID -> ID . ID , ID ) ; 

ID -> ID = ID -> ID ; 

if ( ID -> ID -> ID == ID ) 
{  

if ( ID == ID ) 
( ( ID * ) ID ( sizeof ( ID ) , ID ( ID , ID , ID -> ID , & ID ) , ID ) ) -> ID = 
ID ( ID -> ID -> ID , ID , ID ) ; 
else if ( ID == ID ) 
{ 
ID ID = ID ; 

ID ( & ID , & ID -> ID -> ID ) ; 
ID ( & ID , & ID ) ; 

( ( ID * ) ID ( sizeof ( ID ) , ID ( ID , ID , ID -> ID , & ID ) , ID ) ) -> ID = 
ID ( ID -> ID -> ID , ID , ID ) ; 

ID ( & ID ) ; 
} 
else if ( ID == ID ) 
{ 
ID ID = ID ; 
ID ID = ID ; 
unsigned * ID ; 
unsigned * ID ; 
void * ID ; 
int ID = INTEGER ; 

 
for ( ID = ID ( ID ) ; ID != ID ; ID = ID ( ID ) ) 
{ 
ID ( & ID , & ( ( ID * ) ID ( ID ) ) -> ID -> ID ) ; 
if ( ! ID ( & ( ( ID * ) ID ( ID ) ) -> ID -> ID , ID ) ) 
{ 
ID = INTEGER ; 
break ; 
} 
} 

if ( ID ) 
ID ( & ID , ID ) ; 

ID = ID ( & ID ) ; 
for ( ID = ID ; 
* ID != ID ; 
ID ++ ) 
{ 
ID * ID = ID ( ID -> ID -> ID , * ID ) ; 

ID ( & ID , * ID ) ; 

if ( ID -> ID == ID || ID -> ID == ID ) 
( ( ID * ) ID ( sizeof ( ID ) , ID ( ID , ID , ID -> ID , & ID ) , ID ) ) -> ID = 
ID ( ID -> ID -> ID , ID , ID ) ; 
} 
ID ( & ID ) ; 
ID ( ID ) ; 
} 
} 
ID = ID ; 
} 
} 
ID ( & ID -> ID , ID ( ID ) ) ; 
} 
 
ID ( STRING ) ; 
 
} 
 
else 
ID ( STRING ) ; 
 

return ID -> ID ; 
} 

ID * ID ( ID * ID , enum ID ID ) 
{ 
ID * ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 
ID ID = ID ; 

ID -> ID = ID ( ID ) ; 
ID -> ID = ID ; 
ID -> ID = ID ; 

ID ( ID -> ID -> ID , ID , ID ) -> ID = ID ; 

ID -> ID = ID ( STRING ) ; 

ID = ID ( STRING , INTEGER , INTEGER , ID , ID , ID ) ; 

if ( ID == ID ) 
{  
unsigned ID ; 

ID ( & ID , ID ) ;  

for ( ID = INTEGER ; ID < ID ( ID ) ; ID ++ ) 
if ( ID ( ID -> ID , ID ) -> ID == ID ) 
ID ( & ID , ID ) ; 

ID ( & ID , ID ) ; 
} 

if ( ID == ID ) 
{  
unsigned ID ; 

ID ( & ID , ID ) ;  

for ( ID = INTEGER ; ID < ID ( ID ) ; ID ++ ) 
if ( ID ( ID -> ID , ID ) -> ID == ID ) 
ID ( & ID , ID ) ; 
} 

ID ( & ID , ID ) ; 

ID ( ID , ID , ID -> ID -> ID , & ID ) ; 

ID ( ID -> ID ) ; 
ID ( ID ) ; 
ID ( & ID ) ; 

return ID ; 
} 

 
static void * ID ; 

static ID * ID ( int ID , ID * ID , ID * ID ) 
{ 

} 

ID * ID ( ID * ID , int ID ) 
{ 
ID * ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 

ID -> ID = ID ( ID ) ; 
ID -> ID = ID ; 

ID ( ID -> ID -> ID , ID , ID ) -> ID = ID ; 

ID -> ID = ID ( STRING ) ; 

ID = ID ( STRING , INTEGER , INTEGER , ID , ID , ID ) ; 

ID ( ID , ID , ID -> ID -> ID ) ; 

ID ( ID -> ID ) ; 

return ID ; 
} 

 

static ID * ID ; 

void ID ( const void * ID ) 
{ 
if ( ID -> ID == ID )  
ID ( STRING , ID ) ;  
} 

void ID ( const void * ID ) 
{ 
ID * ID = ( ID * ) ID ; 

ID ( STRING , ID ( ID ) ) ; 

switch ( ID -> ID ) 
{ 
case ID : 
{ 
unsigned * ID , 
* ID = ID ( & ( ID -> ID . ID -> ID ) ) ; 

for ( ID = ID ; * ID != ID ; ID ++ ) 
{ 
ID * ID = ( ID * ) ( ID ( ID -> ID -> ID ) [ * ID ] ) ; 

if ( ! ID ( & ID -> ID -> ID , ID ( ID ) ) ) 
{ 
ID ( STRING , * ID ) ; 
ID ( ID -> ID . ID , INTEGER ) ; 

ID ( STRING ) ; 
ID ( & ID -> ID . ID , ID , INTEGER ) ; 
ID ( STRING ) ; 

if ( ID ( & ID -> ID -> ID , ID ( ID ) ) ) 
ID ( STRING , ID ( ID -> ID . ID ) ) ; 
} 
} 
} 
break ; 

case ID : 
{ 
unsigned * ID , 
* ID = ID ( & ( ID -> ID . ID -> ID ) ) ; 

for ( ID = ID ; * ID != ID ; ID ++ ) 
{ 
ID ( STRING , * ID ) ; 
ID ( ( ID * ) ( ID ( ID -> ID -> ID ) [ * ID ] ) , INTEGER ) ; 
} 
} 
break ; 

case ID : 
{ 
if ( ID ( & ID -> ID , ID ( ID ) ) ) 
ID ( STRING , ID -> ID . ID -> ID -> ID ) ; 
else 
ID ( ID -> ID . ID , INTEGER ) ; 

ID ( STRING ) ; 
ID ( & ID -> ID . ID , ID , INTEGER ) ; 
ID ( STRING ) ; 
} 
break ; 

default : 
ID ( ID , STRING ) ; 
} 

ID ( STRING ) ; 

ID ( STRING , 
ID ( & ID -> ID , ID ( ID ) ) ? STRING : 
ID ( & ID -> ID , ID ( ID ) ) ? STRING : STRING ) ; 
} 

void ID ( const void * ID ) 
{ 
ID * ID = ( ID * ) ID ; 

if ( ID ( & ID -> ID , ID ( ( ID * ) ID ( ID ) ) ) ) 
ID ( STRING ) ; 
else if ( ID ( & ID -> ID , ID ( ( ID * ) ID ( ID ) ) ) ) 
ID ( STRING ) ; 
else 
{ 
ID ( STRING ) ; 
ID ( ID -> ID ) ; 
ID ( STRING ) ; 
} 
} 

void ID ( ID * ID , ID * ID ) 
{ 
ID * ID = ID ( ) ; 

ID ( ID ) ; 
ID = ID ; 
ID ( ID -> ID ) ; 
ID ( ID -> ID , ID , ID , ID ) ; 
ID ( ID ) ; 
} 

ID * ID ( ID * ID ) 
{ 
return ID ; 
} 

typedef struct ID 
{ 
ID * ID ; 
struct ID * ID ; 
} ID ; 

static ID ID = ID ; 
static ID ID = ID ; 
static ID ID = ID ; 
static ID ID = ID ; 
static ID ID = ID ; 

static void ID ( ID * ID ) 
{ 
ID * ID ; 

if ( ID ( & ( ID -> ID . ID ) ) != INTEGER ) 
{ 
ID ( & ID , & ( ID -> ID . ID ) ) ; 
return ; 
} 

if ( ID ( & ID , ID ( ID ) ) ) 
return ; 

ID ( & ID , ID ( ID ) ) ; 

for ( ID = ( ID * ) ID ( ID ) ; 
ID != ID ; 
ID = ( ID * ) ID ( ID ) ) 
if ( ID -> ID -> ID == ID ) 
ID ( ( ID * ) ID ( ID ) ) ; 
} 

 
static void ID ( ID * ID , unsigned ID ) 
{ 
unsigned ID ;  
unsigned ID ;  

 
ID ( STRING , ID ) ; 
ID ( & ID , ID , INTEGER ) ; 
ID ( STRING ) ; 
 

 
for ( ID = INTEGER , ID = INTEGER ; ID < ID . ID ; ID ++ )  
{ 
unsigned ID ;  
unsigned ID = ID . ID [ ID ] ;  

for ( ID = INTEGER ; ID < INTEGER ; ID <<= INTEGER )  
{ 
if ( ( ID & ID ) != INTEGER )  
{ 
ID * ID ; 

for ( ID = ( ID * ) ID ( ID ( ID -> ID ) [ ID ] ) ; 
ID != ID ; 
ID = ( ID * ) ID ( ID ) ) 
if ( ID -> ID -> ID == ID ) 
{ 
ID * ID = ( ID * ) ID ( ID ) ; 

if ( ID ( & ID -> ID . ID ) != INTEGER ) 
ID ( & ID , & ( ( ( ID * ) ID ( ID ) ) -> ID . ID ) ) ; 
else 
{ 
ID ( & ID ) ; 
ID ( ID ) ; 
ID ( & ID , & ID ) ; 
} 

} 
} 
ID ++ ; 
} 
} 
} 

 
static ID * ID ( void * ID , ID * * ID , ID * ID ) 
{ 
ID * ID = ( ID * ) ID ( ID , & ID , ID ) ; 

 
ID ( STRING ) ; 
ID ( & ID , ID , INTEGER ) ; 
ID ( STRING ) ; 
if ( ID == ID ) 
ID ( STRING ) ; 
else 
ID ( STRING ) ; 
 

if ( ID == ID ) 
{ 
ID * ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 
ID ID = ID ; 

 
ID ( & ID , & ID ) ; 

 
ID = ( ID * ) ID ( ID , & ID , sizeof ( ID ) , sizeof ( ID ) ) ; 

 
ID -> ID = ( ID * ) ID ( sizeof ( ID ) , ID -> ID ) ; 
ID -> ID -> ID . ID = ID ; 

 
ID -> ID = ID ; 
ID -> ID = * ID ; 
* ID = ID ; 

 
ID ( & ID , & ID ) ; 
if ( ID ( & ID ) != INTEGER ) 
ID ( & ID -> ID , ID ( ID -> ID ) ) ; 
} 

return ID ; 
} 

ID * ID ( ID * ID ) 
{ 
ID * ID ; 

for ( ID = ( ID * ) ID ( ID -> ID ) ; ID != ID ; ID = ( ID * ) ID ( ID ) ) 
if ( ID ( & ID -> ID , ID ( ID ) ) ) 
{ 
ID * ID ; 
ID * ID = ID ; 

do 
{ 
 
for ( ID = ( ID * ) ID ( ID ) ; 
ID != ID && ID -> ID -> ID == ID ; 
ID = ( ID * ) ID ( ID ) ) 
; 

 
if ( ID != ID ) 
{ 
if ( ID ( & ID -> ID -> ID , ID ) ) 
{ 
ID = ( ID * ) ID ( ID ) ; 
ID ( & ID -> ID , ID ( ID ) ) ; 
} 
else 
ID = ID ;  
} 
} 
while ( ID != ID ) ; 
} 
return ID ; 
} 

struct ID { ID * ID ; unsigned ID ; } ; 

int ID ( const void * ID , const void * ID ) 
{ 
struct ID * ID = ( struct ID * ) ID ; 
struct ID * ID = ( struct ID * ) ID ; 

if ( ID -> ID < ID -> ID ) 
return - INTEGER ; 
else if ( ID -> ID == ID -> ID ) 
return INTEGER ; 
else 
return INTEGER ; 
} 

ID * ID ( ID * ID ) 
{ 
ID * ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 

ID ID = ID ( ) , ID ; 
ID * ID = ID ; 
void * ID ; 
ID * ID ; 
unsigned ID ;  
unsigned ID ;  
unsigned ID = ID ( ID -> ID ) ; 
ID * ID = ID ; 
ID * ID = ID ; 

 
ID ( STRING , ID ) ; 
for ( ID = INTEGER ; ID <= ID ; ID ++ ) 
{ 
ID * ID = ( ID * ) ID ( ID -> ID ) [ ID ] ; 
ID ( STRING , ID , ID ) ; 
if ( ID != ID ) 
{ 
if ( ID ( & ID -> ID , ID ( ID ) ) ) 
ID ( STRING , ID -> ID . ID -> ID -> ID ) ; 
else 
ID ( ID -> ID . ID , INTEGER ) ; 
} 
else ID ( STRING ) ; 
ID ( STRING ) ; 
} 
 

ID = ID ( ) ; 
ID ( ID , STRING , ( ( double ) ( ID - ID ) ) / ID ) ; 

 
ID -> ID = ID ( STRING ) ; 
ID -> ID = ID ( ID -> ID ) ; 
ID -> ID = ID -> ID ; 
ID -> ID = ID ; 
ID -> ID = ID ( ID ) ; 
ID = ID ( STRING , INTEGER , INTEGER , ID , ID , ID ) ; 

 
ID ( & ID , ID ) ; 
ID ( & ID , ID ) ; 
ID ( & ID , ID ) ; 
ID ( & ID , ID ( ID -> ID ) - INTEGER ) ; 
ID ( & ID , ID ) ; 

 
ID ( & ID , & ID -> ID ) ; 

 
{ 
unsigned ID = INTEGER ; 
unsigned * ID = ID ( ID -> ID , INTEGER ) ; 
struct ID * ID ; 

ID = ID ( ) ; 
ID ( ID , STRING , ( ( double ) ( ID - ID ) ) / ID ) ; 

 
for ( ID = ( ID * ) ID ( ID -> ID ) ; ID != ID ; ID = ( ID * ) ID ( ID ) ) 
if ( ID ( & ID -> ID , ID ( ID ) ) ) 
ID ++ ; 

ID ( STRING , ID ) ; 

 
ID = ( struct ID * ) ID ( ID * sizeof ( struct ID ) ) ; 

 
ID = INTEGER ; 
for ( ID = ( ID * ) ID ( ID -> ID ) ; ID != ID ; ID = ( ID * ) ID ( ID ) ) 
if ( ID ( & ID -> ID , ID ( ID ) ) ) 
{ 
ID [ ID ] . ID = ID ; 
ID [ ID ] . ID = ID [ ID ( ID ) ] ; 
ID ++ ; 
} 

 
ID ( ID ) ; 

 
ID ( ID , ID , sizeof ( struct ID ) , ID ) ; 

ID ( & ID ) ; 
ID ( & ID ) ; 

for ( ID = ( ID * ) ID ( ID -> ID ) ; ID != ID ; ID = ( ID * ) ID ( ID ) ) 
if ( ID ( & ID -> ID , ID ( ID ) ) ) 
{ 
ID ( & ID ) ; 
ID ( ID ) ; 
ID ( ID , ID ( & ID ) ) ; 
ID ( ID , ID ( & ID ) ) ; 
ID ( & ID -> ID . ID , & ID ) ; 
} 
} 

ID = ID ( ) ; 
ID ( ID , STRING , ( ( double ) ( ID - ID ) ) / ID ) ; 

 
 
ID ( STRING , ID , ID == INTEGER ? STRING : STRING ) ; 

ID ( STRING , ID * sizeof ( unsigned * ) ) ; 
ID ( STRING , ( ID ( ID ) - ID ( ID , INTEGER ) ) * sizeof ( unsigned ) ) ; 
ID ( STRING , ID ( ID ) * sizeof ( unsigned ) ) ; 
ID ( ID ) ; 

ID ( STRING , ID * sizeof ( ID ) ) ; 
ID ( STRING , ID ( ID ) ) ; 
ID ( ID ) ; 
 
ID ( & ID ) ; 
ID ( & ID ) ; 

 
ID ( & ID , & ( ( ( ID * ) ID ( ID -> ID ) ) -> ID . ID ) ) ;  
ID ( ID -> ID , ID ( ID , & ID , ID ) -> ID ) ; 

while ( ID != ID ) 
{ 
 
ID * ID = ID ; 
ID ID = ID -> ID -> ID ; 
ID = ID -> ID ; 

 
ID ( & ID ) ; 
for ( ID = INTEGER , ID = INTEGER ; ID < ID . ID ; ID ++ )  
{ 
unsigned ID ;  
unsigned ID = ID . ID [ ID ] ;  

for ( ID = INTEGER ; ID < INTEGER ; ID <<= INTEGER )  
{ 
if ( ( ID & ID ) != INTEGER )  
{ 
ID * ID ; 

for ( ID = ( ID * ) ID ( ID ( ID -> ID ) [ ID ] ) ; 
ID != ID ; 
ID = ( ID * ) ID ( ID ) ) 
ID ( & ID , ID -> ID -> ID ) ; 
} 
ID ++ ; 
} 
} 

 
ID ( & ID , ID ) ; 

 
for ( ID = INTEGER , ID = INTEGER ; ID < ID . ID ; ID ++ )  
{ 
unsigned ID ;  
unsigned ID = ID . ID [ ID ] ;  

for ( ID = INTEGER ; ID < INTEGER ; ID <<= INTEGER )  
{ 
if ( ( ID & ID ) != INTEGER )  
{ 
ID ( & ID ) ; 
ID ( & ID , & ID ) ; 

ID ( ID , ID ) ; 

( ( ID * ) ID ( sizeof ( ID ) , 
ID ( ID , & ID , ID ) -> ID , 
ID -> ID -> ID ) ) -> ID = ID ( ID -> ID -> ID , ID ) ; 
} 
ID ++ ; 
} 
} 
ID ( ID ) ; 
} 

ID ( ID -> ID ) ; 

ID = ID ( ) ; 
ID ( ID , STRING , ( ( double ) ( ID - ID ) ) / ID ) ; 

return ID ; 
} 

typedef struct ID { ID ID ; 
struct ID * ID ; 
struct ID * ID ; 
} ID ; 

static ID * ID ( void * ID , ID ID , ID * ID ) 
{ 
ID * ID ; 

ID = ( ID * ) ID ( ID , & ID , ID ) ; 

 
ID ( STRING ) ; 
ID ( & ID , ID , INTEGER ) ; 
ID ( STRING ) ; 
if ( ID == ID ) 
ID ( STRING ) ; 
else 
ID ( STRING ) ; 
 

if ( ID == ID ) 
{ 
ID ID = ID ; 

ID ( & ID , & ID ) ; 

 
ID = ( ID * ) ID ( ID , & ID , sizeof ( ID ) , sizeof ( ID ) ) ; 

 
ID -> ID = ( ID * ) ID ( sizeof ( ID ) , ID -> ID ) ; 
ID -> ID -> ID . ID = ( ID * ) ID ; 
} 

return ID ; 
} 

ID * ID ( void * ID , ID * ID , ID * ID ) 
{ 
static ID ID = ID ; 
unsigned * ID = ID ( & ID -> ID . ID -> ID ) ; 
unsigned * ID = ID ; 

ID ( & ID ) ; 

while ( * ID != ID ) 
{ 
ID * ID = ( ID * ) ID ( ID -> ID -> ID ) [ * ID ++ ] ; 

if ( ! ID ( & ID -> ID , ID ( ID ) ) ) 
{ 
 
ID ( STRING , ID ( ID -> ID ) , ID ( ID ) ) ; 
 

ID ( & ID , ID ( ID -> ID . ID ) ) ; 
} 
} 
ID ( ID ) ; 

return ID ( ID , ID , ID ) ; 
} 

ID * ID ( ID * ID ) 
{ 

void * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 

 
 
ID -> ID = ID ( STRING ) ; 
ID -> ID = ID ( ID -> ID ) ; 
ID -> ID = ID ( ID -> ID ) ; 
ID -> ID = ID -> ID ; 
ID -> ID = ID ; 
ID = ID ( STRING , INTEGER , INTEGER , ID , ID , ID ) ; 

 
for ( ID = ( ID * ) ID ( ID -> ID ) ; ID != ID ; ID = ( ID * ) ID ( ID ) ) 
{ 
ID * ID = ID ( ID , ID , ID ) ; 

 
ID ( STRING , ID ( ID ) ) ; 
 

if ( ID ( & ID -> ID , ID ( ID ) ) ) 
ID ( & ID -> ID , ID ( ID -> ID ) ) ; 

if ( ID ( ID ) == INTEGER ) 
ID ( ID -> ID , ID -> ID ) ; 
} 

 
for ( ID = ( ID * ) ID ( ID -> ID ) ; 
ID != ID ; 
ID = ( ID * ) ID ( ID ) ) 
{ 
ID * ID = ID ( ID , ID , ID ) -> ID ; 

for ( ID = ( ID * ) ID ( ID ) ; 
ID != ID ; 
ID = ( ID * ) ID ( ID ) ) 
{ 
ID * ID = ID ( ID , ( ID * ) ID ( ID ) , ID ) -> ID ; 
ID * ID ; 
int ID = INTEGER ; 

for ( ID = ( ID * ) ID ( ID ) ; ID != ID ; ID = ( ID * ) ID ( ID ) ) 
if ( ID ( ID ) == ID && ID -> ID -> ID == ID -> ID -> ID ) 
{ 
ID = INTEGER ; 
break ; 
} 

if ( ! ID ) 
( ( ID * ) ID ( sizeof ( ID ) , ID , ID ) ) -> ID = ID -> ID ; 
} 
} 

 
ID ( ID -> ID ) ; 

return ID ; 
} 

 
 
 
 
 
 
 
 

ID * ID ( ID * ID ) 
{ 
void * ID ; 
ID * ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 
ID * * ID = ( ID * * ) ID ( ID ( ID ) , sizeof ( ID * ) ) ; 

ID -> ID = ID ( STRING ) ; 

ID -> ID = ID ( ID ) ; 

 
for ( ID = ID ( ID ( ID -> ID ) ) ; 
ID != ID ; 
ID = ID ( ID ) ) 
{ 
ID * ID = ( ID * ) ID ( ID ) ; 

ID * ID = ( ID * ) ID ( sizeof ( ID ) , ID -> ID ) ; 

ID -> ID = ID -> ID ; 
ID [ ID -> ID -> ID ] = ID ; 

if ( ID == ID -> ID -> ID ) 
ID ( ID -> ID , ID ) ; 
} 

 
for ( ID = ID ( ID ( ID -> ID ) ) ; 
ID != ID ; 
ID = ID ( ID ) ) 
{ 
ID * ID = ( ID * ) ID ( ID ) ; 
void * ID ; 

for ( ID = ID ( ID ) ; 
ID != ID ; 
ID = ID ( ID ) ) 
{ 
ID * ID = ( ID * ) ID ( ID ) ; 
void * ID ; 

for ( ID = ID ( ID ) ; 
ID != ID ; 
ID = ID ( ID ) ) 
{ 
ID * ID = ( ID * ) ID ( ID ) ; 

if ( ID -> ID -> ID == ID ) 
{ 
ID * ID = ID [ ID -> ID -> ID ] ; 
ID * ID = ID [ ID -> ID -> ID ] ; 
void * ID ; 
int ID = INTEGER ; 

 
if ( ID ( ID ) == ID ) 
{ 
ID = INTEGER ; 
break ; 
} 

if ( ! ID ) 
ID ( INTEGER , ID , ID ) ; 
} 
} 
} 
} 
ID ( ID ) ; 

return ID ; 
} 

static unsigned * ID ; 
static ID * ID ; 

static void ID ( const void * ID ) 
{ 
ID * ID = ( ID * ) ID ; 

ID ( STRING , ID -> ID -> ID , ID [ ID ( ID ) ] , ID [ ID ( ID ) ] ) ; 
} 

void ID ( ID * ID , ID * ID ) 
{ 

ID = ID ; 
ID = ID ( ID -> ID , INTEGER ) ; 

ID ( ID ) ; 
ID ( ID -> ID , ID , ID , ID ) ; 
ID ( ID ) ; 

ID ( ID ) ; 
} 

 
 
 
 
 
 
 
 
 
 

static int ID ( ID * ID , unsigned * ID ) 
{ 
int ID = INTEGER ; 

while ( * ID != INTEGER ) 
ID |= ID ( ID -> ID , * ID ++ ) -> ID == ID ; 

return ID ; 
} 

static void ID ( ID * ID , unsigned * ID , unsigned ID , int ID ) 
{ 
unsigned ID = INTEGER ; 

if ( * ID == INTEGER ) 
{ 
if ( ID ) 
ID ( STRING ) ; 
else 
ID ( STRING , ID ) ; 
} 
else 
while ( * ID != INTEGER ) 
if ( ID ) 
{ 
ID += ID ( STRING , ID ( ID -> ID , * ID ++ ) -> ID ) ; 

if ( ID > ID - INTEGER && & ID != INTEGER ) 
{ 
ID ( STRING ) ; 
ID = INTEGER ; 
} 
} 
else 
{ 
ID ( ID ) ; 
ID += ID ( * ID ++ ) ; 
ID ( STRING ) ; 
} 

ID ( STRING ) ; 
} 

void ID ( ID * ID , unsigned long ID , int ID ) 
{ 
typedef struct ID 
{ 
unsigned * ID ; 
struct ID * ID ; 
} ID ; 
ID * ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 
ID * ID = ID ; 
ID * ID ; 
unsigned long ID = INTEGER ; 

ID ( STRING , ID ? STRING : STRING ) ; 

 
ID -> ID = ( unsigned * ) ID ( INTEGER , sizeof ( unsigned ) ) ; 
* ( ID -> ID ) = ID -> ID -> ID ; 

do 
{ 
ID = ID ; 

 
if ( ! ( ID ( ID , ID -> ID ) && ! ID ) ) 
{ 
ID ( STRING , ID ++ ) ; 
ID ( ID , ID -> ID , INTEGER , ! ID ) ; 
} 

 
if ( ID ( ID , ID -> ID ) ) 
{ 
unsigned * ID = ID -> ID ; 
ID ID = INTEGER , 
ID = INTEGER ; 
unsigned ID ; 
void * ID , 
* ID ; 

 
while ( ID ( ID -> ID , * ID ++ ) -> ID != ID ) 
ID ++ ; 

ID = ID -> ID [ ID ] ; 

 
while ( * ID ++ != INTEGER ) 
ID ++ ; 

 
for ( ID = ID ( ID ( ID -> ID , ID ) -> ID ) ; 
ID != ID ; 
ID = ID ( ID ) 
) 
{ 
unsigned ID = INTEGER ; 
ID ID ; 
unsigned * ID , 
* ID ; 

 
for ( ID = ID ( ID ( ID ) ) ; 
ID != ID ; 
ID = ID ( ID ) 
) 
if ( ( ( ID * ) ID ( ID ) ) -> ID -> ID != ID ) 
ID ++ ; 

 
ID -> ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 
ID = ID -> ID ; 

 
ID -> ID = ( unsigned * ) ID ( ID + ID + ID + INTEGER , sizeof ( unsigned ) ) ; 

 
for ( ID = INTEGER , ID = ID -> ID , ID = ID -> ID ; 
ID < ID ; 
ID ++ ) 
* ID ++ = * ID ++ ; 

 
for ( ID = ID ( ID ( ID ) ) ; 
ID != ID ; 
ID = ID ( ID ) 
) 
{ 
ID * ID = ( ID * ) ID ( ID ) ; 

if ( ID -> ID -> ID != ID ) 
* ID ++ = ID -> ID -> ID ; 
} 

 
for ( ID = INTEGER , ID ++ ; 
ID < ID ; 
ID ++ ) 
* ID ++ = * ID ++ ; 
} 
} 

 
ID = ID -> ID ; 
ID ( ID -> ID ) ; 
ID ( ID ) ; 
} 
while ( ID != ID && ( ID == INTEGER || ID <= ID ) ) ; 
} 

 
 
 
 
 
 
 
 
 
 

 
 

 
static ID * ID ; 

ID * ID ( void * ID , char * ID , int ID ) 
{ 
ID * ID ; 
struct ID { int ID ; char * ID ; } ID ; 

ID . ID = ID ; 
ID . ID = ID ; 

if ( ( ID = ( ID * ) ID ( ID , & ID , ID ) ) == ID ) 
{ 
ID = ( ID * ) ID ( ID , & ID , sizeof ( struct ID ) , sizeof ( ID ) ) ; 
ID -> ID = ID ( ID ) ; 
} 

return ID ; 
} 

ID * ID ( void * ID , unsigned ID ) 
{ 
 
ID * ID ; 

for ( ID = ( ID * ) ID ( ID ( ID ) ) ; 
ID != ID ; 
ID = ( ID * ) ID ( ID ) 
) 
if ( ID -> ID == ID ) 
return ID ; 

return ID ; 
} 

int ID ( ID * ID ) 
{ 
if ( ID == ID ) 
return ID ( STRING ) ; 
else 
return ID ( STRING , ID -> ID == ID ? STRING : STRING , 
ID -> ID , 
ID -> ID == ID ? STRING : STRING 
) ; 
} 

void ID ( ID * ID , unsigned ID , int ID ) 
{ 
unsigned ID = ID ( ID ) ; 
unsigned ID ; 
int ID = INTEGER ; 

for ( ID = ID ; ID < ID ; ID ++ ) 
{ 
ID * ID = ID ( ID -> ID , ID ) ; 

if ( ID != ID ) 
{ 
if ( ID -> ID != ID && ! ID ) 
{ 
if ( ID ) 
ID ( STRING ) ; 
ID = INTEGER ; 
} 
if ( ID ) 
ID ( STRING , ID ) ; 
else 
ID ( STRING , ID ) ; 

ID ( ID ) ; 
ID ( STRING ) ; 
} 
} 
} 

static void ID ( ID * ID ) 
{ 
void * ID , 
* ID , 
* ID ; 
ID * ID , 
* ID ; 

for ( ID = ID ( ( ID * ) ID ( ID -> ID ) ) ; 
ID != ID ; 
ID = ID ( ID ) ) 
{ 
ID = ( ID * ) ID ( ID ) ; 

ID ( ID -> ID ) ; 

ID ( STRING ) ; 

for ( ID = ID ( ID ) ; 
ID != ID ; 
ID = ID ( ID ) ) 
{ 
ID = ( ID * ) ID ( ID ) ; 

for ( ID = ID ( ID ) ; 
ID != ID ; 
ID = ID ( ID ) ) 
{ 
ID ( STRING ) ; 
ID ( ( ( ID * ) ID ( ID ) ) -> ID ) ; 
} 

if ( ID ( ID ) == ID ) 
ID ( STRING ) ; 
else ID ( STRING ) ; 
} 
} 
} 

static void ID ( ID * ID ) 
{ 
ID * ID ; 
ID ID = ID ; 

ID ( & ID , & ( ID -> ID ) ) ; 
ID ( & ID , ID ( ID ) - INTEGER ) ; 
ID ( & ID , ID , ID , ID , ID ) ; 

ID ( STRING ) ; 
ID ( ID , ID -> ID , INTEGER ) ; 
ID ( STRING ) ; 
ID ( ID , ID , INTEGER ) ; 
ID ( STRING ) ; 

ID ( & ID ) ; 

for ( ID = ( ID * ) ID ( ID ( ID -> ID ) ) ; 
ID != ID ; 
ID = ( ID * ) ID ( ID ) ) 
if ( ID -> ID == ID || ID -> ID == ID ) 
{ 
ID ( STRING ) ; 
ID ( ID ) ; 
ID ( STRING ) ; 
ID ( ID , ID -> ID , INTEGER ) ; 
ID ( STRING ) ; 
ID ( ID ) ; 
ID ( STRING ) ; 
ID ( ID , ID -> ID , INTEGER ) ; 
ID ( STRING ) ; 
} 
} 

 
static int ID ( ID * ID , int ID ) 
{ 
if ( ID ( ID , ID ) ) 
return INTEGER ; 

ID ( ID , ID ) ; 
return INTEGER ; 
} 

static int ID ( ID * ID , ID * ID ) 
{ 
if ( ID ( ID , ID ) ) 
return INTEGER ; 

ID ( ID , ID ) ; 
return INTEGER ; 
} 
 

static ID * ID ( ID * ID ) 
{ 
ID * ID = ( ID * ) ID ( sizeof ( ID ) , ID ) ; 

ID ( INTEGER , ID , ID ) ; 

return ID ; 
} 

static void ID ( ID * ID ) 
{ 
 
ID * ID ; 

 
unsigned ID = ID + INTEGER ; 

 
ID ( ID -> ID , ID ( ID -> ID ) ) ; 

 
for ( ID = ( ID * ) ID ( ID ( ID -> ID ) ) ; 
ID != ID ; 
ID = ( ID * ) ID ( ID ) ) 
if ( ID -> ID == ID ) 
ID -> ID = ID ++ ;  

 
for ( ID = ( ID * ) ID ( ID ( ID -> ID ) ) ; 
ID != ID ; 
ID = ( ID * ) ID ( ID ) ) 
if ( ID -> ID == ID ) 
ID -> ID = ID ++ ;  
} 

static ID * ID ( ID * ID ) 
{ 
ID * ID = ID -> ID -> ID ; 
void * ID = ID ( ID ) ; 
ID * ID = ( ID * ) ID ( ID ) ; 
void * ID = ( ID * ) ID ( ID ) ; 
ID * ID = ( ID * ) ID ( ID ) ; 

if ( ID -> ID -> ID == ID && 
ID ( ID ) == ID && 
ID ( ID ) == ID ) 
return ID ; 
else 
{ 
char * ID ; 
ID * ID = ( ID * ) ID ( sizeof ( ID ) , ID -> ID ) ; 
ID * ID = ( ID * ) ID ( sizeof ( ID ) , ID -> ID ) ; 
ID * ID = ( ID * ) ID ( sizeof ( ID ) , ID -> ID ) ; 

ID ( INTEGER , ID , ID ( ID -> ID ) ) ; 
ID ( INTEGER , ID , ID ) ; 
ID ( INTEGER , ID , ID ) ; 

ID = ( char * ) ID ( ID ( ID -> ID -> ID ) + ID ( ID ) + INTEGER , sizeof ( char ) ) ; 
ID ( ID ( ID , ID -> ID -> ID ) , ID ) ; 
ID -> ID = ID ( ID -> ID , ID , ID ) ; 
ID -> ID -> ID = ID ; 

ID -> ID = ID -> ID ; 

ID -> ID = ID -> ID ; 

return ID ; 
} 
} 

static void ID ( ID * ID , ID * ID ) 
{ 
void * ID , 
* ID ; 

if ( ID ( ID , ID -> ID -> ID ) ) 
return ; 


ID ( ID , ID -> ID -> ID ) ; 

for ( ID = ID ( ID ) ; 
ID != ID ; 
ID = ID ( ID ) ) 
for ( ID = ID ( ID ( ID ) ) ; 
ID != ID ; 
ID = ID ( ID ) ) 
{ 
ID * ID = ( ID * ) ID ( ID ) ; 

if ( ID -> ID -> ID == ID ) 
{ 
if ( ID -> ID -> ID != ID ) 
ID ( ID -> ID -> ID , ID ) ; 
else 
ID ( ID , STRING , ID -> ID -> ID , ID -> ID -> ID ) ; 
} 
else if ( ID -> ID -> ID == ID ) 
ID ( ID , ID -> ID -> ID ) ; 
else 
ID ( ID , ID ) ; 
} 
} 

static void ID ( ID * ID ) 
{ 
int ID ; 

do 
{ 
void * ID ; 

ID = INTEGER ; 

for ( ID = ID ( ID ( ID -> ID ) ) ; 
ID != ID ; 
ID = ID ( ID ) ) 
{ 
void * ID ; 
ID * ID = ( ID * ) ID ( ID ) ; 

for ( ID = ID ( ID ) ; 
ID != ID ; 
ID = ID ( ID ) ) 
{ 
void * ID ; 
ID ID = ID ;  
int ID = INTEGER ;  
ID * ID = ( ID * ) ID ( ID ) ; 
ID ( & ID , ID ) ;  

 
for ( ID = ID ( ID ) ; 
ID != ID ; 
ID = ID ( ID ) ) 
{ 
ID * ID = ( ID * ) ID ( ID ) ; 

 
switch ( ID -> ID -> ID ) 
{ 
case ID : 
ID = INTEGER ; 
ID ( & ID , ID -> ID -> ID ) ; 
ID |= ID ( & ID -> ID -> ID , ID -> ID -> ID ) ; 
break ; 
case ID : 
if ( ID ( & ( ID -> ID -> ID ) , ID ) )  
{ 
ID ( & ID , & ( ID -> ID -> ID ) ) ; 
ID ( & ID , ID ) ; 
} 
else 
{ 
ID = INTEGER ; 
ID ( & ID , & ( ID -> ID -> ID ) ) ; 
} 
ID ( & ID , ID -> ID -> ID ) ; 
break ; 
} 
if ( ID ) 
ID |= ID ( & ( ID -> ID -> ID ) , ID ) ; 
} 
ID |= ID ( & ( ID -> ID -> ID ) , & ID ) ; 

if ( ID )  
ID |= ID ( & ( ID -> ID -> ID ) , ID ) ; 
} 
} 
} 
while ( ID ) ; 
} 

static void ID ( ID * ID ) 
{ 
ID * ID ; 
int ID ;  

for ( ID = ( ID * ) ID ( ID ( ID -> ID ) ) ; 
ID != ID ; 
ID = ( ID * ) ID ( ID ) ) 
ID ( & ID -> ID ) ; 

ID ( & ID -> ID -> ID , ID ) ;  

do 
{ 
ID = INTEGER ; 

 
for ( ID = ( ID * ) ID ( ID ( ID -> ID ) ) ; 
ID != ID ; 
ID = ( ID * ) ID ( ID ) ) 
{ 
ID * ID = ID -> ID ; 

if ( ID != ID && ID ( & ( ID -> ID ) ) != INTEGER  ) 
{ 
void * ID ; 

for ( ID = ID ( ID ) ; 
ID != ID ; 
ID = ID ( ID ) ) 
{ 
ID * ID = ID ( ID ) ; 
void * ID ; 

for ( ID = ID ( ID ) ; 
ID != ID ; 
ID = ID ( ID ) ) 
{ 
void * ID ; 
int ID = INTEGER ; 
ID * ID = ID ( ID ) ; 

for ( ID = ID ( ID ) ; 
ID && ID != ID ; 
ID = ID ( ID ) ) 
{ 
ID * ID = ID ( ID ) ; 
ID ID = ID ; 

ID ( & ID , & ID -> ID -> ID ) ; 
ID ( & ID , ID -> ID -> ID ) ; 
if ( ID ( & ID , ID ) ) 
ID ( & ID , ID ) ; 
else 
ID = INTEGER ; 
ID |= ID ( & ID -> ID -> ID , & ID ) ; 
ID ( & ID ) ; 
} 

if ( ID ) 
ID |= ID ( & ( ID -> ID -> ID ) , & ID -> ID ) ; 
} 
} 
} 
} 
} 
while ( ID ) ; 
} 

ID * ID ( ID * ID , ID * ID ) 
{ 
ID * ID ; 
ID * ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 
unsigned ID = INTEGER ; 
unsigned ID = INTEGER ; 

ID -> ID = ID ( STRING , INTEGER , INTEGER , ID , ID , ID ) ; 
ID ( ID -> ID , ID , ID ) -> ID = ID ; 
ID ( ID -> ID , ID , ID ) -> ID = ID ; 
ID ( ID -> ID , ID , ID ) -> ID = ID ; 

ID ( & ( ID ( ID -> ID , ID , ID ) -> ID ) , ID ) ; 
ID -> ID = ID ( STRING ) ; 
ID ( ID -> ID , ( ID * ) ID ( sizeof ( ID ) , ID -> ID ) ) ; 

 
for ( ID = ( ID * ) ID ( ID ) ; ID != ID ; ID = ( ID * ) ID ( ID ) ) 
{ 
ID * ID = ( ID * ) ID ( ID ) ; 
void * ID ; 
ID * ID = ( ID * ) ID ( ( ID * ) ID ( ID -> ID ) ) ; 

ID -> ID = ID ( ID -> ID , ID -> ID , ID ) ; 
ID -> ID -> ID = ID ; 

if ( ID ( ID -> ID , ID -> ID ) == INTEGER ) 
ID -> ID = ID -> ID ; 

ID ++ ; 

for ( ID = ID ( ID ) ; 
ID != ID ; 
ID = ID ( ID ) ) 
{ 
ID * ID = ( ID * ) ID ( ID ) ; 
void * ID ; 
ID * ID = ID ( ID ) ; 

ID ++ ; 

for ( ID = ID ( ID ) ; 
ID != ID ; 
ID = ID ( ID ) ) 
{ 
ID * ID = ( ID * ) ID ( ID ) ; 
ID * ID = ID ( ID ) ; 

switch ( ID -> ID -> ID -> ID ) 
{ 
case ID : 
ID -> ID = ID ( ID -> ID , ID -> ID , ID ) ; 
break ; 
case ID : 
ID -> ID = ID ( ID -> ID , ID -> ID , ID ) ; 
break ; 
case ID : 
ID -> ID = ID ( ID -> ID , ID , ID ) ; 
break ; 
default : 
ID ( ID , STRING ) ; 
} 
} 
} 
} 

ID ( STRING , ID , ID ) ; 
ID ( ID ) ; 

ID ( ID ) ; 

ID ( ID -> ID -> ID , & ( ID -> ID ) ) ; 

ID ( ) ; 

ID ( ID ) ; 
ID ( ID ) ; 

return ID ; 
} 

unsigned ID ( ID * ID ) 
{ 
unsigned ID = INTEGER ; 
ID * ID ; 

for ( ID = ( ID * ) ID ( ID ( ID -> ID ) ) ; 
ID != ID ; 
ID = ( ID * ) ID ( ID ) 
) 
if ( ID -> ID > ID ) 
ID = ID -> ID ; 

return ID + INTEGER ; 
} 

ID * ID ( ID * ID ) 
{ 
return ID ;  
} 

int ID ( ID * ID ) 
{ 
ID * ID , 
* ID ; 

if ( ID -> ID == ID )  
ID = ID ; 
else 
 
ID = ( ID * ) ID ( ID ( ID ) ) ; 

ID = ( ID * ) ID ( ID ( ID ) ) ; 

if ( ID == ID ) 
return INTEGER ; 
else if ( ID -> ID && ID -> ID -> ID == ID ) 
return INTEGER ; 
else 
return INTEGER ; 
} 

ID * ID ( ID * ID ) 
{ 
ID * ID , 
* ID ; 

if ( ID -> ID == ID )  
ID = ID ; 
else 
 
ID = ( ID * ) ID ( ID ( ID ) ) ; 

ID = ( ID * ) ID ( ID ( ID ) ) ; 

if ( ID == ID ) 
return ID ; 
else 
return ID -> ID ; 
} 

ID * ID ( ID * ID ) 
{ 
void * ID ; 

if ( ID == ID ) 
return ID ; 

if ( ID -> ID == ID )  
ID = ID ( ID ) ; 
else 
ID = ID ( ID ( ID ) ) ; 

if ( ID == ID ) 
return ID ; 
else 
return ( ID * ) ID ( ID ) ; 
} 

void ID ( ID * ID , ID * ID ) 
{ 
ID ( ID ) ; 

if ( ID == ID ) 
ID ( ID , ID ) ; 
else 
{ 
ID * ID = ID ( ID ) ; 

if ( ID == ID ) 
ID ( ID , ID ) ; 
else 
while ( ID != ID ) 
{ 
ID ( ID , & ID -> ID -> ID ) ; 
if ( ! ID ( & ID -> ID -> ID , ID ) ) 
{ 
ID ( ID , ID ) ; 
break ; 
} 
ID = ID ( ID ) ; 
} 
} 
} 

int ID ( ID * ID ) 
{ 
ID * ID , 
* ID ; 
int ID = INTEGER ; 

if ( ID -> ID == ID )  
{ 
ID = ID ; 
ID = INTEGER ; 
} 
else 
 
ID = ( ID * ) ID ( ID ( ID ) ) ; 

ID = ( ID * ) ID ( ID ( ID ) ) ; 

if ( ID == ID ) 
return INTEGER ; 
else if ( ID -> ID && ID -> ID -> ID == ID ) 
return INTEGER ; 
else 
return ID ; 
} 

void ID ( ID * ID , int ID ) 
{ 
ID * ID , 
* ID ; 
void * ID ; 

if ( ID -> ID == ID )  
ID = ID ; 
else 
 
ID = ( ID * ) ID ( ID ( ID ) ) ; 

ID = ( ID * ) ID ( ID ( ID ) ) ; 

if ( ID == ID ) 
ID ( STRING ) ; 
else 
ID ( ID -> ID ) ; 
ID ( STRING ) ; 

if ( ID -> ID == ID )  
if ( ID ) 
ID ( STRING ) ; 
else 
ID ( STRING ) ; 

for ( ID = ID ( ID ) ; 
ID != ID ; 
ID = ID ( ID ) ) 
{ 
ID * ID = ( ID * ) ID ( ID ) ; 

ID ( ID -> ID ) ; 
ID ( STRING ) ; 

if ( ID == ID ) 
if ( ID ) 
ID ( STRING ) ; 
else 
ID ( STRING ) ; 
} 

} 

static void ID ( const void * ID ) 
{ 
ID * ID = ( ID * ) ID ; 

if ( ID -> ID == ID ) 
ID ( STRING , ID ( ID ) ) ; 
else 
switch ( ID -> ID -> ID ) 
{ 
case ID : 
case ID : 
ID ( STRING , ID ( ID ) ) ; 
ID ( ID -> ID ) ; 
ID ( STRING ) ; 
break ; 
case ID : 
ID ( STRING , ID ( ID ) , ID -> ID -> ID ) ; 
break ; 
default : 
ID ( ID ) ; 
ID ( ID , STRING ) ; 
break ; 
} 

ID ( STRING , ID ( ID ) ) ; 
} 

void ID ( ID * ID , ID * ID ) 
{ 
ID * ID = ID ( ) ; 
ID * ID = ID ( STRING , STRING ) ; 

ID ( ID ) ; 
ID ( STRING ) ; 
ID ( ID , INTEGER , INTEGER ) ; 
ID ( STRING ) ; 
ID ( ID ) ; 
ID ( STRING ) ; 
ID ( ID ) ; 
ID ( ID ) ; 
ID ( ID ) ; 
ID ( ID -> ID , ID , ID , ID ) ; 
ID ( ID ) ; 
ID ( ID ) ; 
} 

int ID ( const unsigned ID ) 
{ 
return ID ( ID ( ID -> ID , ID ) ) ; 
} 

void ID ( ID * ID ) 
{ 
ID = ID ; 
} 
 
 
 
 

 
 
 
 
 

 
 
 
 
 
 
 

 
 

unsigned ID ; 
unsigned ID ; 
char * ID ; 
char * * ID ; 

ID * ID ; 

static void * ID ; 
static void * ID ; 
static ID * ID ; 

static ID ID = ID ; 
static ID ID = ID ; 
static ID ID = ID ; 
static ID ID = ID ; 
static ID ID = ID ; 

static ID ID ( ID * ID , int ID ) ; 

char * ID ( char * ID )  
{ 
return ID ( ( char * ) ID ( ID ( ID ) + INTEGER ) , ID ) ; 
} 

ID * ID ( char * ID ) 
{ 
return ( ID * ) ID ( ID , & ID , sizeof ( char * ) , sizeof ( ID ) , ID , ID ) ; 
} 

void ID ( void ) 
{ 
ID ( ID , ID ) ; 
} 

void ID ( char * ID ) 
{ 
ID ( ID , ID ) ; 
} 

void ID ( void ) 
{ 
ID ( ID ( ID ) ) ; 
ID ( ID , ID ) ; 
} 

static char * ID ( int ID ) 
{ 
switch ( ID ) 
{ 
case ID : return STRING ; 
case ID : return STRING ; 
case ID : return STRING ; 
case ID : return STRING ; 
case ID : return STRING ; 
case ID : return STRING ; 
case ID : return STRING ; 
case ID : return STRING ; 
case ID : return STRING ; 
case ID : return STRING ; 
case ID : return STRING ; 
case ID : return STRING ; 
case ID : return STRING ; 
case ID : return STRING ; 
case ID : return STRING ; 
case ID : return STRING ; 
case ID : return STRING ; 
case ID : return STRING ; 
case ID : return STRING ; 
default : return STRING ; 
} 
} 

static void ID ( ID ID ) 
{ 
switch ( ID . ID ) 
{ 
case ID : ID ( STRING , ID . ID ? STRING : STRING , ID ( ID . ID ) ) ; break ; 
case ID : ID ( STRING , ID . ID , ID ( ID . ID ) ) ; break ; 
case ID : ID ( STRING , ID . ID , ID ( ID . ID ) ) ; break ; 
case ID : ID ( STRING , ID . ID , ID ( ID . ID ) ) ; break ; 
case ID : ID ( STRING , ID . ID , ID . ID , ID ( ID . ID ) ) ; break ; 
case ID : ID ( STRING , ID . ID , ID ( ID . ID ) ) ; break ; 
default : ID ( STRING , ID ( ID . ID ) ) ; 
} 
} 

static void ID ( ID * ID , ID ID ) 
{ 
switch ( ID . ID ) 
{ 
case ID : ID ( ID , STRING , ID . ID ? STRING : STRING ) ; break ; 
case ID : ID ( ID , STRING , ID . ID ) ; break ; 
case ID : ID ( ID , STRING , ID . ID ) ; break ; 
case ID : ID ( ID , STRING , ID . ID ) ; break ; 
case ID : ID ( ID , STRING , ID . ID ) ; break ; 
case ID : ID ( ID , STRING , ID . ID ) ; break ; 
case ID : ID ( ID , ID . ID ) ; break ; 
case ID : ID ( ID , ID . ID ) ; break ; 
case ID : ID ( ID , ID . ID ) ; break ; 
case ID : ID ( ID , ID . ID ) ; break ; 
case ID : ID ( ID , ID . ID ) ; break ; 
default : ID ( ID , STRING , ID ( ID . ID ) ) ; 
} 
} 

static void ID ( ID * ID , ID ID , int ID ) 
{ 
switch ( ID . ID ) 
{ 
case ID : ID ( ID , ID . ID , ID ) ; break ; 
default : ID ( ID , ID ) ; 
} 
} 

static void ID ( ID * ID , ID ID ) 
{ 
switch ( ID . ID ) 
{ 
case ID : ID ( ID , ID . ID ) ; break ; 
default : 
ID ( STRING ) ; 
ID . ID = ID ; 
} 
} 

ID ID ( ID * ID , int ID ) 
{ 
ID ID ; 

ID . ID = ID ; 

if ( ID == ID ) 
ID ( STRING ) ; 
else if ( ID -> ID == ID ) 
ID ( STRING , ID -> ID ) ; 
else if ( ID -> ID -> ID == ID ) 
ID ( STRING , ID -> ID ) ; 
else if ( ID -> ID -> ID -> ID == ID ) 
{ 
 
ID ( STRING , ID -> ID ) ; 
 
ID = ID -> ID -> ID -> ID ( ID , ID ) ; 
} 
else 
{ 
 
ID ( STRING , ID -> ID ) ; 
ID ( ID ) ; 
ID ( STRING ) ; 
 
ID ( & ID , ID -> ID -> ID , sizeof ( ID ) ) ; 
} 

return ID ; 
} 

static void ID ( ID * ID , ID ID ) 
{ 

 
ID ( STRING , ID -> ID ) ; 
ID ( ID ) ; 
ID ( STRING ) ; 
 

if ( ID == ID ) 
ID ( STRING ) ; 
else if ( ID -> ID == ID ) 
ID ( STRING , ID -> ID ) ; 
else if ( ID -> ID -> ID == ID ) 
{ 
ID -> ID -> ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 
ID ( ID -> ID -> ID , & ID , sizeof ( ID ) ) ; 
} 
else if ( ID . ID != ID -> ID -> ID -> ID ) 
{ 
ID ( STRING ) ; 
ID ( ID ) ; 
ID ( STRING , ID -> ID ) ; 
ID ( * ( ID -> ID -> ID ) ) ; 
ID ( STRING ) ; 
} 
else 
ID ( ID -> ID -> ID , & ID , sizeof ( ID ) ) ; 
} 

static int ID ( void * * ID , ID * ID , ID ID , char * ID , int ID ) 
{ 
if ( * ID == ID ) 
{ 
if ( ID != ID ) 
ID ( ID , STRING , ID ) ; 
ID -> ID = ID ; 
return INTEGER ; 
} 

* ID = ID ( ( ID * ) ID ( * ID ) , ID ) ; 

if ( ID -> ID != ID ) 
{ 
if ( ID != ID ) 
{ 
ID ( ID , STRING , 
ID , 
ID ( ID ) , 
ID ( ID -> ID ) ) ; 
} 
ID -> ID = ID ; 
return INTEGER ; 
} 

* ID = ID ( * ID ) ; 
return INTEGER ; 
} 

static ID ID ( void * ID , int ID ) 
{ 
ID ID ; 
void * ID = ID ( ID ) ; 
ID ID ; 
int ID = ID ; 
char * ID ; 

ID . ID = ID ; 

if ( ID ) 
{ 
ID ( & ID , & ID , ID , STRING , ID ) ; 
ID = ID . ID ; 

if ( ID ( & ID , & ID , ID , ID , ID ) ) 
ID = ID . ID ; 

ID . ID = ID ; 

ID . ID = ID ; 

switch ( ID ) 
{ 
case ID : ID . ID = ID ( ID , STRING ) ; break ; 
case ID : ID . ID = ID ( ID , STRING ) ; break ; 
case ID : ID . ID = ID ( ID , STRING ) ; break ; 
case ID : ID . ID = ID ( ID , STRING ) ; break ; 
case ID : ID ( ID , STRING ) ; 
default : ID ( ID , STRING ) ; 
} 

if ( ID . ID == ID ) 
ID ( ID , STRING , ID ) ; 
} 

return ID ; 
} 

static ID ID ( void * ID , int ID ) 
{ 
void * ID = ID ( ID ) ; 
ID ID ; 
ID * ID = ID ; 

ID . ID = ID ; 

if ( ID ) 
{ 
if ( ID ( & ID , & ID , ID , ID , ID ) ) 
ID = ID . ID ; 

for ( ; ID != ID ; ID = ID ( ID ) ) 
ID ( ID , ID = ID ( ( ID * ) ID ( ID ) , ID ) ) ; 
} 

return ID ; 
} 

static ID ID ( void * ID , int ID ) 
{ 
void * ID = ID ( ID ) ; 
ID ID ; 
ID * ID = ID ; 

ID . ID = ID ; 

if ( ID ) 
{ 
if ( ID ( & ID , & ID , ID , ID , ID ) ) 
ID = ID . ID ; 

for ( ; ID != ID ; ID = ID ( ID ) ) 
ID ( ID , ID = ID ( ( ID * ) ID ( ID ) , ID ) , INTEGER ) ; 
} 

return ID ; 
} 

static ID ID ( void * ID , int ID ) 
{ 
void * ID = ID ( ID ) ; 
ID ID ; 
ID * ID = ID ; 

ID . ID = ID ; 

if ( ID ) 
{ 
if ( ID ( & ID , & ID , ID , ID , ID ) ) 
ID = ID . ID ; 

for ( ; ID != ID ; ID = ID ( ID ) ) 
ID ( ID , ID = ID ( ( ID * ) ID ( ID ) , ID ) , INTEGER ) ; 
} 

return ID ; 
} 

static ID ID ( void * ID , int ID ) 
{ 
void * ID = ID ( ID ) ; 
ID ID ; 
ID * ID = ID ; 

ID . ID = ID ; 

if ( ID ) 
{ 
if ( ID ( & ID , & ID , ID , ID , ID ) ) 
ID = ID . ID ; 

for ( ; ID != ID ; ID = ID ( ID ) ) 
ID ( ID , ID = ID ( ( ID * ) ID ( ID ) , ID ) ) ; 
} 

return ID ; 
} 

static ID ID ( void * ID , int ID ) 
{ 
ID ID ; 

ID . ID = ID ; 
if ( ID ) 
ID . ID = ( ( ID * ) ID ) -> ID ; 

return ID ; 
} 

static ID ID ( void * ID , int ID ) 
{ 
ID ID ; 
void * ID = ID ( ID ) ; 
ID ID ; 

ID . ID = ID ; 

if ( ID ) 
{ 
ID ( & ID , & ID , ID , STRING , ID ) ; 

ID . ID = ID ; 
ID . ID = ID ( ID , ( ID * ) ( ID . ID ) ) ; 
} 

return ID ; 
} 

static ID ID ( void * ID , int ID ) 
{ 
ID ID ; 
void * ID = ID ( ID ) ; 
ID ID ; 

ID . ID = ID ; 

if ( ID ) 
{ 
ID ( & ID , & ID , ID , STRING , ID ) ; 

ID . ID = ID ; 
ID . ID = ID ( ID . ID ) ; 
} 

return ID ; 
} 

static ID ID ( void * ID , int ID ) 
{ 
ID ID ; 
ID * ID ; 
unsigned ID ; 
void * ID = ID ( ID ) ; 
int ID = INTEGER ; 

if ( ID ) 
{ 
ID ( & ID , & ID , ID , STRING , ID ) ; 
ID = ID . ID ; 

ID ( & ID , & ID , ID , STRING , ID ) ; 
ID = ID . ID ; 

if ( ID ( & ID , & ID , ID , STRING , ID ) ) 
switch ( ID . ID ) 
{ 
case ID : ID = INTEGER ; break ; 
case ID : ID = INTEGER ; break ; 
case ID : ID ( ID , STRING ) ; break ; 
case ID : ID ( ID , STRING ) ; break ; 
default : ID ( ID , STRING ) ; 
} 

ID ( ID , ID , ID ) ; 
} 

ID . ID = ID ; 
return ID ; 
} 

static ID ID ( void * ID , int ID ) 
{ 
ID ID ; 
void * ID = ID ( ID ) ; 
ID ID ; 
ID * ID ; 

ID . ID = ID ; 

if ( ID ) 
{ 
ID ( & ID , & ID , ID , STRING , ID ) ; 
ID = ID . ID ; 

ID ( & ID , & ID , ID , STRING , ID ) ; 

switch ( ID . ID ) 
{ 
case ID : 
case ID : 
ID ( ID , STRING ) ; 

case ID : 
case ID : 
case ID : 
ID ( ID , STRING ) ; 

case ID : 
ID ( ID , STRING ) ; 

case ID : 
case ID : 
case ID : 
ID . ID = ID ; 
ID . ID = ID ( ID , ( enum ID ) ID . ID ) ; 
break ; 

case ID : 
ID . ID = ID ; 
 
break ; 

default : ID ( ID , STRING ) ; 
} 
} 

return ID ; 
} 

static ID ID ( void * ID , int ID ) 
{ 
ID ID ; 
void * ID = ID ( ID ) ; 
ID ID ; 

ID . ID = ID ; 

if ( ID ) 
{ 
ID ( & ID , & ID , ID , STRING , ID ) ; 

ID . ID = ID ; 
ID . ID = ID ( ID . ID ) ; 
} 

return ID ; 
} 

static ID ID ( void * ID , int ID ) 
{ 
ID ID ; 
void * ID = ID ( ID ) ; 
ID ID ; 

ID . ID = ID ; 

if ( ID ) 
{ 
ID ( & ID , & ID , ID , STRING , ID ) ; 

ID . ID = ID ; 
ID . ID = ID ( ID . ID ) ; 
} 

return ID ; 
} 

static ID ID ( void * ID , int ID ) 
{ 
ID ID ; 
void * ID = ID ( ID ) ; 
ID ID ; 

ID . ID = ID ; 

if ( ID ) 
{ 
ID ( & ID , & ID , ID , STRING , ID ) ; 

ID . ID = ID ; 
ID . ID = ID ( ID . ID ) ; 
} 

return ID ; 
} 

static ID ID ( void * ID , int ID ) 
{ 
ID ID ; 
void * ID = ID ( ID ) ; 
ID ID ; 

ID . ID = ID ; 
if ( ID ) 
{ 
ID ( & ID , & ID , ID , STRING , ID ) ; 

ID . ID = ID ; 
ID . ID = ID ( ID . ID , INTEGER ) ; 
} 

return ID ; 
} 

static ID ID ( void * ID , int ID ) 
{ 
ID ID ; 
void * ID = ID ( ID ) ; 
ID ID ; 

ID . ID = ID ; 
if ( ID ) 
{ 
ID ( & ID , & ID , ID , STRING , ID ) ; 

ID . ID = ID ; 
ID . ID = ID ( ID . ID , INTEGER ) ; 
} 

return ID ; 
} 

static ID ID ( void * ID , int ID ) 
{ 
ID ID ; 
ID * ID ; 
void * ID = ID ( ID ) ; 
ID ID ; 

ID . ID = ID ; 
if ( ID ) 
{ 
ID ( & ID , & ID , ID , STRING , ID ) ; 
ID = ID . ID ; 

ID ( & ID , & ID , ID , STRING , ID ) ; 

ID . ID = ID ; 
ID . ID = ID ( ID , ID . ID ) ; 
} 

return ID ; 
} 

static ID ID ( void * ID , int ID ) 
{ 
ID ID ; 
ID * ID ; 
void * ID = ID ( ID ) ; 
ID ID ; 
ID ID = { INTEGER } ; 

ID . ID = ID ; 
if ( ID ) 
{ 
ID ( & ID , & ID , ID , STRING , ID ) ; 
ID = ID . ID ; 

ID ( & ID , & ID , ID , STRING , ID ) ; 

if ( ID != ID ) 
ID ( & ID , & ID , ID , STRING , ID ) ; 

ID . ID = ID ; 
ID . ID = ID ( ID , ID . ID , INTEGER , ID . ID ) ; 
} 

return ID ; 
} 

static ID ID ( void * ID , int ID ) 
{ 
ID ID ; 
ID * ID ; 
void * ID = ID ( ID ) ; 
ID ID ; 
ID ID = { INTEGER } ; 

ID . ID = ID ; 
if ( ID ) 
{ 
ID ( & ID , & ID , ID , STRING , ID ) ; 
ID = ID . ID ; 

ID ( & ID , & ID , ID , STRING , ID ) ; 

if ( ID != ID ) 
ID ( & ID , & ID , ID , STRING , ID ) ; 

ID . ID = ID ; 
ID . ID = ID ( ID , ID . ID , INTEGER , ID . ID ) ; 
} 

return ID ; 
} 

static ID ID ( void * ID , int ID ) 
{ 
ID ID ; 
ID * ID ; 
void * ID = ID ( ID ) ; 
ID ID ; 
ID ID = { INTEGER } ; 

ID . ID = ID ; 
if ( ID ) 
{ 
ID ( & ID , & ID , ID , STRING , ID ) ; 
ID = ID . ID ; 

ID ( & ID , & ID , ID , STRING , ID ) ; 

if ( ID != ID ) 
ID ( & ID , & ID , ID , STRING , ID ) ; 

ID . ID = ID ; 
ID . ID = ID ( ID , ID . ID , INTEGER , ID . ID ) ; 
} 

return ID ; 
} 

static ID ID ( void * ID , int ID ) 
{ 
ID ID ; 

if ( ID ) 
ID . ID = ( ( ID * ) ID ) -> ID ; 
ID . ID = ID ; 
ID . ID = ID ( ) ; 

return ID ; 
} 

static ID ID ( void * ID , int ID ) 
{ 
ID ID ; 

if ( ID ) 
ID . ID = ( ( ID * ) ID ) -> ID ; 
ID . ID = ID ; 
ID . ID = ( float ) ( ID ( ) / ID ) ; 

return ID ; 
} 

void ID ( char * ID , ID ( * ID ) ( void * ID , int ID ) ) 
{ 
ID * ID = ID ( ID ) ; 

ID -> ID = INTEGER ; 

ID -> ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 
ID -> ID -> ID = ID ; 
ID -> ID -> ID = ID ; 
} 

void ID ( char * ID , char * ID ) 
{ 
ID * ID = ID ( ID ) ; 

ID -> ID = INTEGER ; 

ID -> ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 
ID -> ID -> ID = ID ; 
ID -> ID -> ID = ID ; 
} 

void ID ( char * ID , int ID ) 
{ 
ID * ID = ID ( ID ) ; 

ID -> ID = INTEGER ; 

ID -> ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 
ID -> ID -> ID = ID ; 
ID -> ID -> ID = ID ; 
} 

void ID ( char * ID , int ID ) 
{ 
ID * ID = ID ( ID ) ; 

ID -> ID = INTEGER ; 

ID -> ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 
ID -> ID -> ID = ID ; 
ID -> ID -> ID = ID ; 
} 

void ID ( char * ID , ID * ID ) 
{ 
ID * ID = ID ( ID ) ; 

ID -> ID = INTEGER ; 

ID -> ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 
ID -> ID -> ID = ID ; 
ID -> ID -> ID = ID ; 
} 

void ID ( char * ID ) 
{ 
ID * ID = ID ( ID ) ; 

ID -> ID = INTEGER ; 

ID -> ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 
ID -> ID -> ID = ID ; 

ID = ID ; 
} 

void ID ( char * ID ) 
{ 
ID = ID ( STRING , INTEGER , INTEGER , ID , ID , ID ) ; 
ID = ID ( ID ) ; 

ID ( STRING ) ; 

 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 

 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 

 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 

 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 

 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 

 
ID ( STRING , INTEGER ) ; 
ID ( STRING , INTEGER ) ; 
ID ( STRING , STRING ) ; 
ID ( STRING , ID ) ;  
ID ( STRING , ID ) ;  

 
ID ( STRING , ID ) ;  
ID ( STRING , ID ) ;  
} 

static void ID ( void * ID , char * ID ) 
{ 
ID * ID = ID ( ID , STRING ) ; 

if ( ID == ID ) 
ID ( ID , STRING , ID ) ; 

ID ( ID ) ; 
ID ( ID , ID , ID , ID ) ; 
ID ( ID ) ; 
ID ( ID ) ; 
} 

 
static unsigned long ID ( ID * ID , int ID ) 
{ 
unsigned long ID = INTEGER ; 

if ( ID ( ID -> ID , STRING ) == INTEGER ) 
{ 
 
unsigned long ID = ID ( ( ID * ) ID ( ID ( ID ( ID ) ) ) , INTEGER ) ; 

 
unsigned long ID = ID ( ( ID * ) ID ( ID ( ID ) ) , ID ) ; 

 
if ( ID ) 
ID ( STRING , ID + INTEGER ) ; 

 
ID ( ( ID * ) ID ( ID ( ID ( ID ) ) ) , ID ) ; 

ID = ID + ID + INTEGER ; 
} 
else if ( ID ( ID -> ID , STRING ) == INTEGER ) 
{ 
 
unsigned long ID = ID ( ( ID * ) ID ( ID ( ID ( ID ) ) ) , INTEGER ) ; 

 
unsigned long ID = ID ( ( ID * ) ID ( ID ( ID ) ) , ID ) ; 

 
if ( ID ) 
ID ( STRING , ID + INTEGER ) ; 

 
ID ( ( ID * ) ID ( ID ( ID ( ID ) ) ) , ID ) ; 

 
if ( ID ) 
ID ( STRING , ID + ID + INTEGER ) ; 

ID = ID + ID + INTEGER ; 
} 
else 
{  
void * ID ; 
int ID = ID ( ID -> ID , STRING ) == INTEGER ; 
 

 
if ( ID ) 
{ 
ID ++ ; 

if ( ID ) 
ID ( STRING ) ; 
} 

for ( ID = ID ( ID ) ; ID != ID ; ID = ID ( ID ) ) 
ID += ID ( ( ID * ) ID ( ID ) , ID ) ; 

if ( ID ) 
{ 
ID ++ ; 

if ( ID ) 
ID ( STRING ) ; 
else 
ID ( STRING , ID -> ID ) ; 
} 
} 

 
if ( ID ) 
ID ( STRING , ID ) ; 
 

return ID ; 
} 

static ID ID ( ID * ID , int ID ) 
{ 
 
void * ID ; 

ID ID , ID , ID ; 

ID * ID = ID ; 
ID * ID = ID ; 

if ( ID ( ID ) != ID ) 
{ 
ID = ( ID * ) ID ( ID ( ID ) ) ; 

if ( ID ( ID ( ID ) ) != ID ) 
ID = ( ID * ) ID ( ID ( ID ( ID ) ) ) ; 
} 

ID . ID = ID ;  

if ( ID == ID )  
return ID ; 

if ( ID ( & ID , ID -> ID ) ) 
ID = ID ( ID , ID ) ; 

if ( ID ( & ID , ID -> ID ) ) 
ID = ID ( ID , ID ) ; 

 
ID ( STRING , ID -> ID ) ; 
if ( ID -> ID != ID ) 
ID ( STRING , ID -> ID ) ; 

ID ( STRING , ID ? STRING : STRING ) ; 
ID ( STRING , ID == ID ? STRING : ID -> ID ) ; 
if ( ID != ID ) 
if ( ID -> ID != ID ) 
ID ( STRING , ID -> ID ) ; 
ID ( STRING , ID == ID ? STRING : ID -> ID , ID == ID ? ID : ID -> ID ) ; 
if ( ID != ID ) 
if ( ID -> ID != ID ) 
ID ( STRING , ID -> ID ) ; 
ID ( STRING ) ; 
 

if ( ID ( & ID , ID -> ID ) && ( ID . ID != ID . ID ) ) 
ID ( ID , STRING , ID -> ID ) ; 

switch ( ID -> ID ) 
{ 
 
case INTEGER  : 
for ( ID = ID ( ID ) ; ID != ID ; ID = ID ( ID ) ) 
ID = ID ( ( ID * ) ID ( ID ) , ID ) ; 
break ; 

case ID  :  
ID = ID ( ID , ID ) ; 

ID . ID = ID ; 

if ( ID . ID != ID ) 
ID ( STRING ) ; 
else 
ID = ID ( ID , ID && ID . ID ) ; 
break ; 

case ID  :  
ID = ID ( ID , ID ) ; 

ID . ID = ID ; 

if ( ID . ID != ID ) 
ID ( STRING ) ; 
else 
while ( ID && ID . ID ) 
{ 
ID = ID ( ID , ID && ID . ID ) ; 
ID = ID ( ID , ID ) ; 
} 
break ; 

 
case ID  :  
ID . ID = ID ; 
ID . ID = ( char * ) ( ID -> ID ) ; 
break ; 

case ID :  
ID = ID ( ID , ID ) ; 
break ; 

case ID :  
ID . ID = ID ; 
ID . ID = ID -> ID . ID ; 
break ; 

case ID :  
ID . ID = ID ; 
ID . ID = ( float ) ( ID -> ID . ID ) ; 
break ; 

} 

 
if ( ID && ID ( & ID , ID -> ID ) ) 
ID ( ID , ID ) ; 
else if ( ID && ID ( & ID , ID -> ID ) ) 
{ 
ID = ID ( ID , ID ) ; 
ID ( ID , ID ) ; 
ID = ID ; 
} 
 
ID ( STRING ) ; 
ID ( ID ) ; 
ID ( STRING ) ; 
 

return ID ; 
} 

void ID ( void * ID ) 
{ 
ID * ID = ( ID * ) ID ( ID ( ID ( ID ( ID ) ) ) ) ; 
ID ID ; 

ID = ( ID * ) ID ( ID ( ID ( ID ) ) ) ; 
ID ( ID , STRING ) ; 


ID ( & ID , 
ID  , 

ID  , 

ID  , 

ID  , 

ID  , 

ID  , 

ID  , 

ID  , 

ID  , 

ID  , 

ID  , 


ID  , 
ID  , 
ID  , 
ID  , 
ID  , 
ID  , 
ID ) ; 

ID ( & ID , 
ID  , 
ID  , 
ID  , 

ID  , 
ID  , 
ID  , 

ID  , 
ID  , 
ID  , 

ID  , 
ID  , 
ID  , 

ID  , 
ID  , 
ID  , 

ID  , 
ID  , 
ID  , 

ID  , 
ID  , 
ID  , 

ID  , 
ID  , 
ID  , 

ID  , 
ID  , 
ID  , 

ID  , 
ID  , 
ID  , 

ID  , 
ID  , 
ID  , 

ID  , 
ID  , 
ID  , 
ID  , 
ID  , 
ID  , 

ID  , 
ID ) ; 

ID ( & ID , 
ID  , 
ID  , 
ID  , 

ID  , 
ID  , 
ID  , 

ID  , 
ID  , 
ID  , 

ID  , 
ID  , 
ID  , 

ID  , 
ID  , 
ID  , 

ID  , 
ID  , 
ID  , 

ID  , 
ID  , 
ID  , 

ID  , 
ID  , 
ID  , 

ID  , 
ID  , 
ID  , 

ID  , 
ID  , 
ID  , 

ID  , 
ID  , 
ID  , 

ID  , 

ID  , 
ID  , 
ID  , 
ID  , 
ID  , 
ID  , 
ID ) ; 

ID ( & ID , 
ID  , 

ID  , 

ID  , 

ID  , 

ID  , 

ID  , 

ID  , 

ID  , 

ID  , 

ID  , 

ID  , 

ID  , 
ID ) ; 

ID ( & ID , 
ID  , 

ID  , 

ID  , 

ID  , 

ID  , 

ID  , 

ID  , 

ID  , 

ID  , 

ID  , 

ID  , 
ID ) ; 

if ( ID ( ID ) == ID ) 
ID ( ID , STRING ) ; 

 

ID = ID ( ID , INTEGER ) ; 
} 


void ID ( void ) 
{ 
if ( ID ( ) != INTEGER ) 
{ 
ID ( STRING ) ; 
ID ( ID , STRING , ID ( ) == INTEGER ? STRING : STRING , ID ) ; 
} 
} 

 
 
 
 
 
 
 
 
 
 
 
 

 

 
 

 
 
 
 

 

 

char * ID ( int ID ) 
{ 
switch ( ID ) 
{ 
case ID : 
return STRING ; 
case ID : 
return STRING ; 
case ID : 
return STRING ; 
case ID : 
return STRING ; 
case ID : 
return STRING ; 
case ID : 
return STRING ; 
case ID : 
return STRING ; 
case ID : 
return STRING ; 
case ID : 
return STRING ; 
default : 
return STRING ; 
} 
} 

void ID ( ID * ID , ID * ID ) 
{ 
if ( ID ( ID -> ID . ID ) ) 
{ 
ID ( STRING , ID ( ID ) ) ; 
ID ( ID -> ID . ID , INTEGER ) ; 
ID ( STRING ) ; 
ID ( & ID -> ID . ID , ID , INTEGER ) ; 
ID ( STRING , 
ID ( ID -> ID . ID ) ? STRING : STRING , 
ID ( & ID -> ID , ID ( ID ) ) ? STRING : STRING 
) ; 
} 
else 
{ 
ID ( STRING , ID ( ID ) , ID -> ID . ID -> ID -> ID ) ; 
ID ( & ID -> ID . ID , ID , INTEGER ) ; 
ID ( STRING ) ; 
} 

} 

static void ID ( ID * ID , int ID , unsigned ID ) 
{ 
if ( ID == INTEGER ) 
ID ( STRING ) ; 
else if ( ID > INTEGER ) 
{ 
unsigned ID = ID ( ID -> ID [ ID ] . ID ) ; 

ID ( STRING , ID ( & ID -> ID , ID ) ? STRING : STRING , ID ) ; 
} 
else 
{ 
if ( ID < ID -> ID ) 
ID ( STRING , - ID ) ; 
else 
ID ( STRING , - ID ) ; 
} 
} 

typedef struct ID 
{ 
ID * ID ; 
ID * ID ; 
} ID ; 

typedef struct ID 
{ 
ID ID ; 
unsigned ID ; 
} ID ; 

static void * ID ; 
static unsigned ID ; 

unsigned ID ( ID * ID , ID * ID ) 
{ 
ID ID ; 
ID * ID ; 

 
ID ( STRING ) ; 
ID ( ID , ID , INTEGER ) ; 
ID ( STRING ) ; 
ID ( ID , ID , INTEGER ) ; 
ID ( STRING ) ; 
 

ID . ID = ID ; 
ID . ID = ID ; 
ID = ( ID * ) ID ( ID , & ID , ID ) ; 

if ( ID == ID )  
{ 
ID * ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 
ID * ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 

ID ( ID , ID ) ; 
ID ( ID , ID ) ; 

ID . ID = ID ; 
ID . ID = ID ; 

ID = ( ID * ) ID ( ID , & ID , sizeof ( ID ) , sizeof ( ID ) ) ; 
ID -> ID = ID ; 
ID += ID ( ID ) ; 
ID += ID ( ID ) ; 
ID += INTEGER ;  
 
ID ( STRING ) ; 
ID ( ID , ID ) ; 
ID ( STRING ) ; 
 
} 
 
else 
ID ( STRING ) ; 
 

return ID -> ID ; 
} 

 
typedef enum ID {  ID , 
 ID , 
 ID , 
 ID , 
 ID , 
 ID , 
 ID , 
 ID , 
 ID , 
 ID 
} ID ; 

static int ID [ ID ] = { STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING } ; 

static void ID ( ID * ID , ID * ID , ID * ID , unsigned ID , ID * ID , ID * ID , ID * ID , int ID ) 
{ 
unsigned ID = ID ( ID ) ; 
unsigned ID = ID ( ID ) ; 

* ID = ID ; 

if ( ID + ID == INTEGER )  
* ID = ID ; 
else if ( ID + ID == INTEGER )  
* ID = ID ; 
else if ( ID > INTEGER && ID > INTEGER )  
* ID = ID ; 
else 
{ 
unsigned * ID = ID ( & ID -> ID . ID -> ID ) ; 
unsigned ID = ID ( & ID -> ID . ID -> ID ) ; 
unsigned ID = INTEGER ; 
unsigned ID = INTEGER ; 
ID * ID = ID -> ID ; 
void * ID = ID -> ID -> ID ; 
int ID ; 

if ( ID ( ID ) == ID ) 
ID ( ID ) ; 

if ( ID ( ID ) == ID ) 
ID ( ID ) ; 

 
 

 
for ( ID = INTEGER ; ID < ID ; ID ++ ) 
if ( ID ( ID ( ID [ ID ] ) ) && 
ID ( & ID -> ID , ID [ ID ] ) && 
ID ( & ( ID ( ID [ ID ] ) -> ID . ID ) , ID ) ) 
{ 
ID ++ ; 

if ( ID ( ID ( ID [ ID ] ) ) ) 
ID ++ ; 
} 

if ( ID > INTEGER ) 
* ID = ID ; 

 

 

 
 
{ 
unsigned * ID = ( unsigned * ) ID ( ID , sizeof ( unsigned ) ) ; 
ID * * ID = ( ID * * ) ID ( ID , sizeof ( ID * ) ) ; 
ID * * ID = ( ID * * ) ID ( ID , sizeof ( ID * ) ) ; 
ID * ID = ( ID * ) ID ( ID , sizeof ( ID ) ) ; 
ID * ID = ( ID * ) ID ( ID , sizeof ( ID ) ) ; 
int ID = INTEGER ; 
unsigned ID = INTEGER ; 
unsigned ID ; 
int ID = INTEGER ; 

for ( ID = INTEGER ; ID < ID ; ID ++ ) 
{ 
ID * ID = ID ( ID [ ID ] ) ; 
ID * ID = ID ( ID [ ID ] ) ; 

if ( ID ( ID ) ) 
ID [ ID ] = INTEGER ; 
else if ( ID ( ID ) == INTEGER ) 
ID [ ID ] = INTEGER ; 
else 
ID [ ID ] = ID - INTEGER ; 

if ( ID ( ID ) ) 
{ 
ID * ID = ID ( ID ) ; 

ID [ ID ] = ID ( ID ) ; 

if ( ID != ID ) 
{ 
ID [ ID ] = ID -> ID ; 

if ( ID [ ID ] -> ID == ID ) 
ID [ ID ] = ID ; 
} 

ID ( & ID [ ID ] , ID ) ; 
ID ( & ID [ ID ] , ID ) ; 
} 
} 

while ( ID ) 
{ 
int ID , ID ; 

ID = INTEGER ; 

for ( ID = INTEGER ; ID < ID ; ID ++ ) 
{ 
if ( ID ( ID ( ID [ ID ] ) ) ) 
for ( ID = INTEGER ; ID < ID ; ID ++ ) 
if ( ID ( ID ( ID [ ID ] ) ) && ! ID ( ID ( ID [ ID ] ) ) ) 
if ( ID [ ID ] == ID [ ID ] ) 
{ 
if ( ID ( & ID [ ID ] , ID ) ) 
ID ( & ID [ ID ] , & ( ID ( ID [ ID ] ) -> ID . ID ) ) ; 

if ( ID ( & ID [ ID ] , & ( ID ( ID [ ID ] ) -> ID . ID ) ) ) 
if ( ID [ ID ] > ID [ ID ] + INTEGER ) 
{ 
ID [ ID ] = ID [ ID ] + INTEGER ; 
ID = INTEGER ; 
} 
} 
} 
} 

 
for ( ID = INTEGER ; ID < ID ; ID ++ ) 
if ( ID ( ID ( ID [ ID ] ) ) && 
ID ( & ID -> ID , ID [ ID ] ) && 
ID ( & ( ID ( ID [ ID ] ) -> ID . ID ) , ID ) ) 
{ 
if ( ID [ ID ] == INTEGER ) 
{ 
ID ++ ; 
ID = ID ; 
} 
} 

 
for ( ID = INTEGER ; ID < ID ; ID ++ ) 
if ( ID ( ID ( ID [ ID ] ) ) ) 
{ 
if ( ID != ID ) 
if ( ID ( & ID [ ID ] , ID ) ) 
ID = INTEGER ; 
} 

if ( ! ID && ID < INTEGER ) 
{ 
unsigned * ID = ID ( ID ) ; 
unsigned * ID = ID ; 

* ID = ID ; 
if ( ID ) 
{ 
ID ( STRING , ID ( ID ) ) ; 
ID ( ID ( ID -> ID -> ID , ID ) ) ; 
ID ( STRING , ID ( ID ( ID [ ID ] ) ) ) ; 
ID ( ID , ID ( ID [ ID ] ) ) ; 
} 

while ( * ID != ID ) 
{ 
if ( ID ) 
ID ( STRING , ID ( ID [ * ID ] . ID ) ) ; 

if ( ID [ * ID ] . ID != ID ( ID [ ID ] ) ) 
{ 
if ( ID ) 
ID ( STRING ) ; 
ID ( ID , * ID ) ; 
} 
else 
if ( ID ) 
ID ( STRING ) ; 

ID ++ ; 
} 

ID ( ID ) ; 
} 
else if ( ID ) 
{ 
 
ID ( STRING , ID ( ID ) ) ; 
ID ( ID ( ID -> ID -> ID , ID ) ) ; 
ID ( STRING , 
ID , 
ID , 
ID == INTEGER ? STRING : STRING , 
ID , 
ID == INTEGER ? STRING : STRING ) ; 


for ( ID = INTEGER ; ID < ID ; ID ++ ) 
{ 
if ( ID != ID ) 
if ( ID [ ID ] == ID - INTEGER ) 
ID ( STRING ) ; 
else 
ID ( STRING , ID [ ID ] ) ; 

 
if ( ID [ ID ] != ID ) 
{ 
ID ( ID [ ID ] ) ; 
ID ( STRING ) ; 

ID ( STRING ) ; 
ID ( & ID [ ID ] , ID , INTEGER ) ; 
ID ( STRING ) ; 

if ( ID [ ID ] != ID ) 
{ 
ID ( ID [ ID ] ) ; 
ID ( STRING ) ; 
ID ( & ID [ ID ] , ID , INTEGER ) ; 
ID ( STRING ) ; 
} 
else 
ID ( STRING ) ; 
} 
else 
ID ( STRING ) ; 
 
ID ( ID , ID ( ID [ ID ] ) ) ; 
} 

ID ( STRING , ID == INTEGER ? STRING : STRING , ID , ID == INTEGER ? STRING : STRING ) ; 

if ( ID == INTEGER ) 
ID ( ID , ID ( ID [ ID ] ) ) ; 

for ( ID = INTEGER ; ID < ID ; ID ++ ) 
if ( ID ( ID ( ID [ ID ] ) ) ) 
{ 
if ( ID != ID ) 
if ( ID ( & ID [ ID ] , ID ) ) 
{ 
ID ( ID ( ID -> ID -> ID , ID ) ) ; 
ID ( STRING ) ; 
ID ( ID , ID ( ID [ ID ] ) ) ; 
} 
} 
} 

for ( ID = INTEGER ; ID < ID ; ID ++ ) 
{ 
ID ( & ID [ ID ] ) ; 
ID ( & ID [ ID ] ) ; 
} 

ID ( ID ) ; 
ID ( ID ) ; 
ID ( ID ) ; 
ID ( ID ) ; 
ID ( ID ) ; 
} 
 
ID ( ID ) ; 
} 

} 

ID * ID ( ID * ID , int ID ) 
{ 
ID * ID ; 
ID * ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 
ID * ID ; 
ID * ID ; 
ID ID = ID ; 
ID ID ; 

ID -> ID = ID ( ID -> ID ) ; 
ID -> ID = ID ( ID ) ; 
ID -> ID = ID ( ID -> ID ) + INTEGER ; 
ID -> ID = ID -> ID ; 

ID ( STRING , ID ( ID -> ID ) , ID -> ID * ( ID -> ID - INTEGER ) ) ; 

if ( ID -> ID * ID -> ID == INTEGER ) 
ID ( ID , STRING ) ; 
else 
{ 
ID ID = ID ( ID -> ID -> ID -> ID ) + INTEGER ; 
ID * ID = ( ID * ) ID ( ID , sizeof ( ID ) ) ; 
ID ID = ID ; 
ID ID = ID ; 

 
ID -> ID = ID ( ID ( ID -> ID ) ) ; 

 
ID = ( ID * ) ID ( ID -> ID -> ID ) ; 
ID = ( ID * ) ID ( ID ) ; 
while ( ID != ID ) 
{ 

ID = ( ID * ) ID ( ID ) ; 
if ( ID ( & ID -> ID -> ID , ID ( ID ) ) ) 
ID ( & ID -> ID , ID ( ID -> ID . ID ) ) ; 

ID = ( ID * ) ID ( ID ) ; 

if ( ID != ID ) 
if ( ID -> ID -> ID == ID )  
ID = ( ID * ) ID ( ID ) ; 
} 

 
for ( ID -> ID = INTEGER ; 
ID ( ID -> ID -> ID -> ID , ID -> ID ) -> ID == ID ; 
ID -> ID ++ ) 
; 

 
ID -> ID = INTEGER ; 
ID ( ID -> ID -> ID , ID , ID ) ;  
if ( ID ( & ID -> ID -> ID , ID ( ID ) ) ) 
if ( ID [ ID ( ID -> ID . ID ) ] == INTEGER ) 
{ 
ID [ ID ( ID -> ID . ID ) ] = ID -> ID ++ ; 
} 

 
{ 
unsigned ID ; 
for ( ID = INTEGER ; ID < ID ; ID ++ ) 
ID ( STRING , ID , ID [ ID ] ) ; 
} 
 

 
ID -> ID = ( ID * ) ID ( ID -> ID , sizeof ( ID ) ) ; 

ID ( ID -> ID -> ID , ID , ID ) ;  
if ( ID ( & ID -> ID -> ID , ID ( ID ) ) ) 
{ 
ID * ID ; 
int ID = ID [ ID ( ID -> ID . ID ) ] ; 

ID -> ID [ ID ] . ID = ID -> ID . ID ; 

if ( ID -> ID . ID -> ID == ID )  
ID = ID -> ID . ID ; 
else 
{ 
void * ID ; 
ID = ( ID * ) ID ( ID ( ID -> ID . ID ) ) ; 

ID -> ID [ ID ] . ID = INTEGER ; 
for ( ID = ID ( ID ) ; ID != ID && ID ( ID ) != ID -> ID . ID ; ID = ID ( ID ) ) 
ID -> ID [ ID ] . ID += INTEGER ; 
} 

ID -> ID [ ID ] . ID = ( ( ID * ) ID ( ID ( ID ) ) ) -> ID ; 
} 

ID = ID ( STRING , INTEGER , INTEGER , ID , ID , ID ) ; 
ID = INTEGER ;  

ID -> ID = ( int * * ) ID ( ID -> ID * ID -> ID , sizeof ( int * ) ) ; 

if ( ID ) 
ID -> ID = ( unsigned * ) ID ( ID -> ID * ID -> ID , sizeof ( unsigned ) ) ; 

for ( ID = ( ID * ) ID ( ID -> ID ) ; ID != ID ; ID = ( ID * ) ID ( ID ) )  
{ 
unsigned ID ; 

for ( ID = INTEGER ; ID < ID -> ID ; ID ++ )  
{ 
ID * ID ; 

 
ID ( & ID ) ; 
for ( ID = ( ID * ) ID ( ID ) ; ID != ID ; ID = ( ID * ) ID ( ID ) )  
if ( ID -> ID -> ID == ID ) 
ID ( & ID , ID ( ID ( ID ) ) ) ; 

 
ID ( & ID ) ; 
if ( ID ( & ID -> ID , ID ( ID ) ) && ! ID ( & ID , ID ( ID ) ) ) 
{ 
unsigned * ID , 
* ID = ID ( & ( ID -> ID . ID -> ID ) ) ; 

for ( ID = ID ; * ID != ID ; ID ++ ) 
if ( ID ( & ID -> ID -> ID , ID ( ( ( ID * ) ID ( ID -> ID -> ID ) [ * ID ] ) ) ) ) 
if ( ID ( & ( ( ID * ) ID ( ID -> ID -> ID ) [ * ID ] ) -> ID . ID , ID ) ) 
ID ( & ID , ID [ ID ( ( ( ID * ) ID ( ID -> ID -> ID ) [ * ID ] ) -> ID . ID ) ] ) ; 
} 

if ( ID ) 
ID ( ID -> ID , ID , ID , ID , & ID , & ID , & ID , INTEGER ) ; 

 
if ( ID ( & ID ) != INTEGER || ID ( & ID ) != INTEGER ) 
ID ( & ID , & ID ) ; 
} 
} 

 
ID -> ID = ID ; 
ID -> ID = ( int * ) ID ( ID , sizeof ( int ) ) ; 

for ( ID = ( ID * ) ID ( ID ( ID ) ) ; ID != ID ; ID = ( ID * ) ID ( ID ) ) 
{ 
unsigned * ID , 
* ID ; 
int * ID = ID -> ID + ID -> ID ; 

 
ID = ID ( ID -> ID . ID ) ; 
for ( ID = ID ; * ID != ID ; ID ++ ) 
* ID ++ = - ( * ID ) ; 
ID ( ID ) ; 

 
ID = ID ( ID -> ID . ID ) ; 
for ( ID = ID ; * ID != ID ; ID ++ ) 
* ID ++ = * ID ; 
ID ( ID ) ; 

 
* ID = INTEGER ; 
} 

 
for ( ID = ( ID * ) ID ( ID -> ID ) ; ID != ID ; ID = ( ID * ) ID ( ID ) )  
{ 
unsigned ID ; 

for ( ID = INTEGER ; ID < ID -> ID ; ID ++ )  
{ 
ID * ID ; 

 
ID ( & ID ) ; 
for ( ID = ( ID * ) ID ( ID ) ; ID != ID ; ID = ( ID * ) ID ( ID ) )  
if ( ID -> ID -> ID == ID ) 
ID ( & ID , ID ( ID ( ID ) ) ) ; 

 
ID ( & ID ) ; 
if ( ID ( & ID -> ID , ID ( ID ) ) && ! ID ( & ID , ID ( ID ) ) ) 
{ 
unsigned * ID , 
* ID = ID ( & ( ID -> ID . ID -> ID ) ) ; 

for ( ID = ID ; * ID != ID ; ID ++ ) 
if ( ID ( & ID -> ID -> ID , ID ( ( ( ID * ) ID ( ID -> ID -> ID ) [ * ID ] ) ) ) ) 
if ( ID ( & ( ( ID * ) ID ( ID -> ID -> ID ) [ * ID ] ) -> ID . ID , ID ) ) 
ID ( & ID , ID [ ID ( ( ( ID * ) ID ( ID -> ID -> ID ) [ * ID ] ) -> ID . ID ) ] ) ; 
} 

if ( ID ) 
ID ( ID -> ID , ID , ID , ID , & ID , & ID , & ID , INTEGER ) ; 

 
if ( ID ( & ID ) != INTEGER || ID ( & ID ) != INTEGER ) 
* ( ID -> ID + ( ID ( ID ) * ID -> ID ) + ID ) = ID -> ID + ID ( & ID , & ID ) ; 
else 
* ( ID -> ID + ( ID ( ID ) * ID -> ID ) + ID ) = ID -> ID ; 

if ( ID ) 
* ( ID -> ID + ( ID ( ID ) * ID -> ID ) + ID ) = ID ; 
} 
} 
 
 
{ 
unsigned ID ; 
unsigned ID = INTEGER ; 

ID ( STRING ) ; 

for ( ID = INTEGER ; ID < ID ; ID ++ ) 
{ 
ID ( STRING , ID , ID -> ID [ ID ] ) ; 
if ( ID == INTEGER ) 
{ 
ID += ID -> ID [ ID ] ; 
ID ( STRING , ID ) ; 
} 
else 
{ 
ID ( ID -> ID [ ID ] , INTEGER ) ; 
ID -- ; 
} 
ID ( STRING ) ; 
} 

ID ( STRING ) ; 
for ( ID = INTEGER ; ID < ID -> ID ; ID ++ ) 
{ 
unsigned ID ; 

ID ( STRING , ID ) ; 
for ( ID = INTEGER ; ID < ID -> ID ; ID ++ ) 
ID ( STRING , * ( ID -> ID + ( ID * ID -> ID ) + ID ) ) ; 
ID ( STRING ) ; 
} 
} 
 

ID ( ID ) ; 
ID ( & ID ) ; 
ID ( & ID ) ; 
} 

ID ( & ID ) ; 

return ID ; 
} 

void ID ( ID * ID , ID * ID ) 
{ 
unsigned ID ; 
unsigned ID ; 
unsigned ID ; 
unsigned ID = ID -> ID -> ID -> ID -> ID ; 
int ID = INTEGER ; 
int * ID ; 

ID * ID = ID ( ) ; 

ID ( ID ) ; 

ID ( STRING STRING STRING , ID ( ID -> ID ) ) ; 
ID ( ) ; 
ID ( STRING , ID ) ; 

ID ( STRING ) ; 
ID ( ID -> ID -> ID , INTEGER , INTEGER ) ; 

ID ( STRING ) ; 
for ( ID = INTEGER ; ID < ID -> ID ; ID ++ ) 
{ 
ID ( STRING , 
ID ( ID -> ID [ ID ] . ID ) , 
ID -> ID [ ID ] . ID , 
ID -> ID [ ID ] . ID -> ID ) ; 

ID ( ID -> ID [ ID ] . ID , INTEGER ) ; 
ID ( STRING ) ; 
} 

ID ( STRING , ID -> ID ) ; 
ID ( STRING ) ; 
ID ( & ID -> ID , ID , INTEGER ) ; 
ID ( STRING ) ; 

 
ID ( STRING ) ; 
for ( ID = ID ; ID < ID -> ID ; ID ++ ) 
{ 
if ( ID == ID -> ID ) 
ID ( STRING ) ; 
if ( ID != ID ) 
ID ( STRING , ID ) ; 
} 
ID ( STRING ) ; 

 
ID ( STRING ) ; 
for ( ID = ID ; ID < ID -> ID ; ID ++ ) 
{ 
if ( ID == ID -> ID ) 
ID ( STRING ) ; 
if ( ID != ID ) 
{ 
char ID [ INTEGER ] = { INTEGER } ; 
char * ID = ID ( ID -> ID -> ID -> ID , ID ) -> ID ; 

ID ( ID , ID , INTEGER ) ; 

ID ( STRING , ID ) ; 
} 
} 
ID ( STRING ) ; 

 
ID ( STRING ) ; 
for ( ID = ID ; ID < ID -> ID ; ID ++ ) 
{ 
if ( ID == ID -> ID ) 
ID ( STRING ) ; 
if ( ID != ID ) 
ID ( STRING ) ; 
} 
ID ( STRING ) ; 


for ( ID = INTEGER ; ID < ID -> ID ; ID ++ ) 
{ 
ID ( STRING , ID ) ; 
for ( ID = ID ; ID < ID -> ID ; ID ++ ) 
{ 
ID = ID ( ID , ID , ID ) ; 

if ( ID == ID -> ID ) 
ID ( STRING ) ; 

if ( ID != ID ) 
if ( ! ( * ID == INTEGER || * ( ID + INTEGER ) == INTEGER ) ) 
ID ( STRING , ID ++ ) ; 
else 
ID ( ID , * ID , ID ) ; 
} 
ID ( STRING ) ; 
} 

ID ( STRING ) ; 

if ( ID <= INTEGER ) 
ID ( STRING ) ; 
else 
{ 
ID = INTEGER ; 
for ( ID = INTEGER ; ID < ID -> ID ; ID ++ ) 
{ 
for ( ID = ID ; ID < ID -> ID ; ID ++ ) 
{ 
ID = ID ( ID , ID , ID ) ; 

if ( ID != ID ) 
if ( ! ( * ID == INTEGER || * ( ID + INTEGER ) == INTEGER ) ) 
{ 
ID ( STRING , ID ++ ) ; 

while ( * ID != INTEGER ) 
ID ( ID , * ID ++ , ID ) ; 

ID ( STRING ) ; 
} 
} 
} 
} 
ID ( ID ) ; 
} 

 
static int ID ; 
static char ID [ ID ] ; 
static int ID ; 

void ID ( ID * ID ) 
{ 
while ( ID ( ID ) && ID != ID && ID != STRING && ID != STRING ) 
ID = ID ( ID ) ; 
} 

void ID ( ID * ID ) 
{ 
while ( ID != ID && ID != STRING && ID != STRING ) 
ID = ID ( ID ) ; 

ID = ID ( ID ) ; 

ID ( ID ) ; 
} 

void ID ( ID * ID ) 
{ 
while ( ID != ID && ID != STRING ) 
ID = ID ( ID ) ; 

ID = ID ( ID ) ; 

ID ( ID ) ; 
} 

void ID ( ID * ID ) 
{ 
char * ID = ID ; 

ID ( ID ) ; 

while ( ID - ID < ID - INTEGER && ! ID ( ID ) && ID != ID ) 
{ 
* ID ++ = ( char ) ID ; 
ID = ID ( ID ) ; 
} 

* ID = INTEGER ; 

ID ( ID ) ; 
} 

void ID ( ID * ID ) 
{ 
int ID = INTEGER ; 

ID = INTEGER ; 

while ( ID == STRING ) 
{ 
ID ^= INTEGER ; 
ID = ID ( ID ) ; 
} 

ID ( ID ) ; 

while ( ID ( ID ) ) 
{ 
ID = ID * INTEGER + ID - STRING ; 
ID = ID ( ID ) ; 
} 

if ( ID ) 
ID *= - INTEGER ; 

ID ( ID ) ; 
} 


void ID ( ID * ID , ID * ID ) 
{ 
int * ID = ( int * ) ID ( ID ( ID -> ID -> ID -> ID -> ID ) + INTEGER , sizeof ( int ) ) ; 
int * ID = ( int * ) ID ( INTEGER , sizeof ( int ) ) ; 

ID = ID ( ID ) ; 
while ( ID ( ID , STRING ) != INTEGER && ID != ID ) 
{ 
ID ( ID ) ; 

ID ( ID ) ; 
} 

ID ( ID ) ; 
ID ( ID ) ; 
ID ( ID ) ; 

while ( INTEGER ) 
{ 
int ID ; 
int ID ; 

ID ( ID ) ; 
ID = ID ; 
if ( ID == INTEGER )  
break ; 

ID ( ID ) ; 
ID = INTEGER ; 

while ( ID != STRING && ID != ID ) 
{ 
int ID = INTEGER ; 
int * ID ; 

while ( ID ( ID ) || ID == STRING || ID == STRING || ID == STRING || ID == STRING || ID == STRING ) 
{ 
if ( ID == STRING || ID == STRING || ID == STRING || ID == STRING ) 
ID = ID ( ID ) ;  

ID ( ID ) ; 

ID [ ID ++ ] = ID ; 
} 

ID ( ID ) ; 

if ( ID > INTEGER ) 
{ 
ID = ( int * ) ID ( ID + INTEGER , sizeof ( int ) ) ; 
ID ( ID , ID , ID * sizeof ( int ) ) ; 
* ( ID -> ID + ( ID * ID -> ID ) + ID ) = ID ; 
} 
else 
* ( ID -> ID + ( ID * ID -> ID ) + ID ) = ID ; 

ID ++ ; 
} 

ID ( ID ) ; 
} 

ID ( ID ) ; 
} 

void ID ( ID * ID , ID * ID , int ID ) 
{ 
unsigned ID ; 
unsigned ID ; 
unsigned ID ; 
int ID ; 
int ID ; 
int * ID ; 
ID * ID = ID -> ID -> ID ; 
ID * ID = ID -> ID ; 
ID * ID ; 
unsigned ID = INTEGER ; 

ID * ID = ID ( ) ; 

ID ( ID -> ID ) ; 

ID ( ID ) ; 

ID ( STRING STRING STRING , ID ( ID -> ID ) ) ; 
ID ( ) ; 
ID ( STRING , ID ) ; 

if ( ! ID ) 
{ 
ID ( STRING ) ; 
for ( ID = INTEGER ; ID < ID -> ID ; ID ++ ) 
{ 
ID ( STRING , ID ) ; 
ID ( ID ( ID -> ID -> ID -> ID , ID ) ) ; 
} 

ID ( STRING ) ; 
if ( ID ( ID -> ID -> ID ) == ID ) 
ID ( ID -> ID -> ID ) ; 

ID = ID ( ID -> ID -> ID ) ; 

for ( ID = INTEGER ; ID < ID ; ID ++ ) 
{ 
ID * ID = ( ID * ) ID ( ID -> ID -> ID ) [ ID ] ; 

if ( ID != ID && ID ( ID ) ) 
{ 
ID ( STRING , ID ( ID ) ) ; 
ID ( ID , INTEGER ) ; 
ID ( STRING , ID ( ID ) ? STRING : STRING ) ; 
} 
} 

ID ( STRING ) ; 
ID ( ID -> ID , ID , ID ) ;  
ID ( ID , ID ) ; 

ID ( STRING ) ; 
ID ( ID -> ID , ID , ID ) ;  
{ 
ID ( STRING , ID ( ID ) ) ; 
ID ( & ID -> ID . ID -> ID , ID , INTEGER ) ; 
ID ( STRING ) ; 
} 
} 

ID ( STRING ) ; 
for ( ID = INTEGER ; ID < ID -> ID ; ID ++ ) 
{ 
ID ( STRING , 
ID , 
ID -> ID [ ID ] . ID , 
ID -> ID [ ID ] . ID -> ID , 
ID ( ID -> ID [ ID ] . ID ) ) ; 

ID ( ID -> ID [ ID ] . ID , INTEGER ) ; 
ID ( STRING ) ; 
} 

ID ( STRING , ID -> ID ) ; 

ID ( STRING ) ; 
ID ( & ID -> ID , ID , INTEGER ) ; 
ID ( STRING ) ; 

ID ( STRING ) ; 
for ( ID = ID ; ID < ID -> ID ; ID ++ ) 
ID ( STRING , ID ) ; 

ID ( STRING ) ; 

for ( ID = ID ; ID < ID -> ID ; ID ++ ) 
{ 
ID * ID = ID ( ID -> ID -> ID -> ID , ID ) ; 

ID ( STRING ) ; 
ID ( ID ) ; 
if ( ID == INTEGER && ID -> ID != ID ) 
ID = ID ; 
} 

if ( ! ID ) 
ID = ID -> ID ; 

ID ( STRING ) ; 

for ( ID = INTEGER ; ID < ID -> ID ; ID ++ ) 
{ 
ID ( STRING , ID ) ; 
for ( ID = ID ; ID < ID ; ID ++ ) 
{ 
int ID = INTEGER ; 
ID = ID ( ID , ID , ID ) ; 

if ( ID -> ID != ID ) 
ID ( STRING , ID [ ( * ( ID -> ID + ( ID * ID -> ID ) + ID ) ) ] ) ; 
else 
ID ( STRING ) ; 

while ( * ID != INTEGER ) 
{ 
if ( ID ) 
ID = INTEGER ; 
else 
ID ( STRING ) ; 

ID ( STRING , * ID ++ ) ; 
} 
} 
ID ( STRING ) ; 
} 

if ( ID -> ID != ID ) 
{ 
ID ( STRING ) ; 
for ( ID = ID ; ID < ID ; ID ++ ) 
ID ( STRING , ID ) ; 

ID ( STRING ) ; 

for ( ID = ID ; ID < ID ; ID ++ ) 
{ 
ID ( STRING ) ; 
ID ( ID ( ID -> ID -> ID -> ID , ID ) ) ; 
} 

ID ( STRING ) ; 

for ( ID = INTEGER ; ID < ID -> ID ; ID ++ ) 
{ 
ID ( STRING , ID ) ; 
for ( ID = ID ; ID < ID ; ID ++ ) 
ID ( STRING , ( * ( ID -> ID + ( ID * ID -> ID ) + ID ) ) ) ; 
ID ( STRING ) ; 
} 
} 

ID ( ID ) ; 
} 

static char * ID ; 
static ID ; 
static char * ID ; 
static int ID = INTEGER ; 

static void ID ( char * ID , ID * ID ) 
{ 
ID = INTEGER ; 
ID = ID ; 

ID = ID ( STRING ) -> ID -> ID ; 

if ( * ID != INTEGER ) 
ID = ID ( ID -> ID , ID , ID ) -> ID ; 

ID ( STRING , * ID == INTEGER ? STRING : ID , ID ) ; 
} 

static int ID ( ID * ID ) 
{ 
ID * ID , 
* ID ; 
int ID = INTEGER ; 

if ( ! ID ( * ID ) && * ID != INTEGER ) 
{ 
while ( ! ID ( * ID ) && * ID != INTEGER ) 
ID ++ ; 
if ( ID != INTEGER ) 
{ 
if ( * ID == INTEGER ) 
return ID ; 
else 
return ID ; 
} 
} 

while ( ! ID ( * ID ) && * ID != INTEGER ) 
ID ++ ; 

if ( * ID == INTEGER ) 
{ 
 
ID ( STRING ) ; 
 
return ID ; 
} 

for ( ID = ( ID * ) ID ( ID ( ID -> ID -> ID -> ID ) ) ; 
ID != ID ; 
ID = ( ID * ) ID ( ID ) ) 
if ( ID -> ID == ID ) 
{ 
int ID = ID ( ID -> ID ) ; 

if ( ID ( ID -> ID , ID , ID ) == INTEGER && ID > ID ) 
{ 
ID = ID ; 
ID = ID ; 
} 
} 

if ( ID > INTEGER ) 
{ 
 
ID ( STRING , ID -> ID , ID -> ID ) ; 
 
ID += ID ; 
return ID -> ID ; 
} 
else 
{ 
 
ID ( STRING ) ; 
 
return ID ; 
} 
} 

ID * ID ( ID * ID , char * ID ) 
{ 
 
unsigned ID = INTEGER ; 
unsigned ID = INTEGER ; 
unsigned ID = INTEGER ; 
 
int * ID = ( int * ) ID ( INTEGER ) ; 
int * ID = ID ; 
int ID ; 
ID * ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 

ID -> ID = ID ; 

ID ( ID , STRING , ID ) ; 

ID ( ID , ID -> ID -> ID ) ; 

ID ( ID ) ; 

* ++ ID = INTEGER ; 

while ( INTEGER ) 
{ 
int * ID = * ( ID -> ID + ( * ID * ID -> ID ) + ID ) ; 

if ( * ID == INTEGER ) 
{ 
ID ( ID , STRING ) ; 
ID ( ID ) ; 
return ( ID ) ; 
} 

 
{ 
int * ID ; 

ID ( STRING , * ( ID + INTEGER ) ) ; 
for ( ID = ID + INTEGER ; ID <= ID ; ID += INTEGER ) 
ID ( STRING , * ID , ID ( ID -> ID -> ID , * ID ) -> ID , * ( ID + INTEGER ) ) ; 
ID ( STRING , * ID ) ; 
} 
 

if ( * ID < INTEGER )  
{ 
* ++ ID = ID ; 
* ++ ID = - * ID ; 
 
ID ( STRING , ID - ID ) ; 
ID ++ ; 
if ( ID - ID > ID ) 
ID = ID - ID ; 
 
ID ( ID ) ; 
}  
else 
{ 
ID * ID = & ( ID -> ID [ * ID ] ) ; 
unsigned ID = ID ( ID -> ID ) ; 
unsigned ID = ID -> ID -> ID ; 
int ID ; 

if ( ID ( & ID -> ID , ID ) ) 
{ 
ID ( ID , STRING ) ; 
 
ID ( STRING , ID , ID , ID ) ; 
 
ID -> ID = INTEGER ; 
ID ( ID ) ; 
return ( ID ) ; 
} 

ID -= ID -> ID * INTEGER ; 
ID = - * ( * ( ID -> ID + ( * ID * ID -> ID ) + ID ) ) ;  
 
ID ( STRING , ID , ID -> ID * INTEGER , * ID , ID ) ; 
 
* ++ ID = ID ; 
* ++ ID = ID ; 
 
ID ( STRING , ID -> ID , ID - ID ) ; 
ID ++ ; 
if ( ID - ID > ID ) 
ID = ID - ID ; 
 
} 
} 
} 

enum ID 
{ 
ID , ID , ID , ID , ID 
} ; 

typedef struct ID 
{ 
struct ID * ID ; 
struct ID * ID ; 
} ID ; 

typedef struct ID 
{ 
unsigned ID ; 
enum ID ID ; 
struct ID * ID ; 
unsigned ID ; 
unsigned ID ; 
} ID ; 

typedef struct ID 
{ 
unsigned ID ; 
unsigned ID ; 
} ID ; 

static ID * ID = ID ; 
static ID * ID = ID ; 
static ID * ID = ID ; 
static int ID ; 

void ID ( ID * ID , void * ID ) 
{ 
ID * ID ; 
ID * ID ; 
ID * ID = ID ( ) ; 
unsigned ID = INTEGER ; 
unsigned ID = INTEGER ; 
unsigned ID = INTEGER ; 
unsigned ID = INTEGER ; 
unsigned ID = INTEGER ; 
ID * ID = ID ; 
ID * ID = ID ; 

ID ( & ID ) ; 
ID ( & ID ) ; 

ID ( ID ) ; 

for ( ID = ( ID * ) ID ( ID ) ; ID != ID ; ID = ( ID * ) ID ( ID ) ) 
{ 
if ( ID < ID -> ID ) 
ID = ID -> ID ; 


switch ( ID -> ID ) 
{ 
case ID : 
ID ( ID , ID -> ID ) ; 
ID ++ ; 
break ; 

case ID : 
ID ( ID , ID -> ID ) ; 
ID ++ ; 
break ; 

case ID : 
ID ( ID , ID -> ID ) ; 
ID ++ ; 
break ; 
} 

for ( ID = ( ID * ) ID ( ID ) ; ID != ID ; ID = ( ID * ) ID ( ID ) ) 
{ 
ID ++ ; 

ID ( ID , ID -> ID ) ; 
} 
} 

ID = ( ID + INTEGER ) / INTEGER ; 

ID ( STRING , 
ID , ID == INTEGER ? STRING : STRING , 
ID , ID == INTEGER ? STRING : STRING , 
ID , ID == INTEGER ? STRING : STRING , 
ID , ID == INTEGER ? STRING : STRING , 
ID - INTEGER , ID - INTEGER == INTEGER ? STRING : STRING ) ; 

ID ( STRING , ID ) ; 

ID ( STRING ) ; 
ID ( ID ) ; 
ID ( STRING , ID ( ID ) ) ; 

ID ( STRING ) ; 
ID ( ID ) ; 
ID ( STRING , ID ( ID ) ) ; 

ID ( STRING ) ; 
ID ( ID ) ; 
ID ( STRING , ID ( ID ) ) ; 
ID ( STRING , ID ( ID ) ) ; 

ID ( STRING ) ; 
ID ( ID ) ; 
ID ( STRING , ID ( ID ) ) ; 
ID ( STRING , ID ( ID ) ) ; 

ID ( STRING ) ; 
ID ( ID ) ; 
ID ( STRING , ID ( ID ) ) ; 
ID ( STRING , ID ( ID ) ) ; 

ID ( & ID ) ; 
ID ( & ID ) ; 
ID ( & ID ) ; 
ID ( & ID ) ; 
ID ( & ID ) ; 

ID ( ID ) ; 
} 

static ID * ID ; 

void ID ( const void * ID ) 
{ 
ID ( STRING , ID ) ;  
} 

void ID ( const void * ID ) 
{ 
ID * ID = ( ID * ) ID ; 

ID ( STRING , ID -> ID ) ; 

switch ( ID -> ID ) 
{ 
case ID : 
ID ( STRING ) ; 
break ; 
case ID : 
ID ( STRING ) ; 
break ; 
case ID : 
ID ( STRING , ID -> ID , ID -> ID ) ; 
break ; 
case ID : 
case ID : 
ID ( STRING , ID ( ID -> ID -> ID -> ID -> ID , ID -> ID ) -> ID , ID -> ID ) ; 
break ; 
default : 
ID ( STRING ) ; 
break ; 
} 
} 

void ID ( const void * ID ) 
{ 
ID * ID = ( ID * ) ID ; 

if ( ID -> ID != INTEGER ) 
{ 
ID ( STRING ) ; 
ID ( ID ( ID -> ID -> ID -> ID -> ID , ID -> ID ) ) ; 
ID ( STRING , ID -> ID ) ; 
} 
} 

void ID ( ID * ID , ID * ID ) 
{ 
ID * ID = ID ( ) ; 

ID ( ID ) ; 
ID = ID ; 
ID ( ID -> ID , ID , ID , ID ) ; 
ID ( ID ) ; 
} 

 

 
ID ( ID , ID , ID , ID , ID )  
{  
ID ( STRING , ID , ID ( ID -> ID -> ID -> ID , ID ) -> ID ) ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
 
ID ( ID , ID ) ;  
ID ( ID , ID ) ;  
 
if ( ++ ID == ID )  
ID = ID ;  
 
if ( ID == ID )  
ID ( ID , STRING ) ;  
 
if ( ID >= ID )  
{  
if ( ID < ID - ID )  
ID = ID - ID ;  
}  
else  
{  
if ( ID < ID - ( ID - ID ) )  
ID = ID - ( ID - ID ) ;  
}  
} 

ID * ID ( ID * ID , char * ID , int ID , int ID ) 
{ 
typedef struct ID 
{ 
ID * ID ; 
unsigned ID ; 
unsigned ID ; 
unsigned ID ; 
ID * ID ; 
} ID ; 

ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 

ID * * ID ;  
ID * * ID ;  
ID * * ID ;  
int ID ;  
int ID ;  
int ID ;  
int ID = INTEGER ; 
unsigned ID = ID -> ID ; 
unsigned ID = INTEGER ;  
ID * ID ;  


 
 
if ( ID == INTEGER ) 
ID = INTEGER ; 

ID = ID ( ID , sizeof ( ID ) ) ;  
ID = ID + ID ;  
ID = ID ;  
ID = ID ;  

ID ( STRING , ID , ID ? STRING : STRING , ID ) ; 
ID ( & ID -> ID , ID , INTEGER ) ; 
ID ( STRING ) ; 

 
ID = ( ID * * ) ID ( ID , sizeof ( ID * ) ) ; 
ID = ( ID * * ) ID ( ID , sizeof ( ID * ) ) ; 
ID = ( ID * * ) ID ( ID , sizeof ( ID * ) ) ; 

 
ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 
ID -> ID = ID ; 
ID -> ID = ID ( STRING ) ; 
ID ( ID -> ID , ID ( sizeof ( ID ) , ID -> ID ) ) ; 
( ( ID * ) ID ( ID -> ID ) ) -> ID = ID ; 

 
ID [ ID -> ID ] = ( ID * ) ID ( sizeof ( ID ) , ID -> ID ) ; 
ID [ ID -> ID ] -> ID = ID -> ID ; 
ID [ ID -> ID ] -> ID = ID ; 
ID [ ID -> ID ] -> ID = ID ; 

 
ID ( sizeof ( ID ) , ID ( ID -> ID ) , ID [ ID -> ID ] ) ; 

 
ID ( ID , ID -> ID -> ID ) ; 
ID ( ID ) ; 

 
ID ( & ID ) ; 
ID ( & ID ) ; 
ID ( & ID ) ; 
ID = - INTEGER ; 

 
do 
{ 
 
 
for ( ID = ID - INTEGER ; ID > INTEGER ; ID -- ) 
if ( ID [ ID ] != ID ) 
{ 
int * ID = ID ( ID , ID , ID ) ; 

if ( * ID == INTEGER ) 
{ 
ID [ ID ] = ID ;  
ID ( STRING , ID , INTEGER ) ; 
} 
else 
{ 
while ( * ID < INTEGER )  
{ 
ID ++ ; 
ID ( STRING , ID , INTEGER ) ; 
} 

while ( * ID > INTEGER ) 
if ( ID ( & ID -> ID , ID ( ID -> ID [ * ID ] . ID ) ) ) 
{ 
ID = INTEGER ; 
ID ( STRING , ID ( ID -> ID [ * ID ] . ID ) , INTEGER ) ; 
ID ++ ; 
} 
else 
{ 
ID * ID = & ( ID -> ID [ * ID ] ) ; 
unsigned ID = ID -> ID * INTEGER ; 
unsigned ID = ID -> ID -> ID ; 

ID * ID = ID [ ID ] ; 
ID * ID ; 

ID ( STRING , ID ( ID -> ID [ * ID ] . ID ) , INTEGER ) ; 

for ( ID = ( ID * ) ID ( ID ) ; ID != ID ; ID = ( ID * ) ID ( ID ) ) 
{ 
ID ( ID , ID ) ; 
ID ( ID , ID , ID , ID , ID ) ; 
} 
ID ++ ; 
} 
} 
} 

 
while ( ID != ID ) 
{ 
int ID ; 
unsigned ID ; 
ID * ID ; 
int * ID ; 
unsigned ID = ID -> ID ; 
unsigned ID = ID -> ID ; 
unsigned ID = ID -> ID ; 
ID * ID = ID -> ID ; 
ID * ID = ( ID * ) ID ( ID ) ;  
ID * ID = ID -> ID ; 
ID * ID ; 
ID * ID ; 

ID ( STRING , ID , ID ) ; 
ID ( STRING , ID - ID , INTEGER ) ; 

 
if ( ++ ID == ID ) 
ID = ID ; 

 
while ( ID > INTEGER ) 
{ 
ID * ID ; 

ID -- ; 

ID = ( ID * ) ID ( ID ) ; 
ID -> ID ++ ; 
ID -> ID ++ ; 
ID = ( ID * ) ID ( ID ) ; 
ID ( STRING , ID , ID -> ID ) ; 

 
if ( ID != ID ) 
for ( ID = ( ID * ) ID ( ID ) ; ID != ID ; ID = ( ID * ) ID ( ID ) ) 
ID ( ID , ID , ID , ID , ID ) ; 
} 

ID ( STRING , ID -> ID , INTEGER ) ; 

 
ID = - * ( ID ( ID , ID -> ID , ID ) ) ; 
ID ( STRING , ID , INTEGER ) ; 
ID = ID [ ID ] ; 
if ( ID == ID ) 
{ 
ID ( STRING , ID , INTEGER ) ; 
ID = ( ID * ) ID ( sizeof ( ID ) , ID -> ID ) ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID [ ID ] = ID ; 

 
ID = INTEGER ; 
} 
else 
{  
void * ID ; 

for ( ID = ID ( ID ) ; ID != ID ; ID = ID ( ID ) ) 
{ 
ID * ID = ( ID * ) ID ( ID ) ; 
void * ID ; 

for ( ID = ID ( ID ) ; ID != ID ; ID = ID ( ID ) ) 
if ( ID ( ID ) == ID ) 
goto ID ; 
} 

 
ID = INTEGER ; 
} 

 
 
 
ID = ( ID * ) ID ( sizeof ( ID ) , ID -> ID ) ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
if ( ID -> ID == ID -> ID ) 
ID -> ID = ID -> ID ; 
else 
ID -> ID = ID -> ID - INTEGER ; 

ID ( sizeof ( ID ) , ID , ID ) ; 
ID = ( ID * ) ID ( sizeof ( ID ) , ID , ID ) ; 
 
ID = ( ID * ) ID ( sizeof ( ID ) , ID , ID ) ; 
 

 
ID = ID ( ID , ID , ID ) ; 

while ( * ID < INTEGER ) 
ID ++ ; 

while ( * ID > INTEGER ) 
if ( ID ( & ID -> ID , ID ( ID -> ID [ * ID ] . ID ) ) ) 
{ 
ID = INTEGER ; 
ID ( STRING , ID ( ID -> ID [ * ID ] . ID ) , INTEGER ) ; 
ID ++ ; 
} 
else 
{ 
ID * ID = & ( ID -> ID [ * ID ] ) ; 
unsigned ID = ID -> ID * INTEGER ; 
unsigned ID = ID -> ID -> ID ; 

 

ID ( STRING , ID ( ID -> ID [ * ID ] . ID ) , INTEGER ) ; 
if ( ! ( ID && 
ID -> ID == ID -> ID  && 
ID != INTEGER ) )  
if ( ID || ID != INTEGER ) 
{ 
ID ( ID , ID ) ; 
ID ( ID , ID , ID , ID , ID ) ; 
} 

ID ++ ;  
} 
ID : ; 

} 

 
 
ID ( ID , INTEGER , sizeof ( ID * ) * ID ) ;  
ID ( ID , INTEGER , sizeof ( ID * ) * ID ) ;  

 
for ( ID = INTEGER ; ID < ID ; ID ++ ) 
{ 
if ( ID [ ID ] != ID ) 
{ 
int * ID = ID ( ID , ID [ ID ] -> ID , ID ) ; 

while ( * ID < INTEGER ) 
{ 
ID * * ID = & ID [ - * ID ] ; 
ID * * ID = & ID [ - * ID ] ; 

if ( * ID == ID ) 
{ 
ID ( STRING , - * ID , INTEGER ) ; 

* ID = ( ID * ) ID ( sizeof ( ID ) , ID -> ID ) ; 
( * ID ) -> ID = - * ID ; 
( * ID ) -> ID = ID ; 
( * ID ) -> ID = ID + INTEGER ; 

* ID = ( ID * ) ID ( sizeof ( ID ) , ID -> ID ) ; 
( * ID ) -> ID = ID ; 
( * ID ) -> ID = ID ; 
( * ID ) -> ID = ID + INTEGER ; 

ID ( sizeof ( ID ) , * ID , * ID ) ; 
} 
ID ++ ; 
} 
} 
} 

if ( ID [ INTEGER ] != ID ) ID = INTEGER ; 

 
for ( ID = INTEGER , ID = INTEGER ; ID < ID ; ID ++ ) 
{ 
if ( ID [ ID ] != ID ) 
{ 
int * ID = ID ( ID , ID [ ID ] -> ID , ID ) ; 

if ( * ID < INTEGER ) 
{ 
ID ( STRING , - * ID , INTEGER ) ; 
ID = INTEGER ; 
ID ( sizeof ( ID ) , ID [ ID ] , ID [ - * ID ] ) ; 
} 
} 
ID [ ID ] = ID [ ID ] ; 
} 

 
ID ( STRING , ID , INTEGER ) ; 
ID ( ID ) ; 
ID += INTEGER ; 
} 
while ( ID ) ; 

if ( ID ) ID ( STRING ) ; else ID ( STRING ) ; 

 
ID ( ID , ID -> ID ) ; 

 
ID ( ID ) ; 
ID ( ID ) ; 
ID ( ID ) ; 

return ID ; 
} 

ID * ID ( ID * ID , char * ID , int ID , int ID ) 
{ 
typedef struct ID 
{ 
ID * ID ; 
unsigned ID ; 
unsigned ID ; 
unsigned ID ; 
ID * ID ; 
} ID ; 

ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 

ID * * ID ;  
ID * * ID ;  
int ID ;  
int ID ;  
int ID ;  
unsigned ID = ID -> ID ; 
unsigned ID = INTEGER ;  
ID * ID ;  
int ID = INTEGER ; 


 
 
if ( ID == INTEGER ) 
ID = INTEGER ; 

ID = ( ID * ) ID ( ID , sizeof ( ID ) ) ;  
ID = ID + ID ;  
ID = ID ;  
ID = ID ;  

ID ( STRING , ID , ID ? STRING : STRING , ID ) ; 
ID ( & ID -> ID , ID , INTEGER ) ; 
ID ( STRING ) ; 

 
ID = ( ID * * ) ID ( ID , sizeof ( ID * ) ) ; 
ID = ( ID * * ) ID ( ID , sizeof ( ID * ) ) ; 

 
ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 
ID -> ID = ID ; 
ID -> ID = ID ( STRING ) ; 
ID ( ID -> ID , ID ( sizeof ( ID ) , ID -> ID ) ) ; 
( ( ID * ) ID ( ID -> ID ) ) -> ID = ID ; 

 
ID [ ID -> ID ] = ( ID * ) ID ( sizeof ( ID ) , ID -> ID ) ; 
ID [ ID -> ID ] -> ID = ID -> ID ; 
ID [ ID -> ID ] -> ID = ID ; 
ID [ ID -> ID ] -> ID = ID ; 

 
ID ( sizeof ( ID ) , ID ( ID -> ID ) , ID [ ID -> ID ] ) ; 

 
ID ( ID , ID -> ID -> ID ) ; 
ID ( ID ) ; 

 
ID ( & ID ) ; 
ID ( & ID ) ; 
ID ( & ID ) ; 
ID = - INTEGER ; 

 
do 
{ 
 
 
for ( ID = ID - INTEGER ; ID > INTEGER ; ID -- ) 
if ( ID [ ID ] != ID ) 
{ 
int * ID = ID ( ID , ID , ID ) ; 

if ( * ID == INTEGER ) 
{ 
ID [ ID ] = ID ;  
ID ( STRING , ID , INTEGER ) ; 
} 
else 
{ 
while ( * ID < INTEGER )  
{ 
ID ++ ; 
ID ( STRING , ID , INTEGER ) ; 
} 

while ( * ID > INTEGER ) 
if ( ID ( & ID -> ID , ID ( ID -> ID [ * ID ] . ID ) ) ) 
{ 
 ID = INTEGER ; 
ID ( STRING , ID ( ID -> ID [ * ID ] . ID ) , INTEGER ) ; 
ID ++ ; 
} 
else 
{ 
ID * ID = & ( ID -> ID [ * ID ] ) ; 
unsigned ID = ID -> ID ; 
unsigned ID = ID -> ID -> ID ; 

ID * ID = ID [ ID ] ; 
ID * ID ; 

ID ( STRING , ID ( ID -> ID [ * ID ] . ID ) , INTEGER ) ; 

for ( ID = ( ID * ) ID ( ID ) ; ID != ID ; ID = ( ID * ) ID ( ID ) ) 
{ 
ID ( ID , ID ) ; 
ID ( ID , ID , ID , ID , ID ) ; 
} 
ID ++ ; 
} 
} 
} 

 
while ( ID != ID ) 
{ 
int ID ; 
unsigned ID ; 
ID * ID ; 
int * ID ; 
unsigned ID = ID -> ID ; 
unsigned ID = ID -> ID ; 
unsigned ID = ID -> ID ; 
ID * ID = ID -> ID ; 
ID * ID = ( ID * ) ID ( ID ) ;  
ID * ID = ID -> ID ; 
ID * ID ; 

ID ( STRING , ID , ID ) ; 
ID ( STRING , ID - ID , INTEGER ) ; 

 
if ( ++ ID == ID ) 
ID = ID ; 

 
while ( ID > INTEGER ) 
{ 
ID * ID ; 

ID -- ; 

ID = ( ID * ) ID ( ID ) ; 
if ( ID ( ID ) != ID )  
{ 
ID -> ID ++ ; 
ID -> ID ++ ; 
} 
ID = ( ID * ) ID ( ID ) ; 
ID ( STRING , ID , ID -> ID ) ; 

 
if ( ID != ID ) 
for ( ID = ( ID * ) ID ( ID ) ; ID != ID ; ID = ( ID * ) ID ( ID ) ) 
ID ( ID , ID , ID , ID , ID ) ; 
} 

ID ( STRING , ID -> ID , INTEGER ) ; 

 
ID = - * ( ID ( ID , ID -> ID , ID ) ) ; 
ID ( STRING , ID , INTEGER ) ; 
ID = ID [ ID ] ; 
if ( ID == ID ) 
{ 
ID ( STRING , ID , INTEGER ) ; 
ID = ( ID * ) ID ( sizeof ( ID ) , ID -> ID ) ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID [ ID ] = ID ; 

 
ID = INTEGER ; 
} 
else 
{  
void * ID ; 

for ( ID = ID ( ID ) ; ID != ID ; ID = ID ( ID ) ) 
if ( ID ( ID ) == ID ) 
goto ID ; 

 
ID = INTEGER ; 
} 

 
ID = ( ID * ) ID ( sizeof ( ID ) , ID , ID ) ; 
ID -> ID = ID ; 

 
ID = ID ( ID , ID , ID ) ; 

while ( * ID < INTEGER ) 
ID ++ ; 

while ( * ID > INTEGER ) 
if ( ID ( & ID -> ID , ID ( ID -> ID [ * ID ] . ID ) ) ) 
{ 
ID ( STRING , ID ( ID -> ID [ * ID ] . ID ) , INTEGER ) ; 
ID ++ ; 
} 
else 
{ 
ID * ID = & ( ID -> ID [ * ID ] ) ; 
unsigned ID = ID -> ID ; 
unsigned ID = ID -> ID -> ID ; 

 
ID ( STRING , ID ( ID -> ID [ * ID ] . ID ) , INTEGER ) ; 
if ( ! ( ID && 
ID -> ID == ID -> ID  && 
ID != INTEGER ) )  
if ( ID || ID != INTEGER ) 
{ 
ID ( ID , ID ) ; 
ID ( ID , ID , ID , ID , ID ) ;  
} 

ID ++ ;  
} 
ID : ; 

} 

 

 
ID ( ID , INTEGER , sizeof ( ID * ) * ID ) ;  

 
for ( ID = INTEGER , ID = INTEGER ; ID < ID ; ID ++ ) 
{ 
if ( ID [ ID ] != ID ) 
{ 
int * ID = ID ( ID , ID [ ID ] -> ID , ID ) ; 

while ( * ID < INTEGER ) 
{ 
ID * * ID = & ID [ - * ID ] ; 

if ( * ID == ID ) 
{ 
ID ( STRING , - * ID , ID ) ; 

ID = INTEGER ; 

* ID = ( ID * ) ID ( sizeof ( ID ) , ID -> ID ) ; 
( * ID ) -> ID = - * ID ; 
( * ID ) -> ID = ID ; 
( * ID ) -> ID = ID + INTEGER ; 
} 

( ( ID * ) ID ( sizeof ( ID ) , ID [ ID ] , * ID ) ) -> ID = ID ; 

ID ++ ; 
} 
} 
} 

if ( ID ) 
{ 
 
for ( ID = INTEGER ; ID < ID ; ID ++ ) 
ID [ ID ] = ID [ ID ] ; 

 
ID ( STRING , ID , INTEGER ) ; 
ID ( ID ) ; 
ID += INTEGER ; 
} 
} 
while ( ID ) ; 

 
ID ( STRING , ID , INTEGER ) ; 

if ( ID != ID ) 
{ 
ID ( STRING , INTEGER , INTEGER ) ; 
} 
else 
{ 
for ( ID = INTEGER ; ID < ID ; ID ++ ) 
{ 
int * ID ; 

ID = ID ( ID , ID , ID ) ; 

while ( * ID > INTEGER ) 
{ 
if ( ID ( & ID -> ID , ID ( ID -> ID [ * ID ] . ID ) ) ) 
{ 
ID = INTEGER ; 
ID ( STRING , ID ( ID -> ID [ * ID ] . ID ) , ID ) ; 
} 
ID ++ ; 
} 
} 
} 

if ( ID ) ID ( STRING ) ; else ID ( STRING ) ; 

 
ID ( ID , ID -> ID ) ; 

 
ID ( ID ) ; 
ID ( ID ) ; 

return ID ; 
}$

ansi_cpp_rdp_full
$
translation_unit ::=
  declaration_seq? ;
// Generated by gramex V3.0 from 'ansi_cpp_prd97.raw' (this build Mar 25 2012 at 13:21:48)
// Command line: C:\csle\dev\gramex\gramex.exe ansi_cpp_prd97.raw

// M()(translation_unit)

// Start of provenance

// ansi_cpp_prd97.raw - a grammar for the 1998 ANSI C++ standard language

// 1. This is the grammar summary from the 1997 Public Review Document for
// ANSI C++, cut-and-pasted from http://www.open-std.org/jtc1/sc22/open/n2356/ 
// on 30 August 2006.

// 2. There may be differences between this grammar and the one in the final 
// published standard. 

// 3. You can process this file with the gramex tool to make something close
// to a Bison input file, and use the gramconv tool to convert EBNF
// constructs to pure BNF, and to translate to a variety of other formats.

// 4. For tool and grammar downloads, see the Royal Holloway Compilers Group
// homepage under http://www.cs.rhul.ac.uk, or contact us at
// A.Johnstone@rhul.ac.uk or E.Scott@rhul.ac.uk.

// 5. Please don't change this file.

//         Adrian Johnstone and Elizabeth Scott, 24 August 2006

// End of provenance
//   ______________________________________________________________________

//   Annex 0 (informative)

//   Grammar summary                                                 [gram]

//   ______________________________________________________________________

// 1 This summary of C++ syntax is intended to be an aid to  comprehension.
//   It  is  not  an  exact  statement of the language.  In particular, the
//   grammar described here accepts a superset  of  valid  C++  constructs.
//   Disambiguation rules (_stmt.ambig_, _dcl.spec_, _class.member.lookup_)
//   must be applied to distinguish expressions  from  declarations.   Fur-
//   ther,  access  control, ambiguity, and type rules must be used to weed
//   out syntactically valid but meaningless constructs.

//   1.1  Keywords                                               [gram.key]

// 1 New context-dependent keywords are introduced into a program by  type-
//   def  (_dcl.typedef_),  namespace  (_namespace.def_),  class (_class_),
//   enumeration (_dcl.enum_), and template (_temp_) declarations.
(* Comment out lexical material 

typedef_name ::=
  identifier ;
namespace_name ::=
  original_namespace_name |
  namespace_alias ;

original_namespace_name ::=
  identifier ;

namespace_alias ::=
  identifier ;
class_name ::=
  identifier |
  template_id ;
enum_name ::=
  identifier ;
template_name ::=
  identifier |
  'Note' 'that' 'a' typedef_name 'naming' 'a' 'class' 'is' 'also' 'a' class_name |
  '(_class.name_).' ;

//   1.2  Lexical conventions                                    [gram.lex]
hex_quad ::=
  hexadecimal_digit hexadecimal_digit hexadecimal_digit hexadecimal_digit ;

universal_character_name ::=
  '\\u' hex_quad |
  '\\U' hex_quad hex_quad ;

preprocessing_token ::=
  header_name |
  identifier |
  pp_number |
  character_literal |
  string_literal |
  preprocessing_op_or_punc |
  'each' 'non-white-space' 'character' 'that' 'cannot' 'be' 'one' 'of' 'the' 'above' ;
token ::=
  identifier |
  'keyword' |
  literal |
  operator |
  'punctuator' ;
header_name ::=
  '<h-char-sequence>' |
  '\"q-char-sequence\"' ;
h_char_sequence ::=
  h_char |
  h_char_sequence h_char ;
h_char ::=
  'any' 'member' 'of' 'the' 'source' 'character' 'set' 'except' |
  new_line 'and' '>' ;
q_char_sequence ::=
  q_char |
  q_char_sequence q_char ;
q_char ::=
  'any' 'member' 'of' 'the' 'source' 'character' 'set' 'except' |
  new_line 'and' '\"' ;
pp_number ::=
  digit |
  '.' digit |
  pp_number digit |
  pp_number nondigit |
  pp_number 'e' sign |
  pp_number 'E' sign |
  pp_number '.' ;
identifier ::=
  nondigit |
  identifier nondigit |
  identifier digit ;
nondigit ::=
  universal_character_name |
  '_' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' |
  'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' |
  'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' |
  'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' ;
digit ::=
  '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' ;

preprocessing_op_or_punc ::=
  '{' | '}' | '[' | ']' | '#' | '##' | '(' | ')' |
  '<:' | ':>' | '<%' | '%>' | '%:' | '%:%:' | ';' | ':' | '...' |
  'new' | 'delete' | '?' | '::' | '.' | '.*' |
  '+' | '-' | '*' | '/' | '%' | '^' | '&' | '|' | '~' |
  '!' | '=' | '<' | '>' | '+=' | '-=' | '*=' | '/=' | '%=' |
  '^=' | '&=' | '|=' | '<<' | '>>' | '>>=' | '<<=' | '==' | '!=' |
  '<=' | '>=' | '&&' | '||' | '++' | '--' | ',' | '->*' | '->' |
  'and' | 'and_eq' | 'bitand' | 'bitor' | 'compl' | 'not' | 'not_eq' | 'or' | 'or_eq' |
  'xor' | 'xor_eq' ;

literal ::=
  integer_literal |
  character_literal |
  floating_literal |
  string_literal |
  boolean_literal ;
integer_literal ::=
  decimal_literal integer_suffix? |
  octal_literal integer_suffix? |
  hexadecimal_literal integer_suffix? ;
decimal_literal ::=
  nonzero_digit |
  decimal_literal digit ;
octal_literal ::=
  '0' |
  octal_literal octal_digit ;
hexadecimal_literal ::=
  '0x' hexadecimal_digit |
  '0X' hexadecimal_digit |
  hexadecimal_literal hexadecimal_digit ;
nonzero_digit ::=
  '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' ;
octal_digit ::=
  '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' ;
hexadecimal_digit ::=
  '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' |
  'a' | 'b' | 'c' | 'd' | 'e' | 'f' |
  'A' | 'B' | 'C' | 'D' | 'E' | 'F' ;
integer_suffix ::=
  unsigned_suffix long_suffix? |
  long_suffix unsigned_suffix? ;
unsigned_suffix ::=
  'u' | 'U' ;
long_suffix ::=
  'l' | 'L' ;
character_literal ::=
  '\'c-char-sequence\'' |
  'L\'c-char-sequence\'' ;
c_char_sequence ::=
  c_char |
  c_char_sequence c_char ;

c_char ::=
  'any' 'member' 'of' 'the' 'source' 'character' 'set' 'except' |
  'the' 'single-quote' '\',' 'backslash' '\\,' 'or' new_line 'character' |
  escape_sequence |
  universal_character_name ;
escape_sequence ::=
  simple_escape_sequence |
  octal_escape_sequence |
  hexadecimal_escape_sequence ;
simple_escape_sequence ::=
  '\\\'' | '\\\"' | '\\?' | '\\\\' |
  '\\a' | '\\b' | '\\f' | '\\n' | '\\r' | '\\t' | '\\v' ;
octal_escape_sequence ::=
  '\\' octal_digit |
  '\\' octal_digit octal_digit |
  '\\' octal_digit octal_digit octal_digit ;
hexadecimal_escape_sequence ::=
  '\\x' hexadecimal_digit |
  hexadecimal_escape_sequence hexadecimal_digit ;
floating_literal ::=
  fractional_constant exponent_part? floating_suffix? |
  digit_sequence exponent_part floating_suffix? ;
fractional_constant ::=
  digit_sequence? '.' digit_sequence |
  digit_sequence '.' ;
exponent_part ::=
  'e' sign? digit_sequence |
  'E' sign? digit_sequence ;
sign ::=
  '+' | '-' ;
digit_sequence ::=
  digit |
  digit_sequence digit ;
floating_suffix ::=
  'f' | 'l' | 'F' | 'L' ;
string_literal ::=
  '\"s-char-sequenceopt\"' |
  'L\"s-char-sequenceopt\"' ;
s_char_sequence ::=
  s_char |
  s_char_sequence s_char ;
s_char ::=
  'any' 'member' 'of' 'the' 'source' 'character' 'set' 'except' |
  'the' 'double-quote' '\",' 'backslash' '\\,' 'or' new_line 'character' |
  escape_sequence |
  universal_character_name ;
boolean_literal ::=
  'false' |
  'true' ;
*)
literal ::=
  integer_literal |
  character_literal |
  floating_literal |
  string_literal |
  boolean_literal ;

string_literal ::= 'STRING' | string_literal 'STRING' ; (* Allow C-style String catenation *)
character_literal ::= 'CHARACTER' ;
integer_literal ::= 'INTEGER' ;
floating_literal ::= 'REAL' ;
boolean_literal ::= 'true' | 'false' ;

identifier ::= 'ID' ;

//   1.3  Basic concepts                                       [gram.basic]
//translation_unit ::=
//  declaration_seq? ;

//   1.4  Expressions                                           [gram.expr]
primary_expression ::=
  literal |
  'this' |
  '::' identifier |
  '::' operator_function_id |
  '::' qualified_id |
  '(' expression ')' |
  id_expression ;

(* Comment out unexpected duplicate production
id_expression ::=
  unqualified_id |
  qualified_id ;
*)

id_expression ::=
  unqualified_id |
  qualified_id ;

unqualified_id ::=
  identifier |
  operator_function_id |
  conversion_function_id |
  '~' class_name |
  template_id ;
qualified_id ::=
  nested_name_specifier 'template'? unqualified_id ;
nested_name_specifier ::=
  class_or_namespace_name '::' nested_name_specifier? ;

class_or_namespace_name ::=
  class_name |
  namespace_name ;
postfix_expression ::=
  primary_expression |
  postfix_expression '[' expression ']' |
  postfix_expression '(' expression_list? ')' |
  simple_type_specifier '(' expression_list? ')' |
  postfix_expression '.' 'template'? '::'? id_expression |
  postfix_expression '->' 'template'? '::'? id_expression |
  postfix_expression '.' pseudo_destructor_name |
  postfix_expression '->' pseudo_destructor_name |
  postfix_expression '++' |
  postfix_expression '--' |
  'dynamic_cast' '<' type_id '>' '(' expression ')' |
  'static_cast' '<' type_id '>' '(' expression ')' |
  'reinterpret_cast' '<' type_id '>' '(' expression ')' |
  'const_cast' '<' type_id '>' '(' expression ')' |
  'typeid' '(' expression ')' |
  'typeid' '(' type_id ')' ;

expression_list ::=
  assignment_expression |
  expression_list ',' assignment_expression ;
pseudo_destructor_name ::=
  '::'? nested_name_specifier? type_name '::' '~' type_name |
  '::'? nested_name_specifier? '~' type_name ;
unary_expression ::=
  postfix_expression |
  '++' cast_expression |
  '--' cast_expression |
  unary_operator cast_expression |
  'sizeof' unary_expression |
  'sizeof' '(' type_id ')' |
  new_expression |
  delete_expression ;
unary_operator ::=
  '*' | '&' | '+' | '-' | '!' | '~' ;
new_expression ::=
  '::'? 'new' new_placement? new_type_id new_initializer? |
  '::'? 'new' new_placement? '(' type_id ')' new_initializer? ;
new_placement ::=
  '(' expression_list ')' ;
new_type_id ::=
  type_specifier_seq new_declarator? ;
new_declarator ::=
  ptr_operator new_declarator? |
  direct_new_declarator ;
direct_new_declarator ::=
  '[' expression ']' |
  direct_new_declarator '[' constant_expression ']' ;
new_initializer ::=
  '(' expression_list? ')' ;
delete_expression ::=
  '::'? 'delete' cast_expression |
  '::'? 'delete' '[' ']' cast_expression ;
cast_expression ::=
  unary_expression |
  '(' type_id ')' cast_expression ;
pm_expression ::=
  cast_expression |
  pm_expression '.*' cast_expression |
  pm_expression '->*' cast_expression ;
multiplicative_expression ::=
  pm_expression |
  multiplicative_expression '*' pm_expression |
  multiplicative_expression '/' pm_expression |
  multiplicative_expression '%' pm_expression ;
additive_expression ::=
  multiplicative_expression |
  additive_expression '+' multiplicative_expression |
  additive_expression '-' multiplicative_expression ;

shift_expression ::=
  additive_expression |
  shift_expression '<<' additive_expression |
  shift_expression '>>' additive_expression ;
relational_expression ::=
  shift_expression |
  relational_expression '<' shift_expression |
  relational_expression '>' shift_expression |
  relational_expression '<=' shift_expression |
  relational_expression '>=' shift_expression ;
equality_expression ::=
  relational_expression |
  equality_expression '==' relational_expression |
  equality_expression '!=' relational_expression ;
and_expression ::=
  equality_expression |
  and_expression '&' equality_expression ;
exclusive_or_expression ::=
  and_expression |
  exclusive_or_expression '^' and_expression ;
inclusive_or_expression ::=
  exclusive_or_expression |
  inclusive_or_expression '|' exclusive_or_expression ;
logical_and_expression ::=
  inclusive_or_expression |
  logical_and_expression '&&' inclusive_or_expression ;
logical_or_expression ::=
  logical_and_expression |
  logical_or_expression '||' logical_and_expression ;
conditional_expression ::=
  logical_or_expression |
  logical_or_expression '?' expression ':' assignment_expression ;
assignment_expression ::=
  conditional_expression |
  logical_or_expression assignment_operator assignment_expression |
  throw_expression ;
assignment_operator ::=
  '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '>>=' | '<<=' | '&=' | '^=' | '|=' ;
expression ::=
  assignment_expression |
  expression ',' assignment_expression ;
constant_expression ::=
  conditional_expression ;

//   1.5  Statements                                       [gram.stmt.stmt]
statement ::=
  labeled_statement |
  expression_statement |
  compound_statement |
  selection_statement |
  iteration_statement |
  jump_statement |
  declaration_statement |
  try_block ;

labeled_statement ::=
  identifier ':' statement |
  'case' constant_expression ':' statement |
  'default' ':' statement ;
expression_statement ::=
  expression? ';' ;
compound_statement ::=
  '{' statement_seq? '}' ;
statement_seq ::=
  statement |
  statement_seq statement ;
selection_statement ::=
  'if' '(' condition ')' statement |
  'if' '(' condition ')' statement 'else' statement |
  'switch' '(' condition ')' statement ;
condition ::=
  expression |
  type_specifier_seq declarator '=' assignment_expression ;
iteration_statement ::=
  'while' '(' condition ')' statement |
  'do' statement 'while' '(' expression ')' ';' |
  'for' '(' for_init_statement condition? ';' expression? ')' statement ;
for_init_statement ::=
  expression_statement |
  simple_declaration ;
jump_statement ::=
  'break' ';' |
  'continue' ';' |
  'return' expression? ';' |
  'goto' identifier ';' ;
declaration_statement ::=
  block_declaration ;

//   1.6  Declarations                                       [gram.dcl.dcl]
declaration_seq ::=
  declaration |
  declaration_seq declaration ;
declaration ::=
  block_declaration |
  function_definition |
  template_declaration |
  explicit_instantiation |
  explicit_specialization |
  linkage_specification |
  namespace_definition ;
block_declaration ::=
  simple_declaration |
  asm_definition |
  namespace_alias_definition |
  using_declaration |
  using_directive ;
simple_declaration ::=
  decl_specifier_seq? init_declarator_list? ';' ;

decl_specifier ::=
  storage_class_specifier |
  type_specifier |
  function_specifier |
  'friend' |
  'typedef' ;
decl_specifier_seq ::=
  decl_specifier_seq? decl_specifier ;
storage_class_specifier ::=
  'auto' |
  'register' |
  'static' |
  'extern' |
  'mutable' ;
function_specifier ::=
  'inline' |
  'virtual' |
  'explicit' ;
typedef_name ::=
  identifier ;
type_specifier ::=
  simple_type_specifier |
  class_specifier |
  enum_specifier |
  elaborated_type_specifier |
  cv_qualifier ;
simple_type_specifier ::=
  '::'? nested_name_specifier? type_name |
  'char' |
  'wchar_t' |
  'bool' |
  'short' |
  'int' |
  'long' |
  'signed' |
  'unsigned' |
  'float' |
  'double' |
  'void' ;
type_name ::=
  class_name |
  enum_name |
  typedef_name ;
elaborated_type_specifier ::=
  class_key '::'? nested_name_specifier? identifier |
  'enum' '::'? nested_name_specifier? identifier |
  'typename' '::'? nested_name_specifier identifier |
  'typename' '::'? nested_name_specifier identifier '<' template_argument_list '>' ;
enum_name ::=
  identifier ;
enum_specifier ::=
  'enum' identifier? '{' enumerator_list? '}' ;

enumerator_list ::=
  enumerator_definition |
  enumerator_list ',' enumerator_definition ;
enumerator_definition ::=
  enumerator |
  enumerator '=' constant_expression ;
enumerator ::=
  identifier ;
namespace_name ::=
  original_namespace_name |
  namespace_alias ;
original_namespace_name ::=
  identifier ;

namespace_definition ::=
  named_namespace_definition |
  unnamed_namespace_definition ;

named_namespace_definition ::=
  original_namespace_definition |
  extension_namespace_definition ;

original_namespace_definition ::=
  'namespace' identifier '{' namespace_body '}' ;

extension_namespace_definition ::=
  'namespace' original_namespace_name '{' namespace_body '}' ;

unnamed_namespace_definition ::=
  'namespace' '{' namespace_body '}' ;

namespace_body ::=
  declaration_seq? ;
namespace_alias ::=
  identifier ;

namespace_alias_definition ::=
  'namespace' identifier '=' qualified_namespace_specifier ';' ;

qualified_namespace_specifier ::=
  '::'? nested_name_specifier? namespace_name ;
using_declaration ::=
  'using' 'typename'? '::'? nested_name_specifier unqualified_id ';' |
  'using' '::' unqualified_id ';' ;
using_directive ::=
  'using' 'namespace' '::'? nested_name_specifier? namespace_name ';' ;
asm_definition ::=
  'asm' '(' string_literal ')' ';' ;
linkage_specification ::=
  'extern' string_literal '{' declaration_seq? '}' |
  'extern' string_literal declaration ;

//   1.7  Declarators                                       [gram.dcl.decl]
init_declarator_list ::=
  init_declarator |
  init_declarator_list ',' init_declarator ;
init_declarator ::=
  declarator initializer? ;
declarator ::=
  direct_declarator |
  ptr_operator declarator ;
direct_declarator ::=
  declarator_id |
  direct_declarator '(' parameter_declaration_clause ')' cv_qualifier_seq? exception_specification? |
  direct_declarator '[' constant_expression? ']' |
  '(' declarator ')' ;
ptr_operator ::=
  '*' cv_qualifier_seq? |
  '&' |
  '::'? nested_name_specifier '*' cv_qualifier_seq? ;
cv_qualifier_seq ::=
  cv_qualifier cv_qualifier_seq? ;
cv_qualifier ::=
  'const' |
  'volatile' ;
declarator_id ::=
  '::'? id_expression |
  '::'? nested_name_specifier? type_name ;
type_id ::=
  type_specifier_seq abstract_declarator? ;
type_specifier_seq ::=
  type_specifier type_specifier_seq? ;
abstract_declarator ::=
  ptr_operator abstract_declarator? |
  direct_abstract_declarator ;
direct_abstract_declarator ::=
  direct_abstract_declarator? '(' parameter_declaration_clause ')' cv_qualifier_seq? exception_specification? |
  direct_abstract_declarator? '[' constant_expression? ']' |
  '(' abstract_declarator ')' ;
parameter_declaration_clause ::=
  parameter_declaration_list? '...'? |
  parameter_declaration_list ',' '...' ;
parameter_declaration_list ::=
  parameter_declaration |
  parameter_declaration_list ',' parameter_declaration ;
parameter_declaration ::=
  decl_specifier_seq declarator |
  decl_specifier_seq declarator '=' assignment_expression |
  decl_specifier_seq abstract_declarator? |
  decl_specifier_seq abstract_declarator? '=' assignment_expression ;
function_definition ::=
  decl_specifier_seq? declarator ctor_initializer? function_body |
  decl_specifier_seq? declarator function_try_block ;

function_body ::=
  compound_statement ;

initializer ::=
  '=' initializer_clause |
  '(' expression_list ')' ;
initializer_clause ::=
  assignment_expression |
  '{' initializer_list ','? '}' |
  '{' '}' ;
initializer_list ::=
  initializer_clause |
  initializer_list ',' initializer_clause ;

//   1.8  Classes                                              [gram.class]
class_name ::=
  identifier |
  template_id ;
class_specifier ::=
  class_head '{' member_specification? '}' ;
class_head ::=
  class_key identifier? base_clause? |
  class_key nested_name_specifier identifier base_clause? ;
class_key ::=
  'class' |
  'struct' |
  'union' ;
member_specification ::=
  member_declaration member_specification? |
  access_specifier ':' member_specification? ;
member_declaration ::=
  decl_specifier_seq? member_declarator_list? ';' |
  function_definition ';'? |
  qualified_id ';' |
  using_declaration |
  template_declaration ;
member_declarator_list ::=
  member_declarator |
  member_declarator_list ',' member_declarator ;
member_declarator ::=
  declarator pure_specifier? |
  declarator constant_initializer? |
  identifier? ':' constant_expression ;
pure_specifier ::=
  '=' '0' ;
constant_initializer ::=
  '=' constant_expression ;

//   1.9  Derived classes                              [gram.class.derived]
base_clause ::=
  ':' base_specifier_list ;
base_specifier_list ::=
  base_specifier |
  base_specifier_list ',' base_specifier ;

base_specifier ::=
  '::'? nested_name_specifier? class_name |
  'virtual' access_specifier? '::'? nested_name_specifier? class_name |
  access_specifier 'virtual'? '::'? nested_name_specifier? class_name ;
access_specifier ::=
  'private' |
  'protected' |
  'public' ;

//   1.10  Special member functions                          [gram.special]
conversion_function_id ::=
  operator conversion_type_id ;
conversion_type_id ::=
  type_specifier_seq conversion_declarator? ;
conversion_declarator ::=
  ptr_operator conversion_declarator? ;
ctor_initializer ::=
  ':' mem_initializer_list ;
mem_initializer_list ::=
  mem_initializer |
  mem_initializer ',' mem_initializer_list ;
mem_initializer ::=
  mem_initializer_id '(' expression_list? ')' ;
mem_initializer_id ::=
  '::'? nested_name_specifier? class_name |
  identifier ;

//   1.11  Overloading                                          [gram.over]
operator_function_id ::=
  operator operator ;
operator ::=
  'new' | 'delete' | 'new[]' | 'delete[]' |
  '+' | '-' | '*' | '/' | '%' | '^' | '&' | '|' | '~' |
  '!' | '=' | '<' | '>' | '+=' | '-=' | '*=' | '/=' | '%=' |
  '^=' | '&=' | '|=' | '<<' | '>>' | '>>=' | '<<=' | '==' | '!=' |
  '<=' | '>=' | '&&' | '||' | '++' | '--' | ',' | '->*' | '->' |
  '()' | '[]' ;

//   1.12  Templates                                            [gram.temp]
template_declaration ::=
  'export'? 'template' '<' template_parameter_list '>' declaration ;
template_parameter_list ::=
  template_parameter |
  template_parameter_list ',' template_parameter ;
template_parameter ::=
  type_parameter |
  parameter_declaration ;
type_parameter ::=
  'class' identifier? |
  'class' identifier? '=' type_id |
  'typename' identifier? |
  'typename' identifier? '=' type_id |
  'template' '<' template_parameter_list '>' 'class' identifier? |
  'template' '<' template_parameter_list '>' 'class' identifier? '=' template_name ;

template_id ::=
  template_name '<' template_argument_list '>' ;
template_name ::=
  identifier ;
template_argument_list ::=
  template_argument |
  template_argument_list ',' template_argument ;
template_argument ::=
  assignment_expression |
  type_id |
  template_name ;
explicit_instantiation ::=
  'template' declaration ;
explicit_specialization ::=
  'template' '<' '>' declaration ;

//   1.13  Exception handling                                 [gram.except]
try_block ::=
  'try' compound_statement handler_seq ;
function_try_block ::=
  'try' ctor_initializer? function_body handler_seq ;
handler_seq ::=
  handler handler_seq? ;
handler ::=
  'catch' '(' exception_declaration ')' compound_statement ;
exception_declaration ::=
  type_specifier_seq declarator |
  type_specifier_seq abstract_declarator |
  type_specifier_seq |
  '...' ;
throw_expression ::=
  'throw' assignment_expression? ;
exception_specification ::=
  'throw' '(' type_id_list? ')' ;
type_id_list ::=
  type_id |
  type_id_list ',' type_id ;

(* Comment out preprocessor stuff 
//   1.14  Preprocessing directives                              [gram.cpp]
preprocessing_file ::=
  group? ;
group ::=
  group_part |
  group group_part ;
group_part ::=
  pp_tokens? new_line |
  if_section |
  control_line ;
if_section ::=
  if_group elif_groups? else_group? endif_line ;
if_group ::=
  '#' 'if' constant_expression new_line group? |
  '#' 'ifdef' identifier new_line group? |
  '#' 'ifndef' identifier new_line group? ;

elif_groups ::=
  elif_group |
  elif_groups elif_group ;
elif_group ::=
  '#' 'elif' constant_expression new_line group? ;
else_group ::=
  '#' 'else' new_line group? ;
endif_line ::=
  '#' 'endif' new_line ;
control_line ::=
  '#' 'include' pp_tokens new_line |
  '#' 'define' identifier replacement_list new_line |
  '#' 'define' identifier lparen 'identifier-list'? ')' replacement_list new_line |
  '#' 'undef' identifier new_line |
  '#' 'line' pp_tokens new_line |
  '#' 'error' pp_tokens? new_line |
  '#' 'pragma' pp_tokens? new_line |
  '#' new_line ;
lparen ::=
  'the' 'left-parenthesis' 'character' 'without' 'preceding' 'white-space' ;
replacement_list ::=
  pp_tokens? ;
pp_tokens ::=
  preprocessing_token |
  pp_tokens preprocessing_token ;
new_line ::=
  'the' new_line 'character' ;
*)

// End of ansi_cpp_prd97.raw
$
accept
$char 
* ID ,  
* * ID ,  
* ID = STRING ;  

int 
ID = INTEGER ,  
ID = INTEGER ,  
ID ,  
ID ;  

int ID = INTEGER ;  

char * ID = STRING 
STRING STRING STRING STRING STRING STRING STRING STRING 
STRING STRING STRING STRING STRING 
STRING 
STRING STRING STRING STRING STRING STRING STRING STRING 
STRING STRING STRING STRING STRING STRING STRING STRING 
STRING STRING STRING STRING STRING STRING STRING STRING 
STRING STRING STRING STRING STRING STRING STRING STRING 
STRING STRING STRING STRING STRING STRING STRING STRING 
STRING STRING STRING STRING STRING STRING STRING STRING 
STRING STRING STRING STRING STRING STRING STRING STRING 
STRING STRING STRING STRING STRING STRING STRING STRING 
STRING STRING STRING STRING STRING STRING STRING ; 

ID * ID = ID ; 
void * ID = ID ; 
ID * ID = ID ; 
void * ID = ID ; 
ID * ID = ID ; 
void * ID = ID ; 
ID * ID = ID ; 
void * ID = ID ; 

 
static int ID = INTEGER ; 

ID * ID ; 

ID * ID ( char * ID , ID * ID ) 
{ 
if ( ID ) 
{ 
ID * ID = ( ID * ) ID ( sizeof ( ID ) , ID ) ; 
if ( ID != ID ) 
ID -> ID = ID ; 
else 
ID ( ID , ID , sizeof ( ID ) ) ; 
return ID ; 
} 
else 
return ID ; 
} 

ID * ID ( char * ID , ID * ID ) 
{ 
if ( ID ) 
{ 
ID = ( ID * ) ID ( sizeof ( ID ) , ID ) ; 
if ( ID != ID ) 
ID -> ID = ID ; 
else 
ID ( ID , ID , sizeof ( ID ) ) ; 

( ( ID * ) ID ( sizeof ( ID ) , ID , ID ) ) -> ID = INTEGER ; 
return ID ; 
} 
else 
return ID ; 
} 

ID * ID ( char * ID , ID * ID ) 
{ 
if ( ID ) 
{ 
ID * ID = ( ID * ) ID ( sizeof ( ID ) , sizeof ( ID ) , ID ) ; 
if ( ID != ID ) 
ID -> ID = ID ; 
else 
ID ( ID , ID , sizeof ( ID ) ) ; 

( ( ID * ) ID ( ID ) ) -> ID = INTEGER ; 

return ID ; 
} 
else 
return ID ; 
} 


 
static void ID ( void ) 
{ 
ID ( STRING , STRING , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , STRING , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , STRING , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , STRING , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
} 

 

ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 

 

static void ID ( void ) 
{ 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , 
ID  , ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , 
ID  , ID  , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID ) ; 
ID ( & ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID , 
ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID , 
ID , ID ) ; 
ID ( & ID , ID , ID , ID , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , 
ID  , ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID ) ; 
ID ( & ID , ID  , ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , 
ID  , ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID  , 
ID  , ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , 
ID  , ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , 
ID  , ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID  , 
ID  , ID  , ID ) ; 
ID ( & ID , ID , ID  , ID  , ID  , ID  , 
ID  , ID ) ; 
ID ( & ID , ID , ID  , ID ) ; 
ID ( & ID , ID , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , 
ID , ID ) ; 
ID ( & ID , ID , ID , ID , ID , 
ID , ID ) ; 
ID ( & ID , ID , ID  , ID ) ; 
ID ( & ID , ID  , ID  , ID ) ; 
ID ( & ID , ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID  , ID ) ; 
ID ( & ID , ID , ID  , ID ) ; 
ID ( & ID , ID  , ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID  , ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , 
ID  , ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID  , 
ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , 
ID  , ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID  , 
ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , 
ID  , ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID  , 
ID  , ID  , ID ) ; 
ID ( & ID , ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID , ID ) ; 
ID ( & ID , ID , ID , ID , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID , 
ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID ) ; 
ID ( & ID , ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID , 
ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID ) ; 
ID ( & ID , ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID  , ID  , ID  , ID  , 
ID  , ID ) ; 
ID ( & ID , ID  , ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , 
ID  , ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID  , 
ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , 
ID  , ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID  , 
ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , 
ID  , ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID  , 
ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , 
ID  , ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID  , 
ID  , ID  , ID ) ; 
ID ( & ID , ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID , 
ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID , 
ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID , 
ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID , 
ID , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , 
ID  , ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID  , 
ID  , ID  , ID ) ; 
ID ( & ID , ID , ID  , ID  , ID  , ID  , 
ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , 
ID  , ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID , 
ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID ) ; 
ID ( & ID , ID , ID ) ; 
} 

 
static char * ID ( ID * ID ) ; 
static char * ID ( ID * ID ) ; 
static void ID ( ID * ID ) ; 
static ID * ID ( ID * ID ) ; 
static ID * ID ( ID * ID ) ; 
static ID * ID ( ID * ID ) ; 
static ID * ID ( ID * ID ) ; 
static ID * ID ( ID * ID ) ; 
static ID * ID ( ID * ID ) ; 
static char * ID ( ID * ID ) ; 
void ID ( ID * ID ) ; 

 
static char * ID ( ID * ID ) 
{ 
char * ID ; 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
ID ( ID , & ID , & ID ) ; 
} 
return ID ; 
} 

static char * ID ( ID * ID ) 
{ 
char * ID ; 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
ID ( ID , & ID , & ID ) ; 
} 
return ID ; 
} 

static void ID ( ID * ID ) 
{ 
char * ID ; 
char * ID ; 
char * ID ; 
char * ID ; 
char * ID ; 
long int ID ; 
long int ID ; 
char * ID ; 
char * ID ; 
char * ID ; 
char * ID ; 
char * ID ; 
long int ID ; 
char * ID ; 
{ 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
if ( ID ( ID ) == ID )  
ID ( ID , STRING , ID ) ;  
else  
{  
ID ( ) ;  
ID ( ) ;  
}  
 
} 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
{  
while ( INTEGER ) 
{ 
ID ( ID , & ID , & ID ) ; 
{ 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
ID = ID ( ID ( STRING , ID ) ) ; 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
break ;  
} 
}  
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID ( ID , ID , ID , ID ) ;  
} 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
{  
while ( INTEGER ) 
{ 
ID ( ID , & ID , & ID ) ; 
{ 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
ID = ID ( ID ( STRING , ID ) ) ; 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
break ;  
} 
}  
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID ( ID , ID , ID , ID ) ;  
} 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
{  
while ( INTEGER ) 
{ 
ID ( ID , & ID , & ID ) ; 
{ 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
ID = ID ( ID ( STRING , ID ) ) ; 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
break ;  
} 
}  
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID ( ID , ID , ID , ID ) ;  
} 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID ( ID , ID , ID , ID ) ;  
} 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
ID * ID ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID . ID ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID . ID ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID == INTEGER ) {  
ID = ( ID * ) ID ( sizeof ( ID ) ) ;  
ID -> ID = ID ;  
ID -> ID = ( unsigned ) ID ;  
ID -> ID = ( unsigned ) ID ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
ID = ID ;  
 
} 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
ID * ID ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID == INTEGER ) {  
ID = ( ID * ) ID ( sizeof ( ID ) ) ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
ID = ID ;  
 
} 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
ID = ID ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ( ID , ID , ID ) ; ID -> ID ++ ;  
} 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
ID = ID ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
ID = ID ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
ID = ID ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
ID = ID ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
ID = ID ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID . ID ; 
ID ( ) ; 
ID = ( unsigned ) ID ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID . ID ; 
ID ( ) ; 
ID = ( unsigned ) ID ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID . ID ; 
ID ( ) ; 
ID = ( unsigned ) ID ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
ID = INTEGER ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID . ID ; 
ID ( ) ; 
ID = ( unsigned ) ID ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID . ID ; 
ID ( ) ; 
ID = ( unsigned ) ID ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , & ID , ID ) ) 
{ 
{  
while ( INTEGER ) 
{ 
ID ( ID , & ID , & ID ) ; 
{ 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
ID = INTEGER ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
ID = INTEGER ; ID = INTEGER ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
ID = INTEGER ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
ID = ID ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
break ;  
} 
}  
if ( ID == INTEGER ) {  
ID = INTEGER ;  
} 
if ( ID ( ID , ID  , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
ID = ID ; 
ID = ID ( ID ( STRING , ID ) ) ; 
ID = ID ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
ID = INTEGER ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
ID = INTEGER ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
ID = INTEGER ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
ID ( ID , STRING ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
if ( ID ( ID , ID  , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
ID ( ID ( STRING , ID ) ) ; 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
ID ( ID , STRING ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
ID ( ID , STRING ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
ID ( ID , STRING ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
ID ( ID , STRING ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
ID ( ID , STRING ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
ID ( ID , STRING ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
ID ( ID , & ID , & ID ) ; 
ID ( ID , & ID , & ID ) ; 
} 
} 

static ID * ID ( ID * ID ) 
{ 
ID * ID ; 
char * ID ; 
char * ID ; 
{ 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ( ID , ID , ID ) ;  
} 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ( ID , ID , ID ) ;  
} 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ( ID , ID , ID ) ;  
} 
} 
else 
ID ( ID , & ID , & ID ) ; 
ID ( ID , & ID , & ID ) ; 
} 
return ID ; 
} 

static ID * ID ( ID * ID ) 
{ 
ID * ID ; 
char * ID ; 
long int ID ; 
ID * ID ; 
long int ID ; 
char * ID ; 
{ 
int ID = ID ; 
{  
while ( INTEGER ) 
{ 
ID ( ID , & ID , & ID ) ; 
{ 
if ( ID ( ID , ID  , ID ) ) 
{ 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID == INTEGER ) {  
ID = ID ( ID , ID , ID ) ;  
ID -> ID = INTEGER ;  
ID -> ID ++ ;   
 
} 
if ( ID ( ID , ID  , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID . ID ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID -> ID = ( unsigned ) ID ;  
} 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ( ID ( STRING , ID , ID ++ ) , ID , ID ) ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
ID -> ID ++ ;  
ID -> ID = INTEGER ;  
ID -> ID = INTEGER ;  
 
} 
if ( ID ( ID , & ID , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
{  
while ( INTEGER ) 
{ 
ID ( ID , & ID , & ID ) ; 
{ 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
break ;  
} 
}  
if ( ID == INTEGER ) {  
ID ( ID , STRING ) ;  
} 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
if ( ID ( ID , & ID , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ( ID , ID , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID . ID ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID -> ID = ID ;  
} 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID -> ID = INTEGER ;   
} 
if ( ID ( ID , ID , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID . ID ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID -> ID = ID ;  
} 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
if ( ID == INTEGER ) {  
if ( ID -> ID == INTEGER ) ID -> ID = INTEGER ;  
if ( ID -> ID != INTEGER && ( ID -> ID < ID -> ID ) )  
ID ( ID , STRING ) ;  
 
} if ( ID == INTEGER ) {  
ID -> ID = ID ;  
} 
{  
while ( INTEGER ) 
{ 
ID ( ID , & ID , & ID ) ; 
{ 
if ( ID ( ID , ID  , ID ) ) 
{ 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID == INTEGER ) {  
ID -> ID = ID ( ID , ID , ID ) ;  
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
break ;  
} 
}  
if ( ID ( ID , & ID , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID -> ID = ID ;  
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID -> ID = ID ;  
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID -> ID = ID ;  
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID -> ID = ID ;  
} 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ( ID ( STRING , ID , ID ++ ) , ID , ID ) ;  
ID -> ID = ID ;  
ID -> ID = ID ; ID -> ID = INTEGER ;  
ID -> ID ++ ;  
ID -> ID = INTEGER ;  
ID -> ID = INTEGER ;  
 
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ( ID ( STRING , ID , ID ++ ) , ID , ID ) ;  
ID -> ID = ID ;  
ID -> ID = ID ; ID -> ID = INTEGER ;  
ID -> ID ++ ;  
ID -> ID = INTEGER ;  
ID -> ID = INTEGER ;  
 
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ( ID ( STRING , ID , ID ++ ) , ID , ID ) ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
ID -> ID ++ ;  
ID -> ID = INTEGER ;  
ID -> ID = INTEGER ;  
 
} 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
break ;  
} 
}  
ID ( ID , & ID , & ID ) ; 
} 
return ID ; 
} 

static ID * ID ( ID * ID ) 
{ 
ID * ID ; 
char * ID ; 
long int ID ; 
double ID ; 
char * ID ; 
char * ID ; 
char * ID ; 
{ 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ( ID , ID , ID ) ;  
ID ( ID ) ;  
ID -> ID ++ ;   
ID -> ID = ID ;  
 
} if ( ID == INTEGER && ID -> ID ) { 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ( ID , & ID , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
ID * ID ; 
{  
while ( INTEGER ) 
{ 
ID ( ID , & ID , & ID ) ; 
{ 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID . ID ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ( ID * ) ID ( sizeof ( ID ) , INTEGER ) ;  
ID -> ID = ID ;  
ID -> ID = ID -> ID ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
 
} 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID . ID ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ( ID * ) ID ( sizeof ( ID ) , INTEGER ) ;  
ID -> ID = ID ;  
ID -> ID = ID -> ID ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
 
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID == INTEGER ) {  
ID = ( ID * ) ID ( sizeof ( ID ) , INTEGER ) ;  
ID -> ID = ID ;  
ID -> ID = ID -> ID ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
 
} 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ( ID * ) ID ( sizeof ( ID ) , INTEGER ) ;  
ID -> ID = ID ;  
ID -> ID = ID -> ID ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
 
} 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
break ;  
} 
}  
} 
if ( ! ID ( ID , & ID , ID ) ) break ; 
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID == INTEGER ) {  
ID = ( ID * ) ID ( ID ) ;  
} 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ( ID , ID , ID ) ;  
} 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ( ID , ID , ID ) ;  
} 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ( ID , ID , ID ) ;  
} 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ( ID , ID , ID ) ;  
} 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ( ID , ID , ID ) ;  
} 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ( ID , ID , ID ) ;  
} 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ( ID , ID , ID ) ;  
} 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
ID ( ID , STRING ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
ID ( ID , STRING ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
ID ( ID , STRING ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID == INTEGER ) {  
ID ( ID , STRING , ID ) ;  
} 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID ( ID , STRING ) ;  
} 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID ( ID , STRING ) ;  
} 
} 
else 
ID ( ID , & ID , & ID ) ; 
ID ( ID , & ID , & ID ) ; 
} 
return ID ; 
} 

static ID * ID ( ID * ID ) 
{ 
ID * ID ; 
ID * ID ; 
{ 
ID * ID ; if ( ID == INTEGER ) {  
ID = ID = ( ID * ) ID ( sizeof ( ID ) , INTEGER ) ;  
} 
{  
while ( INTEGER ) 
{ 
ID ( ID , & ID , & ID ) ; 
{ 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID == INTEGER ) {  
ID -> ID = ( ID * ) ID ( sizeof ( ID ) , INTEGER ) ;  
ID = ID -> ID ;  
ID -> ID = ID ( ID ( STRING , ID , ID ++ ) , ID , ID ) ;  
ID -> ID -> ID ++ ;  
ID -> ID -> ID = ID ;  
 
} 
} 
if ( ID -> ID != ID  ) break ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ) ; 
} 
}  
if ( ID == INTEGER ) {  
ID = ID -> ID ;  
} 
ID ( ID , & ID , & ID ) ; 
} 
return ID ; 
} 

static ID * ID ( ID * ID ) 
{ 
ID * ID ; 
char * ID ; 
char * ID ; 
ID * ID ; 
{ 
unsigned ID ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
ID = ID ; ID = INTEGER ;  
ID ++ ;  
ID = ID ( ID , ID , ID == INTEGER ? ID : ID ) ;  
if ( ID == ID )  
{  
ID = ID ;  
ID -> ID ++ ;  
}  

if ( ID ( ID , ID  , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID -> ID = INTEGER ; 
if ( ID ( ID , ID , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
ID * ID ; ID = STRING ; ID = INTEGER ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
if ( ID ( ID , ID  , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
if ( ID ( ID , ID  , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ++ ; 
} 
if ( ! ID ( ID , ID  , ID ) ) break ; 
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
if ( ID == INTEGER ) {  
ID = ( ID * ) ID ( sizeof ( ID ) , INTEGER ) ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
ID -> ID = ID -> ID ;  
ID -> ID = ID ;  
 
} 
} 
if ( ! ID ( ID , ID , ID ) ) break ; 
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
ID = STRING ; ID = INTEGER ; 
if ( ID ( ID , ID  , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
if ( ID ( ID , ID  , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ++ ; 
} 
if ( ! ID ( ID , ID  , ID ) ) break ; 
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
if ( ID == INTEGER ) {  
ID -> ID = ID ;  
} 
if ( ID ( ID , & ID , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID -> ID = ID ;  
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID -> ID = ID ;  
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID -> ID = ID ;  
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID -> ID = ID ;  
} 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
ID = INTEGER ;  
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID == INTEGER ) {  
ID ++ ;  
ID -> ID = ID ;  
ID -> ID = INTEGER ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
 
} 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID , & ID , & ID ) ; 
} 
return ID ; 
} 

static ID * ID ( ID * ID ) 
{ 
ID * ID ; 
ID * ID ; 
char * ID ; 
char * ID ; 
{ 
ID * ID ; int ID ; int ID ; if ( ID == INTEGER ) {  
ID = ID = ( ID * ) ID ( sizeof ( ID ) , INTEGER ) ;  
} 
{  
while ( INTEGER ) 
{ 
ID ( ID , & ID , & ID ) ; 
{ 
if ( ID == INTEGER ) {  
ID = ID ; ID = ID ; ID = ID ;  
} 
{  
while ( INTEGER ) 
{ 
ID ( ID , & ID , & ID ) ; 
{ 
if ( ID ( ID , & ID , ID ) ) 
{ 
{  
while ( INTEGER ) 
{ 
ID ( ID , & ID , & ID ) ; 
{ 
if ( ID ( ID , & ID , ID ) ) 
{ 
ID = ID ( ID ( STRING , ID ) ) ; 
ID = INTEGER ; 
} 
else 
if ( ID ( ID , & ID , ID ) ) 
{ 
ID = ID ( ID ( STRING , ID ) ) ; 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
break ;  
} 
}  
if ( ID ( ID , ID  , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
if ( ID ( ID , & ID , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ;  
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ;  
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ;  
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ;  
} 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
} 
else 
if ( ID ( ID , & ID , ID ) ) 
{ 
ID = ID ( ID ( STRING , ID ) ) ; 
ID = INTEGER ; 
if ( ID == INTEGER ) {  
ID = ID -> ID ; ID = ID ;  
} 
if ( ID ( ID , ID  , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ( ID , ID , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID ( ID , STRING ) ;  
} 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
if ( ID ( ID , & ID , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ( ID , ID  , ID ) ) 
{ 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID ( ID , & ID , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ;  
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ;  
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ;  
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ;  
} 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
} 
else 
if ( ID ( ID , & ID , ID ) ) 
{ 
{  
while ( INTEGER ) 
{ 
ID ( ID , & ID , & ID ) ; 
{ 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ;  
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ;  
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ;  
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ;  
} 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
break ;  
} 
}  
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
break ;  
} 
}  
if ( ID == INTEGER ) {  
ID -> ID = ( ID * ) ID ( sizeof ( ID ) , INTEGER ) ;  
ID = ID -> ID ;  
ID -> ID = ID ;  
ID -> ID = ID -> ID ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
 
} 
} 
if ( ! ID ( ID , & ID , ID ) ) break ; 
} 
}  
if ( ID == INTEGER ) {  
ID = ID -> ID ;  
} 
ID ( ID , & ID , & ID ) ; 
} 
return ID ; 
} 

static char * ID ( ID * ID ) 
{ 
char * ID ; 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
ID ( ID , & ID , & ID ) ; 
} 
return ID ; 
} 

void ID ( ID * ID ) 
{ 
{ 
if ( ID ( ID , & ID , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ( ID , ID , ID ) ) 
{ 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , & ID , ID ) ) 
{ 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
if ( ! ID ( ID , & ID , ID ) ) break ; 
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
if ( ID == INTEGER ) ID ( ID , STRING ) ; 
ID ( ID , & ID , & ID ) ; 
} 
} 

int ID ( int ID , char * ID [ ] ) 
{ 
ID ID , ID = ID ( ) ; 
int 
ID = INTEGER ,  
ID = INTEGER ,  
ID = INTEGER ,  
ID = INTEGER ,  

ID = INTEGER ;  

unsigned long ID = INTEGER ;  

unsigned long ID = INTEGER ;  

char * ID = ID ;  

ID * ID = ( ID * ) ID ( STRING ) ;  
ID * ID ; 

ID ( STRING STRING STRING STRING ) ; 

ID ( STRING ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING ) ; 
ID ( STRING ) ; 
ID ( STRING ) ; 
ID ( STRING ) ; 
ID ( STRING ) ; 

ID = ID ( ID , ID ) ; 

 
for ( ID = INTEGER ; ID [ ID ] != ID ; ID ++ ) 
ID [ ID ] = ID ( ID [ ID ] , STRING ) ; 

if ( ID ) 
{ 
ID [ INTEGER ] = STRING ; 
ID = STRING ; 
ID [ INTEGER ] = ID ;  

} 
if ( ( ID = ID [ INTEGER ] ) == ID ) 
ID ( STRING ) ; 

if ( ID [ INTEGER ] != ID ) 
ID ( ID , STRING ) ; 
ID ( ID , INTEGER , INTEGER , ( int ) ID ) ; 
ID ( INTEGER , INTEGER , INTEGER , ID , ID ) ; 
if ( ID ) 
ID ( ) ; 
ID = ID ( STRING , INTEGER , INTEGER , ID , ID , ID ) ; 
ID = ID ( STRING , INTEGER , INTEGER , ID , ID , ID ) ; 
ID = ID ( STRING , INTEGER , INTEGER , ID , ID , ID ) ; 
ID = ID ( STRING , INTEGER , INTEGER , ID , ID , ID ) ; 
ID ( ) ; 
ID ( ) ; 
ID ( ) ; 
if ( ID ) 
ID ( STRING STRING STRING ) ; 
for ( ID = INTEGER ; ID <= ID ; ID ++ ) 
{ 
ID = ID == ID ; 
ID ( ID || ( ID && ID == ID ) ) ; 

for ( ID = INTEGER ; ( ID = ID [ ID ] ) != ID ; ID ++ ) 
{ 
if ( ID ( ID ) == ID ) 
ID ( STRING ) ; 

ID ( ) ; 
ID ( ) ; 

ID ( ID = ID ( STRING , ID ) ) ;  
if ( ID ( ) != INTEGER ) 
ID ( ID , STRING , ID ( ) == INTEGER ? STRING : STRING , ID ) ;  
ID ( ID , sizeof ( ID ) ) ; 
} 
} 

ID = ID [ INTEGER ] ;  

ID ( ID , ID ) ; 
if ( ID != ID ) 
{ 
ID * ID ; 

if ( * ID == STRING )  
ID = STRING ; 
ID = ID ( ( ID = ID ( ID , STRING ) ) , STRING ) ; 

if ( ID == ID ) 
ID ( ID , STRING , ID ) ; 

if ( ID ) 
ID ( ID , STRING , ID ) ; 

ID ( ID ) ; 
ID ( ID , ID , ID , ID ) ; 
ID ( ID ) ; 
ID ( ID ) ; 
} 

ID ( ID , ID ) ; 
if ( ID ) 
{ 
ID ( INTEGER ) ; 
ID ( ) ; 

} 
ID ( ) ; 
if ( ID ) 
{ 
ID = ID ( ) ; 
ID ( ID , STRING , ( ( double ) ( ID - ID ) ) / ID ) ; 
} 
return ID ; 
} 

 

 

extern void * ID , * ID , * ID ; 

void * ID ;  
extern char * ID ;  


int 
ID = INTEGER ,  
ID = INTEGER ,  
ID = INTEGER ,  
ID = INTEGER ,  
ID = INTEGER ,  
ID ,  
ID = INTEGER ,  
ID = INTEGER ;  

char 
* ID ;  

unsigned ID ;  
unsigned ID = ID ;  

ID * ID ; 

char 
* ID = STRING ,  
* ID = STRING ,  
* ID = ID ,  
* ID = ID ,  
* ID = ID ,  
* ID = ID ,  
* ID = STRING ,  
* ID = STRING ;  

unsigned 
ID = INTEGER ,  
ID = INTEGER ,  
ID = INTEGER ,  
ID = INTEGER ,  
ID = INTEGER ,  
ID = INTEGER ,  
ID = INTEGER ,  
ID = INTEGER ,  
ID = INTEGER ,  
ID = INTEGER ,  
ID = INTEGER ,  
ID ,  
ID = INTEGER ,  
ID = INTEGER ;  

unsigned long ID = INTEGER ;  
unsigned long ID = INTEGER ;  

ID 
* ID = ID ;  

ID 
* ID = ID ;  

ID 
* ID = ID ;  

ID 
* ID = ID ;  

ID 
ID ; 

void ID ( enum ID ID , char * ID , char * ID , char * ID ) 
{ 
ID * ID = ( ID * ) ID ( sizeof ( ID ) ) ; 

ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID = ID ; 
} 

ID * ID ( char * ID , ID ID , ID ID ) 
{ 
ID * ID ; 
void * ID ; 

 
if ( ID == ID ) 
ID = ID ; 
else if ( ID == ID || ID == ID ) 
ID = ID ; 
else ID = ID ; 

if ( ( ID = ( ID * ) ID ( ID , & ID , ID ) ) == ID ) 
{ 
if ( ID == ID && ID ) 
{ 
ID ( ID , STRING , ID ) ; 
ID ( ID ) ; 
} 
else 
{ 
if ( ID == ID ) 
ID ( ID , STRING , ID ) ; 
ID = ( ID * ) ID ( sizeof ( ID ) ) ; 
ID -> ID = ID ; 
ID ( ID , ID ) ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID -> ID = INTEGER ;  
ID -> ID = INTEGER ; 
ID ( & ID -> ID , ID ) ; 
ID -> ID = INTEGER ; 
ID -> ID = INTEGER ; 
switch ( ID ) 
{ 
case ID : 
ID -> ID = STRING ; 
break ; 
case ID : 
ID -> ID = STRING ; 
break ; 
case ID : 
case ID : 
ID -> ID = STRING ; 
ID -> ID = INTEGER ; 
break ; 
default : 
ID -> ID = STRING ; 
break ; 
} 
} 
} 
else 
if ( ID == ID ) 
ID ( ID , STRING , ID ) ; 

return ID ; 
} 

ID * ID ( char * ID , char * ID , int ID ) 
{ 
ID * ID ; 

ID ( ID ) ; 
ID ( ID ) ; 
ID = ID ( ID , ID , ID ) ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = STRING ; 
ID -> ID = INTEGER ; 
return ID ; 
} 


void ID ( void ) 
{ 
ID = ID ( ID , STRING ) ; 
ID = ID ( ID , STRING ) ; 
ID ( & ID , ID , ID , ID , ID ) ; 

ID ( ID , ID , ID , STRING ) ; 
ID ( ID , STRING , STRING , STRING ) ; 
ID ( ID , STRING , STRING , STRING ) ; 
ID ( ID , STRING , STRING , STRING ) ; 
ID ( ID , STRING , STRING , STRING ) ; 
ID ( ID , STRING , STRING , STRING ) ; 
ID ( ID , STRING , STRING , STRING ) ; 
ID ( ID , STRING , STRING , STRING ) ; 
ID ( ID , STRING , STRING , STRING ) ; 
ID ( ID , STRING , STRING , STRING ) ; 
ID ( ID , STRING , STRING , STRING ) ; 

ID ( STRING , ID , ID ) -> ID = ID ;  
ID ( STRING , ID , ID ) -> ID = ID ; 
ID ( STRING , ID , ID ) -> ID = ID ; 
ID ( ID , ID , ID ) -> ID = ID ; 
} 

static void ID ( void * ID ) 
{ 
ID * ID = ( ID * ) ID ( ID ) ; 

while ( ID != ID ) 
{ 
if ( ID -> ID == ID || ID -> ID == ID ) 
{ 
ID -> ID = ID -> ID ; 
ID -> ID = ID ++ ; 
} 
ID = ( ID * ) ID ( ID ) ; 
} 

 
ID = ( ID * ) ID ( ID ) ; 
while ( ID != ID ) 
{ 
if ( ID -> ID == ID || ID -> ID == ID || 
ID -> ID == ID || ID -> ID == ID || 
ID -> ID == ID ) 
{ 
ID ( & ID -> ID , ID -> ID ) ; 
ID -> ID = ID ( & ID -> ID ) ; 
ID ( & ID -> ID , ID ) ; 
ID -> ID = ID ( & ID -> ID ) ; 

ID -> ID = INTEGER ; 
} 
else if ( ID -> ID == ID && ID -> ID != ID ) 
{ 
ID ( & ID -> ID , ID -> ID -> ID ) ; 
ID -> ID = ID ( & ID -> ID ) ; 
} 
ID = ( ID * ) ID ( ID ) ; 
} 
} 

static void ID ( void * ID ) 
{ 
ID * ID = ( ID * ) ID ( ID ) ; 
char * ID = STRING ;  
int ID = INTEGER ; 

if ( ID ) 
ID ( ID , STRING ) ; 

while ( ID != ID )  
{ 
if ( ID -> ID == ID || ID -> ID == ID ) 
{ 
char * ID = ID , 
* ID = ID -> ID ; 

if ( ! ID ( ID ) )  
{ 
 
while ( * ID == * ID && * ID != INTEGER )  
{ 
ID ++ ; 
ID ++ ; 
} 

ID ++ ;  

 
 
while ( * ( ID ) != INTEGER )  
{ 
 
char * ID = ID -> ID , 
* ID = ID ;  

while ( ID != ID ) 
ID ( * ID ++ ) ;  
ID ( INTEGER ) ;  

if ( ID ) 
ID ( ID , STRING , ID ) ; 

ID = INTEGER ; 

ID ( ID , ID , ID ) ; 

ID ++ ; 
} 
} 

ID = ID -> ID ; 
} 
ID = ( ID * ) ID ( ID ) ; 
} 
if ( ID && ! ID ) 
ID ( ID , STRING ) ; 

} 

void ID ( char * ID , int ID ) 
{ 
void 
* ID = ID ( ID ) , 
* ID = ID ( ID ) ; 

ID * ID = ( ID * ) ID ( sizeof ( ID ) ) ; 

ID -> ID = STRING ; 
ID ( ID , ID ) ; 

ID ( ID , ID ) ;  
ID ( ID ) ;  
ID ( ID , ID ) ;  
ID ( ID ) ;  
ID ( ID ) ;  
ID ( ID ) ;  

ID ( ID , ID ) ;  
ID ( ID ) ;  

if ( ID )  
ID ( ID ) ; 

if ( ID ( ) > INTEGER ) 
{ 
if ( ID ) 
ID ( ID , STRING ) ; 
else 
ID ( ID , STRING ) ; 
} 

ID ( ID ( ID , STRING ) ) ;  

ID ( ID ( ID , STRING ) , ID ) ;  

if ( ID )  
ID ( ) ; 
} 

void * ID ( char * ID ) 
{ 
ID * ID ; 

ID ( ID ) ; 
ID = ID ( ID , ID , ID ) ; 
ID -> ID ++ ;  

return ID ; 
} 

 
 
 
 
 
 
 
 
 
 
 
 
 

static int ID ;  

void ID ( char * ID ) 
{ 
if ( ID ( ID , ID ) == INTEGER ) 
ID = INTEGER ;  
} 

void ID ( char * ID ) 
{ 
if ( ID == ID ) 
return ; 

if ( * ID == INTEGER ) 
ID ( ID , STRING ) ; 
 
{ 
int ID = INTEGER ; 

while ( * ID != INTEGER ) 
{ 
ID |= ! ID ( * ID ) ; 
ID ++ ; 
} 

if ( ID ) 
ID ( ID , STRING ) ; 
} 
} 

void ID ( char * ID ) 
{ 
ID ( ID ) ;  
if ( * ( ID + INTEGER ) != INTEGER ) 
ID ( ID , STRING ) ; 
} 

void ID ( char * ID ) 
{ 
ID ( ID ) ;  
if ( ! ( * ( ID + INTEGER ) == INTEGER || * ( ID + INTEGER ) == INTEGER ) ) 
ID ( ID , STRING ) ; 
} 

void ID ( char * ID ) 
{ 
if ( ( ID ( STRING , ID , INTEGER ) == INTEGER ) || 
( ID ( STRING , ID , INTEGER ) == INTEGER ) || 
( ID ( STRING , ID , INTEGER ) == INTEGER ) || 
( ID ( STRING , ID , INTEGER ) == INTEGER ) || 
( ID ( STRING , ID , INTEGER ) == INTEGER ) || 
( ID ( STRING , ID , INTEGER ) == INTEGER ) || 
( ID ( STRING , ID , INTEGER ) == INTEGER ) || 
( ID ( STRING , ID , INTEGER ) == INTEGER ) || 
( ID ( STRING , ID , INTEGER ) == INTEGER ) ) 
ID ( ID , STRING , ID ) ; 
} 

static void ID ( void * ID ) 
{ 
unsigned ID = INTEGER , 
ID = INTEGER , 
ID = INTEGER ; 

ID * ID = ( ID * ) ID ( ID ) ; 

while ( ID != ID ) 
{ 
if ( ID -> ID == ID ) 
ID ++ ; 
else if ( ID -> ID == ID ) 
ID ++ ; 
else 
ID ++ ; 

ID = ( ID * ) ID ( ID ) ; 
} 

if ( ID ) 
ID ( ID , STRING , 
ID , ID - ID + INTEGER , ID , ID ) ; 
} 

static void ID ( ID * ID ) 
{ 
if ( ID -> ID )  
{ 
ID ( ID , STRING , ID -> ID ) ;  
ID -> ID = INTEGER ; 
return ; 
} 

if ( ! ID -> ID )  
{ 
ID * ID = ID -> ID ;  

ID -> ID = INTEGER ;  

if ( ID -> ID == ID )  
{ 
ID -> ID = INTEGER ;  
while ( ID != ID && ID -> ID )  
{ 
if ( ! ID -> ID -> ID )  
ID ( ID -> ID ) ; 

ID ( & ID -> ID , & ID -> ID -> ID ) ;  
ID -> ID = ID -> ID -> ID ;  

ID = ID -> ID ; 
} 
} 
else 
while ( ID != ID )  
{ 
if ( ! ID -> ID -> ID )  
ID ( ID -> ID ) ; 

ID ( & ID -> ID , & ID -> ID -> ID ) ;  
ID -> ID |= ID -> ID -> ID ;  
ID = ID -> ID ; 
} 
ID -> ID = INTEGER ;  
ID -> ID = INTEGER ;  
 
ID -> ID = ID ( & ID -> ID ) ; 
} 
} 

 
static void ID ( ID * ID ) 
{ 
ID * ID = ID -> ID ;  

while ( ID != ID )  
{ 
ID * ID = ID ;  
unsigned ID = ID -> ID -> ID ; 

do  
{ 
ID = ID -> ID ; 
if ( ID == ID )  
ID ( & ID -> ID -> ID , & ID -> ID ) ; 
else 
ID ( & ID -> ID -> ID , & ID -> ID -> ID ) ; 
} 
while ( ID != ID && ID -> ID -> ID ) ; 

 
ID |= ( ( ID -> ID -> ID = 
ID ( & ID -> ID -> ID ) 
) != ID ) ; 

ID = ID -> ID ;  
} 
} 

 
static void ID ( ID * ID ) 
{ 
ID * ID = ID -> ID ;  

while ( ID != ID ) 
{ 
unsigned ID = ID -> ID -> ID ; 

ID ( & ID -> ID -> ID , & ID -> ID ) ; 

ID |= ( ( ID -> ID -> ID = 
ID ( & ID -> ID -> ID ) 
) != ID ) ; 
ID = ID -> ID ; 
} 
} 

static void ID ( void * ID ) 
{ 
ID * ID ; 
unsigned ID = INTEGER ; 

do 
{ 
ID ++ ; 
ID = INTEGER ; 
ID = ( ID * ) ID ( ID ) ; 
while ( ID != ID ) 
{ 
if ( ID -> ID == ID )  
ID ( ID ) ; 
else 
ID ( ID ) ; 
ID = ( ID * ) ID ( ID ) ; 
} 
} 
while ( ID ) ; 

if ( ID ) 
ID ( ID , STRING , ID , ID == INTEGER ? STRING : STRING ) ; 

} 

static int ID ( char * ID ) 
{ 
ID * ID = ( ID * ) ID ( ID , & ID , ID ) ; 

if ( ID != ID ) 
{ 
if ( ID -> ID == ID ) 
{ 
ID ( ID , STRING , ID ) ; 
return INTEGER ; 
} 
} 
return INTEGER ; 
} 

static int ID ( void ) 
{ 
int ID = INTEGER , 
ID = INTEGER ; 
char * ID [ ] = { ID , ID } ; 

while ( ID [ ID ] != ID ) 
ID |= ID ( ID [ ID ++ ] ) ; 

return ID ; 
} 

 
static int ID ( void * ID ) 
{ 
int ID = INTEGER ; 
ID * ID = ( ID * ) ID ( ID ) ; 

while ( ID != ID ) 
{ 
ID * ID = ID -> ID ; 
int ID = ID -> ID , 
ID = INTEGER ; 

if ( ID == ID && ID -> ID == INTEGER && ! ID -> ID ) 
ID ( ID , STRING , ID -> ID ) ; 

if ( ID == ID && ID == ID ) 
{ 
ID ( ID , STRING , ID -> ID ) ; 
ID = INTEGER ; 
} 

if ( ID == ID )  
{ 
while ( ID != ID ) 
{ 
if ( ID -> ID -> ID == ID )  
if ( ID -> ID == ID )  
ID -> ID -> ID = INTEGER ; 
else if ( ID -> ID -> ID -> ID == ID )  
ID -> ID -> ID -> ID = INTEGER ;  
else 
ID -> ID -> ID = INTEGER ;  

if ( ID -> ID -> ID != ID ) 
ID = INTEGER ; 
ID = ID -> ID ; 
} 
} 
else 
ID = INTEGER ; 

if ( ID ) 
{ 
if ( ID -> ID == ID ) 
{ 
ID ( ID , STRING , ID -> ID ) ; 
ID -> ID = INTEGER ; 
} 
else 
{ 
ID -> ID = INTEGER ; 
} 
ID = INTEGER ; 
} 
ID = ( ID * ) ID ( ID ) ; 
} 

 
ID = ( ID * ) ID ( ID ) ; 

while ( ID != ID ) 
{ 
if ( ID -> ID == ID && ID -> ID != ID ) 
if ( ID -> ID -> ID == ID && ID -> ID -> ID -> ID ) 
ID -> ID = INTEGER ; 
ID = ( ID * ) ID ( ID ) ; 
} 
return ID ; 
} 

static void ID ( void * ID ) 
{ 
ID * ID = ( ID * ) ID ( ID ) ; 

while ( ID != ID ) 
{ 
ID ( ID ) ; 
ID = ( ID * ) ID ( ID ) ; 
} 
} 

 
static int ID ( void * ID ) 
{ 
int ID = INTEGER ; 
ID * ID = ( ID * ) ID ( ID ) ; 

while ( ID != ID ) 
{ 
if ( ID ( & ID , ID -> ID ) && ID -> ID != ID ) 
{ 
ID * ID = ID -> ID ; 

while ( ID != ID ) 
{ 

if ( ID -> ID == INTEGER && ID -> ID -> ID ) 
{ 
ID ( ID , STRING , ID -> ID ) ; 
ID ( STRING , ID -> ID -> ID ) ; 
ID ( ID -> ID , INTEGER ) ; 
ID ( STRING ) ; 
ID = INTEGER ; 
ID -> ID = INTEGER ; 
ID -> ID -> ID = INTEGER ; 
} 
ID = ID -> ID ; 
} 
} 
ID = ( ID * ) ID ( ID ) ; 
} 
return ID ; 
} 
static int ID ( void * ID ) 
{ 
int ID = INTEGER ; 
ID ID = ID ; 

ID * ID = ( ID * ) ID ( ID ) ; 

while ( ID != ID ) 
{ 
if ( ID ( & ID , ID -> ID ) && ID -> ID != ID ) 
{ 
ID * ID = ID -> ID ; 

while ( ID != ID ) 
{ 
ID * ID = ID -> ID ; 

while ( ID != ID ) 
{ 
 
if ( ID -> ID -> ID && ID -> ID -> ID ) 
{ 
ID ( ID , STRING , ID -> ID ) ; 
ID ( STRING , ID -> ID -> ID ) ; 
ID ( ID -> ID , INTEGER ) ; 
ID ( STRING , ID -> ID -> ID ) ; 
ID ( ID -> ID , INTEGER ) ; 
ID ( STRING ) ; 
ID -> ID -> ID = INTEGER ; 
ID -> ID -> ID = INTEGER ; 
ID = INTEGER ; 
} 

ID ( & ID , & ID -> ID -> ID ) ; 
ID ( & ID , & ID -> ID -> ID ) ; 

if ( ID ( & ID ) != INTEGER ) 
{ 
ID ( ID , STRING , ID -> ID ) ; 
ID ( STRING , ID -> ID -> ID ) ; 
ID ( ID -> ID , INTEGER ) ; 
ID ( STRING , ID -> ID -> ID ) ; 
ID ( ID -> ID , INTEGER ) ; 
ID ( STRING ) ; 
ID ( & ID , ID , INTEGER ) ; 
ID ( STRING ) ; 
ID -> ID -> ID = INTEGER ; 
ID -> ID -> ID = INTEGER ; 
ID = INTEGER ; 
} 
ID = ID -> ID ; 
} 
ID = ID -> ID ; 
} 
} 
ID = ( ID * ) ID ( ID ) ; 
} 
return ID ; 
} 

static int ID ( void * ID ) 
{ 
int ID = INTEGER ; 
ID * ID = ( ID * ) ID ( ID ) ; 
ID ID = ID ; 

while ( ID != ID ) 
{ 
if ( ID -> ID && ( ID -> ID != ID ) ) 
{ 
ID ( & ID , & ID -> ID ) ; 
ID ( & ID , & ID -> ID ) ; 

if ( ID ( & ID ) != INTEGER ) 
{ 
ID ( ID , STRING , ID -> ID ) ; 
ID ( ID , INTEGER ) ; 
ID ( STRING ) ; 

ID ( & ID , ID , INTEGER ) ; 
ID ( STRING ) ; 
ID -> ID = INTEGER ; 
ID = INTEGER ; 
} 
} 
ID = ( ID * ) ID ( ID ) ; 
} 
return ID ; 
} 

static void ID ( void * ID ) 
{ 
ID * ID = ( ID * ) ID ( ID ) ; 

while ( ID != ID ) 
{ 
if ( ID -> ID == ID && ID -> ID != INTEGER && ID -> ID == ID ) 
{ 
ID ( & ID -> ID , & ID -> ID ) ; 
ID -> ID = ID ( & ID -> ID ) ; 
} 
ID = ( ID * ) ID ( ID ) ; 
} 
} 

int ID ( void * ID ) 
{ 
int ID = INTEGER ; 

 
if ( ID ) 
ID ( ID , STRING ) ; 
ID |= ID ( ID ) ; 

 
ID ( ID ) ; 

 
if ( ID -> ID != ID ) 
ID ( ID , STRING , 
ID -> ID == ID ? STRING : 
ID -> ID == ID ? STRING : STRING , 
ID -> ID ) ; 

 
if ( ID ) 
ID ( ID , STRING ) ; 
ID ( ID ) ; 

 
if ( ID ) 
ID ( ID , STRING ) ; 
ID ( ID ) ; 

 
if ( ID ) 
ID ( ID , STRING ) ; 
ID |= ID ( ) ; 

 
if ( ID ) 
ID ( ID , STRING ) ; 
ID |= ID ( ID ) ; 

 
if ( ID ) 
ID ( ID , STRING ) ; 
ID |= ID ( ID ) ; 

 
if ( ID ) 
ID ( ID , STRING ) ; 
ID |= ID ( ID ) ; 

 
if ( ID ) 
ID ( ID , STRING ) ; 
ID ( ID ) ; 
 
ID ( ID ) ; 

return ID ; 
} 


extern void * ID ; 
extern char * ID ;  

char * ID = ID ; 
char * ID = ID ; 

static unsigned ID = INTEGER ;  

static void ID ( ID * ID ) 
{ 
if ( ID -> ID != ID ) 
ID ( ID -> ID ) ; 
ID ( STRING , ID -> ID ) ; 
} 

static void ID ( void ) 
{ 
unsigned ID ; 

for ( ID = INTEGER ; ID < ID ; ID ++ ) 
ID ( STRING ) ; 
} 

 

static void ID ( char * ID , ID * ID , char * ID ) 
{ 
ID ( STRING ) ; 

if ( ID ( ID ) > INTEGER ) 
ID ( STRING , 
ID == INTEGER ? STRING : STRING , 
ID == INTEGER ? STRING : ID , 
ID == INTEGER ? STRING : STRING , 
ID 
) ; 
else 
{ 
ID ( STRING , 
ID == INTEGER ? STRING : STRING , 
ID == INTEGER ? STRING : ID , 
ID == INTEGER ? STRING : STRING ) ; 
ID ( ID , ID , INTEGER ) ; 
} 

if ( ID == ID ) 
ID ( STRING ) ; 
else 
ID ( STRING , ID ) ; 
} 

static void ID ( char * ID ) 
{ 
while ( * ID != INTEGER ) 
{ 
if ( * ID == STRING || * ID == STRING || * ID == STRING ) 
ID ( STRING ) ; 
ID ( STRING , * ID ++ ) ; 
} 
} 

static void ID ( ID * ID ) 
{ 
if ( ID -> ID != ID ) 
ID ( ID -> ID ) ; 
switch ( ID -> ID ) 
{ 
case ID : 
ID ( STRING , ID -> ID , ID -> ID , ID -> ID ) ; 
break ; 
case ID : 
ID ( STRING , ID -> ID , ID -> ID , ID -> ID ) ; 
break ; 
case ID : 
ID ( STRING , ID -> ID , ID -> ID , ID -> ID ) ; 
break ; 
case ID : 
ID ( STRING , ID -> ID ) ; 
break ; 
} 
} 

void ID ( void * ID ) 
{ 
char * ID , 
* ID , 
* ID , 
* ID , 
* ID , 
* ID , 
* ID , 
* ID , 
* ID , 
* ID , 
* ID ; 

ID * ID = ( ID * ) ID ( ID ) ; 

ID = ID ( STRING ) ; 
ID ( STRING ) ; 
ID ( STRING ) ; 
ID ( STRING ) ; 
ID ( STRING ) ; 
ID ( STRING ) ; 
ID ( STRING ) ; 
ID ( STRING ) ; 
ID ( STRING ) ; 
ID ( STRING ) ; 
ID ( STRING ) ; 
ID ( STRING ) ; 
ID ( STRING ) ; 
ID ( STRING ) ; 
ID ( 
) ; 
ID ( 
) ; 

while ( ID != ID ) 
{ 
if ( ID -> ID == ID || ID -> ID == ID ) 
{ 
char * ID = ID -> ID ; 

ID -> ID = ID ( STRING ) ;  
while ( * ID != INTEGER )  
{ 
if ( * ID == STRING || * ID == STRING || * ID == STRING ) 
ID ( STRING ) ; 
ID ( * ID ++ ) ; 
} 
ID ( STRING ) ;  
} 
ID = ( ID * ) ID ( ID ) ; 
} 

ID = ( ID * ) ID ( ID ) ; 

ID = ID = ID ( STRING ) ; 
ID ( STRING ) ; 
ID ( STRING ) ; 
ID ( STRING ) ; 
ID = ID ( STRING ) ; 
ID = ID ( STRING ) ; 
ID = ID ( STRING ) ; 
ID = ID ( STRING ) ; 
ID = ID ( STRING ) ; 
ID = ID ( STRING ) ; 
ID = ID ( STRING ) ; 
ID = ID ( STRING ) ; 
ID = ID ( STRING ) ; 
ID = ID ( STRING ) ; 
ID ( STRING ) ; 
ID ( STRING ) ; 

while ( ID != ID ) 
{ 
if ( ID -> ID == ID || ID -> ID == ID ) 
{ 
ID -> ID = ID ( STRING ) ; 

if ( ID ( ID -> ID ) ) 
ID ( ID -> ID ) ; 
else 
{ 
char * ID = ID -> ID ; 

while ( * ID != INTEGER ) 
ID ( * ID ++ ) ; 

ID = ID -> ID ; 

ID ( STRING ) ; 
if ( ID ( ID , STRING ) == INTEGER )  
{ 
ID ( STRING ) ; 
ID ( STRING ) ; 
ID ( STRING ) ; 
} 
else if ( ID ( ID , STRING ) == INTEGER )  
{ 
ID ( STRING ) ; 
ID ( STRING ) ; 
ID ( STRING ) ; 
} 
else while ( * ID != INTEGER ) 
ID ( * ID ++ ) ; 

ID ( STRING ) ; 
} 
if ( ID -> ID == ID ) 
{ 
switch ( ID -> ID ) 
{ 
case ID : 
ID -> ID = ID ; 
break ; 
case ID : 
ID -> ID = ID ; 
break ; 
case ID : 
ID -> ID = ID ; 
break ; 
case ID : 
ID -> ID = ID ; 
break ; 
case ID : 
ID -> ID = ID ; 
break ; 
case ID : 
ID -> ID = ID ; 
break ; 
case ID : 
ID -> ID = ID ; 
break ; 
case ID : 
ID -> ID = ID ; 
break ; 
case ID : 
ID -> ID = ID ; 
break ; 
case ID : 
ID -> ID = ID ; 
break ; 
} 
} 
else 
ID -> ID = ID ; 
} 
ID = ( ID * ) ID ( ID ) ; 
} 
} 

static void ID ( ID * ID , int ID , int ID ) 
{ 
if ( ID != ID ) 
{ 
unsigned ID ; 

ID ( ID -> ID , INTEGER , ID ) ; 
ID ( STRING , ID ? ID -> ID : STRING ) ; 

if ( ID ) 
for ( ID = INTEGER ; ID < ID -> ID ; ID ++ ) 
ID ( STRING ) ; 

ID ( STRING , ID ? STRING : STRING ) ; 
switch ( ID -> ID ) 
{ 
case ID : 
ID ( STRING , ID -> ID ) ; 
break ; 
case ID : 
ID ( STRING , ID -> ID ) ; 
break ; 
case ID : 
ID ( STRING , ID -> ID ) ; 
break ; 
case ID : 
ID ( STRING , ID -> ID ) ; 
break ; 
} 
ID ( STRING , ID ? STRING : STRING ) ; 
} 
} 

static void ID ( char * ID , ID * ID , int ID , int ID ) 
{ 
ID ( STRING ) ; 

 
if ( ID ) 
{ 
if ( ID ) 
ID ( STRING ) ; 
else 
{ 
if ( ID == ID ) 
ID ( STRING ) ; 
else 
ID ( STRING , ID ? STRING : STRING , ID ? STRING : STRING , ID ) ; 
} 

if ( ID != ID ) 
ID ( STRING ) ;  
} 

if ( ID == ID && ID && ! ID ) 
ID ( STRING ) ; 
else 
ID ( ID , INTEGER , ID ) ; 

ID ( STRING ) ; 
} 

static void ID ( ID * ID ) 
{ 
switch ( ID -> ID ) 
{ 
case ID : 
ID ( STRING , ID -> ID ) ; 
break ; 
case ID : 
case ID : 
ID ( STRING , ID -> ID ) ; 
break ; 
case ID : 
case ID : 
case ID : 
ID ( STRING , ID -> ID ) ; 
break ; 
default : 
ID ( STRING , ID -> ID ) ; 
break ; 
} 
} 

 
static void ID ( ID * ID , int ID ) ; 
static void ID ( ID * ID , int ID ) ; 

void ID ( ID * ID , int ID ) 
{ 
switch ( ID -> ID ) 
{ 
case ID : 
case ID : 
case ID : 
case ID : 
ID ( STRING , ID -> ID ) ; 
break ; 
case ID : 
ID ( STRING , ID -> ID ) ; 
break ; 
case ID : 
 
break ; 
case ID : 
ID ( STRING , ID -> ID ) ; 
break ; 
case ID : 
ID ( ID , ID ) ; 
break ; 
case ID : 
if ( ID ) 
{ 
 
if ( ID -> ID == ID )  
{ 
if ( ID -> ID == INTEGER && ID -> ID == INTEGER ) 
{ 
ID ( STRING ) ; 
ID ( ID , ID ) ; 
ID ( STRING ) ; 
} 
else if ( ID -> ID == INTEGER && ID -> ID == INTEGER ) 
{ 
ID ( STRING ) ; 
ID ( ID , ID ) ; 
ID ( STRING ) ; 
} 
else if ( ID -> ID == INTEGER && ID -> ID == INTEGER ) 
{ 
ID ( STRING ) ; 
ID ( ID , ID ) ; 
ID ( STRING ) ; 
} 
else if ( ID -> ID == INTEGER && ID -> ID == INTEGER ) 
{ 
ID ( STRING ) ; 
ID ( ID , ID ) ; 
ID ( STRING ) ; 
} 
} 
else 
{  
ID ( STRING ) ; 
ID ( ID , ID ) ; 
ID ( STRING , ID -> ID , ID -> ID ) ; 
if ( ID -> ID != ID ) 
ID ( STRING , ID -> ID -> ID ) ; 
else 
ID ( STRING ) ; 
} 
} 
else 
ID ( STRING , ID -> ID ) ; 
break ; 
default : 
ID ( ID , STRING ) ; 
} 
} 

static void ID ( ID * ID , int ID ) 
{ 
ID * ID = ID -> ID ; 

while ( ID != ID ) 
{ 
ID ( ID -> ID , ID ) ; 
ID = ID -> ID ; 
} 
} 

static void ID ( ID * ID , int ID ) 
{ 
ID * ID = ID -> ID ; 

while ( ID != ID ) 
{ 
ID ( ID -> ID , ID ) ; 

if ( ( ID = ID -> ID ) != ID ) 
ID ( STRING ) ; 
} 
} 

void ID ( char * ID ) 
{ 
ID * ID ; 

ID * ID = ID ; 
ID * ID = ( ID * ) ID ( ID ( ID ) ) ; 
unsigned ID = INTEGER ; 
int ID = INTEGER ; 
char * ID = ID ( ID ( ID ) ) ; 

if ( ID ) 
ID ( ID , STRING , ID ) ; 

if ( * ID == STRING ) 
ID = ID ; 
else if ( ( ID = ID ( ID , STRING ) ) == ID ) 
ID ( ID , STRING , ID ) ; 

ID ( ID ) ; 

ID ( 
STRING 
STRING 
STRING ) ; 

ID ( ) ; 

ID ( 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING , 
ID ( ID , STRING ) , 
ID , ID 
) ; 

ID ( STRING , ID ) ; 

ID ( STRING ) ; 
ID ( ) ; 
ID ( STRING ) ; 

 
ID ( STRING ) ; 
while ( ID != ID ) 
{ 
if ( ID -> ID == ID || ID -> ID == ID ) 
{ 
ID ( STRING ) ; 
if ( ID ++ % INTEGER == INTEGER ) 
ID ( STRING ) ; 
ID ( ID ) ; 
if ( ID ) 
{ 
ID ( STRING ) ; 
ID = INTEGER ; 
} 
} 
ID = ( ID * ) ID ( ID ) ; 
} 
ID ( STRING ) ; 

 
ID ( STRING 
STRING 
STRING , 
ID , 
ID 
) ; 

 
ID ( STRING ) ; 
while ( ID != ID ) 
{ 
ID ( STRING , 
ID -> ID , ID -> ID , ID -> ID ) ; 
ID ( STRING , ID -> ID ) ; 
ID ( STRING , ID -> ID , ID -> ID ) ; 
ID ( STRING , ID -> ID , ID -> ID ) ; 
ID = ID -> ID ; 
} 

 
ID ( STRING ) ; 
ID ( STRING , ID -> ID ) ; 
for ( ID = INTEGER ; ID < ID -> ID ; ID ++ ) 
ID ( STRING ) ; 
ID ( STRING , ID -> ID ) ; 

ID ( ID , ID -> ID , INTEGER , INTEGER ) ; 

ID ( STRING ) ; 

ID ( STRING , 
ID ( ID , STRING ) ) ; 

ID ( ID ) ; 
} 

static void ID ( ID * ID , ID * ID ) ; 
static void ID ( ID * ID , ID * ID ) ; 

static void ID ( ID * ID , ID * ID , int ID , char * ID ) 
{ 
if ( ID -> ID == INTEGER )  
{ 
ID ( STRING ) ; 
ID ( ID -> ID , & ID -> ID , ID ) ; 
ID ( STRING ) ; 
ID ( ) ; 
} 

ID ( STRING , ID -> ID ) ; 

if ( ID -> ID ) 
{ 
ID ( ) ; 
ID ( STRING ) ; 
} 

ID ++ ; 

 
if ( ! ( ( ID -> ID == INTEGER || ID -> ID == INTEGER ) && ( ID -> ID == INTEGER || ID -> ID == INTEGER ) ) ) 
{ 
ID ( ) ; 
ID ( STRING ) ; 
} 

ID ( ) ; 
ID ( STRING ) ; 

ID ( ) ; 
ID ( STRING ) ; 
ID ++ ; 

 
if ( ID -> ID != INTEGER && ! ID -> ID ) 
{ 
ID ( ) ; 
ID ( ID -> ID , & ID -> ID , ID -> ID ) ; 
ID ( STRING ) ; 
} 

ID ( ) ; 
ID ( STRING ) ; 
ID ++ ; 

ID ( ID , ID ) ; 

ID ( ) ; 
ID ( STRING ) ; 
ID -- ; 

if ( ! ( ( ID -> ID == INTEGER || ID -> ID == INTEGER ) && ( ID -> ID == INTEGER || ID -> ID == INTEGER ) ) ) 
{ 
ID ( ) ; 
ID ( STRING ) ; 
} 

if ( ID -> ID > INTEGER )  
{ 
ID ( ) ; 
ID ( STRING , ID -> ID ) ; 
} 

if ( ID -> ID != ID ) 
{ 
ID ( ) ; 
ID ( STRING , ID -> ID -> ID ) ; 

if ( ID ) 
{ 
if ( ID -> ID == ID ) 
{ 
 
ID ( STRING ) ; 
ID ( ) ; 
} 
else if ( ID -> ID == ID ) 
{ 
 
ID ( STRING ) ; 
ID ( ) ; 
} 
} 

ID ( ) ; 
ID ( STRING ) ;  
} 
else if ( ID -> ID != INTEGER ) 
{ 
ID ( ) ; 
ID ( STRING ) ; 
ID ( ID -> ID , & ID -> ID , ID ) ; 
ID ( STRING ) ; 
} 

if ( ID -> ID == INTEGER ) 
{ 
ID ( ) ; 
ID ( STRING ) ; 
} 

ID -- ; 
ID ( ) ; 
ID ( STRING ) ; 

if ( ID -> ID > INTEGER )  
{ 
ID ( ) ; 
ID ( STRING , ID -> ID ) ; 
ID ( STRING ) ; 
} 

ID -- ; 
ID ( ) ; 
ID ( STRING , ID -> ID ) ; 

if ( ID -> ID == INTEGER && ( ID || ID != ID ) ) 
{ 
ID ( ) ; 
ID ( STRING ) ; 
ID ( ) ; 
ID ( STRING ) ; 
ID ++ ; 
ID ( ) ; 
ID ( STRING , ID -> ID ) ; 
if ( ID ) 
{ 
 
if ( ID == ID ) 
{ 
 
ID ( ) ; 
if ( ID ) 
ID ( STRING , ID -> ID + INTEGER ) ; 
else 
ID ( STRING ) ; 
} 
else if ( ID == ID ) 
{ 
 
ID ( ) ; 
if ( ID ) 
ID ( STRING , ID -> ID + INTEGER ) ; 
else 
ID ( STRING ) ; 
} 
} 

 
if ( ! ID && ID != ID )  
{ 
while ( * ID != STRING ) 
{ 
if ( * ID == STRING ) 
ID ( STRING ) ; 
else 
ID ( STRING , * ID ) ; 
ID ++ ; 
} 

ID ( STRING ) ;  
} 

ID -- ; 
ID ( ) ; 
ID ( STRING ) ; 
} 
} 

static void ID ( ID * ID , ID * ID , char * ID , ID * ID , int ID , int ID , char * ID ) 
{ 
if ( ID == ID ) 
ID = ID -> ID ; 

if ( ! ( ID -> ID == ID && ID -> ID ) ) 
ID ( ) ;  

switch ( ID -> ID ) 
{ 
case ID : 
case ID : 
case ID : 
case ID : 
case ID : 
if ( ID ) 
{ 
if ( ID == ID ) 
{ 
 
ID ( STRING ) ; 
ID ( ) ; 
} 
else if ( ID == ID ) 
{ 
 
ID ( STRING ) ; 
ID ( ) ; 
} 
else if ( ID == ID ) 
{ 
 
ID ( STRING ) ; 
ID ( ) ; 
} 
} 
ID ( STRING , 
ID == INTEGER ? STRING : STRING , 
ID == INTEGER ? STRING : ID -> ID , 
ID == INTEGER ? STRING : STRING ) ; 

ID ( ID ) ; 
ID ( STRING , ID -> ID ) ; 
ID ( ) ; 
if ( ID != ID && ! ID )  
{ 
ID ( STRING , ID , 
ID -> ID == ID ? STRING : 
ID -> ID == ID ? STRING : STRING ) ; 
ID ( ) ; 
} 
ID ( STRING ) ; 
break ; 
case ID : 
if ( ! ID )  
{ 
char * ID = ID -> ID ; 

if ( ID -> ID != INTEGER ) 
ID ( STRING , ID -> ID ) ; 

while ( * ID != STRING ) 
{ 
if ( * ID == STRING ) 
ID ( STRING ) ; 
else 
if ( ID ( * ID ) ) 
ID ( STRING , * ID ) ; 
ID ++ ; 
} 

if ( ID -> ID != INTEGER ) 
ID ( STRING ) ; 

if ( ID -> ID == ID && ID -> ID ) 
ID ( STRING ) ;  
} 
break ; 
case ID : 
if ( ID && ID == ID ) 
ID ( STRING , ID -> ID ) ; 
if ( ID != ID && ! ID )  
ID ( STRING , ID ) ; 
ID ( STRING , ID -> ID ) ; 
if ( ! ( ID -> ID && ID == ID ) ) 
ID ( ID == ID ? ID -> ID : ( char * ) ID , ID , INTEGER , INTEGER ) ; 
ID ( STRING ) ; 
break ; 
case ID : 
ID ( ID , STRING ) ; 
break ; 
case ID : 
ID ( ID , ID , ID , ID ) ; 
break ; 
default : 
ID ( ID , STRING ) ; 
} 
} 

static void ID ( ID * ID , ID * ID ) 
{ 
ID * ID = ID -> ID ; 

while ( ID != ID ) 
{ 
ID ( ID -> ID , ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID ) ; 
ID = ID -> ID ; 
} 
} 

static void ID ( ID * ID , ID * ID ) 
{ 
ID * ID = ID -> ID ; 

if ( ID -> ID == ID )  
ID ( ID -> ID , ID ) ; 
else 
{ 
while ( ID != ID ) 
{ 
if ( ID -> ID -> ID != ID ) 
ID ( ID , STRING ) ; 

ID ( ) ; 

ID ( STRING ) ; 
ID ( ID -> ID -> ID , & ID -> ID -> ID , ID ) ; 
ID ( STRING ) ; 
ID ( ) ; 
ID ( STRING ) ; 
ID ++ ; 

ID ( ID -> ID , ID ) ; 

ID -- ; 
ID ( ) ; 

ID ( STRING ) ; 

if ( ( ID = ID -> ID ) != ID ) 
{ 
ID ( ) ; 
ID ( STRING ) ; 
} 
else 
 
if ( ! ( ID -> ID && ID -> ID != INTEGER ) ) 
{ 
ID ( ) ; 
ID ( STRING ) ; 
ID ++ ; 
ID ( ) ; 
ID ( ID -> ID , & ID -> ID , ID -> ID ) ; 
ID -- ; 
ID ( ) ; 
ID ( STRING ) ; 
} 
} 
} 
} 

static void ID ( void * ID ) 
{ 
ID * ID ; 
unsigned ID ; 

if ( ! ID ( & ID , ID ( ID ) -> ID ) ) 
return ; 

ID = ID ( ID ) -> ID ; 

while ( ID != ID ) 
{ 
if ( ID -> ID -> ID != ID ) 
ID ( ID -> ID ) ; 

if ( ID -> ID != ID ) 
if ( ID ( ID , & ( ID -> ID ) , ID ) == ID ) 
{ 
ID * ID = ( ID * ) ID ( sizeof ( ID ) ) ; 

ID -> ID = ID -> ID ; 
ID ( ID , ID ) ; 

ID ( STRING , ID -> ID -> ID ) ; 
for ( ID = INTEGER ; ID < ID -> ID -> ID ; ID ++ ) 
ID ( STRING ) ; 
ID ( STRING , ID -> ID ) ; 
} 

ID = ID -> ID ; 
} 
} 

static void ID ( void * ID ) 
{ 
ID * ID = ( ID * ) ID ( ID ) ; 
unsigned ID ; 

ID ( STRING ) ; 
while ( ID != ID ) 
{ 
if ( ID -> ID == ID && ( ID -> ID > INTEGER ) && ! ID -> ID ) 
{ 
unsigned ID , 
ID = ( ( ID ( ID -> ID , STRING ) == INTEGER ) && ID -> ID == INTEGER ) ; 

void * ID = ID ( ID , ID -> ID ) ; 

if ( ID != ID ) 
ID ( STRING ) ; 

ID ( STRING , ID -> ID ) ; 

for ( ID = INTEGER ; ID < ID -> ID ; ID ++ ) 
ID ( STRING ) ; 
ID ( STRING , ID -> ID ) ; 

ID ( ID , ID -> ID , INTEGER , INTEGER ) ; 

ID ( STRING ) ; 

if ( ID -> ID ) 
ID ( STRING ) ; 

 
if ( ! ID ) 
{ 
ID ( STRING , ID -> ID ) ; 
for ( ID = INTEGER ; ID < ID -> ID ; ID ++ ) 
ID ( STRING ) ; 
ID ( STRING ) ; 
} 

if ( ! ID )  
ID ( ID ) ; 

ID ( ID ) ; 

 
if ( ID ) 
ID ( STRING , ID -> ID ) ; 
 
ID ( STRING ) ; 
ID ( ID -> ID , & ID -> ID , ID -> ID ? ( char * ) ID : ID -> ID ) ; 
ID ( STRING ) ; 
 
ID ( STRING ) ; 
ID = INTEGER ; 

ID ( ID , ID ) ; 

 
 
ID ( STRING , 
ID == INTEGER ? STRING : STRING , 
ID == INTEGER ? STRING : ID -> ID , 
ID == INTEGER ? STRING : STRING , 
ID -> ID , ID -> ID ) ; 
 
ID ( STRING ) ; 
 
if ( ID ) 
ID ( STRING , ID -> ID ) ; 

ID ( STRING , ID ? STRING : STRING ) ; 
} 
ID = ( ID * ) ID ( ID ) ; 
} 
} 

void ID ( char * ID , void * ID ) 
{ 
ID * ID ; 
ID * ID ; 
ID * ID ; 
unsigned ID ; 
char * ID ; 

if ( ID ) 
ID ( ID , STRING , ID ) ; 

if ( * ID == STRING ) 
ID = ID ; 
else if ( ( ID = ID ( ID , STRING ) ) == ID ) 
ID ( ID , STRING , ID ) ; 

ID ( ID ) ; 

 
ID ( STRING 
STRING 
STRING ) ; 

ID ( ) ; 
ID ( STRING 
STRING 
STRING 
STRING , 

ID ( ID , STRING ) ) ; 

if ( ID != ID ) 
ID ( ID ) ; 

if ( * ID != STRING )  
ID ( STRING , ID ( ID , STRING ) ) ; 

ID ( STRING 
STRING 
STRING 
STRING 

STRING 
STRING 
STRING 
STRING 
STRING 
STRING , ID ) ; 

ID = ID ; 
for ( ID = INTEGER ; ID < ID ; ID ++ ) 
{ 
ID ( STRING , ID ) ; 
if ( ID % INTEGER == INTEGER ) 
ID ( STRING ) ; 
while ( * ID ++ != INTEGER ) 
; 
} 

ID ( STRING ) ; 

ID = ID ; 
while ( ID != ID ) 
{ 
ID ( STRING , ID -> ID , ID -> ID ) ; 
ID ( STRING , ID -> ID ) ; 
ID = ID -> ID ; 
} 

 
if ( ID ) 
ID ( STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 

STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
) ; 

 
ID ( STRING ) ; 
ID = ( ID * ) ID ( ID ( ID ) ) ; 
while ( ID != ID ) 
{ 
if ( ID -> ID == ID || ID -> ID == ID ) 
{ 
ID ( STRING ) ; 
ID ( ID -> ID ) ; 
ID ( STRING ) ; 

if ( ID -> ID != ID ) 
{ 
ID ( STRING ) ; 
ID ( ID -> ID ) ; 
ID ( STRING ) ; 
} 
else 
ID ( STRING ) ; 

ID ( STRING , ID -> ID ) ; 
ID ( STRING , ID -> ID ) ; 
ID ( STRING ) ; 
} 
ID = ( ID * ) ID ( ID ) ; 
} 
ID ( STRING ) ; 

 
ID ( STRING ) ; 
ID = ( ID * ) ID ( ID ) ; 
while ( ID != ID ) 
{ 
if ( ID ( & ID , ID -> ID ) && ! ID -> ID ) 
{ 
if ( ID -> ID > INTEGER ) 
ID ( STRING , ID -> ID ) ; 

if ( ID -> ID == ID ) 
ID ( STRING , ID -> ID ) ; 
} 
ID = ( ID * ) ID ( ID ) ; 
} 

ID ( STRING ) ; 
ID = ( ID * ) ID ( ID ) ; 
while ( ID != ID ) 
{ 
if ( ID ( & ID , ID -> ID ) && ! ID -> ID ) 
{ 
if ( ID -> ID > INTEGER ) 
{ 
ID ( STRING , ID -> ID ) ; 
ID ( & ID -> ID , ID , INTEGER ) ; 
ID ( STRING ) ; 
} 

if ( ID -> ID == ID ) 
{ 
ID ( STRING , ID -> ID ) ; 
ID ( & ID -> ID , ID , INTEGER ) ; 
ID ( STRING ) ; 
} 
} 
ID = ( ID * ) ID ( ID ) ; 
} 
ID ( STRING ) ; 

 
ID ( STRING ) ; 
ID = ( ID * ) ID ( ID ) ; 
while ( ID != ID ) 
{ 
if ( ID -> ID == ID && ( ID -> ID > INTEGER ) ) 
{ 
unsigned ID ; 

if ( ID -> ID ) 
{ 
ID ( STRING , ID -> ID ) ; 
if ( ID -> ID != ID ) 
ID ( ID , ID -> ID , INTEGER , INTEGER ) ; 
ID ( STRING ) ; 
ID ( ID , ID ) ; 
} 
else 
{ 
if ( ID != ID ) 
ID ( STRING ) ; 

ID ( STRING , ID -> ID ) ; 

for ( ID = INTEGER ; ID < ID -> ID ; ID ++ ) 
ID ( STRING ) ; 
ID ( STRING , ID -> ID ) ; 

ID ( ID , ID -> ID , INTEGER , INTEGER ) ; 

ID ( STRING ) ; 
} 
} 
ID = ( ID * ) ID ( ID ) ; 
} 

 
if ( ID != ID ) 
ID ( STRING , ID ) ; 

 
ID ( ID ) ; 

 
ID ( STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING , 
ID , ID ) ; 

ID ( STRING ) ; 

if ( ID ) 
ID ( STRING 
STRING 
) ; 

 
ID ( STRING , ID ) ; 
ID ( STRING , 
( int ) ID ( ID , STRING ) , ID ) ; 

if ( * ID != INTEGER )  
ID ( STRING , ID ) ; 
ID ( STRING ) ; 

if ( ID != ID ) 
ID ( ID ) ; 

ID ( STRING ) ; 

ID ( STRING 
STRING 
STRING , 
ID ) ; 

ID ( STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
) ; 

ID ( STRING 
STRING ) ; 

if ( ! ID ) 
ID ( STRING 
STRING 
) ; 

ID ( STRING 
STRING , 
ID , ID , 
ID , ID , ID ) ; 

if ( ID ) 
ID ( STRING ) ; 

 
ID = ID ; 
while ( ID != ID ) 
{ 
ID ( STRING , 
ID -> ID , 
ID -> ID , 
ID -> ID , 
ID -> ID , 
ID -> ID , 
ID -> ID , 
ID -> ID ) ; 

ID = ID -> ID ; 
} 

ID ( STRING 
STRING ) ; 

if ( ID != ID ) 
ID ( STRING , ID ) ; 

ID ( STRING 
STRING , ID ) ; 

ID ( STRING , ID == INTEGER ? STRING : STRING ) ; 

if ( ID ) 
ID ( STRING ) ; 

ID ( 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING ) ; 

ID ( STRING , ID -> ID ) ; 

ID ( ID -> ID , ID -> ID , INTEGER , INTEGER ) ; 

ID ( 
STRING 
STRING 
STRING ) ; 

if ( ID && ! ID ) 
ID ( STRING ) ; 

ID ( 
STRING 
STRING 
STRING 
) ; 


if ( ID ) 
{ 
ID ( STRING ) ; 

ID ( STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
) ; 
} 

if ( ID != ID ) 
ID ( STRING , ID ) ; 

ID ( 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING , 
( int ) ID ( ID , STRING ) , ID ) ; 

ID ( STRING ) ; 

ID ( STRING , 
ID ( ID , STRING ) ) ; 

ID ( ID ) ; 
} 

void ID ( void * ID ) 
{ 
ID * ID = ( ID * ) ID ( ID ) ; 

if ( ID ) 
ID ( STRING ) ; 
while ( ID != ID ) 
{ 
ID * ID = ID -> ID ; 
int ID = ID -> ID ; 
unsigned ID ; 

if ( ID != ID && ID != ID && ID != ID && ID != ID ) 
{ 
ID ( STRING ) ; 
ID ( ID ) ; 

ID ( ID , ID -> ID , INTEGER , INTEGER ) ; 

ID ( STRING , ID -> ID ) ; 
for ( ID = INTEGER ; ID < ID -> ID ; ID ++ ) 
ID ( STRING ) ; 
ID ( STRING ) ; 

if ( ID == ID ) 
ID ( STRING , ID -> ID ) ; 
else 
{ 
if ( ID == ID ) 
{ 
if ( ID -> ID == INTEGER && ID -> ID == INTEGER && ID -> ID == ID ) 
ID ( STRING ) ; 
else if ( ID -> ID == INTEGER && ID -> ID == INTEGER && ID -> ID == ID ) 
ID ( STRING ) ; 
else if ( ID -> ID == INTEGER && ID -> ID == INTEGER && ID -> ID == ID ) 
ID ( STRING ) ; 
else 
ID ( STRING ) ; 
} 
while ( ID != ID ) 
{ 
ID ( ID -> ID ) ; 
ID ( ID , ID -> ID , INTEGER , INTEGER ) ; 

if ( ID -> ID != ID ) 
ID ( STRING , ID -> ID ) ; 

ID ( STRING ) ; 
ID = ID -> ID ; 
if ( ID != ID && ID != ID ) 
ID ( STRING ) ; 
} 

if ( ID == ID ) 
{ 
if ( ID -> ID == INTEGER && ID -> ID == INTEGER && ID -> ID == ID ) 
ID ( STRING ) ; 
else if ( ID -> ID == INTEGER && ID -> ID == INTEGER && ID -> ID == ID ) 
ID ( STRING ) ; 
else if ( ID -> ID == INTEGER && ID -> ID == INTEGER && ID -> ID == ID ) 
ID ( STRING ) ; 
else if ( ID -> ID == INTEGER && ID -> ID == INTEGER && ID -> ID == ID ) 
ID ( STRING ) ; 
else 
{ 
ID ( STRING , ID -> ID , ID -> ID ) ; 
if ( ID -> ID != ID ) 
ID ( STRING , ID -> ID -> ID ) ; 
else 
ID ( STRING ) ; 
} 
} 
} 

ID ( STRING ) ; 

ID ( STRING , ID -> ID ? STRING : STRING ) ; 
ID ( & ID -> ID , ID , INTEGER ) ; 
ID ( STRING ) ; 

ID ( STRING ) ; 
ID ( & ID -> ID , ID , INTEGER ) ; 
ID ( STRING ) ; 

if ( ID -> ID == INTEGER ) 
ID ( STRING ) ; 
else 
ID ( STRING , ID -> ID ) ; 
} 

ID = ( ID * ) ID ( ID ) ; 
} 
}$

(*!!!!!!!!!!!!!!!*)

ansi_cpp_mult_gtb_src
$
(* ART3 grammar generated by ART from 'v2\ansi_cppV2.art' on Jun 10 2018 08:39:42 - AJ multiply out! *)

translation_unit ::=
   # |
   declaration_seq 


abstract_declarator ::=
   direct_abstract_declarator |
   ptr_operator |
   ptr_operator abstract_declarator 

access_specifier ::=
   'private' |
   'protected' |
   'public' 

additive_expression ::=
   multiplicative_expression |
   additive_expression '+' multiplicative_expression |
   additive_expression '-' multiplicative_expression 

and_expression ::=
   equality_expression |
   and_expression '&' equality_expression 

asm_definition ::=
   'asm' '(' string_literal ')' ';' 

assignment_expression ::=
   conditional_expression |
   logical_or_expression assignment_operator assignment_expression |
   throw_expression 

assignment_operator ::=
   '=' |
   '*=' |
   '/=' |
   '%=' |
   '+=' |
   '-=' |
   '>>=' |
   '<<=' |
   '&=' |
   '^=' |
   '|=' 

base_clause ::=
   ':' base_specifier_list 

base_specifier ::=
   class_name |
   nested_name_specifier class_name |
   '::' class_name |
   '::' nested_name_specifier class_name |
   'virtual' class_name |
   'virtual' nested_name_specifier class_name |
   'virtual' '::' class_name |
   'virtual' '::' nested_name_specifier class_name |
   'virtual' access_specifier class_name |
   'virtual' access_specifier nested_name_specifier class_name |
   'virtual' access_specifier '::' class_name |
   'virtual' access_specifier '::' nested_name_specifier class_name |
   access_specifier class_name |
   access_specifier nested_name_specifier class_name |
   access_specifier '::' class_name |
   access_specifier '::' nested_name_specifier class_name |
   access_specifier 'virtual' class_name |
   access_specifier 'virtual' nested_name_specifier class_name |
   access_specifier 'virtual' '::' class_name |
   access_specifier 'virtual' '::' nested_name_specifier class_name 

base_specifier_list ::=
   base_specifier |
   base_specifier_list ',' base_specifier 

block_declaration ::=
   simple_declaration |
   asm_definition |
   namespace_alias_definition |
   using_declaration |
   using_directive 

boolean_literal ::=
   'true' |
   'false' 

cast_expression ::=
   unary_expression |
   '(' type_id ')' cast_expression 

character_literal ::=
   'CHARACTER' 

class_head ::=
   class_key nested_name_specifier identifier |
   class_key nested_name_specifier identifier base_clause |
   class_key |
   class_key base_clause |
   class_key identifier |
   class_key identifier base_clause 

class_key ::=
   'class' |
   'struct' |
   'union' 

class_name ::=
   identifier |
   template_id 

class_or_namespace_name ::=
   class_name |
   namespace_name 

class_specifier ::=
   class_head '{' '}' |
   class_head '{' member_specification '}' 

compound_statement ::=
   '{' '}' |
   '{' statement_seq '}' 

condition ::=
   expression |
   type_specifier_seq declarator '=' assignment_expression 

conditional_expression ::=
   logical_or_expression |
   logical_or_expression '?' expression ':' assignment_expression 

constant_expression ::=
   conditional_expression 

constant_initializer ::=
   '=' constant_expression 

conversion_declarator ::=
   ptr_operator |
   ptr_operator conversion_declarator 

conversion_function_id ::=
   operator conversion_type_id 

conversion_type_id ::=
   type_specifier_seq |
   type_specifier_seq conversion_declarator 

ctor_initializer ::=
   ':' mem_initializer_list 

cv_qualifier ::=
   'const' |
   'volatile' 

cv_qualifier_seq ::=
   cv_qualifier |
   cv_qualifier cv_qualifier_seq 

decl_specifier ::=
   storage_class_specifier |
   type_specifier |
   function_specifier |
   'friend' |
   'typedef' 

decl_specifier_seq ::=
   decl_specifier |
   decl_specifier_seq decl_specifier 

declaration ::=
   block_declaration |
   function_definition |
   template_declaration |
   explicit_instantiation |
   explicit_specialization |
   linkage_specification |
   namespace_definition 

declaration_seq ::=
   declaration |
   declaration_seq declaration 

declaration_statement ::=
   block_declaration 

declarator ::=
   direct_declarator |
   ptr_operator declarator 

declarator_id ::=
   id_expression |
   '::' id_expression |
   type_name |
   nested_name_specifier type_name |
   '::' type_name |
   '::' nested_name_specifier type_name 

delete_expression ::=
   'delete' cast_expression |
   '::' 'delete' cast_expression |
   'delete' '[' ']' cast_expression |
   '::' 'delete' '[' ']' cast_expression 

direct_abstract_declarator ::=
   '(' abstract_declarator ')' |
   '[' ']' |
   '[' constant_expression ']' |
   direct_abstract_declarator '[' ']' |
   direct_abstract_declarator '[' constant_expression ']' |
   '(' parameter_declaration_clause ')' |
   '(' parameter_declaration_clause ')' exception_specification |
   '(' parameter_declaration_clause ')' cv_qualifier_seq |
   '(' parameter_declaration_clause ')' cv_qualifier_seq exception_specification |
   direct_abstract_declarator '(' parameter_declaration_clause ')' |
   direct_abstract_declarator '(' parameter_declaration_clause ')' exception_specification |
   direct_abstract_declarator '(' parameter_declaration_clause ')' cv_qualifier_seq |
   direct_abstract_declarator '(' parameter_declaration_clause ')' cv_qualifier_seq exception_specification 

direct_declarator ::=
   declarator_id |
   '(' declarator ')' |
   direct_declarator '[' ']' |
   direct_declarator '[' constant_expression ']' |
   direct_declarator '(' parameter_declaration_clause ')' |
   direct_declarator '(' parameter_declaration_clause ')' exception_specification |
   direct_declarator '(' parameter_declaration_clause ')' cv_qualifier_seq |
   direct_declarator '(' parameter_declaration_clause ')' cv_qualifier_seq exception_specification 

direct_new_declarator ::=
   '[' expression ']' |
   direct_new_declarator '[' constant_expression ']' 

elaborated_type_specifier ::=
   'typename' nested_name_specifier identifier |
   'typename' '::' nested_name_specifier identifier |
   'typename' nested_name_specifier identifier '<' template_argument_list '>' |
   'typename' '::' nested_name_specifier identifier '<' template_argument_list '>' |
   class_key identifier |
   class_key nested_name_specifier identifier |
   class_key '::' identifier |
   class_key '::' nested_name_specifier identifier |
   'enum' identifier |
   'enum' nested_name_specifier identifier |
   'enum' '::' identifier |
   'enum' '::' nested_name_specifier identifier 

enum_name ::=
   identifier 

enum_specifier ::=
   'enum' '{' '}' |
   'enum' '{' enumerator_list '}' |
   'enum' identifier '{' '}' |
   'enum' identifier '{' enumerator_list '}' 

enumerator ::=
   identifier 

enumerator_definition ::=
   enumerator |
   enumerator '=' constant_expression 

enumerator_list ::=
   enumerator_definition |
   enumerator_list ',' enumerator_definition 

equality_expression ::=
   relational_expression |
   equality_expression '==' relational_expression |
   equality_expression '!=' relational_expression 

exception_declaration ::=
   type_specifier_seq declarator |
   type_specifier_seq abstract_declarator |
   type_specifier_seq |
   '...' 

exception_specification ::=
   'throw' '(' ')' |
   'throw' '(' type_id_list ')' 

exclusive_or_expression ::=
   and_expression |
   exclusive_or_expression '^' and_expression 

explicit_instantiation ::=
   'template' declaration 

explicit_specialization ::=
   'template' '<' '>' declaration 

expression ::=
   assignment_expression |
   expression ',' assignment_expression 

expression_list ::=
   assignment_expression |
   expression_list ',' assignment_expression 

expression_statement ::=
   ';' |
   expression ';' 

extension_namespace_definition ::=
   'namespace' original_namespace_name '{' namespace_body '}' 

floating_literal ::=
   'REAL' 

for_init_statement ::=
   expression_statement |
   simple_declaration 

function_body ::=
   compound_statement 

function_definition ::=
   declarator function_try_block |
   decl_specifier_seq declarator function_try_block |
   declarator function_body |
   declarator ctor_initializer function_body |
   decl_specifier_seq declarator function_body |
   decl_specifier_seq declarator ctor_initializer function_body 

function_specifier ::=
   'inline' |
   'virtual' |
   'explicit' 

function_try_block ::=
   'try' function_body handler_seq |
   'try' ctor_initializer function_body handler_seq 

handler ::=
   'catch' '(' exception_declaration ')' compound_statement 

handler_seq ::=
   handler |
   handler handler_seq 

id_expression ::=
   unqualified_id |
   qualified_id 

identifier ::=
   'ID' 

inclusive_or_expression ::=
   exclusive_or_expression |
   inclusive_or_expression '|' exclusive_or_expression 

init_declarator ::=
   declarator |
   declarator initializer 

init_declarator_list ::=
   init_declarator |
   init_declarator_list ',' init_declarator 

initializer ::=
   '=' initializer_clause |
   '(' expression_list ')' 

initializer_clause ::=
   assignment_expression |
   '{' '}' |
   '{' initializer_list '}' |
   '{' initializer_list ',' '}' 

initializer_list ::=
   initializer_clause |
   initializer_list ',' initializer_clause 

integer_literal ::=
   'INTEGER' 

iteration_statement ::=
   'while' '(' condition ')' statement |
   'do' statement 'while' '(' expression ')' ';' |
   'for' '(' for_init_statement ';' ')' statement |
   'for' '(' for_init_statement ';' expression ')' statement |
   'for' '(' for_init_statement condition ';' ')' statement |
   'for' '(' for_init_statement condition ';' expression ')' statement 

jump_statement ::=
   'break' ';' |
   'continue' ';' |
   'goto' identifier ';' |
   'return' ';' |
   'return' expression ';' 

labeled_statement ::=
   identifier ':' statement |
   'case' constant_expression ':' statement |
   'default' ':' statement 

linkage_specification ::=
   'extern' string_literal declaration |
   'extern' string_literal '{' '}' |
   'extern' string_literal '{' declaration_seq '}' 

literal ::=
   integer_literal |
   character_literal |
   floating_literal |
   string_literal |
   boolean_literal 

logical_and_expression ::=
   inclusive_or_expression |
   logical_and_expression '&&' inclusive_or_expression 

logical_or_expression ::=
   logical_and_expression |
   logical_or_expression '||' logical_and_expression 

mem_initializer ::=
   mem_initializer_id '(' ')' |
   mem_initializer_id '(' expression_list ')' 

mem_initializer_id ::=
   identifier |
   class_name |
   nested_name_specifier class_name |
   '::' class_name |
   '::' nested_name_specifier class_name 

mem_initializer_list ::=
   mem_initializer |
   mem_initializer ',' mem_initializer_list 

member_declaration ::=
   qualified_id ';' |
   using_declaration |
   template_declaration |
   function_definition |
   function_definition ';' |
   ';' |
   member_declarator_list ';' |
   decl_specifier_seq ';' |
   decl_specifier_seq member_declarator_list ';' 

member_declarator ::=
   declarator |
   declarator pure_specifier |
   declarator |
   declarator constant_initializer |
   ':' constant_expression |
   identifier ':' constant_expression 

member_declarator_list ::=
   member_declarator |
   member_declarator_list ',' member_declarator 

member_specification ::=
   member_declaration |
   member_declaration member_specification |
   access_specifier ':' |
   access_specifier ':' member_specification 

multiplicative_expression ::=
   pm_expression |
   multiplicative_expression '*' pm_expression |
   multiplicative_expression '/' pm_expression |
   multiplicative_expression '%' pm_expression 

named_namespace_definition ::=
   original_namespace_definition |
   extension_namespace_definition 

namespace_alias ::=
   identifier 

namespace_alias_definition ::=
   'namespace' identifier '=' qualified_namespace_specifier ';' 

namespace_body ::=
   # |
   declaration_seq 

namespace_definition ::=
   named_namespace_definition |
   unnamed_namespace_definition 

namespace_name ::=
   original_namespace_name |
   namespace_alias 

nested_name_specifier ::=
   class_or_namespace_name '::' |
   class_or_namespace_name '::' nested_name_specifier 

new_declarator ::=
   direct_new_declarator |
   ptr_operator |
   ptr_operator new_declarator 

new_expression ::=
   'new' new_type_id |
   'new' new_type_id new_initializer |
   'new' new_placement new_type_id |
   'new' new_placement new_type_id new_initializer |
   '::' 'new' new_type_id |
   '::' 'new' new_type_id new_initializer |
   '::' 'new' new_placement new_type_id |
   '::' 'new' new_placement new_type_id new_initializer |
   'new' '(' type_id ')' |
   'new' '(' type_id ')' new_initializer |
   'new' new_placement '(' type_id ')' |
   'new' new_placement '(' type_id ')' new_initializer |
   '::' 'new' '(' type_id ')' |
   '::' 'new' '(' type_id ')' new_initializer |
   '::' 'new' new_placement '(' type_id ')' |
   '::' 'new' new_placement '(' type_id ')' new_initializer 

new_initializer ::=
   '(' ')' |
   '(' expression_list ')' 

new_placement ::=
   '(' expression_list ')' 

new_type_id ::=
   type_specifier_seq |
   type_specifier_seq new_declarator 

operator ::=
   'new' |
   'delete' |
   'new[]' |
   'delete[]' |
   '+' |
   '-' |
   '*' |
   '/' |
   '%' |
   '^' |
   '&' |
   '|' |
   '~' |
   '!' |
   '=' |
   '<' |
   '>' |
   '+=' |
   '-=' |
   '*=' |
   '/=' |
   '%=' |
   '^=' |
   '&=' |
   '|=' |
   '<<' |
   '>>' |
   '>>=' |
   '<<=' |
   '==' |
   '!=' |
   '<=' |
   '>=' |
   '&&' |
   '||' |
   '++' |
   '--' |
   ',' |
   '->*' |
   '->' |
   '()' |
   '[]' 

operator_function_id ::=
   operator operator 

original_namespace_definition ::=
   'namespace' identifier '{' namespace_body '}' 

original_namespace_name ::=
   identifier 

parameter_declaration ::=
   decl_specifier_seq declarator |
   decl_specifier_seq declarator '=' assignment_expression |
   decl_specifier_seq |
   decl_specifier_seq abstract_declarator |
   decl_specifier_seq '=' assignment_expression |
   decl_specifier_seq abstract_declarator '=' assignment_expression 

parameter_declaration_clause ::=
   parameter_declaration_list ',' '...' |
   # |
   '...' |
   parameter_declaration_list |
   parameter_declaration_list '...' 

parameter_declaration_list ::=
   parameter_declaration |
   parameter_declaration_list ',' parameter_declaration 

pm_expression ::=
   cast_expression |
   pm_expression '.*' cast_expression |
   pm_expression '->*' cast_expression 

postfix_expression ::=
   primary_expression |
   postfix_expression '[' expression ']' |
   postfix_expression '.' pseudo_destructor_name |
   postfix_expression '->' pseudo_destructor_name |
   postfix_expression '++' |
   postfix_expression '--' |
   'dynamic_cast' '<' type_id '>' '(' expression ')' |
   'static_cast' '<' type_id '>' '(' expression ')' |
   'reinterpret_cast' '<' type_id '>' '(' expression ')' |
   'const_cast' '<' type_id '>' '(' expression ')' |
   'typeid' '(' expression ')' |
   'typeid' '(' type_id ')' |
   postfix_expression '(' ')' |
   postfix_expression '(' expression_list ')' |
   simple_type_specifier '(' ')' |
   simple_type_specifier '(' expression_list ')' |
   postfix_expression '.' id_expression |
   postfix_expression '.' '::' id_expression |
   postfix_expression '.' 'template' id_expression |
   postfix_expression '.' 'template' '::' id_expression |
   postfix_expression '->' id_expression |
   postfix_expression '->' '::' id_expression |
   postfix_expression '->' 'template' id_expression |
   postfix_expression '->' 'template' '::' id_expression 

primary_expression ::=
   literal |
   'this' |
   '::' identifier |
   '::' operator_function_id |
   '::' qualified_id |
   '(' expression ')' |
   id_expression 

pseudo_destructor_name ::=
   type_name '::' '~' type_name |
   nested_name_specifier type_name '::' '~' type_name |
   '::' type_name '::' '~' type_name |
   '::' nested_name_specifier type_name '::' '~' type_name |
   '~' type_name |
   nested_name_specifier '~' type_name |
   '::' '~' type_name |
   '::' nested_name_specifier '~' type_name 

ptr_operator ::=
   '&' |
   '*' |
   '*' cv_qualifier_seq |
   nested_name_specifier '*' |
   nested_name_specifier '*' cv_qualifier_seq |
   '::' nested_name_specifier '*' |
   '::' nested_name_specifier '*' cv_qualifier_seq 

pure_specifier ::=
   '=' '0' 

qualified_id ::=
   nested_name_specifier unqualified_id |
   nested_name_specifier 'template' unqualified_id 

qualified_namespace_specifier ::=
   namespace_name |
   nested_name_specifier namespace_name |
   '::' namespace_name |
   '::' nested_name_specifier namespace_name 

relational_expression ::=
   shift_expression |
   relational_expression '<' shift_expression |
   relational_expression '>' shift_expression |
   relational_expression '<=' shift_expression |
   relational_expression '>=' shift_expression 

selection_statement ::=
   'if' '(' condition ')' statement |
   'if' '(' condition ')' statement 'else' statement |
   'switch' '(' condition ')' statement 

shift_expression ::=
   additive_expression |
   shift_expression '<<' additive_expression |
   shift_expression '>>' additive_expression 

simple_declaration ::=
   ';' |
   init_declarator_list ';' |
   decl_specifier_seq ';' |
   decl_specifier_seq init_declarator_list ';' 

simple_type_specifier ::=
   'char' |
   'wchar_t' |
   'bool' |
   'short' |
   'int' |
   'long' |
   'signed' |
   'unsigned' |
   'float' |
   'double' |
   'void' |
   type_name |
   nested_name_specifier type_name |
   '::' type_name |
   '::' nested_name_specifier type_name 

statement ::=
   labeled_statement |
   expression_statement |
   compound_statement |
   selection_statement |
   iteration_statement |
   jump_statement |
   declaration_statement |
   try_block 

statement_seq ::=
   statement |
   statement_seq statement 

storage_class_specifier ::=
   'auto' |
   'register' |
   'static' |
   'extern' |
   'mutable' 

string_literal ::=
   'STRING' |
   string_literal 'STRING' 

template_argument ::=
   assignment_expression |
   type_id |
   template_name 

template_argument_list ::=
   template_argument |
   template_argument_list ',' template_argument 

template_declaration ::=
   'template' '<' template_parameter_list '>' declaration |
   'export' 'template' '<' template_parameter_list '>' declaration 

template_id ::=
   template_name '<' template_argument_list '>' 

template_name ::=
   identifier 

template_parameter ::=
   type_parameter |
   parameter_declaration 

template_parameter_list ::=
   template_parameter |
   template_parameter_list ',' template_parameter 

throw_expression ::=
   'throw' |
   'throw' assignment_expression 


try_block ::=
   'try' compound_statement handler_seq 

type_id ::=
   type_specifier_seq |
   type_specifier_seq abstract_declarator 

type_id_list ::=
   type_id |
   type_id_list ',' type_id 

type_name ::=
   class_name |
   enum_name |
   typedef_name 

type_parameter ::=
   'class' |
   'class' identifier |
   'class' '=' type_id |
   'class' identifier '=' type_id |
   'typename' |
   'typename' identifier |
   'typename' '=' type_id |
   'typename' identifier '=' type_id |
   'template' '<' template_parameter_list '>' 'class' |
   'template' '<' template_parameter_list '>' 'class' identifier |
   'template' '<' template_parameter_list '>' 'class' '=' template_name |
   'template' '<' template_parameter_list '>' 'class' identifier '=' template_name 

type_specifier ::=
   simple_type_specifier |
   class_specifier |
   enum_specifier |
   elaborated_type_specifier |
   cv_qualifier 

type_specifier_seq ::=
   type_specifier |
   type_specifier type_specifier_seq 

typedef_name ::=
   identifier 

unary_expression ::=
   postfix_expression |
   '++' cast_expression |
   '--' cast_expression |
   unary_operator cast_expression |
   'sizeof' unary_expression |
   'sizeof' '(' type_id ')' |
   new_expression |
   delete_expression 

unary_operator ::=
   '*' |
   '&' |
   '+' |
   '-' |
   '!' |
   '~' 

unnamed_namespace_definition ::=
   'namespace' '{' namespace_body '}' 

unqualified_id ::=
   identifier |
   operator_function_id |
   conversion_function_id |
   '~' class_name |
   template_id 

using_declaration ::=
   'using' '::' unqualified_id ';' |
   'using' nested_name_specifier unqualified_id ';' |
   'using' '::' nested_name_specifier unqualified_id ';' |
   'using' 'typename' nested_name_specifier unqualified_id ';' |
   'using' 'typename' '::' nested_name_specifier unqualified_id ';' 

using_directive ::=
   'using' 'namespace' namespace_name ';' |
   'using' 'namespace' nested_name_specifier namespace_name ';' |
   'using' 'namespace' '::' namespace_name ';' |
   'using' 'namespace' '::' nested_name_specifier namespace_name ';' 

$
accept
(*gtb_src.tok*)
$char 
* ID ,  
* * ID ,  
* ID = STRING ;  

int 
ID = INTEGER ,  
ID = INTEGER ,  
ID ,  
ID ;  

int ID = INTEGER ;  

char * ID = STRING 
STRING STRING STRING STRING STRING STRING STRING STRING 
STRING STRING STRING STRING STRING STRING 
STRING 
STRING STRING STRING STRING STRING STRING STRING STRING 
STRING STRING STRING STRING STRING STRING STRING STRING 
STRING STRING STRING STRING STRING STRING STRING STRING 
STRING STRING STRING STRING STRING STRING STRING STRING 
STRING STRING STRING STRING STRING STRING STRING STRING 
STRING STRING STRING STRING STRING STRING STRING STRING 
STRING STRING STRING STRING STRING STRING STRING STRING 
STRING STRING ; 


 
static int ID = INTEGER ; 

ID * ID ; 

ID * ID ( char * ID , ID * ID ) 
{ 
if ( ID ) 
{ 
ID * ID = ( ID * ) ID ( sizeof ( ID ) , ID ) ; 
if ( ID != ID ) 
ID -> ID = ID ; 
else 
ID ( ID , ID , sizeof ( ID ) ) ; 
return ID ; 
} 
else 
return ID ; 
} 

ID * ID ( char * ID , ID * ID ) 
{ 
if ( ID ) 
{ 
ID = ( ID * ) ID ( sizeof ( ID ) , ID ) ; 
if ( ID != ID ) 
ID -> ID = ID ; 
else 
ID ( ID , ID , sizeof ( ID ) ) ; 

( ( ID * ) ID ( sizeof ( ID ) , ID , ID ) ) -> ID = INTEGER ; 
return ID ; 
} 
else 
return ID ; 
} 

ID * ID ( char * ID , ID * ID ) 
{ 
if ( ID ) 
{ 
ID * ID = ( ID * ) ID ( sizeof ( ID ) , sizeof ( ID ) , ID ) ; 
if ( ID != ID ) 
ID -> ID = ID ; 
else 
ID ( ID , ID , sizeof ( ID ) ) ; 

( ( ID * ) ID ( ID ) ) -> ID = INTEGER ; 

return ID ; 
} 
else 
return ID ; 
} 


 
static void ID ( void ) 
{ 
ID ( STRING , STRING , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , STRING , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , STRING , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , STRING , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
} 

 

ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 

 

static void ID ( void ) 
{ 
ID ( & ID , ID , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , 
ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , 
ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , 
ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , 
ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , 
ID  , ID ) ; 
ID ( & ID , ID , ID , ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID  , ID  , ID  , ID  , 
ID  , ID ) ; 
ID ( & ID , ID , ID  , ID  , ID ) ; 
ID ( & ID , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID  , ID  , ID  , ID  , 
ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID  , ID ) ; 
ID ( & ID , ID , ID  , ID  , ID  , ID  , 
ID  , ID ) ; 
ID ( & ID , ID , ID  , ID  , ID  , ID  , 
ID  , ID ) ; 
ID ( & ID , ID , ID  , ID  , ID  , ID  , 
ID  , ID ) ; 
ID ( & ID , ID , ID  , ID  , ID  , ID  , 
ID  , ID ) ; 
ID ( & ID , ID , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID  , ID ) ; 
ID ( & ID , ID , ID  , ID ) ; 
ID ( & ID , ID , ID  , ID ) ; 
ID ( & ID , ID , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID  , ID ) ; 
ID ( & ID , ID , ID , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID  , ID ) ; 
ID ( & ID , ID , ID , ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID  , ID ) ; 
ID ( & ID , ID , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , 
ID  , ID ) ; 
ID ( & ID , ID , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID ) ; 
} 

 
static void ID ( ID * ID ) ; 
static void ID ( ID * ID ) ; 
static void ID ( ID * ID ) ; 
static void ID ( ID * ID ) ; 
static void ID ( ID * ID ) ; 
static void ID ( ID * ID ) ; 
static void ID ( ID * ID ) ; 
static void ID ( ID * ID ) ; 
static void ID ( ID * ID ) ; 
static void ID ( ID * ID ) ; 
static void ID ( ID * ID ) ; 
static void ID ( ID * ID ) ; 
static void ID ( ID * ID ) ; 
static void ID ( ID * ID ) ; 
static void ID ( ID * ID ) ; 
static char * ID ( ID * ID ) ; 
static void ID ( ID * ID ) ; 
static void ID ( ID * ID ) ; 
static void ID ( ID * ID ) ; 
static char * ID ( ID * ID ) ; 
static void ID ( ID * ID ) ; 
static void ID ( ID * ID ) ; 
void ID ( ID * ID ) ; 

 
static void ID ( ID * ID ) 
{ 
{ 
if ( ID ) { ID -> ID = STRING ; ID -> ID = INTEGER ; } 
ID ( ID ) ; 
if ( ID ( ID , ID  , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
ID ( ID , & ID , & ID ) ; 
} 
} 

static void ID ( ID * ID ) 
{ 
{ 
if ( ID ) { ID -> ID = STRING ; ID -> ID = INTEGER ; } 
ID ( ID ) ; 
if ( ID ( ID , & ID , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
if ( ! ID ( ID , & ID , ID ) ) break ; 
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
ID ( ID , & ID , & ID ) ; 
} 
} 

static void ID ( ID * ID ) 
{ 
{ 
ID ( ID ( STRING , ID ) ) ; 
if ( ID ( ID , ID  , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID -> ID = ID ; ID -> ID = ID ; } 
} 
ID ( ID , & ID , & ID ) ; 
} 
} 

static void ID ( ID * ID ) 
{ 
{ 
if ( ID ( ID , & ID , ID ) ) 
{ 
if ( ID ) { ID -> ID = STRING ; ID -> ID = INTEGER ; } 
ID ( ID ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
ID ( ID , & ID , & ID ) ; 
ID ( ID , & ID , & ID ) ; 
} 
} 

static void ID ( ID * ID ) 
{ 
{ 
if ( ID ) { ID -> ID = STRING ; ID -> ID = INTEGER ; } 
ID ( ID ) ; 
if ( ID ( ID , ID  , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
ID ( ID , & ID , & ID ) ; 
} 
} 

static void ID ( ID * ID ) 
{ 
{ 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) { ID -> ID = STRING ; ID -> ID = INTEGER ; } 
ID ( ID ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) { ID -> ID = STRING ; ID -> ID = INTEGER ; } 
ID ( ID ) ; 
} 
else 
ID ( ID , & ID , & ID ) ; 
ID ( ID , & ID , & ID ) ; 
} 
} 

static void ID ( ID * ID ) 
{ 
{ 
if ( ID ) { ID -> ID = STRING ; ID -> ID = INTEGER ; } 
ID ( ID ) ; 
if ( ID ( ID , & ID , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
if ( ! ID ( ID , & ID , ID ) ) break ; 
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
ID ( ID , & ID , & ID ) ; 
} 
} 

static void ID ( ID * ID ) 
{ 
{ 
ID ( ID ( STRING , ID ) ) ; 
if ( ID ( ID , & ID , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID -> ID = ID ; ID -> ID = ID ; } 
} 
ID ( ID , & ID , & ID ) ; 
} 
} 

static void ID ( ID * ID ) 
{ 
{ 
if ( ID ) { ID -> ID = STRING ; ID -> ID = INTEGER ; } 
ID ( ID ) ; 
if ( ID ( ID , & ID , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
ID ( ID , & ID , & ID ) ; 
} 
} 

static void ID ( ID * ID ) 
{ 
{ 
if ( ID ) { ID -> ID = STRING ; ID -> ID = INTEGER ; } 
ID ( ID ) ; 
if ( ID ( ID , ID  , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
if ( ! ID ( ID , ID  , ID ) ) break ; 
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
ID ( ID , & ID , & ID ) ; 
} 
} 

static void ID ( ID * ID ) 
{ 
{ 
if ( ID ) { ID -> ID = STRING ; ID -> ID = INTEGER ; } 
ID ( ID ) ; 
if ( ID ( ID , ID  , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
if ( ! ID ( ID , ID  , ID ) ) break ; 
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
ID ( ID , & ID , & ID ) ; 
} 
} 

static void ID ( ID * ID ) 
{ 
{ 
if ( ID ) { ID -> ID = STRING ; ID -> ID = INTEGER ; } 
ID ( ID ) ; 
if ( ID ( ID , ID  , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
if ( ! ID ( ID , ID  , ID ) ) break ; 
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
ID ( ID , & ID , & ID ) ; 
} 
} 

static void ID ( ID * ID ) 
{ 
{ 
if ( ID ) { ID -> ID = STRING ; ID -> ID = INTEGER ; } 
ID ( ID ) ; 
if ( ID ( ID , & ID , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
if ( ! ID ( ID , & ID , ID ) ) break ; 
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
ID ( ID , & ID , & ID ) ; 
} 
} 

static void ID ( ID * ID ) 
{ 
{ 
if ( ID ) { ID -> ID = STRING ; ID -> ID = INTEGER ; } 
ID ( ID ) ; 
if ( ID ( ID , & ID , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
if ( ! ID ( ID , & ID , ID ) ) break ; 
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
ID ( ID , & ID , & ID ) ; 
} 
} 

static void ID ( ID * ID ) 
{ 
char * ID ; 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID -> ID = ID ( ID ) ;  
if ( ID -> ID -> ID == ID )  
{  
ID -> ID -> ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ;  
ID -> ID -> ID -> ID = ID ;  
ID -> ID -> ID = INTEGER ;  
}  
 
} 
ID ( ID , & ID , & ID ) ; 
} 
} 

static char * ID ( ID * ID ) 
{ 
char * ID ; 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID -> ID = ID ( ID ) ;  
} 
if ( ID ( ID , ID  , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
{  
while ( INTEGER ) 
{ 
ID ( ID , & ID , & ID ) ; 
{ 
ID ( ID ( STRING , ID ) ) ; 
} 
if ( ! ID ( ID , & ID , ID ) ) break ; 
} 
}  
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
ID ( ID , & ID , & ID ) ; 
} 
return ID ; 
} 

static void ID ( ID * ID ) 
{ 
{ 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID -> ID = ID ( STRING ) ;  
if ( ID -> ID -> ID == ID )  
{  
ID -> ID -> ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ;  
ID -> ID -> ID -> ID = ID ;  
ID -> ID -> ID = INTEGER ;  
}  
 
} 
ID ( ID , & ID , & ID ) ; 
} 
} 

static void ID ( ID * ID ) 
{ 
{ 
{  
while ( INTEGER ) 
{ 
ID ( ID , & ID , & ID ) ; 
{ 
if ( ID ( ID , & ID , ID ) ) 
{ 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
if ( ! ID ( ID , & ID , ID ) ) break ; 
} 
}  
ID ( ID , & ID , & ID ) ; 
} 
} 

static void ID ( ID * ID ) 
{ 
char * ID ; 
{ 
if ( ID == INTEGER ) {  
ID ( ) ;  
} 
if ( ID ) { ID -> ID = STRING ; ID -> ID = INTEGER ; } 
ID = ID ( ID ) ; 
if ( ID == INTEGER ) {  
ID ( ID ) ;  
} if ( ID == INTEGER ) {  
ID ( ID ) ;  
} 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
{  
while ( INTEGER ) 
{ 
ID ( ID , & ID , & ID ) ; 
{ 
ID ( ID ( STRING , ID ) ) ; 
} 
if ( ID -> ID != ID  ) break ; 
ID ( ) ; 
} 
}  
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID ( ) ;  
} 
ID ( ID , & ID , & ID ) ; 
} 
} 

static char * ID ( ID * ID ) 
{ 
char * ID ; 
{ 
if ( ID ( ID , ID  , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
if ( ID ) ID ( ID , ID , sizeof ( ID ) ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID -> ID = ID ( ID ) ;  
if ( ID -> ID -> ID == ID )  
{  
ID -> ID -> ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ;  
ID -> ID -> ID -> ID = ID ;  
ID -> ID -> ID -> ID = ID ;  
ID -> ID -> ID = INTEGER ;  
}  
 
} 
if ( ID ( ID , ID  , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
{  
while ( INTEGER ) 
{ 
ID ( ID , & ID , & ID ) ; 
{ 
ID ( ID ( STRING , ID ) ) ; 
} 
if ( ! ID ( ID , & ID , ID ) ) break ; 
} 
}  
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
ID ( ID , & ID , & ID ) ; 
} 
return ID ; 
} 

static void ID ( ID * ID ) 
{ 
{ 
if ( ID ( ID , & ID , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
ID ( ID ( STRING , ID ) ) ; 
} 
if ( ! ID ( ID , & ID , ID ) ) break ; 
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
ID ( ID , & ID , & ID ) ; 
} 
} 

static void ID ( ID * ID ) 
{ 
{ 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ( ID , & ID , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
ID ( ID ( STRING , ID ) ) ; 
} 
if ( ! ID ( ID , & ID , ID ) ) break ; 
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID , & ID , & ID ) ; 
} 
} 

void ID ( ID * ID ) 
{ 
{ 
ID ( ID ( STRING , ID ) ) ; 
if ( ID ( ID , ID  , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID == INTEGER ) {  
ID ( ) ; ID ( STRING ) ;  
} 
ID ( ID ( STRING , ID ) ) ; 
if ( ID == INTEGER ) {  
ID ( ) ;  
} 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
ID ( ID , STRING , ID ) ; 
} 
ID ( ID , & ID , & ID ) ; 
} 
} 

int ID ( int ID , char * ID [ ] ) 
{ 
ID ID , ID = ID ( ) ; 
int 
ID = INTEGER ,  
ID = INTEGER ,  
ID = INTEGER ,  
ID = INTEGER ,  

ID = INTEGER ;  

unsigned long ID = INTEGER ;  

unsigned long ID = INTEGER ;  

char * ID = ID ;  

ID * ID = ( ID * ) ID ( STRING ) ;  
ID * ID ; 

ID ( STRING STRING STRING STRING ) ; 

ID ( STRING ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 

ID = ID ( ID , ID ) ; 

 
for ( ID = INTEGER ; ID [ ID ] != ID ; ID ++ ) 
ID [ ID ] = ID ( ID [ ID ] , STRING ) ; 

if ( ID ) 
{ 
ID [ INTEGER ] = STRING ; 
ID = STRING ; 
ID [ INTEGER ] = ID ;  

} 
if ( ( ID = ID [ INTEGER ] ) == ID ) 
ID ( STRING ) ; 

if ( ID [ INTEGER ] != ID ) 
ID ( ID , STRING ) ; 
ID ( ID , INTEGER , INTEGER , ( int ) ID ) ; 
ID ( INTEGER , INTEGER , INTEGER , ID , ID ) ; 
if ( ID ) 
ID ( ) ; 
ID ( ) ; 
ID ( ) ; 
ID ( ID ) ; 
if ( ID ) 
ID ( STRING STRING STRING ) ; 
for ( ID = INTEGER ; ID <= ID ; ID ++ ) 
{ 
ID = ID == ID ; 
ID ( ID || ( ID && ID == ID ) ) ; 

for ( ID = INTEGER ; ( ID = ID [ ID ] ) != ID ; ID ++ ) 
{ 
if ( ID ( ID ) == ID ) 
ID ( STRING ) ; 

ID ( ) ; 
ID ( ) ; 

ID ( ID = ID ( STRING , ID ) ) ;  
if ( ID ( ) != INTEGER ) 
ID ( ID , STRING , ID ( ) == INTEGER ? STRING : STRING , ID ) ;  
ID ( ID , sizeof ( ID ) ) ; 
} 
} 

ID = ID [ INTEGER ] ;  

ID ( ID , ID ) ; 
if ( ID != ID ) 
{ 
ID * ID ; 

if ( * ID == STRING )  
ID = STRING ; 
ID = ID ( ( ID = ID ( ID , STRING ) ) , STRING ) ; 

if ( ID == ID ) 
ID ( ID , STRING , ID ) ; 

if ( ID ) 
ID ( ID , STRING , ID ) ; 

ID ( ID ) ; 
ID ( ID , ID , ID , ID ) ; 
ID ( ID ) ; 
ID ( ID ) ; 
} 

ID ( ID ) ; 
if ( ID ) 
{ 
ID ( INTEGER ) ; 
ID ( ) ; 

} 
ID ( ) ; 
if ( ID ) 
{ 
ID = ID ( ) ; 
ID ( ID , STRING , ( ( double ) ( ID - ID ) ) / ID ) ; 
} 
return ID ; 
} 

 
 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
 

typedef struct ID { unsigned ID ; ID ID ; } ID ; 

typedef struct ID { ID ID ; 
struct ID * ID ; 
} ID ; 

static void * ID ; 
static ID ID = ID ; 
static ID ID = ID ; 

static ID * ID ( int ID , ID * ID , ID * ID , ID * ID ) 
{ 
ID ID = { INTEGER , ID } ; 
ID * ID ; 

 
ID ( STRING , 
ID -> ID , 
ID -> ID ) ; 
ID ( ID , ID , INTEGER ) ; 
ID ( STRING ) ; 
 

ID . ID = ID -> ID ; 
ID ( & ID . ID , ID ) ; 

ID = ( ID * ) ID ( ID , & ID , ID ) ; 

if ( ID == ID )  
{ 
void * ID ; 

ID = ( ID * ) ID ( ID , 
& ID , 
sizeof ( ID ) , 
sizeof ( ID ) ) ; 

ID -> ID = ( ID * ) ID ( sizeof ( ID ) , ID -> ID ) ; 
ID -> ID -> ID . ID = ID -> ID ; 
ID ( & ID -> ID -> ID . ID , ID ) ; 

if ( ID == ID -> ID -> ID ) 
ID ( ID -> ID , ID -> ID ) ; 

ID ( & ID -> ID , ID ( ID -> ID ) ) ; 

for ( ID = ID ( ID -> ID ) ; 
ID != ID ; 
ID = ID ( ID ) ) 
{ 
ID * ID = ( ID * ) ID ( ID ) ; 
void * ID ; 

ID * ID = ( ID * ) ID ( sizeof ( ID ) , ID -> ID ) ; 

( ( ID * ) ID ( sizeof ( ID ) , ID , ID -> ID ) ) -> ID = 
ID ( ID -> ID -> ID , ID , ID ) ; 

ID -> ID . ID = ID ; 
ID ( & ID -> ID . ID , ID ) ; 

 
ID ( STRING ) ; 
ID ( ID , ID , INTEGER ) ; 
ID ( STRING ) ; 
 

for ( ID = ID ( ID ) ; 
ID != ID ; 
ID = ID ( ID ) ) 
{ 
ID * ID = ( ID * ) ID ( ID ) ; 

if ( ID -> ID -> ID != ID ) 
{ 
ID * ID = ( ID * ) ID ( sizeof ( ID ) , ID -> ID ) ; 
ID * ID = ( ID * ) ID ( sizeof ( ID ) , ID , ID ) ; 

 
ID ( STRING ) ; 
ID ( ID , ID , INTEGER ) ; 
ID ( STRING ) ; 
 

ID -> ID . ID = ID ; 
ID ( & ID -> ID . ID , ID ) ; 

ID -> ID = ID -> ID ; 

if ( ID -> ID -> ID == ID ) 
{  

if ( ID == ID ) 
( ( ID * ) ID ( sizeof ( ID ) , ID ( ID , ID , ID -> ID , & ID ) , ID ) ) -> ID = 
ID ( ID -> ID -> ID , ID , ID ) ; 
else if ( ID == ID ) 
{ 
ID ID = ID ; 

ID ( & ID , & ID -> ID -> ID ) ; 
ID ( & ID , & ID ) ; 

( ( ID * ) ID ( sizeof ( ID ) , ID ( ID , ID , ID -> ID , & ID ) , ID ) ) -> ID = 
ID ( ID -> ID -> ID , ID , ID ) ; 

ID ( & ID ) ; 
} 
else if ( ID == ID ) 
{ 
ID ID = ID ; 
ID ID = ID ; 
unsigned * ID ; 
unsigned * ID ; 
void * ID ; 
int ID = INTEGER ; 

 
for ( ID = ID ( ID ) ; ID != ID ; ID = ID ( ID ) ) 
{ 
ID ( & ID , & ( ( ID * ) ID ( ID ) ) -> ID -> ID ) ; 
if ( ! ID ( & ( ( ID * ) ID ( ID ) ) -> ID -> ID , ID ) ) 
{ 
ID = INTEGER ; 
break ; 
} 
} 

if ( ID ) 
ID ( & ID , ID ) ; 

ID = ID ( & ID ) ; 
for ( ID = ID ; 
* ID != ID ; 
ID ++ ) 
{ 
ID * ID = ID ( ID -> ID -> ID , * ID ) ; 

ID ( & ID , * ID ) ; 

if ( ID -> ID == ID || ID -> ID == ID ) 
( ( ID * ) ID ( sizeof ( ID ) , ID ( ID , ID , ID -> ID , & ID ) , ID ) ) -> ID = 
ID ( ID -> ID -> ID , ID , ID ) ; 
} 
ID ( & ID ) ; 
ID ( ID ) ; 
} 
} 
ID = ID ; 
} 
} 
ID ( & ID -> ID , ID ( ID ) ) ; 
} 
 
ID ( STRING ) ; 
 
} 
 
else 
ID ( STRING ) ; 
 

return ID -> ID ; 
} 

ID * ID ( ID * ID , enum ID ID ) 
{ 
ID * ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 
ID ID = ID ; 

ID -> ID = ID ( ID ) ; 
ID -> ID = ID ; 
ID -> ID = ID ; 

ID ( ID -> ID -> ID , ID , ID ) -> ID = ID ; 

ID -> ID = ID ( STRING ) ; 

ID = ID ( STRING , INTEGER , INTEGER , ID , ID , ID ) ; 

if ( ID == ID ) 
{  
unsigned ID ; 

ID ( & ID , ID ) ;  

for ( ID = INTEGER ; ID < ID ( ID ) ; ID ++ ) 
if ( ID ( ID -> ID , ID ) -> ID == ID ) 
ID ( & ID , ID ) ; 

ID ( & ID , ID ) ; 
} 

if ( ID == ID ) 
{  
unsigned ID ; 

ID ( & ID , ID ) ;  

for ( ID = INTEGER ; ID < ID ( ID ) ; ID ++ ) 
if ( ID ( ID -> ID , ID ) -> ID == ID ) 
ID ( & ID , ID ) ; 
} 

ID ( & ID , ID ) ; 

ID ( ID , ID , ID -> ID -> ID , & ID ) ; 

ID ( ID -> ID ) ; 
ID ( ID ) ; 
ID ( & ID ) ; 

return ID ; 
} 

 
static void * ID ; 

static ID * ID ( int ID , ID * ID , ID * ID ) 
{ 

} 

ID * ID ( ID * ID , int ID ) 
{ 
ID * ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 

ID -> ID = ID ( ID ) ; 
ID -> ID = ID ; 

ID ( ID -> ID -> ID , ID , ID ) -> ID = ID ; 

ID -> ID = ID ( STRING ) ; 

ID = ID ( STRING , INTEGER , INTEGER , ID , ID , ID ) ; 

ID ( ID , ID , ID -> ID -> ID ) ; 

ID ( ID -> ID ) ; 

return ID ; 
} 

 

static ID * ID ; 

void ID ( const void * ID ) 
{ 
if ( ID -> ID == ID )  
ID ( STRING , ID ) ;  
} 

void ID ( const void * ID ) 
{ 
ID * ID = ( ID * ) ID ; 

ID ( STRING , ID ( ID ) ) ; 

switch ( ID -> ID ) 
{ 
case ID : 
{ 
unsigned * ID , 
* ID = ID ( & ( ID -> ID . ID -> ID ) ) ; 

for ( ID = ID ; * ID != ID ; ID ++ ) 
{ 
ID * ID = ( ID * ) ( ID ( ID -> ID -> ID ) [ * ID ] ) ; 

if ( ! ID ( & ID -> ID -> ID , ID ( ID ) ) ) 
{ 
ID ( STRING , * ID ) ; 
ID ( ID -> ID . ID , INTEGER ) ; 

ID ( STRING ) ; 
ID ( & ID -> ID . ID , ID , INTEGER ) ; 
ID ( STRING ) ; 

if ( ID ( & ID -> ID -> ID , ID ( ID ) ) ) 
ID ( STRING , ID ( ID -> ID . ID ) ) ; 
} 
} 
} 
break ; 

case ID : 
{ 
unsigned * ID , 
* ID = ID ( & ( ID -> ID . ID -> ID ) ) ; 

for ( ID = ID ; * ID != ID ; ID ++ ) 
{ 
ID ( STRING , * ID ) ; 
ID ( ( ID * ) ( ID ( ID -> ID -> ID ) [ * ID ] ) , INTEGER ) ; 
} 
} 
break ; 

case ID : 
{ 
if ( ID ( & ID -> ID , ID ( ID ) ) ) 
ID ( STRING , ID -> ID . ID -> ID -> ID ) ; 
else 
ID ( ID -> ID . ID , INTEGER ) ; 

ID ( STRING ) ; 
ID ( & ID -> ID . ID , ID , INTEGER ) ; 
ID ( STRING ) ; 
} 
break ; 

default : 
ID ( ID , STRING ) ; 
} 

ID ( STRING ) ; 

ID ( STRING , 
ID ( & ID -> ID , ID ( ID ) ) ? STRING : 
ID ( & ID -> ID , ID ( ID ) ) ? STRING : STRING ) ; 
} 

void ID ( const void * ID ) 
{ 
ID * ID = ( ID * ) ID ; 

if ( ID ( & ID -> ID , ID ( ( ID * ) ID ( ID ) ) ) ) 
ID ( STRING ) ; 
else if ( ID ( & ID -> ID , ID ( ( ID * ) ID ( ID ) ) ) ) 
ID ( STRING ) ; 
else 
{ 
ID ( STRING ) ; 
ID ( ID -> ID ) ; 
ID ( STRING ) ; 
} 
} 

void ID ( ID * ID , ID * ID ) 
{ 
ID * ID = ID ( ) ; 

ID ( ID ) ; 
ID = ID ; 
ID ( ID -> ID ) ; 
ID ( ID -> ID , ID , ID , ID ) ; 
ID ( ID ) ; 
} 

ID * ID ( ID * ID ) 
{ 
return ID ; 
} 

typedef struct ID 
{ 
ID * ID ; 
struct ID * ID ; 
} ID ; 

static ID ID = ID ; 
static ID ID = ID ; 
static ID ID = ID ; 
static ID ID = ID ; 
static ID ID = ID ; 

static void ID ( ID * ID ) 
{ 
ID * ID ; 

if ( ID ( & ( ID -> ID . ID ) ) != INTEGER ) 
{ 
ID ( & ID , & ( ID -> ID . ID ) ) ; 
return ; 
} 

if ( ID ( & ID , ID ( ID ) ) ) 
return ; 

ID ( & ID , ID ( ID ) ) ; 

for ( ID = ( ID * ) ID ( ID ) ; 
ID != ID ; 
ID = ( ID * ) ID ( ID ) ) 
if ( ID -> ID -> ID == ID ) 
ID ( ( ID * ) ID ( ID ) ) ; 
} 

 
static void ID ( ID * ID , unsigned ID ) 
{ 
unsigned ID ;  
unsigned ID ;  

 
ID ( STRING , ID ) ; 
ID ( & ID , ID , INTEGER ) ; 
ID ( STRING ) ; 
 

 
for ( ID = INTEGER , ID = INTEGER ; ID < ID . ID ; ID ++ )  
{ 
unsigned ID ;  
unsigned ID = ID . ID [ ID ] ;  

for ( ID = INTEGER ; ID < INTEGER ; ID <<= INTEGER )  
{ 
if ( ( ID & ID ) != INTEGER )  
{ 
ID * ID ; 

for ( ID = ( ID * ) ID ( ID ( ID -> ID ) [ ID ] ) ; 
ID != ID ; 
ID = ( ID * ) ID ( ID ) ) 
if ( ID -> ID -> ID == ID ) 
{ 
ID * ID = ( ID * ) ID ( ID ) ; 

if ( ID ( & ID -> ID . ID ) != INTEGER ) 
ID ( & ID , & ( ( ( ID * ) ID ( ID ) ) -> ID . ID ) ) ; 
else 
{ 
ID ( & ID ) ; 
ID ( ID ) ; 
ID ( & ID , & ID ) ; 
} 

} 
} 
ID ++ ; 
} 
} 
} 

 
static ID * ID ( void * ID , ID * * ID , ID * ID ) 
{ 
ID * ID = ( ID * ) ID ( ID , & ID , ID ) ; 

 
ID ( STRING ) ; 
ID ( & ID , ID , INTEGER ) ; 
ID ( STRING ) ; 
if ( ID == ID ) 
ID ( STRING ) ; 
else 
ID ( STRING ) ; 
 

if ( ID == ID ) 
{ 
ID * ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 
ID ID = ID ; 

 
ID ( & ID , & ID ) ; 

 
ID = ( ID * ) ID ( ID , & ID , sizeof ( ID ) , sizeof ( ID ) ) ; 

 
ID -> ID = ( ID * ) ID ( sizeof ( ID ) , ID -> ID ) ; 
ID -> ID -> ID . ID = ID ; 

 
ID -> ID = ID ; 
ID -> ID = * ID ; 
* ID = ID ; 

 
ID ( & ID , & ID ) ; 
if ( ID ( & ID ) != INTEGER ) 
ID ( & ID -> ID , ID ( ID -> ID ) ) ; 
} 

return ID ; 
} 

ID * ID ( ID * ID ) 
{ 
ID * ID ; 

for ( ID = ( ID * ) ID ( ID -> ID ) ; ID != ID ; ID = ( ID * ) ID ( ID ) ) 
if ( ID ( & ID -> ID , ID ( ID ) ) ) 
{ 
ID * ID ; 
ID * ID = ID ; 

do 
{ 
 
for ( ID = ( ID * ) ID ( ID ) ; 
ID != ID && ID -> ID -> ID == ID ; 
ID = ( ID * ) ID ( ID ) ) 
; 

 
if ( ID != ID ) 
{ 
if ( ID ( & ID -> ID -> ID , ID ) ) 
{ 
ID = ( ID * ) ID ( ID ) ; 
ID ( & ID -> ID , ID ( ID ) ) ; 
} 
else 
ID = ID ;  
} 
} 
while ( ID != ID ) ; 
} 
return ID ; 
} 

struct ID { ID * ID ; unsigned ID ; } ; 

int ID ( const void * ID , const void * ID ) 
{ 
struct ID * ID = ( struct ID * ) ID ; 
struct ID * ID = ( struct ID * ) ID ; 

if ( ID -> ID < ID -> ID ) 
return - INTEGER ; 
else if ( ID -> ID == ID -> ID ) 
return INTEGER ; 
else 
return INTEGER ; 
} 

ID * ID ( ID * ID ) 
{ 
ID * ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 

ID ID = ID ( ) , ID ; 
ID * ID = ID ; 
void * ID ; 
ID * ID ; 
unsigned ID ;  
unsigned ID ;  
unsigned ID = ID ( ID -> ID ) ; 
ID * ID = ID ; 
ID * ID = ID ; 

 
ID ( STRING , ID ) ; 
for ( ID = INTEGER ; ID <= ID ; ID ++ ) 
{ 
ID * ID = ( ID * ) ID ( ID -> ID ) [ ID ] ; 
ID ( STRING , ID , ID ) ; 
if ( ID != ID ) 
{ 
if ( ID ( & ID -> ID , ID ( ID ) ) ) 
ID ( STRING , ID -> ID . ID -> ID -> ID ) ; 
else 
ID ( ID -> ID . ID , INTEGER ) ; 
} 
else ID ( STRING ) ; 
ID ( STRING ) ; 
} 
 

ID = ID ( ) ; 
ID ( ID , STRING , ( ( double ) ( ID - ID ) ) / ID ) ; 

 
ID -> ID = ID ( STRING ) ; 
ID -> ID = ID ( ID -> ID ) ; 
ID -> ID = ID -> ID ; 
ID -> ID = ID ; 
ID -> ID = ID ( ID ) ; 
ID = ID ( STRING , INTEGER , INTEGER , ID , ID , ID ) ; 

 
ID ( & ID , ID ) ; 
ID ( & ID , ID ) ; 
ID ( & ID , ID ) ; 
ID ( & ID , ID ( ID -> ID ) - INTEGER ) ; 
ID ( & ID , ID ) ; 

 
ID ( & ID , & ID -> ID ) ; 

 
{ 
unsigned ID = INTEGER ; 
unsigned * ID = ID ( ID -> ID , INTEGER ) ; 
struct ID * ID ; 

ID = ID ( ) ; 
ID ( ID , STRING , ( ( double ) ( ID - ID ) ) / ID ) ; 

 
for ( ID = ( ID * ) ID ( ID -> ID ) ; ID != ID ; ID = ( ID * ) ID ( ID ) ) 
if ( ID ( & ID -> ID , ID ( ID ) ) ) 
ID ++ ; 

ID ( STRING , ID ) ; 

 
ID = ( struct ID * ) ID ( ID * sizeof ( struct ID ) ) ; 

 
ID = INTEGER ; 
for ( ID = ( ID * ) ID ( ID -> ID ) ; ID != ID ; ID = ( ID * ) ID ( ID ) ) 
if ( ID ( & ID -> ID , ID ( ID ) ) ) 
{ 
ID [ ID ] . ID = ID ; 
ID [ ID ] . ID = ID [ ID ( ID ) ] ; 
ID ++ ; 
} 

 
ID ( ID ) ; 

 
ID ( ID , ID , sizeof ( struct ID ) , ID ) ; 

ID ( & ID ) ; 
ID ( & ID ) ; 

for ( ID = ( ID * ) ID ( ID -> ID ) ; ID != ID ; ID = ( ID * ) ID ( ID ) ) 
if ( ID ( & ID -> ID , ID ( ID ) ) ) 
{ 
ID ( & ID ) ; 
ID ( ID ) ; 
ID ( ID , ID ( & ID ) ) ; 
ID ( ID , ID ( & ID ) ) ; 
ID ( & ID -> ID . ID , & ID ) ; 
} 
} 

ID = ID ( ) ; 
ID ( ID , STRING , ( ( double ) ( ID - ID ) ) / ID ) ; 

 
 
ID ( STRING , ID , ID == INTEGER ? STRING : STRING ) ; 

ID ( STRING , ID * sizeof ( unsigned * ) ) ; 
ID ( STRING , ( ID ( ID ) - ID ( ID , INTEGER ) ) * sizeof ( unsigned ) ) ; 
ID ( STRING , ID ( ID ) * sizeof ( unsigned ) ) ; 
ID ( ID ) ; 

ID ( STRING , ID * sizeof ( ID ) ) ; 
ID ( STRING , ID ( ID ) ) ; 
ID ( ID ) ; 
 
ID ( & ID ) ; 
ID ( & ID ) ; 

 
ID ( & ID , & ( ( ( ID * ) ID ( ID -> ID ) ) -> ID . ID ) ) ;  
ID ( ID -> ID , ID ( ID , & ID , ID ) -> ID ) ; 

while ( ID != ID ) 
{ 
 
ID * ID = ID ; 
ID ID = ID -> ID -> ID ; 
ID = ID -> ID ; 

 
ID ( & ID ) ; 
for ( ID = INTEGER , ID = INTEGER ; ID < ID . ID ; ID ++ )  
{ 
unsigned ID ;  
unsigned ID = ID . ID [ ID ] ;  

for ( ID = INTEGER ; ID < INTEGER ; ID <<= INTEGER )  
{ 
if ( ( ID & ID ) != INTEGER )  
{ 
ID * ID ; 

for ( ID = ( ID * ) ID ( ID ( ID -> ID ) [ ID ] ) ; 
ID != ID ; 
ID = ( ID * ) ID ( ID ) ) 
ID ( & ID , ID -> ID -> ID ) ; 
} 
ID ++ ; 
} 
} 

 
ID ( & ID , ID ) ; 

 
for ( ID = INTEGER , ID = INTEGER ; ID < ID . ID ; ID ++ )  
{ 
unsigned ID ;  
unsigned ID = ID . ID [ ID ] ;  

for ( ID = INTEGER ; ID < INTEGER ; ID <<= INTEGER )  
{ 
if ( ( ID & ID ) != INTEGER )  
{ 
ID ( & ID ) ; 
ID ( & ID , & ID ) ; 

ID ( ID , ID ) ; 

( ( ID * ) ID ( sizeof ( ID ) , 
ID ( ID , & ID , ID ) -> ID , 
ID -> ID -> ID ) ) -> ID = ID ( ID -> ID -> ID , ID ) ; 
} 
ID ++ ; 
} 
} 
ID ( ID ) ; 
} 

ID ( ID -> ID ) ; 

ID = ID ( ) ; 
ID ( ID , STRING , ( ( double ) ( ID - ID ) ) / ID ) ; 

return ID ; 
} 

typedef struct ID { ID ID ; 
struct ID * ID ; 
struct ID * ID ; 
} ID ; 

static ID * ID ( void * ID , ID ID , ID * ID ) 
{ 
ID * ID ; 

ID = ( ID * ) ID ( ID , & ID , ID ) ; 

 
ID ( STRING ) ; 
ID ( & ID , ID , INTEGER ) ; 
ID ( STRING ) ; 
if ( ID == ID ) 
ID ( STRING ) ; 
else 
ID ( STRING ) ; 
 

if ( ID == ID ) 
{ 
ID ID = ID ; 

ID ( & ID , & ID ) ; 

 
ID = ( ID * ) ID ( ID , & ID , sizeof ( ID ) , sizeof ( ID ) ) ; 

 
ID -> ID = ( ID * ) ID ( sizeof ( ID ) , ID -> ID ) ; 
ID -> ID -> ID . ID = ( ID * ) ID ; 
} 

return ID ; 
} 

ID * ID ( void * ID , ID * ID , ID * ID ) 
{ 
static ID ID = ID ; 
unsigned * ID = ID ( & ID -> ID . ID -> ID ) ; 
unsigned * ID = ID ; 

ID ( & ID ) ; 

while ( * ID != ID ) 
{ 
ID * ID = ( ID * ) ID ( ID -> ID -> ID ) [ * ID ++ ] ; 

if ( ! ID ( & ID -> ID , ID ( ID ) ) ) 
{ 
 
ID ( STRING , ID ( ID -> ID ) , ID ( ID ) ) ; 
 

ID ( & ID , ID ( ID -> ID . ID ) ) ; 
} 
} 
ID ( ID ) ; 

return ID ( ID , ID , ID ) ; 
} 

ID * ID ( ID * ID ) 
{ 

void * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 

 
 
ID -> ID = ID ( STRING ) ; 
ID -> ID = ID ( ID -> ID ) ; 
ID -> ID = ID ( ID -> ID ) ; 
ID -> ID = ID -> ID ; 
ID -> ID = ID ; 
ID = ID ( STRING , INTEGER , INTEGER , ID , ID , ID ) ; 

 
for ( ID = ( ID * ) ID ( ID -> ID ) ; ID != ID ; ID = ( ID * ) ID ( ID ) ) 
{ 
ID * ID = ID ( ID , ID , ID ) ; 

 
ID ( STRING , ID ( ID ) ) ; 
 

if ( ID ( & ID -> ID , ID ( ID ) ) ) 
ID ( & ID -> ID , ID ( ID -> ID ) ) ; 

if ( ID ( ID ) == INTEGER ) 
ID ( ID -> ID , ID -> ID ) ; 
} 

 
for ( ID = ( ID * ) ID ( ID -> ID ) ; 
ID != ID ; 
ID = ( ID * ) ID ( ID ) ) 
{ 
ID * ID = ID ( ID , ID , ID ) -> ID ; 

for ( ID = ( ID * ) ID ( ID ) ; 
ID != ID ; 
ID = ( ID * ) ID ( ID ) ) 
{ 
ID * ID = ID ( ID , ( ID * ) ID ( ID ) , ID ) -> ID ; 
ID * ID ; 
int ID = INTEGER ; 

for ( ID = ( ID * ) ID ( ID ) ; ID != ID ; ID = ( ID * ) ID ( ID ) ) 
if ( ID ( ID ) == ID && ID -> ID -> ID == ID -> ID -> ID ) 
{ 
ID = INTEGER ; 
break ; 
} 

if ( ! ID ) 
( ( ID * ) ID ( sizeof ( ID ) , ID , ID ) ) -> ID = ID -> ID ; 
} 
} 

 
ID ( ID -> ID ) ; 

return ID ; 
} 

 
 
 
 
 
 
 
 

ID * ID ( ID * ID ) 
{ 
void * ID ; 
ID * ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 
ID * * ID = ( ID * * ) ID ( ID ( ID ) , sizeof ( ID * ) ) ; 

ID -> ID = ID ( STRING ) ; 

ID -> ID = ID ( ID ) ; 

 
for ( ID = ID ( ID ( ID -> ID ) ) ; 
ID != ID ; 
ID = ID ( ID ) ) 
{ 
ID * ID = ( ID * ) ID ( ID ) ; 

ID * ID = ( ID * ) ID ( sizeof ( ID ) , ID -> ID ) ; 

ID -> ID = ID -> ID ; 
ID [ ID -> ID -> ID ] = ID ; 

if ( ID == ID -> ID -> ID ) 
ID ( ID -> ID , ID ) ; 
} 

 
for ( ID = ID ( ID ( ID -> ID ) ) ; 
ID != ID ; 
ID = ID ( ID ) ) 
{ 
ID * ID = ( ID * ) ID ( ID ) ; 
void * ID ; 

for ( ID = ID ( ID ) ; 
ID != ID ; 
ID = ID ( ID ) ) 
{ 
ID * ID = ( ID * ) ID ( ID ) ; 
void * ID ; 

for ( ID = ID ( ID ) ; 
ID != ID ; 
ID = ID ( ID ) ) 
{ 
ID * ID = ( ID * ) ID ( ID ) ; 

if ( ID -> ID -> ID == ID ) 
{ 
ID * ID = ID [ ID -> ID -> ID ] ; 
ID * ID = ID [ ID -> ID -> ID ] ; 
void * ID ; 
int ID = INTEGER ; 

 
if ( ID ( ID ) == ID ) 
{ 
ID = INTEGER ; 
break ; 
} 

if ( ! ID ) 
ID ( INTEGER , ID , ID ) ; 
} 
} 
} 
} 
ID ( ID ) ; 

return ID ; 
} 

static unsigned * ID ; 
static ID * ID ; 

static void ID ( const void * ID ) 
{ 
ID * ID = ( ID * ) ID ; 

ID ( STRING , ID -> ID -> ID , ID [ ID ( ID ) ] , ID [ ID ( ID ) ] ) ; 
} 

void ID ( ID * ID , ID * ID ) 
{ 

ID = ID ; 
ID = ID ( ID -> ID , INTEGER ) ; 

ID ( ID ) ; 
ID ( ID -> ID , ID , ID , ID ) ; 
ID ( ID ) ; 

ID ( ID ) ; 
} 

 
 
 
 
 
 
 
 
 
 

static int ID ( ID * ID , unsigned * ID ) 
{ 
int ID = INTEGER ; 

while ( * ID != INTEGER ) 
ID |= ID ( ID -> ID , * ID ++ ) -> ID == ID ; 

return ID ; 
} 

static void ID ( ID * ID , unsigned * ID , unsigned ID , int ID ) 
{ 
unsigned ID = INTEGER ; 

if ( * ID == INTEGER ) 
{ 
if ( ID ) 
ID ( STRING ) ; 
else 
ID ( STRING , ID ) ; 
} 
else 
while ( * ID != INTEGER ) 
if ( ID ) 
{ 
ID += ID ( STRING , ID ( ID -> ID , * ID ++ ) -> ID ) ; 

if ( ID > ID - INTEGER && & ID != INTEGER ) 
{ 
ID ( STRING ) ; 
ID = INTEGER ; 
} 
} 
else 
{ 
ID ( ID ) ; 
ID += ID ( * ID ++ ) ; 
ID ( STRING ) ; 
} 

ID ( STRING ) ; 
} 

void ID ( ID * ID , unsigned long ID , int ID ) 
{ 
typedef struct ID 
{ 
unsigned * ID ; 
struct ID * ID ; 
} ID ; 
ID * ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 
ID * ID = ID ; 
ID * ID ; 
unsigned long ID = INTEGER ; 

ID ( STRING , ID ? STRING : STRING ) ; 

 
ID -> ID = ( unsigned * ) ID ( INTEGER , sizeof ( unsigned ) ) ; 
* ( ID -> ID ) = ID -> ID -> ID ; 

do 
{ 
ID = ID ; 

 
if ( ! ( ID ( ID , ID -> ID ) && ! ID ) ) 
{ 
ID ( STRING , ID ++ ) ; 
ID ( ID , ID -> ID , INTEGER , ! ID ) ; 
} 

 
if ( ID ( ID , ID -> ID ) ) 
{ 
unsigned * ID = ID -> ID ; 
ID ID = INTEGER , 
ID = INTEGER ; 
unsigned ID ; 
void * ID , 
* ID ; 

 
while ( ID ( ID -> ID , * ID ++ ) -> ID != ID ) 
ID ++ ; 

ID = ID -> ID [ ID ] ; 

 
while ( * ID ++ != INTEGER ) 
ID ++ ; 

 
for ( ID = ID ( ID ( ID -> ID , ID ) -> ID ) ; 
ID != ID ; 
ID = ID ( ID ) 
) 
{ 
unsigned ID = INTEGER ; 
ID ID ; 
unsigned * ID , 
* ID ; 

 
for ( ID = ID ( ID ( ID ) ) ; 
ID != ID ; 
ID = ID ( ID ) 
) 
if ( ( ( ID * ) ID ( ID ) ) -> ID -> ID != ID ) 
ID ++ ; 

 
ID -> ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 
ID = ID -> ID ; 

 
ID -> ID = ( unsigned * ) ID ( ID + ID + ID + INTEGER , sizeof ( unsigned ) ) ; 

 
for ( ID = INTEGER , ID = ID -> ID , ID = ID -> ID ; 
ID < ID ; 
ID ++ ) 
* ID ++ = * ID ++ ; 

 
for ( ID = ID ( ID ( ID ) ) ; 
ID != ID ; 
ID = ID ( ID ) 
) 
{ 
ID * ID = ( ID * ) ID ( ID ) ; 

if ( ID -> ID -> ID != ID ) 
* ID ++ = ID -> ID -> ID ; 
} 

 
for ( ID = INTEGER , ID ++ ; 
ID < ID ; 
ID ++ ) 
* ID ++ = * ID ++ ; 
} 
} 

 
ID = ID -> ID ; 
ID ( ID -> ID ) ; 
ID ( ID ) ; 
} 
while ( ID != ID && ( ID == INTEGER || ID <= ID ) ) ; 
} 

 
 
 
 
 
 
 
 
 
 

 
 

 
static ID * ID ; 

ID * ID ( void * ID , char * ID , int ID ) 
{ 
ID * ID ; 
struct ID { int ID ; char * ID ; } ID ; 

ID . ID = ID ; 
ID . ID = ID ; 

if ( ( ID = ( ID * ) ID ( ID , & ID , ID ) ) == ID ) 
{ 
ID = ( ID * ) ID ( ID , & ID , sizeof ( struct ID ) , sizeof ( ID ) ) ; 
ID -> ID = ID ( ID ) ; 
} 

return ID ; 
} 

ID * ID ( void * ID , unsigned ID ) 
{ 
 
ID * ID ; 

for ( ID = ( ID * ) ID ( ID ( ID ) ) ; 
ID != ID ; 
ID = ( ID * ) ID ( ID ) 
) 
if ( ID -> ID == ID ) 
return ID ; 

return ID ; 
} 

int ID ( ID * ID ) 
{ 
if ( ID == ID ) 
return ID ( STRING ) ; 
else 
return ID ( STRING , ID -> ID == ID ? STRING : STRING , 
ID -> ID , 
ID -> ID == ID ? STRING : STRING 
) ; 
} 

void ID ( ID * ID , unsigned ID , int ID ) 
{ 
unsigned ID = ID ( ID ) ; 
unsigned ID ; 
int ID = INTEGER ; 

for ( ID = ID ; ID < ID ; ID ++ ) 
{ 
ID * ID = ID ( ID -> ID , ID ) ; 

if ( ID != ID ) 
{ 
if ( ID -> ID != ID && ! ID ) 
{ 
if ( ID ) 
ID ( STRING ) ; 
ID = INTEGER ; 
} 
if ( ID ) 
ID ( STRING , ID ) ; 
else 
ID ( STRING , ID ) ; 

ID ( ID ) ; 
ID ( STRING ) ; 
} 
} 
} 

static void ID ( ID * ID ) 
{ 
void * ID , 
* ID , 
* ID ; 
ID * ID , 
* ID ; 

for ( ID = ID ( ( ID * ) ID ( ID -> ID ) ) ; 
ID != ID ; 
ID = ID ( ID ) ) 
{ 
ID = ( ID * ) ID ( ID ) ; 

ID ( ID -> ID ) ; 

ID ( STRING ) ; 

for ( ID = ID ( ID ) ; 
ID != ID ; 
ID = ID ( ID ) ) 
{ 
ID = ( ID * ) ID ( ID ) ; 

for ( ID = ID ( ID ) ; 
ID != ID ; 
ID = ID ( ID ) ) 
{ 
ID ( STRING ) ; 
ID ( ( ( ID * ) ID ( ID ) ) -> ID ) ; 
} 

if ( ID ( ID ) == ID ) 
ID ( STRING ) ; 
else ID ( STRING ) ; 
} 
} 
} 

static void ID ( ID * ID ) 
{ 
ID * ID ; 
ID ID = ID ; 

ID ( & ID , & ( ID -> ID ) ) ; 
ID ( & ID , ID ( ID ) - INTEGER ) ; 
ID ( & ID , ID , ID , ID , ID ) ; 

ID ( STRING ) ; 
ID ( ID , ID -> ID , INTEGER ) ; 
ID ( STRING ) ; 
ID ( ID , ID , INTEGER ) ; 
ID ( STRING ) ; 

ID ( & ID ) ; 

for ( ID = ( ID * ) ID ( ID ( ID -> ID ) ) ; 
ID != ID ; 
ID = ( ID * ) ID ( ID ) ) 
if ( ID -> ID == ID || ID -> ID == ID ) 
{ 
ID ( STRING ) ; 
ID ( ID ) ; 
ID ( STRING ) ; 
ID ( ID , ID -> ID , INTEGER ) ; 
ID ( STRING ) ; 
ID ( ID ) ; 
ID ( STRING ) ; 
ID ( ID , ID -> ID , INTEGER ) ; 
ID ( STRING ) ; 
} 
} 

 
static int ID ( ID * ID , int ID ) 
{ 
if ( ID ( ID , ID ) ) 
return INTEGER ; 

ID ( ID , ID ) ; 
return INTEGER ; 
} 

static int ID ( ID * ID , ID * ID ) 
{ 
if ( ID ( ID , ID ) ) 
return INTEGER ; 

ID ( ID , ID ) ; 
return INTEGER ; 
} 
 

static ID * ID ( ID * ID ) 
{ 
ID * ID = ( ID * ) ID ( sizeof ( ID ) , ID ) ; 

ID ( INTEGER , ID , ID ) ; 

return ID ; 
} 

static void ID ( ID * ID ) 
{ 
 
ID * ID ; 

 
unsigned ID = ID + INTEGER ; 

 
ID ( ID -> ID , ID ( ID -> ID ) ) ; 

 
for ( ID = ( ID * ) ID ( ID ( ID -> ID ) ) ; 
ID != ID ; 
ID = ( ID * ) ID ( ID ) ) 
if ( ID -> ID == ID ) 
ID -> ID = ID ++ ;  

 
for ( ID = ( ID * ) ID ( ID ( ID -> ID ) ) ; 
ID != ID ; 
ID = ( ID * ) ID ( ID ) ) 
if ( ID -> ID == ID ) 
ID -> ID = ID ++ ;  
} 

static ID * ID ( ID * ID ) 
{ 
ID * ID = ID -> ID -> ID ; 
void * ID = ID ( ID ) ; 
ID * ID = ( ID * ) ID ( ID ) ; 
void * ID = ( ID * ) ID ( ID ) ; 
ID * ID = ( ID * ) ID ( ID ) ; 

if ( ID -> ID -> ID == ID && 
ID ( ID ) == ID && 
ID ( ID ) == ID ) 
return ID ; 
else 
{ 
char * ID ; 
ID * ID = ( ID * ) ID ( sizeof ( ID ) , ID -> ID ) ; 
ID * ID = ( ID * ) ID ( sizeof ( ID ) , ID -> ID ) ; 
ID * ID = ( ID * ) ID ( sizeof ( ID ) , ID -> ID ) ; 

ID ( INTEGER , ID , ID ( ID -> ID ) ) ; 
ID ( INTEGER , ID , ID ) ; 
ID ( INTEGER , ID , ID ) ; 

ID = ( char * ) ID ( ID ( ID -> ID -> ID ) + ID ( ID ) + INTEGER , sizeof ( char ) ) ; 
ID ( ID ( ID , ID -> ID -> ID ) , ID ) ; 
ID -> ID = ID ( ID -> ID , ID , ID ) ; 
ID -> ID -> ID = ID ; 

ID -> ID = ID -> ID ; 

ID -> ID = ID -> ID ; 

return ID ; 
} 
} 

static void ID ( ID * ID , ID * ID ) 
{ 
void * ID , 
* ID ; 

if ( ID ( ID , ID -> ID -> ID ) ) 
return ; 


ID ( ID , ID -> ID -> ID ) ; 

for ( ID = ID ( ID ) ; 
ID != ID ; 
ID = ID ( ID ) ) 
for ( ID = ID ( ID ( ID ) ) ; 
ID != ID ; 
ID = ID ( ID ) ) 
{ 
ID * ID = ( ID * ) ID ( ID ) ; 

if ( ID -> ID -> ID == ID ) 
{ 
if ( ID -> ID -> ID != ID ) 
ID ( ID -> ID -> ID , ID ) ; 
else 
ID ( ID , STRING , ID -> ID -> ID , ID -> ID -> ID ) ; 
} 
else if ( ID -> ID -> ID == ID ) 
ID ( ID , ID -> ID -> ID ) ; 
else 
ID ( ID , ID ) ; 
} 
} 

static void ID ( ID * ID ) 
{ 
int ID ; 

do 
{ 
void * ID ; 

ID = INTEGER ; 

for ( ID = ID ( ID ( ID -> ID ) ) ; 
ID != ID ; 
ID = ID ( ID ) ) 
{ 
void * ID ; 
ID * ID = ( ID * ) ID ( ID ) ; 

for ( ID = ID ( ID ) ; 
ID != ID ; 
ID = ID ( ID ) ) 
{ 
void * ID ; 
ID ID = ID ;  
int ID = INTEGER ;  
ID * ID = ( ID * ) ID ( ID ) ; 
ID ( & ID , ID ) ;  

 
for ( ID = ID ( ID ) ; 
ID != ID ; 
ID = ID ( ID ) ) 
{ 
ID * ID = ( ID * ) ID ( ID ) ; 

 
switch ( ID -> ID -> ID ) 
{ 
case ID : 
ID = INTEGER ; 
ID ( & ID , ID -> ID -> ID ) ; 
ID |= ID ( & ID -> ID -> ID , ID -> ID -> ID ) ; 
break ; 
case ID : 
if ( ID ( & ( ID -> ID -> ID ) , ID ) )  
{ 
ID ( & ID , & ( ID -> ID -> ID ) ) ; 
ID ( & ID , ID ) ; 
} 
else 
{ 
ID = INTEGER ; 
ID ( & ID , & ( ID -> ID -> ID ) ) ; 
} 
ID ( & ID , ID -> ID -> ID ) ; 
break ; 
} 
if ( ID ) 
ID |= ID ( & ( ID -> ID -> ID ) , ID ) ; 
} 
ID |= ID ( & ( ID -> ID -> ID ) , & ID ) ; 

if ( ID )  
ID |= ID ( & ( ID -> ID -> ID ) , ID ) ; 
} 
} 
} 
while ( ID ) ; 
} 

static void ID ( ID * ID ) 
{ 
ID * ID ; 
int ID ;  

for ( ID = ( ID * ) ID ( ID ( ID -> ID ) ) ; 
ID != ID ; 
ID = ( ID * ) ID ( ID ) ) 
ID ( & ID -> ID ) ; 

ID ( & ID -> ID -> ID , ID ) ;  

do 
{ 
ID = INTEGER ; 

 
for ( ID = ( ID * ) ID ( ID ( ID -> ID ) ) ; 
ID != ID ; 
ID = ( ID * ) ID ( ID ) ) 
{ 
ID * ID = ID -> ID ; 

if ( ID != ID && ID ( & ( ID -> ID ) ) != INTEGER  ) 
{ 
void * ID ; 

for ( ID = ID ( ID ) ; 
ID != ID ; 
ID = ID ( ID ) ) 
{ 
ID * ID = ID ( ID ) ; 
void * ID ; 

for ( ID = ID ( ID ) ; 
ID != ID ; 
ID = ID ( ID ) ) 
{ 
void * ID ; 
int ID = INTEGER ; 
ID * ID = ID ( ID ) ; 

for ( ID = ID ( ID ) ; 
ID && ID != ID ; 
ID = ID ( ID ) ) 
{ 
ID * ID = ID ( ID ) ; 
ID ID = ID ; 

ID ( & ID , & ID -> ID -> ID ) ; 
ID ( & ID , ID -> ID -> ID ) ; 
if ( ID ( & ID , ID ) ) 
ID ( & ID , ID ) ; 
else 
ID = INTEGER ; 
ID |= ID ( & ID -> ID -> ID , & ID ) ; 
ID ( & ID ) ; 
} 

if ( ID ) 
ID |= ID ( & ( ID -> ID -> ID ) , & ID -> ID ) ; 
} 
} 
} 
} 
} 
while ( ID ) ; 
} 

ID * ID ( ID * ID , ID * ID ) 
{ 
ID * ID ; 
ID * ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 
unsigned ID = INTEGER ; 
unsigned ID = INTEGER ; 

ID -> ID = ID ( STRING , INTEGER , INTEGER , ID , ID , ID ) ; 
ID ( ID -> ID , ID , ID ) -> ID = ID ; 
ID ( ID -> ID , ID , ID ) -> ID = ID ; 
ID ( ID -> ID , ID , ID ) -> ID = ID ; 

ID ( & ( ID ( ID -> ID , ID , ID ) -> ID ) , ID ) ; 
ID -> ID = ID ( STRING ) ; 
ID ( ID -> ID , ( ID * ) ID ( sizeof ( ID ) , ID -> ID ) ) ; 

 
for ( ID = ( ID * ) ID ( ID ) ; ID != ID ; ID = ( ID * ) ID ( ID ) ) 
{ 
ID * ID = ( ID * ) ID ( ID ) ; 
void * ID ; 
ID * ID = ( ID * ) ID ( ( ID * ) ID ( ID -> ID ) ) ; 

ID -> ID = ID ( ID -> ID , ID -> ID , ID ) ; 
ID -> ID -> ID = ID ; 

if ( ID ( ID -> ID , ID -> ID ) == INTEGER ) 
ID -> ID = ID -> ID ; 

ID ++ ; 

for ( ID = ID ( ID ) ; 
ID != ID ; 
ID = ID ( ID ) ) 
{ 
ID * ID = ( ID * ) ID ( ID ) ; 
void * ID ; 
ID * ID = ID ( ID ) ; 

ID ++ ; 

for ( ID = ID ( ID ) ; 
ID != ID ; 
ID = ID ( ID ) ) 
{ 
ID * ID = ( ID * ) ID ( ID ) ; 
ID * ID = ID ( ID ) ; 

switch ( ID -> ID -> ID -> ID ) 
{ 
case ID : 
ID -> ID = ID ( ID -> ID , ID -> ID , ID ) ; 
break ; 
case ID : 
ID -> ID = ID ( ID -> ID , ID -> ID , ID ) ; 
break ; 
case ID : 
ID -> ID = ID ( ID -> ID , ID , ID ) ; 
break ; 
default : 
ID ( ID , STRING ) ; 
} 
} 
} 
} 

ID ( STRING , ID , ID ) ; 
ID ( ID ) ; 

ID ( ID ) ; 

ID ( ID -> ID -> ID , & ( ID -> ID ) ) ; 

ID ( ) ; 

ID ( ID ) ; 
ID ( ID ) ; 

return ID ; 
} 

unsigned ID ( ID * ID ) 
{ 
unsigned ID = INTEGER ; 
ID * ID ; 

for ( ID = ( ID * ) ID ( ID ( ID -> ID ) ) ; 
ID != ID ; 
ID = ( ID * ) ID ( ID ) 
) 
if ( ID -> ID > ID ) 
ID = ID -> ID ; 

return ID + INTEGER ; 
} 

ID * ID ( ID * ID ) 
{ 
return ID ;  
} 

int ID ( ID * ID ) 
{ 
ID * ID , 
* ID ; 

if ( ID -> ID == ID )  
ID = ID ; 
else 
 
ID = ( ID * ) ID ( ID ( ID ) ) ; 

ID = ( ID * ) ID ( ID ( ID ) ) ; 

if ( ID == ID ) 
return INTEGER ; 
else if ( ID -> ID && ID -> ID -> ID == ID ) 
return INTEGER ; 
else 
return INTEGER ; 
} 

ID * ID ( ID * ID ) 
{ 
ID * ID , 
* ID ; 

if ( ID -> ID == ID )  
ID = ID ; 
else 
 
ID = ( ID * ) ID ( ID ( ID ) ) ; 

ID = ( ID * ) ID ( ID ( ID ) ) ; 

if ( ID == ID ) 
return ID ; 
else 
return ID -> ID ; 
} 

ID * ID ( ID * ID ) 
{ 
void * ID ; 

if ( ID == ID ) 
return ID ; 

if ( ID -> ID == ID )  
ID = ID ( ID ) ; 
else 
ID = ID ( ID ( ID ) ) ; 

if ( ID == ID ) 
return ID ; 
else 
return ( ID * ) ID ( ID ) ; 
} 

void ID ( ID * ID , ID * ID ) 
{ 
ID ( ID ) ; 

if ( ID == ID ) 
ID ( ID , ID ) ; 
else 
{ 
ID * ID = ID ( ID ) ; 

if ( ID == ID ) 
ID ( ID , ID ) ; 
else 
while ( ID != ID ) 
{ 
ID ( ID , & ID -> ID -> ID ) ; 
if ( ! ID ( & ID -> ID -> ID , ID ) ) 
{ 
ID ( ID , ID ) ; 
break ; 
} 
ID = ID ( ID ) ; 
} 
} 
} 

int ID ( ID * ID ) 
{ 
ID * ID , 
* ID ; 
int ID = INTEGER ; 

if ( ID -> ID == ID )  
{ 
ID = ID ; 
ID = INTEGER ; 
} 
else 
 
ID = ( ID * ) ID ( ID ( ID ) ) ; 

ID = ( ID * ) ID ( ID ( ID ) ) ; 

if ( ID == ID ) 
return INTEGER ; 
else if ( ID -> ID && ID -> ID -> ID == ID ) 
return INTEGER ; 
else 
return ID ; 
} 

void ID ( ID * ID , int ID ) 
{ 
ID * ID , 
* ID ; 
void * ID ; 

if ( ID -> ID == ID )  
ID = ID ; 
else 
 
ID = ( ID * ) ID ( ID ( ID ) ) ; 

ID = ( ID * ) ID ( ID ( ID ) ) ; 

if ( ID == ID ) 
ID ( STRING ) ; 
else 
ID ( ID -> ID ) ; 
ID ( STRING ) ; 

if ( ID -> ID == ID )  
if ( ID ) 
ID ( STRING ) ; 
else 
ID ( STRING ) ; 

for ( ID = ID ( ID ) ; 
ID != ID ; 
ID = ID ( ID ) ) 
{ 
ID * ID = ( ID * ) ID ( ID ) ; 

ID ( ID -> ID ) ; 
ID ( STRING ) ; 

if ( ID == ID ) 
if ( ID ) 
ID ( STRING ) ; 
else 
ID ( STRING ) ; 
} 

} 

static void ID ( const void * ID ) 
{ 
ID * ID = ( ID * ) ID ; 

if ( ID -> ID == ID ) 
ID ( STRING , ID ( ID ) ) ; 
else 
switch ( ID -> ID -> ID ) 
{ 
case ID : 
case ID : 
ID ( STRING , ID ( ID ) ) ; 
ID ( ID -> ID ) ; 
ID ( STRING ) ; 
break ; 
case ID : 
ID ( STRING , ID ( ID ) , ID -> ID -> ID ) ; 
break ; 
default : 
ID ( ID ) ; 
ID ( ID , STRING ) ; 
break ; 
} 

ID ( STRING , ID ( ID ) ) ; 
} 

void ID ( ID * ID , ID * ID ) 
{ 
ID * ID = ID ( ) ; 
ID * ID = ID ( STRING , STRING ) ; 

ID ( ID ) ; 
ID ( STRING ) ; 
ID ( ID , INTEGER , INTEGER ) ; 
ID ( STRING ) ; 
ID ( ID ) ; 
ID ( STRING ) ; 
ID ( ID ) ; 
ID ( ID ) ; 
ID ( ID ) ; 
ID ( ID -> ID , ID , ID , ID ) ; 
ID ( ID ) ; 
ID ( ID ) ; 
} 

int ID ( const unsigned ID ) 
{ 
return ID ( ID ( ID -> ID , ID ) ) ; 
} 

void ID ( ID * ID ) 
{ 
ID = ID ; 
} 
 
 
 
 

 
 
 
 
 

 
 
 
 
 
 
 

 
 

unsigned ID ; 
unsigned ID ; 
char * ID ; 
char * * ID ; 

ID * ID ; 

static void * ID ; 
static void * ID ; 
static ID * ID ; 

static ID ID = ID ; 
static ID ID = ID ; 
static ID ID = ID ; 
static ID ID = ID ; 
static ID ID = ID ; 

static ID ID ( ID * ID , int ID ) ; 

char * ID ( char * ID )  
{ 
return ID ( ( char * ) ID ( ID ( ID ) + INTEGER ) , ID ) ; 
} 

ID * ID ( char * ID ) 
{ 
return ( ID * ) ID ( ID , & ID , sizeof ( char * ) , sizeof ( ID ) , ID , ID ) ; 
} 

void ID ( void ) 
{ 
ID ( ID , ID ) ; 
} 

void ID ( char * ID ) 
{ 
ID ( ID , ID ) ; 
} 

void ID ( void ) 
{ 
ID ( ID ( ID ) ) ; 
ID ( ID , ID ) ; 
} 

static char * ID ( int ID ) 
{ 
switch ( ID ) 
{ 
case ID : return STRING ; 
case ID : return STRING ; 
case ID : return STRING ; 
case ID : return STRING ; 
case ID : return STRING ; 
case ID : return STRING ; 
case ID : return STRING ; 
case ID : return STRING ; 
case ID : return STRING ; 
case ID : return STRING ; 
case ID : return STRING ; 
case ID : return STRING ; 
case ID : return STRING ; 
case ID : return STRING ; 
case ID : return STRING ; 
case ID : return STRING ; 
case ID : return STRING ; 
case ID : return STRING ; 
case ID : return STRING ; 
default : return STRING ; 
} 
} 

static void ID ( ID ID ) 
{ 
switch ( ID . ID ) 
{ 
case ID : ID ( STRING , ID . ID ? STRING : STRING , ID ( ID . ID ) ) ; break ; 
case ID : ID ( STRING , ID . ID , ID ( ID . ID ) ) ; break ; 
case ID : ID ( STRING , ID . ID , ID ( ID . ID ) ) ; break ; 
case ID : ID ( STRING , ID . ID , ID ( ID . ID ) ) ; break ; 
case ID : ID ( STRING , ID . ID , ID . ID , ID ( ID . ID ) ) ; break ; 
case ID : ID ( STRING , ID . ID , ID ( ID . ID ) ) ; break ; 
default : ID ( STRING , ID ( ID . ID ) ) ; 
} 
} 

static void ID ( ID * ID , ID ID ) 
{ 
switch ( ID . ID ) 
{ 
case ID : ID ( ID , STRING , ID . ID ? STRING : STRING ) ; break ; 
case ID : ID ( ID , STRING , ID . ID ) ; break ; 
case ID : ID ( ID , STRING , ID . ID ) ; break ; 
case ID : ID ( ID , STRING , ID . ID ) ; break ; 
case ID : ID ( ID , STRING , ID . ID ) ; break ; 
case ID : ID ( ID , STRING , ID . ID ) ; break ; 
case ID : ID ( ID , ID . ID ) ; break ; 
case ID : ID ( ID , ID . ID ) ; break ; 
case ID : ID ( ID , ID . ID ) ; break ; 
case ID : ID ( ID , ID . ID ) ; break ; 
case ID : ID ( ID , ID . ID ) ; break ; 
default : ID ( ID , STRING , ID ( ID . ID ) ) ; 
} 
} 

static void ID ( ID * ID , ID ID , int ID ) 
{ 
switch ( ID . ID ) 
{ 
case ID : ID ( ID , ID . ID , ID ) ; break ; 
default : ID ( ID , ID ) ; 
} 
} 

static void ID ( ID * ID , ID ID ) 
{ 
switch ( ID . ID ) 
{ 
case ID : ID ( ID , ID . ID ) ; break ; 
default : 
ID ( STRING ) ; 
ID . ID = ID ; 
} 
} 

ID ID ( ID * ID , int ID ) 
{ 
ID ID ; 

ID . ID = ID ; 

if ( ID == ID ) 
ID ( STRING ) ; 
else if ( ID -> ID == ID ) 
ID ( STRING , ID -> ID ) ; 
else if ( ID -> ID -> ID == ID ) 
ID ( STRING , ID -> ID ) ; 
else if ( ID -> ID -> ID -> ID == ID ) 
{ 
 
ID ( STRING , ID -> ID ) ; 
 
ID = ID -> ID -> ID -> ID ( ID , ID ) ; 
} 
else 
{ 
 
ID ( STRING , ID -> ID ) ; 
ID ( ID ) ; 
ID ( STRING ) ; 
 
ID ( & ID , ID -> ID -> ID , sizeof ( ID ) ) ; 
} 

return ID ; 
} 

static void ID ( ID * ID , ID ID ) 
{ 

 
ID ( STRING , ID -> ID ) ; 
ID ( ID ) ; 
ID ( STRING ) ; 
 

if ( ID == ID ) 
ID ( STRING ) ; 
else if ( ID -> ID == ID ) 
ID ( STRING , ID -> ID ) ; 
else if ( ID -> ID -> ID == ID ) 
{ 
ID -> ID -> ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 
ID ( ID -> ID -> ID , & ID , sizeof ( ID ) ) ; 
} 
else if ( ID . ID != ID -> ID -> ID -> ID ) 
{ 
ID ( STRING ) ; 
ID ( ID ) ; 
ID ( STRING , ID -> ID ) ; 
ID ( * ( ID -> ID -> ID ) ) ; 
ID ( STRING ) ; 
} 
else 
ID ( ID -> ID -> ID , & ID , sizeof ( ID ) ) ; 
} 

static int ID ( void * * ID , ID * ID , ID ID , char * ID , int ID ) 
{ 
if ( * ID == ID ) 
{ 
if ( ID != ID ) 
ID ( ID , STRING , ID ) ; 
ID -> ID = ID ; 
return INTEGER ; 
} 

* ID = ID ( ( ID * ) ID ( * ID ) , ID ) ; 

if ( ID -> ID != ID ) 
{ 
if ( ID != ID ) 
{ 
ID ( ID , STRING , 
ID , 
ID ( ID ) , 
ID ( ID -> ID ) ) ; 
} 
ID -> ID = ID ; 
return INTEGER ; 
} 

* ID = ID ( * ID ) ; 
return INTEGER ; 
} 

static ID ID ( void * ID , int ID ) 
{ 
ID ID ; 
void * ID = ID ( ID ) ; 
ID ID ; 
int ID = ID ; 
char * ID ; 

ID . ID = ID ; 

if ( ID ) 
{ 
ID ( & ID , & ID , ID , STRING , ID ) ; 
ID = ID . ID ; 

if ( ID ( & ID , & ID , ID , ID , ID ) ) 
ID = ID . ID ; 

ID . ID = ID ; 

ID . ID = ID ; 

switch ( ID ) 
{ 
case ID : ID . ID = ID ( ID , STRING ) ; break ; 
case ID : ID . ID = ID ( ID , STRING ) ; break ; 
case ID : ID . ID = ID ( ID , STRING ) ; break ; 
case ID : ID . ID = ID ( ID , STRING ) ; break ; 
case ID : ID ( ID , STRING ) ; 
default : ID ( ID , STRING ) ; 
} 

if ( ID . ID == ID ) 
ID ( ID , STRING , ID ) ; 
} 

return ID ; 
} 

static ID ID ( void * ID , int ID ) 
{ 
void * ID = ID ( ID ) ; 
ID ID ; 
ID * ID = ID ; 

ID . ID = ID ; 

if ( ID ) 
{ 
if ( ID ( & ID , & ID , ID , ID , ID ) ) 
ID = ID . ID ; 

for ( ; ID != ID ; ID = ID ( ID ) ) 
ID ( ID , ID = ID ( ( ID * ) ID ( ID ) , ID ) ) ; 
} 

return ID ; 
} 

static ID ID ( void * ID , int ID ) 
{ 
void * ID = ID ( ID ) ; 
ID ID ; 
ID * ID = ID ; 

ID . ID = ID ; 

if ( ID ) 
{ 
if ( ID ( & ID , & ID , ID , ID , ID ) ) 
ID = ID . ID ; 

for ( ; ID != ID ; ID = ID ( ID ) ) 
ID ( ID , ID = ID ( ( ID * ) ID ( ID ) , ID ) , INTEGER ) ; 
} 

return ID ; 
} 

static ID ID ( void * ID , int ID ) 
{ 
void * ID = ID ( ID ) ; 
ID ID ; 
ID * ID = ID ; 

ID . ID = ID ; 

if ( ID ) 
{ 
if ( ID ( & ID , & ID , ID , ID , ID ) ) 
ID = ID . ID ; 

for ( ; ID != ID ; ID = ID ( ID ) ) 
ID ( ID , ID = ID ( ( ID * ) ID ( ID ) , ID ) , INTEGER ) ; 
} 

return ID ; 
} 

static ID ID ( void * ID , int ID ) 
{ 
void * ID = ID ( ID ) ; 
ID ID ; 
ID * ID = ID ; 

ID . ID = ID ; 

if ( ID ) 
{ 
if ( ID ( & ID , & ID , ID , ID , ID ) ) 
ID = ID . ID ; 

for ( ; ID != ID ; ID = ID ( ID ) ) 
ID ( ID , ID = ID ( ( ID * ) ID ( ID ) , ID ) ) ; 
} 

return ID ; 
} 

static ID ID ( void * ID , int ID ) 
{ 
ID ID ; 

ID . ID = ID ; 
if ( ID ) 
ID . ID = ( ( ID * ) ID ) -> ID ; 

return ID ; 
} 

static ID ID ( void * ID , int ID ) 
{ 
ID ID ; 
void * ID = ID ( ID ) ; 
ID ID ; 

ID . ID = ID ; 

if ( ID ) 
{ 
ID ( & ID , & ID , ID , STRING , ID ) ; 

ID . ID = ID ; 
ID . ID = ID ( ID , ( ID * ) ( ID . ID ) ) ; 
} 

return ID ; 
} 

static ID ID ( void * ID , int ID ) 
{ 
ID ID ; 
void * ID = ID ( ID ) ; 
ID ID ; 

ID . ID = ID ; 

if ( ID ) 
{ 
ID ( & ID , & ID , ID , STRING , ID ) ; 

ID . ID = ID ; 
ID . ID = ID ( ID . ID ) ; 
} 

return ID ; 
} 

static ID ID ( void * ID , int ID ) 
{ 
ID ID ; 
ID * ID ; 
unsigned ID ; 
void * ID = ID ( ID ) ; 
int ID = INTEGER ; 

if ( ID ) 
{ 
ID ( & ID , & ID , ID , STRING , ID ) ; 
ID = ID . ID ; 

ID ( & ID , & ID , ID , STRING , ID ) ; 
ID = ID . ID ; 

if ( ID ( & ID , & ID , ID , STRING , ID ) ) 
switch ( ID . ID ) 
{ 
case ID : ID = INTEGER ; break ; 
case ID : ID = INTEGER ; break ; 
case ID : ID ( ID , STRING ) ; break ; 
case ID : ID ( ID , STRING ) ; break ; 
default : ID ( ID , STRING ) ; 
} 

ID ( ID , ID , ID ) ; 
} 

ID . ID = ID ; 
return ID ; 
} 

static ID ID ( void * ID , int ID ) 
{ 
ID ID ; 
void * ID = ID ( ID ) ; 
ID ID ; 
ID * ID ; 

ID . ID = ID ; 

if ( ID ) 
{ 
ID ( & ID , & ID , ID , STRING , ID ) ; 
ID = ID . ID ; 

ID ( & ID , & ID , ID , STRING , ID ) ; 

switch ( ID . ID ) 
{ 
case ID : 
case ID : 
ID ( ID , STRING ) ; 

case ID : 
case ID : 
case ID : 
ID ( ID , STRING ) ; 

case ID : 
ID ( ID , STRING ) ; 

case ID : 
case ID : 
case ID : 
ID . ID = ID ; 
ID . ID = ID ( ID , ( enum ID ) ID . ID ) ; 
break ; 

case ID : 
ID . ID = ID ; 
 
break ; 

default : ID ( ID , STRING ) ; 
} 
} 

return ID ; 
} 

static ID ID ( void * ID , int ID ) 
{ 
ID ID ; 
void * ID = ID ( ID ) ; 
ID ID ; 

ID . ID = ID ; 

if ( ID ) 
{ 
ID ( & ID , & ID , ID , STRING , ID ) ; 

ID . ID = ID ; 
ID . ID = ID ( ID . ID ) ; 
} 

return ID ; 
} 

static ID ID ( void * ID , int ID ) 
{ 
ID ID ; 
void * ID = ID ( ID ) ; 
ID ID ; 

ID . ID = ID ; 

if ( ID ) 
{ 
ID ( & ID , & ID , ID , STRING , ID ) ; 

ID . ID = ID ; 
ID . ID = ID ( ID . ID ) ; 
} 

return ID ; 
} 

static ID ID ( void * ID , int ID ) 
{ 
ID ID ; 
void * ID = ID ( ID ) ; 
ID ID ; 

ID . ID = ID ; 

if ( ID ) 
{ 
ID ( & ID , & ID , ID , STRING , ID ) ; 

ID . ID = ID ; 
ID . ID = ID ( ID . ID ) ; 
} 

return ID ; 
} 

static ID ID ( void * ID , int ID ) 
{ 
ID ID ; 
void * ID = ID ( ID ) ; 
ID ID ; 

ID . ID = ID ; 
if ( ID ) 
{ 
ID ( & ID , & ID , ID , STRING , ID ) ; 

ID . ID = ID ; 
ID . ID = ID ( ID . ID , INTEGER ) ; 
} 

return ID ; 
} 

static ID ID ( void * ID , int ID ) 
{ 
ID ID ; 
void * ID = ID ( ID ) ; 
ID ID ; 

ID . ID = ID ; 
if ( ID ) 
{ 
ID ( & ID , & ID , ID , STRING , ID ) ; 

ID . ID = ID ; 
ID . ID = ID ( ID . ID , INTEGER ) ; 
} 

return ID ; 
} 

static ID ID ( void * ID , int ID ) 
{ 
ID ID ; 
ID * ID ; 
void * ID = ID ( ID ) ; 
ID ID ; 

ID . ID = ID ; 
if ( ID ) 
{ 
ID ( & ID , & ID , ID , STRING , ID ) ; 
ID = ID . ID ; 

ID ( & ID , & ID , ID , STRING , ID ) ; 

ID . ID = ID ; 
ID . ID = ID ( ID , ID . ID ) ; 
} 

return ID ; 
} 

static ID ID ( void * ID , int ID ) 
{ 
ID ID ; 
ID * ID ; 
void * ID = ID ( ID ) ; 
ID ID ; 
ID ID = { INTEGER } ; 

ID . ID = ID ; 
if ( ID ) 
{ 
ID ( & ID , & ID , ID , STRING , ID ) ; 
ID = ID . ID ; 

ID ( & ID , & ID , ID , STRING , ID ) ; 

if ( ID != ID ) 
ID ( & ID , & ID , ID , STRING , ID ) ; 

ID . ID = ID ; 
ID . ID = ID ( ID , ID . ID , INTEGER , ID . ID ) ; 
} 

return ID ; 
} 

static ID ID ( void * ID , int ID ) 
{ 
ID ID ; 
ID * ID ; 
void * ID = ID ( ID ) ; 
ID ID ; 
ID ID = { INTEGER } ; 

ID . ID = ID ; 
if ( ID ) 
{ 
ID ( & ID , & ID , ID , STRING , ID ) ; 
ID = ID . ID ; 

ID ( & ID , & ID , ID , STRING , ID ) ; 

if ( ID != ID ) 
ID ( & ID , & ID , ID , STRING , ID ) ; 

ID . ID = ID ; 
ID . ID = ID ( ID , ID . ID , INTEGER , ID . ID ) ; 
} 

return ID ; 
} 

static ID ID ( void * ID , int ID ) 
{ 
ID ID ; 
ID * ID ; 
void * ID = ID ( ID ) ; 
ID ID ; 
ID ID = { INTEGER } ; 

ID . ID = ID ; 
if ( ID ) 
{ 
ID ( & ID , & ID , ID , STRING , ID ) ; 
ID = ID . ID ; 

ID ( & ID , & ID , ID , STRING , ID ) ; 

if ( ID != ID ) 
ID ( & ID , & ID , ID , STRING , ID ) ; 

ID . ID = ID ; 
ID . ID = ID ( ID , ID . ID , INTEGER , ID . ID ) ; 
} 

return ID ; 
} 

static ID ID ( void * ID , int ID ) 
{ 
ID ID ; 

if ( ID ) 
ID . ID = ( ( ID * ) ID ) -> ID ; 
ID . ID = ID ; 
ID . ID = ID ( ) ; 

return ID ; 
} 

static ID ID ( void * ID , int ID ) 
{ 
ID ID ; 

if ( ID ) 
ID . ID = ( ( ID * ) ID ) -> ID ; 
ID . ID = ID ; 
ID . ID = ( float ) ( ID ( ) / ID ) ; 

return ID ; 
} 

void ID ( char * ID , ID ( * ID ) ( void * ID , int ID ) ) 
{ 
ID * ID = ID ( ID ) ; 

ID -> ID = INTEGER ; 

ID -> ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 
ID -> ID -> ID = ID ; 
ID -> ID -> ID = ID ; 
} 

void ID ( char * ID , char * ID ) 
{ 
ID * ID = ID ( ID ) ; 

ID -> ID = INTEGER ; 

ID -> ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 
ID -> ID -> ID = ID ; 
ID -> ID -> ID = ID ; 
} 

void ID ( char * ID , int ID ) 
{ 
ID * ID = ID ( ID ) ; 

ID -> ID = INTEGER ; 

ID -> ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 
ID -> ID -> ID = ID ; 
ID -> ID -> ID = ID ; 
} 

void ID ( char * ID , int ID ) 
{ 
ID * ID = ID ( ID ) ; 

ID -> ID = INTEGER ; 

ID -> ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 
ID -> ID -> ID = ID ; 
ID -> ID -> ID = ID ; 
} 

void ID ( char * ID , ID * ID ) 
{ 
ID * ID = ID ( ID ) ; 

ID -> ID = INTEGER ; 

ID -> ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 
ID -> ID -> ID = ID ; 
ID -> ID -> ID = ID ; 
} 

void ID ( char * ID ) 
{ 
ID * ID = ID ( ID ) ; 

ID -> ID = INTEGER ; 

ID -> ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 
ID -> ID -> ID = ID ; 

ID = ID ; 
} 

void ID ( char * ID ) 
{ 
ID = ID ( STRING , INTEGER , INTEGER , ID , ID , ID ) ; 
ID = ID ( ID ) ; 

ID ( STRING ) ; 

 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 

 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 

 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 

 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 

 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 
ID ( STRING , ID ) ; 

 
ID ( STRING , INTEGER ) ; 
ID ( STRING , INTEGER ) ; 
ID ( STRING , STRING ) ; 
ID ( STRING , ID ) ;  
ID ( STRING , ID ) ;  

 
ID ( STRING , ID ) ;  
ID ( STRING , ID ) ;  
} 

static void ID ( void * ID , char * ID ) 
{ 
ID * ID = ID ( ID , STRING ) ; 

if ( ID == ID ) 
ID ( ID , STRING , ID ) ; 

ID ( ID ) ; 
ID ( ID , ID , ID , ID ) ; 
ID ( ID ) ; 
ID ( ID ) ; 
} 

 
static unsigned long ID ( ID * ID , int ID ) 
{ 
unsigned long ID = INTEGER ; 

if ( ID ( ID -> ID , STRING ) == INTEGER ) 
{ 
 
unsigned long ID = ID ( ( ID * ) ID ( ID ( ID ( ID ) ) ) , INTEGER ) ; 

 
unsigned long ID = ID ( ( ID * ) ID ( ID ( ID ) ) , ID ) ; 

 
if ( ID ) 
ID ( STRING , ID + INTEGER ) ; 

 
ID ( ( ID * ) ID ( ID ( ID ( ID ) ) ) , ID ) ; 

ID = ID + ID + INTEGER ; 
} 
else if ( ID ( ID -> ID , STRING ) == INTEGER ) 
{ 
 
unsigned long ID = ID ( ( ID * ) ID ( ID ( ID ( ID ) ) ) , INTEGER ) ; 

 
unsigned long ID = ID ( ( ID * ) ID ( ID ( ID ) ) , ID ) ; 

 
if ( ID ) 
ID ( STRING , ID + INTEGER ) ; 

 
ID ( ( ID * ) ID ( ID ( ID ( ID ) ) ) , ID ) ; 

 
if ( ID ) 
ID ( STRING , ID + ID + INTEGER ) ; 

ID = ID + ID + INTEGER ; 
} 
else 
{  
void * ID ; 
int ID = ID ( ID -> ID , STRING ) == INTEGER ; 
 

 
if ( ID ) 
{ 
ID ++ ; 

if ( ID ) 
ID ( STRING ) ; 
} 

for ( ID = ID ( ID ) ; ID != ID ; ID = ID ( ID ) ) 
ID += ID ( ( ID * ) ID ( ID ) , ID ) ; 

if ( ID ) 
{ 
ID ++ ; 

if ( ID ) 
ID ( STRING ) ; 
else 
ID ( STRING , ID -> ID ) ; 
} 
} 

 
if ( ID ) 
ID ( STRING , ID ) ; 
 

return ID ; 
} 

static ID ID ( ID * ID , int ID ) 
{ 
 
void * ID ; 

ID ID , ID , ID ; 

ID * ID = ID ; 
ID * ID = ID ; 

if ( ID ( ID ) != ID ) 
{ 
ID = ( ID * ) ID ( ID ( ID ) ) ; 

if ( ID ( ID ( ID ) ) != ID ) 
ID = ( ID * ) ID ( ID ( ID ( ID ) ) ) ; 
} 

ID . ID = ID ;  

if ( ID == ID )  
return ID ; 

if ( ID ( & ID , ID -> ID ) ) 
ID = ID ( ID , ID ) ; 

if ( ID ( & ID , ID -> ID ) ) 
ID = ID ( ID , ID ) ; 

 
ID ( STRING , ID -> ID ) ; 
if ( ID -> ID != ID ) 
ID ( STRING , ID -> ID ) ; 

ID ( STRING , ID ? STRING : STRING ) ; 
ID ( STRING , ID == ID ? STRING : ID -> ID ) ; 
if ( ID != ID ) 
if ( ID -> ID != ID ) 
ID ( STRING , ID -> ID ) ; 
ID ( STRING , ID == ID ? STRING : ID -> ID , ID == ID ? ID : ID -> ID ) ; 
if ( ID != ID ) 
if ( ID -> ID != ID ) 
ID ( STRING , ID -> ID ) ; 
ID ( STRING ) ; 
 

if ( ID ( & ID , ID -> ID ) && ( ID . ID != ID . ID ) ) 
ID ( ID , STRING , ID -> ID ) ; 

switch ( ID -> ID ) 
{ 
 
case INTEGER  : 
for ( ID = ID ( ID ) ; ID != ID ; ID = ID ( ID ) ) 
ID = ID ( ( ID * ) ID ( ID ) , ID ) ; 
break ; 

case ID  :  
ID = ID ( ID , ID ) ; 

ID . ID = ID ; 

if ( ID . ID != ID ) 
ID ( STRING ) ; 
else 
ID = ID ( ID , ID && ID . ID ) ; 
break ; 

case ID  :  
ID = ID ( ID , ID ) ; 

ID . ID = ID ; 

if ( ID . ID != ID ) 
ID ( STRING ) ; 
else 
while ( ID && ID . ID ) 
{ 
ID = ID ( ID , ID && ID . ID ) ; 
ID = ID ( ID , ID ) ; 
} 
break ; 

 
case ID  :  
ID . ID = ID ; 
ID . ID = ( char * ) ( ID -> ID ) ; 
break ; 

case ID :  
ID = ID ( ID , ID ) ; 
break ; 

case ID :  
ID . ID = ID ; 
ID . ID = ID -> ID . ID ; 
break ; 

case ID :  
ID . ID = ID ; 
ID . ID = ( float ) ( ID -> ID . ID ) ; 
break ; 

} 

 
if ( ID && ID ( & ID , ID -> ID ) ) 
ID ( ID , ID ) ; 
else if ( ID && ID ( & ID , ID -> ID ) ) 
{ 
ID = ID ( ID , ID ) ; 
ID ( ID , ID ) ; 
ID = ID ; 
} 
 
ID ( STRING ) ; 
ID ( ID ) ; 
ID ( STRING ) ; 
 

return ID ; 
} 

void ID ( void * ID ) 
{ 
ID * ID = ( ID * ) ID ( ID ( ID ( ID ( ID ) ) ) ) ; 
ID ID ; 

ID = ( ID * ) ID ( ID ( ID ( ID ) ) ) ; 
ID ( ID , STRING ) ; 


ID ( & ID , 
ID  , 

ID  , 

ID  , 

ID  , 

ID  , 

ID  , 

ID  , 

ID  , 

ID  , 

ID  , 

ID  , 


ID  , 
ID  , 
ID  , 
ID  , 
ID  , 
ID  , 
ID ) ; 

ID ( & ID , 
ID  , 
ID  , 
ID  , 

ID  , 
ID  , 
ID  , 

ID  , 
ID  , 
ID  , 

ID  , 
ID  , 
ID  , 

ID  , 
ID  , 
ID  , 

ID  , 
ID  , 
ID  , 

ID  , 
ID  , 
ID  , 

ID  , 
ID  , 
ID  , 

ID  , 
ID  , 
ID  , 

ID  , 
ID  , 
ID  , 

ID  , 
ID  , 
ID  , 

ID  , 
ID  , 
ID  , 
ID  , 
ID  , 
ID  , 

ID  , 
ID ) ; 

ID ( & ID , 
ID  , 
ID  , 
ID  , 

ID  , 
ID  , 
ID  , 

ID  , 
ID  , 
ID  , 

ID  , 
ID  , 
ID  , 

ID  , 
ID  , 
ID  , 

ID  , 
ID  , 
ID  , 

ID  , 
ID  , 
ID  , 

ID  , 
ID  , 
ID  , 

ID  , 
ID  , 
ID  , 

ID  , 
ID  , 
ID  , 

ID  , 
ID  , 
ID  , 

ID  , 

ID  , 
ID  , 
ID  , 
ID  , 
ID  , 
ID  , 
ID ) ; 

ID ( & ID , 
ID  , 

ID  , 

ID  , 

ID  , 

ID  , 

ID  , 

ID  , 

ID  , 

ID  , 

ID  , 

ID  , 

ID  , 
ID ) ; 

ID ( & ID , 
ID  , 

ID  , 

ID  , 

ID  , 

ID  , 

ID  , 

ID  , 

ID  , 

ID  , 

ID  , 

ID  , 
ID ) ; 

if ( ID ( ID ) == ID ) 
ID ( ID , STRING ) ; 

 

ID = ID ( ID , INTEGER ) ; 
} 


void ID ( void ) 
{ 
if ( ID ( ) != INTEGER ) 
{ 
ID ( STRING ) ; 
ID ( ID , STRING , ID ( ) == INTEGER ? STRING : STRING , ID ) ; 
} 
} 

 
 
 
 
 
 
 
 
 
 
 
 

 

 
 

 
 
 
 

 

 

char * ID ( int ID ) 
{ 
switch ( ID ) 
{ 
case ID : 
return STRING ; 
case ID : 
return STRING ; 
case ID : 
return STRING ; 
case ID : 
return STRING ; 
case ID : 
return STRING ; 
case ID : 
return STRING ; 
case ID : 
return STRING ; 
case ID : 
return STRING ; 
case ID : 
return STRING ; 
default : 
return STRING ; 
} 
} 

void ID ( ID * ID , ID * ID ) 
{ 
if ( ID ( ID -> ID . ID ) ) 
{ 
ID ( STRING , ID ( ID ) ) ; 
ID ( ID -> ID . ID , INTEGER ) ; 
ID ( STRING ) ; 
ID ( & ID -> ID . ID , ID , INTEGER ) ; 
ID ( STRING , 
ID ( ID -> ID . ID ) ? STRING : STRING , 
ID ( & ID -> ID , ID ( ID ) ) ? STRING : STRING 
) ; 
} 
else 
{ 
ID ( STRING , ID ( ID ) , ID -> ID . ID -> ID -> ID ) ; 
ID ( & ID -> ID . ID , ID , INTEGER ) ; 
ID ( STRING ) ; 
} 

} 

static void ID ( ID * ID , int ID , unsigned ID ) 
{ 
if ( ID == INTEGER ) 
ID ( STRING ) ; 
else if ( ID > INTEGER ) 
{ 
unsigned ID = ID ( ID -> ID [ ID ] . ID ) ; 

ID ( STRING , ID ( & ID -> ID , ID ) ? STRING : STRING , ID ) ; 
} 
else 
{ 
if ( ID < ID -> ID ) 
ID ( STRING , - ID ) ; 
else 
ID ( STRING , - ID ) ; 
} 
} 

typedef struct ID 
{ 
ID * ID ; 
ID * ID ; 
} ID ; 

typedef struct ID 
{ 
ID ID ; 
unsigned ID ; 
} ID ; 

static void * ID ; 
static unsigned ID ; 

unsigned ID ( ID * ID , ID * ID ) 
{ 
ID ID ; 
ID * ID ; 

 
ID ( STRING ) ; 
ID ( ID , ID , INTEGER ) ; 
ID ( STRING ) ; 
ID ( ID , ID , INTEGER ) ; 
ID ( STRING ) ; 
 

ID . ID = ID ; 
ID . ID = ID ; 
ID = ( ID * ) ID ( ID , & ID , ID ) ; 

if ( ID == ID )  
{ 
ID * ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 
ID * ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 

ID ( ID , ID ) ; 
ID ( ID , ID ) ; 

ID . ID = ID ; 
ID . ID = ID ; 

ID = ( ID * ) ID ( ID , & ID , sizeof ( ID ) , sizeof ( ID ) ) ; 
ID -> ID = ID ; 
ID += ID ( ID ) ; 
ID += ID ( ID ) ; 
ID += INTEGER ;  
 
ID ( STRING ) ; 
ID ( ID , ID ) ; 
ID ( STRING ) ; 
 
} 
 
else 
ID ( STRING ) ; 
 

return ID -> ID ; 
} 

 
typedef enum ID {  ID , 
 ID , 
 ID , 
 ID , 
 ID , 
 ID , 
 ID , 
 ID , 
 ID , 
 ID 
} ID ; 

static int ID [ ID ] = { STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING } ; 

static void ID ( ID * ID , ID * ID , ID * ID , unsigned ID , ID * ID , ID * ID , ID * ID , int ID ) 
{ 
unsigned ID = ID ( ID ) ; 
unsigned ID = ID ( ID ) ; 

* ID = ID ; 

if ( ID + ID == INTEGER )  
* ID = ID ; 
else if ( ID + ID == INTEGER )  
* ID = ID ; 
else if ( ID > INTEGER && ID > INTEGER )  
* ID = ID ; 
else 
{ 
unsigned * ID = ID ( & ID -> ID . ID -> ID ) ; 
unsigned ID = ID ( & ID -> ID . ID -> ID ) ; 
unsigned ID = INTEGER ; 
unsigned ID = INTEGER ; 
ID * ID = ID -> ID ; 
void * ID = ID -> ID -> ID ; 
int ID ; 

if ( ID ( ID ) == ID ) 
ID ( ID ) ; 

if ( ID ( ID ) == ID ) 
ID ( ID ) ; 

 
 

 
for ( ID = INTEGER ; ID < ID ; ID ++ ) 
if ( ID ( ID ( ID [ ID ] ) ) && 
ID ( & ID -> ID , ID [ ID ] ) && 
ID ( & ( ID ( ID [ ID ] ) -> ID . ID ) , ID ) ) 
{ 
ID ++ ; 

if ( ID ( ID ( ID [ ID ] ) ) ) 
ID ++ ; 
} 

if ( ID > INTEGER ) 
* ID = ID ; 

 

 

 
 
{ 
unsigned * ID = ( unsigned * ) ID ( ID , sizeof ( unsigned ) ) ; 
ID * * ID = ( ID * * ) ID ( ID , sizeof ( ID * ) ) ; 
ID * * ID = ( ID * * ) ID ( ID , sizeof ( ID * ) ) ; 
ID * ID = ( ID * ) ID ( ID , sizeof ( ID ) ) ; 
ID * ID = ( ID * ) ID ( ID , sizeof ( ID ) ) ; 
int ID = INTEGER ; 
unsigned ID = INTEGER ; 
unsigned ID ; 
int ID = INTEGER ; 

for ( ID = INTEGER ; ID < ID ; ID ++ ) 
{ 
ID * ID = ID ( ID [ ID ] ) ; 
ID * ID = ID ( ID [ ID ] ) ; 

if ( ID ( ID ) ) 
ID [ ID ] = INTEGER ; 
else if ( ID ( ID ) == INTEGER ) 
ID [ ID ] = INTEGER ; 
else 
ID [ ID ] = ID - INTEGER ; 

if ( ID ( ID ) ) 
{ 
ID * ID = ID ( ID ) ; 

ID [ ID ] = ID ( ID ) ; 

if ( ID != ID ) 
{ 
ID [ ID ] = ID -> ID ; 

if ( ID [ ID ] -> ID == ID ) 
ID [ ID ] = ID ; 
} 

ID ( & ID [ ID ] , ID ) ; 
ID ( & ID [ ID ] , ID ) ; 
} 
} 

while ( ID ) 
{ 
int ID , ID ; 

ID = INTEGER ; 

for ( ID = INTEGER ; ID < ID ; ID ++ ) 
{ 
if ( ID ( ID ( ID [ ID ] ) ) ) 
for ( ID = INTEGER ; ID < ID ; ID ++ ) 
if ( ID ( ID ( ID [ ID ] ) ) && ! ID ( ID ( ID [ ID ] ) ) ) 
if ( ID [ ID ] == ID [ ID ] ) 
{ 
if ( ID ( & ID [ ID ] , ID ) ) 
ID ( & ID [ ID ] , & ( ID ( ID [ ID ] ) -> ID . ID ) ) ; 

if ( ID ( & ID [ ID ] , & ( ID ( ID [ ID ] ) -> ID . ID ) ) ) 
if ( ID [ ID ] > ID [ ID ] + INTEGER ) 
{ 
ID [ ID ] = ID [ ID ] + INTEGER ; 
ID = INTEGER ; 
} 
} 
} 
} 

 
for ( ID = INTEGER ; ID < ID ; ID ++ ) 
if ( ID ( ID ( ID [ ID ] ) ) && 
ID ( & ID -> ID , ID [ ID ] ) && 
ID ( & ( ID ( ID [ ID ] ) -> ID . ID ) , ID ) ) 
{ 
if ( ID [ ID ] == INTEGER ) 
{ 
ID ++ ; 
ID = ID ; 
} 
} 

 
for ( ID = INTEGER ; ID < ID ; ID ++ ) 
if ( ID ( ID ( ID [ ID ] ) ) ) 
{ 
if ( ID != ID ) 
if ( ID ( & ID [ ID ] , ID ) ) 
ID = INTEGER ; 
} 

if ( ! ID && ID < INTEGER ) 
{ 
unsigned * ID = ID ( ID ) ; 
unsigned * ID = ID ; 

* ID = ID ; 
if ( ID ) 
{ 
ID ( STRING , ID ( ID ) ) ; 
ID ( ID ( ID -> ID -> ID , ID ) ) ; 
ID ( STRING , ID ( ID ( ID [ ID ] ) ) ) ; 
ID ( ID , ID ( ID [ ID ] ) ) ; 
} 

while ( * ID != ID ) 
{ 
if ( ID ) 
ID ( STRING , ID ( ID [ * ID ] . ID ) ) ; 

if ( ID [ * ID ] . ID != ID ( ID [ ID ] ) ) 
{ 
if ( ID ) 
ID ( STRING ) ; 
ID ( ID , * ID ) ; 
} 
else 
if ( ID ) 
ID ( STRING ) ; 

ID ++ ; 
} 

ID ( ID ) ; 
} 
else if ( ID ) 
{ 
 
ID ( STRING , ID ( ID ) ) ; 
ID ( ID ( ID -> ID -> ID , ID ) ) ; 
ID ( STRING , 
ID , 
ID , 
ID == INTEGER ? STRING : STRING , 
ID , 
ID == INTEGER ? STRING : STRING ) ; 


for ( ID = INTEGER ; ID < ID ; ID ++ ) 
{ 
if ( ID != ID ) 
if ( ID [ ID ] == ID - INTEGER ) 
ID ( STRING ) ; 
else 
ID ( STRING , ID [ ID ] ) ; 

 
if ( ID [ ID ] != ID ) 
{ 
ID ( ID [ ID ] ) ; 
ID ( STRING ) ; 

ID ( STRING ) ; 
ID ( & ID [ ID ] , ID , INTEGER ) ; 
ID ( STRING ) ; 

if ( ID [ ID ] != ID ) 
{ 
ID ( ID [ ID ] ) ; 
ID ( STRING ) ; 
ID ( & ID [ ID ] , ID , INTEGER ) ; 
ID ( STRING ) ; 
} 
else 
ID ( STRING ) ; 
} 
else 
ID ( STRING ) ; 
 
ID ( ID , ID ( ID [ ID ] ) ) ; 
} 

ID ( STRING , ID == INTEGER ? STRING : STRING , ID , ID == INTEGER ? STRING : STRING ) ; 

if ( ID == INTEGER ) 
ID ( ID , ID ( ID [ ID ] ) ) ; 

for ( ID = INTEGER ; ID < ID ; ID ++ ) 
if ( ID ( ID ( ID [ ID ] ) ) ) 
{ 
if ( ID != ID ) 
if ( ID ( & ID [ ID ] , ID ) ) 
{ 
ID ( ID ( ID -> ID -> ID , ID ) ) ; 
ID ( STRING ) ; 
ID ( ID , ID ( ID [ ID ] ) ) ; 
} 
} 
} 

for ( ID = INTEGER ; ID < ID ; ID ++ ) 
{ 
ID ( & ID [ ID ] ) ; 
ID ( & ID [ ID ] ) ; 
} 

ID ( ID ) ; 
ID ( ID ) ; 
ID ( ID ) ; 
ID ( ID ) ; 
ID ( ID ) ; 
} 
 
ID ( ID ) ; 
} 

} 

ID * ID ( ID * ID , int ID ) 
{ 
ID * ID ; 
ID * ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 
ID * ID ; 
ID * ID ; 
ID ID = ID ; 
ID ID ; 

ID -> ID = ID ( ID -> ID ) ; 
ID -> ID = ID ( ID ) ; 
ID -> ID = ID ( ID -> ID ) + INTEGER ; 
ID -> ID = ID -> ID ; 

ID ( STRING , ID ( ID -> ID ) , ID -> ID * ( ID -> ID - INTEGER ) ) ; 

if ( ID -> ID * ID -> ID == INTEGER ) 
ID ( ID , STRING ) ; 
else 
{ 
ID ID = ID ( ID -> ID -> ID -> ID ) + INTEGER ; 
ID * ID = ( ID * ) ID ( ID , sizeof ( ID ) ) ; 
ID ID = ID ; 
ID ID = ID ; 

 
ID -> ID = ID ( ID ( ID -> ID ) ) ; 

 
ID = ( ID * ) ID ( ID -> ID -> ID ) ; 
ID = ( ID * ) ID ( ID ) ; 
while ( ID != ID ) 
{ 

ID = ( ID * ) ID ( ID ) ; 
if ( ID ( & ID -> ID -> ID , ID ( ID ) ) ) 
ID ( & ID -> ID , ID ( ID -> ID . ID ) ) ; 

ID = ( ID * ) ID ( ID ) ; 

if ( ID != ID ) 
if ( ID -> ID -> ID == ID )  
ID = ( ID * ) ID ( ID ) ; 
} 

 
for ( ID -> ID = INTEGER ; 
ID ( ID -> ID -> ID -> ID , ID -> ID ) -> ID == ID ; 
ID -> ID ++ ) 
; 

 
ID -> ID = INTEGER ; 
ID ( ID -> ID -> ID , ID , ID ) ;  
if ( ID ( & ID -> ID -> ID , ID ( ID ) ) ) 
if ( ID [ ID ( ID -> ID . ID ) ] == INTEGER ) 
{ 
ID [ ID ( ID -> ID . ID ) ] = ID -> ID ++ ; 
} 

 
{ 
unsigned ID ; 
for ( ID = INTEGER ; ID < ID ; ID ++ ) 
ID ( STRING , ID , ID [ ID ] ) ; 
} 
 

 
ID -> ID = ( ID * ) ID ( ID -> ID , sizeof ( ID ) ) ; 

ID ( ID -> ID -> ID , ID , ID ) ;  
if ( ID ( & ID -> ID -> ID , ID ( ID ) ) ) 
{ 
ID * ID ; 
int ID = ID [ ID ( ID -> ID . ID ) ] ; 

ID -> ID [ ID ] . ID = ID -> ID . ID ; 

if ( ID -> ID . ID -> ID == ID )  
ID = ID -> ID . ID ; 
else 
{ 
void * ID ; 
ID = ( ID * ) ID ( ID ( ID -> ID . ID ) ) ; 

ID -> ID [ ID ] . ID = INTEGER ; 
for ( ID = ID ( ID ) ; ID != ID && ID ( ID ) != ID -> ID . ID ; ID = ID ( ID ) ) 
ID -> ID [ ID ] . ID += INTEGER ; 
} 

ID -> ID [ ID ] . ID = ( ( ID * ) ID ( ID ( ID ) ) ) -> ID ; 
} 

ID = ID ( STRING , INTEGER , INTEGER , ID , ID , ID ) ; 
ID = INTEGER ;  

ID -> ID = ( int * * ) ID ( ID -> ID * ID -> ID , sizeof ( int * ) ) ; 

if ( ID ) 
ID -> ID = ( unsigned * ) ID ( ID -> ID * ID -> ID , sizeof ( unsigned ) ) ; 

for ( ID = ( ID * ) ID ( ID -> ID ) ; ID != ID ; ID = ( ID * ) ID ( ID ) )  
{ 
unsigned ID ; 

for ( ID = INTEGER ; ID < ID -> ID ; ID ++ )  
{ 
ID * ID ; 

 
ID ( & ID ) ; 
for ( ID = ( ID * ) ID ( ID ) ; ID != ID ; ID = ( ID * ) ID ( ID ) )  
if ( ID -> ID -> ID == ID ) 
ID ( & ID , ID ( ID ( ID ) ) ) ; 

 
ID ( & ID ) ; 
if ( ID ( & ID -> ID , ID ( ID ) ) && ! ID ( & ID , ID ( ID ) ) ) 
{ 
unsigned * ID , 
* ID = ID ( & ( ID -> ID . ID -> ID ) ) ; 

for ( ID = ID ; * ID != ID ; ID ++ ) 
if ( ID ( & ID -> ID -> ID , ID ( ( ( ID * ) ID ( ID -> ID -> ID ) [ * ID ] ) ) ) ) 
if ( ID ( & ( ( ID * ) ID ( ID -> ID -> ID ) [ * ID ] ) -> ID . ID , ID ) ) 
ID ( & ID , ID [ ID ( ( ( ID * ) ID ( ID -> ID -> ID ) [ * ID ] ) -> ID . ID ) ] ) ; 
} 

if ( ID ) 
ID ( ID -> ID , ID , ID , ID , & ID , & ID , & ID , INTEGER ) ; 

 
if ( ID ( & ID ) != INTEGER || ID ( & ID ) != INTEGER ) 
ID ( & ID , & ID ) ; 
} 
} 

 
ID -> ID = ID ; 
ID -> ID = ( int * ) ID ( ID , sizeof ( int ) ) ; 

for ( ID = ( ID * ) ID ( ID ( ID ) ) ; ID != ID ; ID = ( ID * ) ID ( ID ) ) 
{ 
unsigned * ID , 
* ID ; 
int * ID = ID -> ID + ID -> ID ; 

 
ID = ID ( ID -> ID . ID ) ; 
for ( ID = ID ; * ID != ID ; ID ++ ) 
* ID ++ = - ( * ID ) ; 
ID ( ID ) ; 

 
ID = ID ( ID -> ID . ID ) ; 
for ( ID = ID ; * ID != ID ; ID ++ ) 
* ID ++ = * ID ; 
ID ( ID ) ; 

 
* ID = INTEGER ; 
} 

 
for ( ID = ( ID * ) ID ( ID -> ID ) ; ID != ID ; ID = ( ID * ) ID ( ID ) )  
{ 
unsigned ID ; 

for ( ID = INTEGER ; ID < ID -> ID ; ID ++ )  
{ 
ID * ID ; 

 
ID ( & ID ) ; 
for ( ID = ( ID * ) ID ( ID ) ; ID != ID ; ID = ( ID * ) ID ( ID ) )  
if ( ID -> ID -> ID == ID ) 
ID ( & ID , ID ( ID ( ID ) ) ) ; 

 
ID ( & ID ) ; 
if ( ID ( & ID -> ID , ID ( ID ) ) && ! ID ( & ID , ID ( ID ) ) ) 
{ 
unsigned * ID , 
* ID = ID ( & ( ID -> ID . ID -> ID ) ) ; 

for ( ID = ID ; * ID != ID ; ID ++ ) 
if ( ID ( & ID -> ID -> ID , ID ( ( ( ID * ) ID ( ID -> ID -> ID ) [ * ID ] ) ) ) ) 
if ( ID ( & ( ( ID * ) ID ( ID -> ID -> ID ) [ * ID ] ) -> ID . ID , ID ) ) 
ID ( & ID , ID [ ID ( ( ( ID * ) ID ( ID -> ID -> ID ) [ * ID ] ) -> ID . ID ) ] ) ; 
} 

if ( ID ) 
ID ( ID -> ID , ID , ID , ID , & ID , & ID , & ID , INTEGER ) ; 

 
if ( ID ( & ID ) != INTEGER || ID ( & ID ) != INTEGER ) 
* ( ID -> ID + ( ID ( ID ) * ID -> ID ) + ID ) = ID -> ID + ID ( & ID , & ID ) ; 
else 
* ( ID -> ID + ( ID ( ID ) * ID -> ID ) + ID ) = ID -> ID ; 

if ( ID ) 
* ( ID -> ID + ( ID ( ID ) * ID -> ID ) + ID ) = ID ; 
} 
} 
 
 
{ 
unsigned ID ; 
unsigned ID = INTEGER ; 

ID ( STRING ) ; 

for ( ID = INTEGER ; ID < ID ; ID ++ ) 
{ 
ID ( STRING , ID , ID -> ID [ ID ] ) ; 
if ( ID == INTEGER ) 
{ 
ID += ID -> ID [ ID ] ; 
ID ( STRING , ID ) ; 
} 
else 
{ 
ID ( ID -> ID [ ID ] , INTEGER ) ; 
ID -- ; 
} 
ID ( STRING ) ; 
} 

ID ( STRING ) ; 
for ( ID = INTEGER ; ID < ID -> ID ; ID ++ ) 
{ 
unsigned ID ; 

ID ( STRING , ID ) ; 
for ( ID = INTEGER ; ID < ID -> ID ; ID ++ ) 
ID ( STRING , * ( ID -> ID + ( ID * ID -> ID ) + ID ) ) ; 
ID ( STRING ) ; 
} 
} 
 

ID ( ID ) ; 
ID ( & ID ) ; 
ID ( & ID ) ; 
} 

ID ( & ID ) ; 

return ID ; 
} 

void ID ( ID * ID , ID * ID ) 
{ 
unsigned ID ; 
unsigned ID ; 
unsigned ID ; 
unsigned ID = ID -> ID -> ID -> ID -> ID ; 
int ID = INTEGER ; 
int * ID ; 

ID * ID = ID ( ) ; 

ID ( ID ) ; 

ID ( STRING STRING STRING , ID ( ID -> ID ) ) ; 
ID ( ) ; 
ID ( STRING , ID ) ; 

ID ( STRING ) ; 
ID ( ID -> ID -> ID , INTEGER , INTEGER ) ; 

ID ( STRING ) ; 
for ( ID = INTEGER ; ID < ID -> ID ; ID ++ ) 
{ 
ID ( STRING , 
ID ( ID -> ID [ ID ] . ID ) , 
ID -> ID [ ID ] . ID , 
ID -> ID [ ID ] . ID -> ID ) ; 

ID ( ID -> ID [ ID ] . ID , INTEGER ) ; 
ID ( STRING ) ; 
} 

ID ( STRING , ID -> ID ) ; 
ID ( STRING ) ; 
ID ( & ID -> ID , ID , INTEGER ) ; 
ID ( STRING ) ; 

 
ID ( STRING ) ; 
for ( ID = ID ; ID < ID -> ID ; ID ++ ) 
{ 
if ( ID == ID -> ID ) 
ID ( STRING ) ; 
if ( ID != ID ) 
ID ( STRING , ID ) ; 
} 
ID ( STRING ) ; 

 
ID ( STRING ) ; 
for ( ID = ID ; ID < ID -> ID ; ID ++ ) 
{ 
if ( ID == ID -> ID ) 
ID ( STRING ) ; 
if ( ID != ID ) 
{ 
char ID [ INTEGER ] = { INTEGER } ; 
char * ID = ID ( ID -> ID -> ID -> ID , ID ) -> ID ; 

ID ( ID , ID , INTEGER ) ; 

ID ( STRING , ID ) ; 
} 
} 
ID ( STRING ) ; 

 
ID ( STRING ) ; 
for ( ID = ID ; ID < ID -> ID ; ID ++ ) 
{ 
if ( ID == ID -> ID ) 
ID ( STRING ) ; 
if ( ID != ID ) 
ID ( STRING ) ; 
} 
ID ( STRING ) ; 


for ( ID = INTEGER ; ID < ID -> ID ; ID ++ ) 
{ 
ID ( STRING , ID ) ; 
for ( ID = ID ; ID < ID -> ID ; ID ++ ) 
{ 
ID = ID ( ID , ID , ID ) ; 

if ( ID == ID -> ID ) 
ID ( STRING ) ; 

if ( ID != ID ) 
if ( ! ( * ID == INTEGER || * ( ID + INTEGER ) == INTEGER ) ) 
ID ( STRING , ID ++ ) ; 
else 
ID ( ID , * ID , ID ) ; 
} 
ID ( STRING ) ; 
} 

ID ( STRING ) ; 

if ( ID <= INTEGER ) 
ID ( STRING ) ; 
else 
{ 
ID = INTEGER ; 
for ( ID = INTEGER ; ID < ID -> ID ; ID ++ ) 
{ 
for ( ID = ID ; ID < ID -> ID ; ID ++ ) 
{ 
ID = ID ( ID , ID , ID ) ; 

if ( ID != ID ) 
if ( ! ( * ID == INTEGER || * ( ID + INTEGER ) == INTEGER ) ) 
{ 
ID ( STRING , ID ++ ) ; 

while ( * ID != INTEGER ) 
ID ( ID , * ID ++ , ID ) ; 

ID ( STRING ) ; 
} 
} 
} 
} 
ID ( ID ) ; 
} 

 
static int ID ; 
static char ID [ ID ] ; 
static int ID ; 

void ID ( ID * ID ) 
{ 
while ( ID ( ID ) && ID != ID && ID != STRING && ID != STRING ) 
ID = ID ( ID ) ; 
} 

void ID ( ID * ID ) 
{ 
while ( ID != ID && ID != STRING && ID != STRING ) 
ID = ID ( ID ) ; 

ID = ID ( ID ) ; 

ID ( ID ) ; 
} 

void ID ( ID * ID ) 
{ 
while ( ID != ID && ID != STRING ) 
ID = ID ( ID ) ; 

ID = ID ( ID ) ; 

ID ( ID ) ; 
} 

void ID ( ID * ID ) 
{ 
char * ID = ID ; 

ID ( ID ) ; 

while ( ID - ID < ID - INTEGER && ! ID ( ID ) && ID != ID ) 
{ 
* ID ++ = ( char ) ID ; 
ID = ID ( ID ) ; 
} 

* ID = INTEGER ; 

ID ( ID ) ; 
} 

void ID ( ID * ID ) 
{ 
int ID = INTEGER ; 

ID = INTEGER ; 

while ( ID == STRING ) 
{ 
ID ^= INTEGER ; 
ID = ID ( ID ) ; 
} 

ID ( ID ) ; 

while ( ID ( ID ) ) 
{ 
ID = ID * INTEGER + ID - STRING ; 
ID = ID ( ID ) ; 
} 

if ( ID ) 
ID *= - INTEGER ; 

ID ( ID ) ; 
} 


void ID ( ID * ID , ID * ID ) 
{ 
int * ID = ( int * ) ID ( ID ( ID -> ID -> ID -> ID -> ID ) + INTEGER , sizeof ( int ) ) ; 
int * ID = ( int * ) ID ( INTEGER , sizeof ( int ) ) ; 

ID = ID ( ID ) ; 
while ( ID ( ID , STRING ) != INTEGER && ID != ID ) 
{ 
ID ( ID ) ; 

ID ( ID ) ; 
} 

ID ( ID ) ; 
ID ( ID ) ; 
ID ( ID ) ; 

while ( INTEGER ) 
{ 
int ID ; 
int ID ; 

ID ( ID ) ; 
ID = ID ; 
if ( ID == INTEGER )  
break ; 

ID ( ID ) ; 
ID = INTEGER ; 

while ( ID != STRING && ID != ID ) 
{ 
int ID = INTEGER ; 
int * ID ; 

while ( ID ( ID ) || ID == STRING || ID == STRING || ID == STRING || ID == STRING || ID == STRING ) 
{ 
if ( ID == STRING || ID == STRING || ID == STRING || ID == STRING ) 
ID = ID ( ID ) ;  

ID ( ID ) ; 

ID [ ID ++ ] = ID ; 
} 

ID ( ID ) ; 

if ( ID > INTEGER ) 
{ 
ID = ( int * ) ID ( ID + INTEGER , sizeof ( int ) ) ; 
ID ( ID , ID , ID * sizeof ( int ) ) ; 
* ( ID -> ID + ( ID * ID -> ID ) + ID ) = ID ; 
} 
else 
* ( ID -> ID + ( ID * ID -> ID ) + ID ) = ID ; 

ID ++ ; 
} 

ID ( ID ) ; 
} 

ID ( ID ) ; 
} 

void ID ( ID * ID , ID * ID , int ID ) 
{ 
unsigned ID ; 
unsigned ID ; 
unsigned ID ; 
int ID ; 
int ID ; 
int * ID ; 
ID * ID = ID -> ID -> ID ; 
ID * ID = ID -> ID ; 
ID * ID ; 
unsigned ID = INTEGER ; 

ID * ID = ID ( ) ; 

ID ( ID -> ID ) ; 

ID ( ID ) ; 

ID ( STRING STRING STRING , ID ( ID -> ID ) ) ; 
ID ( ) ; 
ID ( STRING , ID ) ; 

if ( ! ID ) 
{ 
ID ( STRING ) ; 
for ( ID = INTEGER ; ID < ID -> ID ; ID ++ ) 
{ 
ID ( STRING , ID ) ; 
ID ( ID ( ID -> ID -> ID -> ID , ID ) ) ; 
} 

ID ( STRING ) ; 
if ( ID ( ID -> ID -> ID ) == ID ) 
ID ( ID -> ID -> ID ) ; 

ID = ID ( ID -> ID -> ID ) ; 

for ( ID = INTEGER ; ID < ID ; ID ++ ) 
{ 
ID * ID = ( ID * ) ID ( ID -> ID -> ID ) [ ID ] ; 

if ( ID != ID && ID ( ID ) ) 
{ 
ID ( STRING , ID ( ID ) ) ; 
ID ( ID , INTEGER ) ; 
ID ( STRING , ID ( ID ) ? STRING : STRING ) ; 
} 
} 

ID ( STRING ) ; 
ID ( ID -> ID , ID , ID ) ;  
ID ( ID , ID ) ; 

ID ( STRING ) ; 
ID ( ID -> ID , ID , ID ) ;  
{ 
ID ( STRING , ID ( ID ) ) ; 
ID ( & ID -> ID . ID -> ID , ID , INTEGER ) ; 
ID ( STRING ) ; 
} 
} 

ID ( STRING ) ; 
for ( ID = INTEGER ; ID < ID -> ID ; ID ++ ) 
{ 
ID ( STRING , 
ID , 
ID -> ID [ ID ] . ID , 
ID -> ID [ ID ] . ID -> ID , 
ID ( ID -> ID [ ID ] . ID ) ) ; 

ID ( ID -> ID [ ID ] . ID , INTEGER ) ; 
ID ( STRING ) ; 
} 

ID ( STRING , ID -> ID ) ; 

ID ( STRING ) ; 
ID ( & ID -> ID , ID , INTEGER ) ; 
ID ( STRING ) ; 

ID ( STRING ) ; 
for ( ID = ID ; ID < ID -> ID ; ID ++ ) 
ID ( STRING , ID ) ; 

ID ( STRING ) ; 

for ( ID = ID ; ID < ID -> ID ; ID ++ ) 
{ 
ID * ID = ID ( ID -> ID -> ID -> ID , ID ) ; 

ID ( STRING ) ; 
ID ( ID ) ; 
if ( ID == INTEGER && ID -> ID != ID ) 
ID = ID ; 
} 

if ( ! ID ) 
ID = ID -> ID ; 

ID ( STRING ) ; 

for ( ID = INTEGER ; ID < ID -> ID ; ID ++ ) 
{ 
ID ( STRING , ID ) ; 
for ( ID = ID ; ID < ID ; ID ++ ) 
{ 
int ID = INTEGER ; 
ID = ID ( ID , ID , ID ) ; 

if ( ID -> ID != ID ) 
ID ( STRING , ID [ ( * ( ID -> ID + ( ID * ID -> ID ) + ID ) ) ] ) ; 
else 
ID ( STRING ) ; 

while ( * ID != INTEGER ) 
{ 
if ( ID ) 
ID = INTEGER ; 
else 
ID ( STRING ) ; 

ID ( STRING , * ID ++ ) ; 
} 
} 
ID ( STRING ) ; 
} 

if ( ID -> ID != ID ) 
{ 
ID ( STRING ) ; 
for ( ID = ID ; ID < ID ; ID ++ ) 
ID ( STRING , ID ) ; 

ID ( STRING ) ; 

for ( ID = ID ; ID < ID ; ID ++ ) 
{ 
ID ( STRING ) ; 
ID ( ID ( ID -> ID -> ID -> ID , ID ) ) ; 
} 

ID ( STRING ) ; 

for ( ID = INTEGER ; ID < ID -> ID ; ID ++ ) 
{ 
ID ( STRING , ID ) ; 
for ( ID = ID ; ID < ID ; ID ++ ) 
ID ( STRING , ( * ( ID -> ID + ( ID * ID -> ID ) + ID ) ) ) ; 
ID ( STRING ) ; 
} 
} 

ID ( ID ) ; 
} 

static char * ID ; 
static ID ; 
static char * ID ; 
static int ID = INTEGER ; 

static void ID ( char * ID , ID * ID ) 
{ 
ID = INTEGER ; 
ID = ID ; 

ID = ID ( STRING ) -> ID -> ID ; 

if ( * ID != INTEGER ) 
ID = ID ( ID -> ID , ID , ID ) -> ID ; 

ID ( STRING , * ID == INTEGER ? STRING : ID , ID ) ; 
} 

static int ID ( ID * ID ) 
{ 
ID * ID , 
* ID ; 
int ID = INTEGER ; 

if ( ! ID ( * ID ) && * ID != INTEGER ) 
{ 
while ( ! ID ( * ID ) && * ID != INTEGER ) 
ID ++ ; 
if ( ID != INTEGER ) 
{ 
if ( * ID == INTEGER ) 
return ID ; 
else 
return ID ; 
} 
} 

while ( ! ID ( * ID ) && * ID != INTEGER ) 
ID ++ ; 

if ( * ID == INTEGER ) 
{ 
 
ID ( STRING ) ; 
 
return ID ; 
} 

for ( ID = ( ID * ) ID ( ID ( ID -> ID -> ID -> ID ) ) ; 
ID != ID ; 
ID = ( ID * ) ID ( ID ) ) 
if ( ID -> ID == ID ) 
{ 
int ID = ID ( ID -> ID ) ; 

if ( ID ( ID -> ID , ID , ID ) == INTEGER && ID > ID ) 
{ 
ID = ID ; 
ID = ID ; 
} 
} 

if ( ID > INTEGER ) 
{ 
 
ID ( STRING , ID -> ID , ID -> ID ) ; 
 
ID += ID ; 
return ID -> ID ; 
} 
else 
{ 
 
ID ( STRING ) ; 
 
return ID ; 
} 
} 

ID * ID ( ID * ID , char * ID ) 
{ 
 
unsigned ID = INTEGER ; 
unsigned ID = INTEGER ; 
unsigned ID = INTEGER ; 
 
int * ID = ( int * ) ID ( INTEGER ) ; 
int * ID = ID ; 
int ID ; 
ID * ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 

ID -> ID = ID ; 

ID ( ID , STRING , ID ) ; 

ID ( ID , ID -> ID -> ID ) ; 

ID ( ID ) ; 

* ++ ID = INTEGER ; 

while ( INTEGER ) 
{ 
int * ID = * ( ID -> ID + ( * ID * ID -> ID ) + ID ) ; 

if ( * ID == INTEGER ) 
{ 
ID ( ID , STRING ) ; 
ID ( ID ) ; 
return ( ID ) ; 
} 

 
{ 
int * ID ; 

ID ( STRING , * ( ID + INTEGER ) ) ; 
for ( ID = ID + INTEGER ; ID <= ID ; ID += INTEGER ) 
ID ( STRING , * ID , ID ( ID -> ID -> ID , * ID ) -> ID , * ( ID + INTEGER ) ) ; 
ID ( STRING , * ID ) ; 
} 
 

if ( * ID < INTEGER )  
{ 
* ++ ID = ID ; 
* ++ ID = - * ID ; 
 
ID ( STRING , ID - ID ) ; 
ID ++ ; 
if ( ID - ID > ID ) 
ID = ID - ID ; 
 
ID ( ID ) ; 
}  
else 
{ 
ID * ID = & ( ID -> ID [ * ID ] ) ; 
unsigned ID = ID ( ID -> ID ) ; 
unsigned ID = ID -> ID -> ID ; 
int ID ; 

if ( ID ( & ID -> ID , ID ) ) 
{ 
ID ( ID , STRING ) ; 
 
ID ( STRING , ID , ID , ID ) ; 
 
ID -> ID = INTEGER ; 
ID ( ID ) ; 
return ( ID ) ; 
} 

ID -= ID -> ID * INTEGER ; 
ID = - * ( * ( ID -> ID + ( * ID * ID -> ID ) + ID ) ) ;  
 
ID ( STRING , ID , ID -> ID * INTEGER , * ID , ID ) ; 
 
* ++ ID = ID ; 
* ++ ID = ID ; 
 
ID ( STRING , ID -> ID , ID - ID ) ; 
ID ++ ; 
if ( ID - ID > ID ) 
ID = ID - ID ; 
 
} 
} 
} 

enum ID 
{ 
ID , ID , ID , ID , ID 
} ; 

typedef struct ID 
{ 
struct ID * ID ; 
struct ID * ID ; 
} ID ; 

typedef struct ID 
{ 
unsigned ID ; 
enum ID ID ; 
struct ID * ID ; 
unsigned ID ; 
unsigned ID ; 
} ID ; 

typedef struct ID 
{ 
unsigned ID ; 
unsigned ID ; 
} ID ; 

static ID * ID = ID ; 
static ID * ID = ID ; 
static ID * ID = ID ; 
static int ID ; 

void ID ( ID * ID , void * ID ) 
{ 
ID * ID ; 
ID * ID ; 
ID * ID = ID ( ) ; 
unsigned ID = INTEGER ; 
unsigned ID = INTEGER ; 
unsigned ID = INTEGER ; 
unsigned ID = INTEGER ; 
unsigned ID = INTEGER ; 
ID * ID = ID ; 
ID * ID = ID ; 

ID ( & ID ) ; 
ID ( & ID ) ; 

ID ( ID ) ; 

for ( ID = ( ID * ) ID ( ID ) ; ID != ID ; ID = ( ID * ) ID ( ID ) ) 
{ 
if ( ID < ID -> ID ) 
ID = ID -> ID ; 


switch ( ID -> ID ) 
{ 
case ID : 
ID ( ID , ID -> ID ) ; 
ID ++ ; 
break ; 

case ID : 
ID ( ID , ID -> ID ) ; 
ID ++ ; 
break ; 

case ID : 
ID ( ID , ID -> ID ) ; 
ID ++ ; 
break ; 
} 

for ( ID = ( ID * ) ID ( ID ) ; ID != ID ; ID = ( ID * ) ID ( ID ) ) 
{ 
ID ++ ; 

ID ( ID , ID -> ID ) ; 
} 
} 

ID = ( ID + INTEGER ) / INTEGER ; 

ID ( STRING , 
ID , ID == INTEGER ? STRING : STRING , 
ID , ID == INTEGER ? STRING : STRING , 
ID , ID == INTEGER ? STRING : STRING , 
ID , ID == INTEGER ? STRING : STRING , 
ID - INTEGER , ID - INTEGER == INTEGER ? STRING : STRING ) ; 

ID ( STRING , ID ) ; 

ID ( STRING ) ; 
ID ( ID ) ; 
ID ( STRING , ID ( ID ) ) ; 

ID ( STRING ) ; 
ID ( ID ) ; 
ID ( STRING , ID ( ID ) ) ; 

ID ( STRING ) ; 
ID ( ID ) ; 
ID ( STRING , ID ( ID ) ) ; 
ID ( STRING , ID ( ID ) ) ; 

ID ( STRING ) ; 
ID ( ID ) ; 
ID ( STRING , ID ( ID ) ) ; 
ID ( STRING , ID ( ID ) ) ; 

ID ( STRING ) ; 
ID ( ID ) ; 
ID ( STRING , ID ( ID ) ) ; 
ID ( STRING , ID ( ID ) ) ; 

ID ( & ID ) ; 
ID ( & ID ) ; 
ID ( & ID ) ; 
ID ( & ID ) ; 
ID ( & ID ) ; 

ID ( ID ) ; 
} 

static ID * ID ; 

void ID ( const void * ID ) 
{ 
ID ( STRING , ID ) ;  
} 

void ID ( const void * ID ) 
{ 
ID * ID = ( ID * ) ID ; 

ID ( STRING , ID -> ID ) ; 

switch ( ID -> ID ) 
{ 
case ID : 
ID ( STRING ) ; 
break ; 
case ID : 
ID ( STRING ) ; 
break ; 
case ID : 
ID ( STRING , ID -> ID , ID -> ID ) ; 
break ; 
case ID : 
case ID : 
ID ( STRING , ID ( ID -> ID -> ID -> ID -> ID , ID -> ID ) -> ID , ID -> ID ) ; 
break ; 
default : 
ID ( STRING ) ; 
break ; 
} 
} 

void ID ( const void * ID ) 
{ 
ID * ID = ( ID * ) ID ; 

if ( ID -> ID != INTEGER ) 
{ 
ID ( STRING ) ; 
ID ( ID ( ID -> ID -> ID -> ID -> ID , ID -> ID ) ) ; 
ID ( STRING , ID -> ID ) ; 
} 
} 

void ID ( ID * ID , ID * ID ) 
{ 
ID * ID = ID ( ) ; 

ID ( ID ) ; 
ID = ID ; 
ID ( ID -> ID , ID , ID , ID ) ; 
ID ( ID ) ; 
} 

 

 
ID ( ID , ID , ID , ID , ID )  
{  
ID ( STRING , ID , ID ( ID -> ID -> ID -> ID , ID ) -> ID ) ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
 
ID ( ID , ID ) ;  
ID ( ID , ID ) ;  
 
if ( ++ ID == ID )  
ID = ID ;  
 
if ( ID == ID )  
ID ( ID , STRING ) ;  
 
if ( ID >= ID )  
{  
if ( ID < ID - ID )  
ID = ID - ID ;  
}  
else  
{  
if ( ID < ID - ( ID - ID ) )  
ID = ID - ( ID - ID ) ;  
}  
} 

ID * ID ( ID * ID , char * ID , int ID , int ID ) 
{ 
typedef struct ID 
{ 
ID * ID ; 
unsigned ID ; 
unsigned ID ; 
unsigned ID ; 
ID * ID ; 
} ID ; 

ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 

ID * * ID ;  
ID * * ID ;  
ID * * ID ;  
int ID ;  
int ID ;  
int ID ;  
int ID = INTEGER ; 
unsigned ID = ID -> ID ; 
unsigned ID = INTEGER ;  
ID * ID ;  


 
 
if ( ID == INTEGER ) 
ID = INTEGER ; 

ID = ID ( ID , sizeof ( ID ) ) ;  
ID = ID + ID ;  
ID = ID ;  
ID = ID ;  

ID ( STRING , ID , ID ? STRING : STRING , ID ) ; 
ID ( & ID -> ID , ID , INTEGER ) ; 
ID ( STRING ) ; 

 
ID = ( ID * * ) ID ( ID , sizeof ( ID * ) ) ; 
ID = ( ID * * ) ID ( ID , sizeof ( ID * ) ) ; 
ID = ( ID * * ) ID ( ID , sizeof ( ID * ) ) ; 

 
ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 
ID -> ID = ID ; 
ID -> ID = ID ( STRING ) ; 
ID ( ID -> ID , ID ( sizeof ( ID ) , ID -> ID ) ) ; 
( ( ID * ) ID ( ID -> ID ) ) -> ID = ID ; 

 
ID [ ID -> ID ] = ( ID * ) ID ( sizeof ( ID ) , ID -> ID ) ; 
ID [ ID -> ID ] -> ID = ID -> ID ; 
ID [ ID -> ID ] -> ID = ID ; 
ID [ ID -> ID ] -> ID = ID ; 

 
ID ( sizeof ( ID ) , ID ( ID -> ID ) , ID [ ID -> ID ] ) ; 

 
ID ( ID , ID -> ID -> ID ) ; 
ID ( ID ) ; 

 
ID ( & ID ) ; 
ID ( & ID ) ; 
ID ( & ID ) ; 
ID = - INTEGER ; 

 
do 
{ 
 
 
for ( ID = ID - INTEGER ; ID > INTEGER ; ID -- ) 
if ( ID [ ID ] != ID ) 
{ 
int * ID = ID ( ID , ID , ID ) ; 

if ( * ID == INTEGER ) 
{ 
ID [ ID ] = ID ;  
ID ( STRING , ID , INTEGER ) ; 
} 
else 
{ 
while ( * ID < INTEGER )  
{ 
ID ++ ; 
ID ( STRING , ID , INTEGER ) ; 
} 

while ( * ID > INTEGER ) 
if ( ID ( & ID -> ID , ID ( ID -> ID [ * ID ] . ID ) ) ) 
{ 
ID = INTEGER ; 
ID ( STRING , ID ( ID -> ID [ * ID ] . ID ) , INTEGER ) ; 
ID ++ ; 
} 
else 
{ 
ID * ID = & ( ID -> ID [ * ID ] ) ; 
unsigned ID = ID -> ID * INTEGER ; 
unsigned ID = ID -> ID -> ID ; 

ID * ID = ID [ ID ] ; 
ID * ID ; 

ID ( STRING , ID ( ID -> ID [ * ID ] . ID ) , INTEGER ) ; 

for ( ID = ( ID * ) ID ( ID ) ; ID != ID ; ID = ( ID * ) ID ( ID ) ) 
{ 
ID ( ID , ID ) ; 
ID ( ID , ID , ID , ID , ID ) ; 
} 
ID ++ ; 
} 
} 
} 

 
while ( ID != ID ) 
{ 
int ID ; 
unsigned ID ; 
ID * ID ; 
int * ID ; 
unsigned ID = ID -> ID ; 
unsigned ID = ID -> ID ; 
unsigned ID = ID -> ID ; 
ID * ID = ID -> ID ; 
ID * ID = ( ID * ) ID ( ID ) ;  
ID * ID = ID -> ID ; 
ID * ID ; 
ID * ID ; 

ID ( STRING , ID , ID ) ; 
ID ( STRING , ID - ID , INTEGER ) ; 

 
if ( ++ ID == ID ) 
ID = ID ; 

 
while ( ID > INTEGER ) 
{ 
ID * ID ; 

ID -- ; 

ID = ( ID * ) ID ( ID ) ; 
ID -> ID ++ ; 
ID -> ID ++ ; 
ID = ( ID * ) ID ( ID ) ; 
ID ( STRING , ID , ID -> ID ) ; 

 
if ( ID != ID ) 
for ( ID = ( ID * ) ID ( ID ) ; ID != ID ; ID = ( ID * ) ID ( ID ) ) 
ID ( ID , ID , ID , ID , ID ) ; 
} 

ID ( STRING , ID -> ID , INTEGER ) ; 

 
ID = - * ( ID ( ID , ID -> ID , ID ) ) ; 
ID ( STRING , ID , INTEGER ) ; 
ID = ID [ ID ] ; 
if ( ID == ID ) 
{ 
ID ( STRING , ID , INTEGER ) ; 
ID = ( ID * ) ID ( sizeof ( ID ) , ID -> ID ) ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID [ ID ] = ID ; 

 
ID = INTEGER ; 
} 
else 
{  
void * ID ; 

for ( ID = ID ( ID ) ; ID != ID ; ID = ID ( ID ) ) 
{ 
ID * ID = ( ID * ) ID ( ID ) ; 
void * ID ; 

for ( ID = ID ( ID ) ; ID != ID ; ID = ID ( ID ) ) 
if ( ID ( ID ) == ID ) 
goto ID ; 
} 

 
ID = INTEGER ; 
} 

 
 
 
ID = ( ID * ) ID ( sizeof ( ID ) , ID -> ID ) ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
if ( ID -> ID == ID -> ID ) 
ID -> ID = ID -> ID ; 
else 
ID -> ID = ID -> ID - INTEGER ; 

ID ( sizeof ( ID ) , ID , ID ) ; 
ID = ( ID * ) ID ( sizeof ( ID ) , ID , ID ) ; 
 
ID = ( ID * ) ID ( sizeof ( ID ) , ID , ID ) ; 
 

 
ID = ID ( ID , ID , ID ) ; 

while ( * ID < INTEGER ) 
ID ++ ; 

while ( * ID > INTEGER ) 
if ( ID ( & ID -> ID , ID ( ID -> ID [ * ID ] . ID ) ) ) 
{ 
ID = INTEGER ; 
ID ( STRING , ID ( ID -> ID [ * ID ] . ID ) , INTEGER ) ; 
ID ++ ; 
} 
else 
{ 
ID * ID = & ( ID -> ID [ * ID ] ) ; 
unsigned ID = ID -> ID * INTEGER ; 
unsigned ID = ID -> ID -> ID ; 

 

ID ( STRING , ID ( ID -> ID [ * ID ] . ID ) , INTEGER ) ; 
if ( ! ( ID && 
ID -> ID == ID -> ID  && 
ID != INTEGER ) )  
if ( ID || ID != INTEGER ) 
{ 
ID ( ID , ID ) ; 
ID ( ID , ID , ID , ID , ID ) ; 
} 

ID ++ ;  
} 
ID : ; 

} 

 
 
ID ( ID , INTEGER , sizeof ( ID * ) * ID ) ;  
ID ( ID , INTEGER , sizeof ( ID * ) * ID ) ;  

 
for ( ID = INTEGER ; ID < ID ; ID ++ ) 
{ 
if ( ID [ ID ] != ID ) 
{ 
int * ID = ID ( ID , ID [ ID ] -> ID , ID ) ; 

while ( * ID < INTEGER ) 
{ 
ID * * ID = & ID [ - * ID ] ; 
ID * * ID = & ID [ - * ID ] ; 

if ( * ID == ID ) 
{ 
ID ( STRING , - * ID , INTEGER ) ; 

* ID = ( ID * ) ID ( sizeof ( ID ) , ID -> ID ) ; 
( * ID ) -> ID = - * ID ; 
( * ID ) -> ID = ID ; 
( * ID ) -> ID = ID + INTEGER ; 

* ID = ( ID * ) ID ( sizeof ( ID ) , ID -> ID ) ; 
( * ID ) -> ID = ID ; 
( * ID ) -> ID = ID ; 
( * ID ) -> ID = ID + INTEGER ; 

ID ( sizeof ( ID ) , * ID , * ID ) ; 
} 
ID ++ ; 
} 
} 
} 

if ( ID [ INTEGER ] != ID ) ID = INTEGER ; 

 
for ( ID = INTEGER , ID = INTEGER ; ID < ID ; ID ++ ) 
{ 
if ( ID [ ID ] != ID ) 
{ 
int * ID = ID ( ID , ID [ ID ] -> ID , ID ) ; 

if ( * ID < INTEGER ) 
{ 
ID ( STRING , - * ID , INTEGER ) ; 
ID = INTEGER ; 
ID ( sizeof ( ID ) , ID [ ID ] , ID [ - * ID ] ) ; 
} 
} 
ID [ ID ] = ID [ ID ] ; 
} 

 
ID ( STRING , ID , INTEGER ) ; 
ID ( ID ) ; 
ID += INTEGER ; 
} 
while ( ID ) ; 

if ( ID ) ID ( STRING ) ; else ID ( STRING ) ; 

 
ID ( ID , ID -> ID ) ; 

 
ID ( ID ) ; 
ID ( ID ) ; 
ID ( ID ) ; 

return ID ; 
} 

ID * ID ( ID * ID , char * ID , int ID , int ID ) 
{ 
typedef struct ID 
{ 
ID * ID ; 
unsigned ID ; 
unsigned ID ; 
unsigned ID ; 
ID * ID ; 
} ID ; 

ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 

ID * * ID ;  
ID * * ID ;  
int ID ;  
int ID ;  
int ID ;  
unsigned ID = ID -> ID ; 
unsigned ID = INTEGER ;  
ID * ID ;  
int ID = INTEGER ; 


 
 
if ( ID == INTEGER ) 
ID = INTEGER ; 

ID = ( ID * ) ID ( ID , sizeof ( ID ) ) ;  
ID = ID + ID ;  
ID = ID ;  
ID = ID ;  

ID ( STRING , ID , ID ? STRING : STRING , ID ) ; 
ID ( & ID -> ID , ID , INTEGER ) ; 
ID ( STRING ) ; 

 
ID = ( ID * * ) ID ( ID , sizeof ( ID * ) ) ; 
ID = ( ID * * ) ID ( ID , sizeof ( ID * ) ) ; 

 
ID = ( ID * ) ID ( INTEGER , sizeof ( ID ) ) ; 
ID -> ID = ID ; 
ID -> ID = ID ( STRING ) ; 
ID ( ID -> ID , ID ( sizeof ( ID ) , ID -> ID ) ) ; 
( ( ID * ) ID ( ID -> ID ) ) -> ID = ID ; 

 
ID [ ID -> ID ] = ( ID * ) ID ( sizeof ( ID ) , ID -> ID ) ; 
ID [ ID -> ID ] -> ID = ID -> ID ; 
ID [ ID -> ID ] -> ID = ID ; 
ID [ ID -> ID ] -> ID = ID ; 

 
ID ( sizeof ( ID ) , ID ( ID -> ID ) , ID [ ID -> ID ] ) ; 

 
ID ( ID , ID -> ID -> ID ) ; 
ID ( ID ) ; 

 
ID ( & ID ) ; 
ID ( & ID ) ; 
ID ( & ID ) ; 
ID = - INTEGER ; 

 
do 
{ 
 
 
for ( ID = ID - INTEGER ; ID > INTEGER ; ID -- ) 
if ( ID [ ID ] != ID ) 
{ 
int * ID = ID ( ID , ID , ID ) ; 

if ( * ID == INTEGER ) 
{ 
ID [ ID ] = ID ;  
ID ( STRING , ID , INTEGER ) ; 
} 
else 
{ 
while ( * ID < INTEGER )  
{ 
ID ++ ; 
ID ( STRING , ID , INTEGER ) ; 
} 

while ( * ID > INTEGER ) 
if ( ID ( & ID -> ID , ID ( ID -> ID [ * ID ] . ID ) ) ) 
{ 
 ID = INTEGER ; 
ID ( STRING , ID ( ID -> ID [ * ID ] . ID ) , INTEGER ) ; 
ID ++ ; 
} 
else 
{ 
ID * ID = & ( ID -> ID [ * ID ] ) ; 
unsigned ID = ID -> ID ; 
unsigned ID = ID -> ID -> ID ; 

ID * ID = ID [ ID ] ; 
ID * ID ; 

ID ( STRING , ID ( ID -> ID [ * ID ] . ID ) , INTEGER ) ; 

for ( ID = ( ID * ) ID ( ID ) ; ID != ID ; ID = ( ID * ) ID ( ID ) ) 
{ 
ID ( ID , ID ) ; 
ID ( ID , ID , ID , ID , ID ) ; 
} 
ID ++ ; 
} 
} 
} 

 
while ( ID != ID ) 
{ 
int ID ; 
unsigned ID ; 
ID * ID ; 
int * ID ; 
unsigned ID = ID -> ID ; 
unsigned ID = ID -> ID ; 
unsigned ID = ID -> ID ; 
ID * ID = ID -> ID ; 
ID * ID = ( ID * ) ID ( ID ) ;  
ID * ID = ID -> ID ; 
ID * ID ; 

ID ( STRING , ID , ID ) ; 
ID ( STRING , ID - ID , INTEGER ) ; 

 
if ( ++ ID == ID ) 
ID = ID ; 

 
while ( ID > INTEGER ) 
{ 
ID * ID ; 

ID -- ; 

ID = ( ID * ) ID ( ID ) ; 
if ( ID ( ID ) != ID )  
{ 
ID -> ID ++ ; 
ID -> ID ++ ; 
} 
ID = ( ID * ) ID ( ID ) ; 
ID ( STRING , ID , ID -> ID ) ; 

 
if ( ID != ID ) 
for ( ID = ( ID * ) ID ( ID ) ; ID != ID ; ID = ( ID * ) ID ( ID ) ) 
ID ( ID , ID , ID , ID , ID ) ; 
} 

ID ( STRING , ID -> ID , INTEGER ) ; 

 
ID = - * ( ID ( ID , ID -> ID , ID ) ) ; 
ID ( STRING , ID , INTEGER ) ; 
ID = ID [ ID ] ; 
if ( ID == ID ) 
{ 
ID ( STRING , ID , INTEGER ) ; 
ID = ( ID * ) ID ( sizeof ( ID ) , ID -> ID ) ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID [ ID ] = ID ; 

 
ID = INTEGER ; 
} 
else 
{  
void * ID ; 

for ( ID = ID ( ID ) ; ID != ID ; ID = ID ( ID ) ) 
if ( ID ( ID ) == ID ) 
goto ID ; 

 
ID = INTEGER ; 
} 

 
ID = ( ID * ) ID ( sizeof ( ID ) , ID , ID ) ; 
ID -> ID = ID ; 

 
ID = ID ( ID , ID , ID ) ; 

while ( * ID < INTEGER ) 
ID ++ ; 

while ( * ID > INTEGER ) 
if ( ID ( & ID -> ID , ID ( ID -> ID [ * ID ] . ID ) ) ) 
{ 
ID ( STRING , ID ( ID -> ID [ * ID ] . ID ) , INTEGER ) ; 
ID ++ ; 
} 
else 
{ 
ID * ID = & ( ID -> ID [ * ID ] ) ; 
unsigned ID = ID -> ID ; 
unsigned ID = ID -> ID -> ID ; 

 
ID ( STRING , ID ( ID -> ID [ * ID ] . ID ) , INTEGER ) ; 
if ( ! ( ID && 
ID -> ID == ID -> ID  && 
ID != INTEGER ) )  
if ( ID || ID != INTEGER ) 
{ 
ID ( ID , ID ) ; 
ID ( ID , ID , ID , ID , ID ) ;  
} 

ID ++ ;  
} 
ID : ; 

} 

 

 
ID ( ID , INTEGER , sizeof ( ID * ) * ID ) ;  

 
for ( ID = INTEGER , ID = INTEGER ; ID < ID ; ID ++ ) 
{ 
if ( ID [ ID ] != ID ) 
{ 
int * ID = ID ( ID , ID [ ID ] -> ID , ID ) ; 

while ( * ID < INTEGER ) 
{ 
ID * * ID = & ID [ - * ID ] ; 

if ( * ID == ID ) 
{ 
ID ( STRING , - * ID , ID ) ; 

ID = INTEGER ; 

* ID = ( ID * ) ID ( sizeof ( ID ) , ID -> ID ) ; 
( * ID ) -> ID = - * ID ; 
( * ID ) -> ID = ID ; 
( * ID ) -> ID = ID + INTEGER ; 
} 

( ( ID * ) ID ( sizeof ( ID ) , ID [ ID ] , * ID ) ) -> ID = ID ; 

ID ++ ; 
} 
} 
} 

if ( ID ) 
{ 
 
for ( ID = INTEGER ; ID < ID ; ID ++ ) 
ID [ ID ] = ID [ ID ] ; 

 
ID ( STRING , ID , INTEGER ) ; 
ID ( ID ) ; 
ID += INTEGER ; 
} 
} 
while ( ID ) ; 

 
ID ( STRING , ID , INTEGER ) ; 

if ( ID != ID ) 
{ 
ID ( STRING , INTEGER , INTEGER ) ; 
} 
else 
{ 
for ( ID = INTEGER ; ID < ID ; ID ++ ) 
{ 
int * ID ; 

ID = ID ( ID , ID , ID ) ; 

while ( * ID > INTEGER ) 
{ 
if ( ID ( & ID -> ID , ID ( ID -> ID [ * ID ] . ID ) ) ) 
{ 
ID = INTEGER ; 
ID ( STRING , ID ( ID -> ID [ * ID ] . ID ) , ID ) ; 
} 
ID ++ ; 
} 
} 
} 

if ( ID ) ID ( STRING ) ; else ID ( STRING ) ; 

 
ID ( ID , ID -> ID ) ; 

 
ID ( ID ) ; 
ID ( ID ) ; 

return ID ; 
}$

ansi_cpp_mult_rdp_full
$
(* ART3 grammar generated by ART from 'v2\ansi_cppV2.art' on Jun 10 2018 08:39:42 - AJ multiply out! *)

translation_unit ::=
   # |
   declaration_seq 



abstract_declarator ::=
   direct_abstract_declarator |
   ptr_operator |
   ptr_operator abstract_declarator 

access_specifier ::=
   'private' |
   'protected' |
   'public' 

additive_expression ::=
   multiplicative_expression |
   additive_expression '+' multiplicative_expression |
   additive_expression '-' multiplicative_expression 

and_expression ::=
   equality_expression |
   and_expression '&' equality_expression 

asm_definition ::=
   'asm' '(' string_literal ')' ';' 

assignment_expression ::=
   conditional_expression |
   logical_or_expression assignment_operator assignment_expression |
   throw_expression 

assignment_operator ::=
   '=' |
   '*=' |
   '/=' |
   '%=' |
   '+=' |
   '-=' |
   '>>=' |
   '<<=' |
   '&=' |
   '^=' |
   '|=' 

base_clause ::=
   ':' base_specifier_list 

base_specifier ::=
   class_name |
   nested_name_specifier class_name |
   '::' class_name |
   '::' nested_name_specifier class_name |
   'virtual' class_name |
   'virtual' nested_name_specifier class_name |
   'virtual' '::' class_name |
   'virtual' '::' nested_name_specifier class_name |
   'virtual' access_specifier class_name |
   'virtual' access_specifier nested_name_specifier class_name |
   'virtual' access_specifier '::' class_name |
   'virtual' access_specifier '::' nested_name_specifier class_name |
   access_specifier class_name |
   access_specifier nested_name_specifier class_name |
   access_specifier '::' class_name |
   access_specifier '::' nested_name_specifier class_name |
   access_specifier 'virtual' class_name |
   access_specifier 'virtual' nested_name_specifier class_name |
   access_specifier 'virtual' '::' class_name |
   access_specifier 'virtual' '::' nested_name_specifier class_name 

base_specifier_list ::=
   base_specifier |
   base_specifier_list ',' base_specifier 

block_declaration ::=
   simple_declaration |
   asm_definition |
   namespace_alias_definition |
   using_declaration |
   using_directive 

boolean_literal ::=
   'true' |
   'false' 

cast_expression ::=
   unary_expression |
   '(' type_id ')' cast_expression 

character_literal ::=
   'CHARACTER' 

class_head ::=
   class_key nested_name_specifier identifier |
   class_key nested_name_specifier identifier base_clause |
   class_key |
   class_key base_clause |
   class_key identifier |
   class_key identifier base_clause 

class_key ::=
   'class' |
   'struct' |
   'union' 

class_name ::=
   identifier |
   template_id 

class_or_namespace_name ::=
   class_name |
   namespace_name 

class_specifier ::=
   class_head '{' '}' |
   class_head '{' member_specification '}' 

compound_statement ::=
   '{' '}' |
   '{' statement_seq '}' 

condition ::=
   expression |
   type_specifier_seq declarator '=' assignment_expression 

conditional_expression ::=
   logical_or_expression |
   logical_or_expression '?' expression ':' assignment_expression 

constant_expression ::=
   conditional_expression 

constant_initializer ::=
   '=' constant_expression 

conversion_declarator ::=
   ptr_operator |
   ptr_operator conversion_declarator 

conversion_function_id ::=
   operator conversion_type_id 

conversion_type_id ::=
   type_specifier_seq |
   type_specifier_seq conversion_declarator 

ctor_initializer ::=
   ':' mem_initializer_list 

cv_qualifier ::=
   'const' |
   'volatile' 

cv_qualifier_seq ::=
   cv_qualifier |
   cv_qualifier cv_qualifier_seq 

decl_specifier ::=
   storage_class_specifier |
   type_specifier |
   function_specifier |
   'friend' |
   'typedef' 

decl_specifier_seq ::=
   decl_specifier |
   decl_specifier_seq decl_specifier 

declaration ::=
   block_declaration |
   function_definition |
   template_declaration |
   explicit_instantiation |
   explicit_specialization |
   linkage_specification |
   namespace_definition 

declaration_seq ::=
   declaration |
   declaration_seq declaration 

declaration_statement ::=
   block_declaration 

declarator ::=
   direct_declarator |
   ptr_operator declarator 

declarator_id ::=
   id_expression |
   '::' id_expression |
   type_name |
   nested_name_specifier type_name |
   '::' type_name |
   '::' nested_name_specifier type_name 

delete_expression ::=
   'delete' cast_expression |
   '::' 'delete' cast_expression |
   'delete' '[' ']' cast_expression |
   '::' 'delete' '[' ']' cast_expression 

direct_abstract_declarator ::=
   '(' abstract_declarator ')' |
   '[' ']' |
   '[' constant_expression ']' |
   direct_abstract_declarator '[' ']' |
   direct_abstract_declarator '[' constant_expression ']' |
   '(' parameter_declaration_clause ')' |
   '(' parameter_declaration_clause ')' exception_specification |
   '(' parameter_declaration_clause ')' cv_qualifier_seq |
   '(' parameter_declaration_clause ')' cv_qualifier_seq exception_specification |
   direct_abstract_declarator '(' parameter_declaration_clause ')' |
   direct_abstract_declarator '(' parameter_declaration_clause ')' exception_specification |
   direct_abstract_declarator '(' parameter_declaration_clause ')' cv_qualifier_seq |
   direct_abstract_declarator '(' parameter_declaration_clause ')' cv_qualifier_seq exception_specification 

direct_declarator ::=
   declarator_id |
   '(' declarator ')' |
   direct_declarator '[' ']' |
   direct_declarator '[' constant_expression ']' |
   direct_declarator '(' parameter_declaration_clause ')' |
   direct_declarator '(' parameter_declaration_clause ')' exception_specification |
   direct_declarator '(' parameter_declaration_clause ')' cv_qualifier_seq |
   direct_declarator '(' parameter_declaration_clause ')' cv_qualifier_seq exception_specification 

direct_new_declarator ::=
   '[' expression ']' |
   direct_new_declarator '[' constant_expression ']' 

elaborated_type_specifier ::=
   'typename' nested_name_specifier identifier |
   'typename' '::' nested_name_specifier identifier |
   'typename' nested_name_specifier identifier '<' template_argument_list '>' |
   'typename' '::' nested_name_specifier identifier '<' template_argument_list '>' |
   class_key identifier |
   class_key nested_name_specifier identifier |
   class_key '::' identifier |
   class_key '::' nested_name_specifier identifier |
   'enum' identifier |
   'enum' nested_name_specifier identifier |
   'enum' '::' identifier |
   'enum' '::' nested_name_specifier identifier 

enum_name ::=
   identifier 

enum_specifier ::=
   'enum' '{' '}' |
   'enum' '{' enumerator_list '}' |
   'enum' identifier '{' '}' |
   'enum' identifier '{' enumerator_list '}' 

enumerator ::=
   identifier 

enumerator_definition ::=
   enumerator |
   enumerator '=' constant_expression 

enumerator_list ::=
   enumerator_definition |
   enumerator_list ',' enumerator_definition 

equality_expression ::=
   relational_expression |
   equality_expression '==' relational_expression |
   equality_expression '!=' relational_expression 

exception_declaration ::=
   type_specifier_seq declarator |
   type_specifier_seq abstract_declarator |
   type_specifier_seq |
   '...' 

exception_specification ::=
   'throw' '(' ')' |
   'throw' '(' type_id_list ')' 

exclusive_or_expression ::=
   and_expression |
   exclusive_or_expression '^' and_expression 

explicit_instantiation ::=
   'template' declaration 

explicit_specialization ::=
   'template' '<' '>' declaration 

expression ::=
   assignment_expression |
   expression ',' assignment_expression 

expression_list ::=
   assignment_expression |
   expression_list ',' assignment_expression 

expression_statement ::=
   ';' |
   expression ';' 

extension_namespace_definition ::=
   'namespace' original_namespace_name '{' namespace_body '}' 

floating_literal ::=
   'REAL' 

for_init_statement ::=
   expression_statement |
   simple_declaration 

function_body ::=
   compound_statement 

function_definition ::=
   declarator function_try_block |
   decl_specifier_seq declarator function_try_block |
   declarator function_body |
   declarator ctor_initializer function_body |
   decl_specifier_seq declarator function_body |
   decl_specifier_seq declarator ctor_initializer function_body 

function_specifier ::=
   'inline' |
   'virtual' |
   'explicit' 

function_try_block ::=
   'try' function_body handler_seq |
   'try' ctor_initializer function_body handler_seq 

handler ::=
   'catch' '(' exception_declaration ')' compound_statement 

handler_seq ::=
   handler |
   handler handler_seq 

id_expression ::=
   unqualified_id |
   qualified_id 

identifier ::=
   'ID' 

inclusive_or_expression ::=
   exclusive_or_expression |
   inclusive_or_expression '|' exclusive_or_expression 

init_declarator ::=
   declarator |
   declarator initializer 

init_declarator_list ::=
   init_declarator |
   init_declarator_list ',' init_declarator 

initializer ::=
   '=' initializer_clause |
   '(' expression_list ')' 

initializer_clause ::=
   assignment_expression |
   '{' '}' |
   '{' initializer_list '}' |
   '{' initializer_list ',' '}' 

initializer_list ::=
   initializer_clause |
   initializer_list ',' initializer_clause 

integer_literal ::=
   'INTEGER' 

iteration_statement ::=
   'while' '(' condition ')' statement |
   'do' statement 'while' '(' expression ')' ';' |
   'for' '(' for_init_statement ';' ')' statement |
   'for' '(' for_init_statement ';' expression ')' statement |
   'for' '(' for_init_statement condition ';' ')' statement |
   'for' '(' for_init_statement condition ';' expression ')' statement 

jump_statement ::=
   'break' ';' |
   'continue' ';' |
   'goto' identifier ';' |
   'return' ';' |
   'return' expression ';' 

labeled_statement ::=
   identifier ':' statement |
   'case' constant_expression ':' statement |
   'default' ':' statement 

linkage_specification ::=
   'extern' string_literal declaration |
   'extern' string_literal '{' '}' |
   'extern' string_literal '{' declaration_seq '}' 

literal ::=
   integer_literal |
   character_literal |
   floating_literal |
   string_literal |
   boolean_literal 

logical_and_expression ::=
   inclusive_or_expression |
   logical_and_expression '&&' inclusive_or_expression 

logical_or_expression ::=
   logical_and_expression |
   logical_or_expression '||' logical_and_expression 

mem_initializer ::=
   mem_initializer_id '(' ')' |
   mem_initializer_id '(' expression_list ')' 

mem_initializer_id ::=
   identifier |
   class_name |
   nested_name_specifier class_name |
   '::' class_name |
   '::' nested_name_specifier class_name 

mem_initializer_list ::=
   mem_initializer |
   mem_initializer ',' mem_initializer_list 

member_declaration ::=
   qualified_id ';' |
   using_declaration |
   template_declaration |
   function_definition |
   function_definition ';' |
   ';' |
   member_declarator_list ';' |
   decl_specifier_seq ';' |
   decl_specifier_seq member_declarator_list ';' 

member_declarator ::=
   declarator |
   declarator pure_specifier |
   declarator |
   declarator constant_initializer |
   ':' constant_expression |
   identifier ':' constant_expression 

member_declarator_list ::=
   member_declarator |
   member_declarator_list ',' member_declarator 

member_specification ::=
   member_declaration |
   member_declaration member_specification |
   access_specifier ':' |
   access_specifier ':' member_specification 

multiplicative_expression ::=
   pm_expression |
   multiplicative_expression '*' pm_expression |
   multiplicative_expression '/' pm_expression |
   multiplicative_expression '%' pm_expression 

named_namespace_definition ::=
   original_namespace_definition |
   extension_namespace_definition 

namespace_alias ::=
   identifier 

namespace_alias_definition ::=
   'namespace' identifier '=' qualified_namespace_specifier ';' 

namespace_body ::=
   # |
   declaration_seq 

namespace_definition ::=
   named_namespace_definition |
   unnamed_namespace_definition 

namespace_name ::=
   original_namespace_name |
   namespace_alias 

nested_name_specifier ::=
   class_or_namespace_name '::' |
   class_or_namespace_name '::' nested_name_specifier 

new_declarator ::=
   direct_new_declarator |
   ptr_operator |
   ptr_operator new_declarator 

new_expression ::=
   'new' new_type_id |
   'new' new_type_id new_initializer |
   'new' new_placement new_type_id |
   'new' new_placement new_type_id new_initializer |
   '::' 'new' new_type_id |
   '::' 'new' new_type_id new_initializer |
   '::' 'new' new_placement new_type_id |
   '::' 'new' new_placement new_type_id new_initializer |
   'new' '(' type_id ')' |
   'new' '(' type_id ')' new_initializer |
   'new' new_placement '(' type_id ')' |
   'new' new_placement '(' type_id ')' new_initializer |
   '::' 'new' '(' type_id ')' |
   '::' 'new' '(' type_id ')' new_initializer |
   '::' 'new' new_placement '(' type_id ')' |
   '::' 'new' new_placement '(' type_id ')' new_initializer 

new_initializer ::=
   '(' ')' |
   '(' expression_list ')' 

new_placement ::=
   '(' expression_list ')' 

new_type_id ::=
   type_specifier_seq |
   type_specifier_seq new_declarator 

operator ::=
   'new' |
   'delete' |
   'new[]' |
   'delete[]' |
   '+' |
   '-' |
   '*' |
   '/' |
   '%' |
   '^' |
   '&' |
   '|' |
   '~' |
   '!' |
   '=' |
   '<' |
   '>' |
   '+=' |
   '-=' |
   '*=' |
   '/=' |
   '%=' |
   '^=' |
   '&=' |
   '|=' |
   '<<' |
   '>>' |
   '>>=' |
   '<<=' |
   '==' |
   '!=' |
   '<=' |
   '>=' |
   '&&' |
   '||' |
   '++' |
   '--' |
   ',' |
   '->*' |
   '->' |
   '()' |
   '[]' 

operator_function_id ::=
   operator operator 

original_namespace_definition ::=
   'namespace' identifier '{' namespace_body '}' 

original_namespace_name ::=
   identifier 

parameter_declaration ::=
   decl_specifier_seq declarator |
   decl_specifier_seq declarator '=' assignment_expression |
   decl_specifier_seq |
   decl_specifier_seq abstract_declarator |
   decl_specifier_seq '=' assignment_expression |
   decl_specifier_seq abstract_declarator '=' assignment_expression 

parameter_declaration_clause ::=
   parameter_declaration_list ',' '...' |
   # |
   '...' |
   parameter_declaration_list |
   parameter_declaration_list '...' 

parameter_declaration_list ::=
   parameter_declaration |
   parameter_declaration_list ',' parameter_declaration 

pm_expression ::=
   cast_expression |
   pm_expression '.*' cast_expression |
   pm_expression '->*' cast_expression 

postfix_expression ::=
   primary_expression |
   postfix_expression '[' expression ']' |
   postfix_expression '.' pseudo_destructor_name |
   postfix_expression '->' pseudo_destructor_name |
   postfix_expression '++' |
   postfix_expression '--' |
   'dynamic_cast' '<' type_id '>' '(' expression ')' |
   'static_cast' '<' type_id '>' '(' expression ')' |
   'reinterpret_cast' '<' type_id '>' '(' expression ')' |
   'const_cast' '<' type_id '>' '(' expression ')' |
   'typeid' '(' expression ')' |
   'typeid' '(' type_id ')' |
   postfix_expression '(' ')' |
   postfix_expression '(' expression_list ')' |
   simple_type_specifier '(' ')' |
   simple_type_specifier '(' expression_list ')' |
   postfix_expression '.' id_expression |
   postfix_expression '.' '::' id_expression |
   postfix_expression '.' 'template' id_expression |
   postfix_expression '.' 'template' '::' id_expression |
   postfix_expression '->' id_expression |
   postfix_expression '->' '::' id_expression |
   postfix_expression '->' 'template' id_expression |
   postfix_expression '->' 'template' '::' id_expression 

primary_expression ::=
   literal |
   'this' |
   '::' identifier |
   '::' operator_function_id |
   '::' qualified_id |
   '(' expression ')' |
   id_expression 

pseudo_destructor_name ::=
   type_name '::' '~' type_name |
   nested_name_specifier type_name '::' '~' type_name |
   '::' type_name '::' '~' type_name |
   '::' nested_name_specifier type_name '::' '~' type_name |
   '~' type_name |
   nested_name_specifier '~' type_name |
   '::' '~' type_name |
   '::' nested_name_specifier '~' type_name 

ptr_operator ::=
   '&' |
   '*' |
   '*' cv_qualifier_seq |
   nested_name_specifier '*' |
   nested_name_specifier '*' cv_qualifier_seq |
   '::' nested_name_specifier '*' |
   '::' nested_name_specifier '*' cv_qualifier_seq 

pure_specifier ::=
   '=' '0' 

qualified_id ::=
   nested_name_specifier unqualified_id |
   nested_name_specifier 'template' unqualified_id 

qualified_namespace_specifier ::=
   namespace_name |
   nested_name_specifier namespace_name |
   '::' namespace_name |
   '::' nested_name_specifier namespace_name 

relational_expression ::=
   shift_expression |
   relational_expression '<' shift_expression |
   relational_expression '>' shift_expression |
   relational_expression '<=' shift_expression |
   relational_expression '>=' shift_expression 

selection_statement ::=
   'if' '(' condition ')' statement |
   'if' '(' condition ')' statement 'else' statement |
   'switch' '(' condition ')' statement 

shift_expression ::=
   additive_expression |
   shift_expression '<<' additive_expression |
   shift_expression '>>' additive_expression 

simple_declaration ::=
   ';' |
   init_declarator_list ';' |
   decl_specifier_seq ';' |
   decl_specifier_seq init_declarator_list ';' 

simple_type_specifier ::=
   'char' |
   'wchar_t' |
   'bool' |
   'short' |
   'int' |
   'long' |
   'signed' |
   'unsigned' |
   'float' |
   'double' |
   'void' |
   type_name |
   nested_name_specifier type_name |
   '::' type_name |
   '::' nested_name_specifier type_name 

statement ::=
   labeled_statement |
   expression_statement |
   compound_statement |
   selection_statement |
   iteration_statement |
   jump_statement |
   declaration_statement |
   try_block 

statement_seq ::=
   statement |
   statement_seq statement 

storage_class_specifier ::=
   'auto' |
   'register' |
   'static' |
   'extern' |
   'mutable' 

string_literal ::=
   'STRING' |
   string_literal 'STRING' 

template_argument ::=
   assignment_expression |
   type_id |
   template_name 

template_argument_list ::=
   template_argument |
   template_argument_list ',' template_argument 

template_declaration ::=
   'template' '<' template_parameter_list '>' declaration |
   'export' 'template' '<' template_parameter_list '>' declaration 

template_id ::=
   template_name '<' template_argument_list '>' 

template_name ::=
   identifier 

template_parameter ::=
   type_parameter |
   parameter_declaration 

template_parameter_list ::=
   template_parameter |
   template_parameter_list ',' template_parameter 

throw_expression ::=
   'throw' |
   'throw' assignment_expression 

try_block ::=
   'try' compound_statement handler_seq 

type_id ::=
   type_specifier_seq |
   type_specifier_seq abstract_declarator 

type_id_list ::=
   type_id |
   type_id_list ',' type_id 

type_name ::=
   class_name |
   enum_name |
   typedef_name 

type_parameter ::=
   'class' |
   'class' identifier |
   'class' '=' type_id |
   'class' identifier '=' type_id |
   'typename' |
   'typename' identifier |
   'typename' '=' type_id |
   'typename' identifier '=' type_id |
   'template' '<' template_parameter_list '>' 'class' |
   'template' '<' template_parameter_list '>' 'class' identifier |
   'template' '<' template_parameter_list '>' 'class' '=' template_name |
   'template' '<' template_parameter_list '>' 'class' identifier '=' template_name 

type_specifier ::=
   simple_type_specifier |
   class_specifier |
   enum_specifier |
   elaborated_type_specifier |
   cv_qualifier 

type_specifier_seq ::=
   type_specifier |
   type_specifier type_specifier_seq 

typedef_name ::=
   identifier 

unary_expression ::=
   postfix_expression |
   '++' cast_expression |
   '--' cast_expression |
   unary_operator cast_expression |
   'sizeof' unary_expression |
   'sizeof' '(' type_id ')' |
   new_expression |
   delete_expression 

unary_operator ::=
   '*' |
   '&' |
   '+' |
   '-' |
   '!' |
   '~' 

unnamed_namespace_definition ::=
   'namespace' '{' namespace_body '}' 

unqualified_id ::=
   identifier |
   operator_function_id |
   conversion_function_id |
   '~' class_name |
   template_id 

using_declaration ::=
   'using' '::' unqualified_id ';' |
   'using' nested_name_specifier unqualified_id ';' |
   'using' '::' nested_name_specifier unqualified_id ';' |
   'using' 'typename' nested_name_specifier unqualified_id ';' |
   'using' 'typename' '::' nested_name_specifier unqualified_id ';' 

using_directive ::=
   'using' 'namespace' namespace_name ';' |
   'using' 'namespace' nested_name_specifier namespace_name ';' |
   'using' 'namespace' '::' namespace_name ';' |
   'using' 'namespace' '::' nested_name_specifier namespace_name ';' 

$
accept
$char 
* ID ,  
* * ID ,  
* ID = STRING ;  

int 
ID = INTEGER ,  
ID = INTEGER ,  
ID ,  
ID ;  

int ID = INTEGER ;  

char * ID = STRING 
STRING STRING STRING STRING STRING STRING STRING STRING 
STRING STRING STRING STRING STRING 
STRING 
STRING STRING STRING STRING STRING STRING STRING STRING 
STRING STRING STRING STRING STRING STRING STRING STRING 
STRING STRING STRING STRING STRING STRING STRING STRING 
STRING STRING STRING STRING STRING STRING STRING STRING 
STRING STRING STRING STRING STRING STRING STRING STRING 
STRING STRING STRING STRING STRING STRING STRING STRING 
STRING STRING STRING STRING STRING STRING STRING STRING 
STRING STRING STRING STRING STRING STRING STRING STRING 
STRING STRING STRING STRING STRING STRING STRING ; 

ID * ID = ID ; 
void * ID = ID ; 
ID * ID = ID ; 
void * ID = ID ; 
ID * ID = ID ; 
void * ID = ID ; 
ID * ID = ID ; 
void * ID = ID ; 

 
static int ID = INTEGER ; 

ID * ID ; 

ID * ID ( char * ID , ID * ID ) 
{ 
if ( ID ) 
{ 
ID * ID = ( ID * ) ID ( sizeof ( ID ) , ID ) ; 
if ( ID != ID ) 
ID -> ID = ID ; 
else 
ID ( ID , ID , sizeof ( ID ) ) ; 
return ID ; 
} 
else 
return ID ; 
} 

ID * ID ( char * ID , ID * ID ) 
{ 
if ( ID ) 
{ 
ID = ( ID * ) ID ( sizeof ( ID ) , ID ) ; 
if ( ID != ID ) 
ID -> ID = ID ; 
else 
ID ( ID , ID , sizeof ( ID ) ) ; 

( ( ID * ) ID ( sizeof ( ID ) , ID , ID ) ) -> ID = INTEGER ; 
return ID ; 
} 
else 
return ID ; 
} 

ID * ID ( char * ID , ID * ID ) 
{ 
if ( ID ) 
{ 
ID * ID = ( ID * ) ID ( sizeof ( ID ) , sizeof ( ID ) , ID ) ; 
if ( ID != ID ) 
ID -> ID = ID ; 
else 
ID ( ID , ID , sizeof ( ID ) ) ; 

( ( ID * ) ID ( ID ) ) -> ID = INTEGER ; 

return ID ; 
} 
else 
return ID ; 
} 


 
static void ID ( void ) 
{ 
ID ( STRING , STRING , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , STRING , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , STRING , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , STRING , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
ID ( STRING , ID , ID  , ID ) ; 
} 

 

ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 
ID ID = ID ; 

 

static void ID ( void ) 
{ 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , 
ID  , ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , 
ID  , ID  , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID ) ; 
ID ( & ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID , 
ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID , 
ID , ID ) ; 
ID ( & ID , ID , ID , ID , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , 
ID  , ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID ) ; 
ID ( & ID , ID  , ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , 
ID  , ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID  , 
ID  , ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , 
ID  , ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , 
ID  , ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID  , 
ID  , ID  , ID ) ; 
ID ( & ID , ID , ID  , ID  , ID  , ID  , 
ID  , ID ) ; 
ID ( & ID , ID , ID  , ID ) ; 
ID ( & ID , ID , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , 
ID , ID ) ; 
ID ( & ID , ID , ID , ID , ID , 
ID , ID ) ; 
ID ( & ID , ID , ID  , ID ) ; 
ID ( & ID , ID  , ID  , ID ) ; 
ID ( & ID , ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID  , ID ) ; 
ID ( & ID , ID , ID  , ID ) ; 
ID ( & ID , ID  , ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID  , ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , 
ID  , ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID  , 
ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , 
ID  , ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID  , 
ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , 
ID  , ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID  , 
ID  , ID  , ID ) ; 
ID ( & ID , ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID , ID ) ; 
ID ( & ID , ID , ID , ID , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID , 
ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID ) ; 
ID ( & ID , ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID , 
ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID ) ; 
ID ( & ID , ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID  , ID  , ID  , ID  , 
ID  , ID ) ; 
ID ( & ID , ID  , ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , 
ID  , ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID  , 
ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , 
ID  , ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID  , 
ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , 
ID  , ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID  , 
ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , 
ID  , ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID  , 
ID  , ID  , ID ) ; 
ID ( & ID , ID  , ID  , ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID , 
ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID , 
ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID , 
ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID , 
ID , ID ) ; 
ID ( & ID , ID , ID , ID , ID  , ID  , ID  , 
ID  , ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID  , 
ID  , ID  , ID ) ; 
ID ( & ID , ID , ID  , ID  , ID  , ID  , 
ID  , ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID  , ID  , 
ID  , ID  , ID  , ID  , ID  , 
ID  , ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID  , ID  , ID  , 
ID  , ID ) ; 
ID ( & ID , ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID , 
ID , ID , ID , ID , ID , 
ID , ID , ID , ID , 
ID , ID , ID , ID , ID ) ; 
ID ( & ID , ID , ID ) ; 
} 

 
static char * ID ( ID * ID ) ; 
static char * ID ( ID * ID ) ; 
static void ID ( ID * ID ) ; 
static ID * ID ( ID * ID ) ; 
static ID * ID ( ID * ID ) ; 
static ID * ID ( ID * ID ) ; 
static ID * ID ( ID * ID ) ; 
static ID * ID ( ID * ID ) ; 
static ID * ID ( ID * ID ) ; 
static char * ID ( ID * ID ) ; 
void ID ( ID * ID ) ; 

 
static char * ID ( ID * ID ) 
{ 
char * ID ; 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
ID ( ID , & ID , & ID ) ; 
} 
return ID ; 
} 

static char * ID ( ID * ID ) 
{ 
char * ID ; 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
ID ( ID , & ID , & ID ) ; 
} 
return ID ; 
} 

static void ID ( ID * ID ) 
{ 
char * ID ; 
char * ID ; 
char * ID ; 
char * ID ; 
char * ID ; 
long int ID ; 
long int ID ; 
char * ID ; 
char * ID ; 
char * ID ; 
char * ID ; 
char * ID ; 
long int ID ; 
char * ID ; 
{ 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
if ( ID ( ID ) == ID )  
ID ( ID , STRING , ID ) ;  
else  
{  
ID ( ) ;  
ID ( ) ;  
}  
 
} 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
{  
while ( INTEGER ) 
{ 
ID ( ID , & ID , & ID ) ; 
{ 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
ID = ID ( ID ( STRING , ID ) ) ; 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
break ;  
} 
}  
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID ( ID , ID , ID , ID ) ;  
} 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
{  
while ( INTEGER ) 
{ 
ID ( ID , & ID , & ID ) ; 
{ 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
ID = ID ( ID ( STRING , ID ) ) ; 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
break ;  
} 
}  
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID ( ID , ID , ID , ID ) ;  
} 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
{  
while ( INTEGER ) 
{ 
ID ( ID , & ID , & ID ) ; 
{ 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
ID = ID ( ID ( STRING , ID ) ) ; 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
break ;  
} 
}  
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID ( ID , ID , ID , ID ) ;  
} 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID ( ID , ID , ID , ID ) ;  
} 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
ID * ID ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID . ID ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID . ID ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID == INTEGER ) {  
ID = ( ID * ) ID ( sizeof ( ID ) ) ;  
ID -> ID = ID ;  
ID -> ID = ( unsigned ) ID ;  
ID -> ID = ( unsigned ) ID ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
ID = ID ;  
 
} 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
ID * ID ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID == INTEGER ) {  
ID = ( ID * ) ID ( sizeof ( ID ) ) ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
ID = ID ;  
 
} 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
ID = ID ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ( ID , ID , ID ) ; ID -> ID ++ ;  
} 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
ID = ID ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
ID = ID ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
ID = ID ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
ID = ID ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
ID = ID ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID . ID ; 
ID ( ) ; 
ID = ( unsigned ) ID ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID . ID ; 
ID ( ) ; 
ID = ( unsigned ) ID ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID . ID ; 
ID ( ) ; 
ID = ( unsigned ) ID ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
ID = INTEGER ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID . ID ; 
ID ( ) ; 
ID = ( unsigned ) ID ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID . ID ; 
ID ( ) ; 
ID = ( unsigned ) ID ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , & ID , ID ) ) 
{ 
{  
while ( INTEGER ) 
{ 
ID ( ID , & ID , & ID ) ; 
{ 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
ID = INTEGER ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
ID = INTEGER ; ID = INTEGER ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
ID = INTEGER ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
ID = ID ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
break ;  
} 
}  
if ( ID == INTEGER ) {  
ID = INTEGER ;  
} 
if ( ID ( ID , ID  , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
ID = ID ; 
ID = ID ( ID ( STRING , ID ) ) ; 
ID = ID ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
ID = INTEGER ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
ID = INTEGER ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
ID = INTEGER ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
ID ( ID , STRING ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
if ( ID ( ID , ID  , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
ID ( ID ( STRING , ID ) ) ; 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
ID ( ID , STRING ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
ID ( ID , STRING ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID ( STRING , ID ) ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
ID ( ID , STRING ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
ID ( ID , STRING ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
ID ( ID , STRING ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
ID ( ID , STRING ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
ID ( ID , & ID , & ID ) ; 
ID ( ID , & ID , & ID ) ; 
} 
} 

static ID * ID ( ID * ID ) 
{ 
ID * ID ; 
char * ID ; 
char * ID ; 
{ 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ( ID , ID , ID ) ;  
} 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ( ID , ID , ID ) ;  
} 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ( ID , ID , ID ) ;  
} 
} 
else 
ID ( ID , & ID , & ID ) ; 
ID ( ID , & ID , & ID ) ; 
} 
return ID ; 
} 

static ID * ID ( ID * ID ) 
{ 
ID * ID ; 
char * ID ; 
long int ID ; 
ID * ID ; 
long int ID ; 
char * ID ; 
{ 
int ID = ID ; 
{  
while ( INTEGER ) 
{ 
ID ( ID , & ID , & ID ) ; 
{ 
if ( ID ( ID , ID  , ID ) ) 
{ 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID == INTEGER ) {  
ID = ID ( ID , ID , ID ) ;  
ID -> ID = INTEGER ;  
ID -> ID ++ ;   
 
} 
if ( ID ( ID , ID  , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID . ID ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID -> ID = ( unsigned ) ID ;  
} 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ( ID ( STRING , ID , ID ++ ) , ID , ID ) ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
ID -> ID ++ ;  
ID -> ID = INTEGER ;  
ID -> ID = INTEGER ;  
 
} 
if ( ID ( ID , & ID , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
{  
while ( INTEGER ) 
{ 
ID ( ID , & ID , & ID ) ; 
{ 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
break ;  
} 
}  
if ( ID == INTEGER ) {  
ID ( ID , STRING ) ;  
} 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
if ( ID ( ID , & ID , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ( ID , ID , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID . ID ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID -> ID = ID ;  
} 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID -> ID = INTEGER ;   
} 
if ( ID ( ID , ID , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID . ID ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID -> ID = ID ;  
} 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
if ( ID == INTEGER ) {  
if ( ID -> ID == INTEGER ) ID -> ID = INTEGER ;  
if ( ID -> ID != INTEGER && ( ID -> ID < ID -> ID ) )  
ID ( ID , STRING ) ;  
 
} if ( ID == INTEGER ) {  
ID -> ID = ID ;  
} 
{  
while ( INTEGER ) 
{ 
ID ( ID , & ID , & ID ) ; 
{ 
if ( ID ( ID , ID  , ID ) ) 
{ 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID == INTEGER ) {  
ID -> ID = ID ( ID , ID , ID ) ;  
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
break ;  
} 
}  
if ( ID ( ID , & ID , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID -> ID = ID ;  
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID -> ID = ID ;  
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID -> ID = ID ;  
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID -> ID = ID ;  
} 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ( ID ( STRING , ID , ID ++ ) , ID , ID ) ;  
ID -> ID = ID ;  
ID -> ID = ID ; ID -> ID = INTEGER ;  
ID -> ID ++ ;  
ID -> ID = INTEGER ;  
ID -> ID = INTEGER ;  
 
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ( ID ( STRING , ID , ID ++ ) , ID , ID ) ;  
ID -> ID = ID ;  
ID -> ID = ID ; ID -> ID = INTEGER ;  
ID -> ID ++ ;  
ID -> ID = INTEGER ;  
ID -> ID = INTEGER ;  
 
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ( ID ( STRING , ID , ID ++ ) , ID , ID ) ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
ID -> ID ++ ;  
ID -> ID = INTEGER ;  
ID -> ID = INTEGER ;  
 
} 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
break ;  
} 
}  
ID ( ID , & ID , & ID ) ; 
} 
return ID ; 
} 

static ID * ID ( ID * ID ) 
{ 
ID * ID ; 
char * ID ; 
long int ID ; 
double ID ; 
char * ID ; 
char * ID ; 
char * ID ; 
{ 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ( ID , ID , ID ) ;  
ID ( ID ) ;  
ID -> ID ++ ;   
ID -> ID = ID ;  
 
} if ( ID == INTEGER && ID -> ID ) { 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ( ID , & ID , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
ID * ID ; 
{  
while ( INTEGER ) 
{ 
ID ( ID , & ID , & ID ) ; 
{ 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID . ID ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ( ID * ) ID ( sizeof ( ID ) , INTEGER ) ;  
ID -> ID = ID ;  
ID -> ID = ID -> ID ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
 
} 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID . ID ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ( ID * ) ID ( sizeof ( ID ) , INTEGER ) ;  
ID -> ID = ID ;  
ID -> ID = ID -> ID ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
 
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID == INTEGER ) {  
ID = ( ID * ) ID ( sizeof ( ID ) , INTEGER ) ;  
ID -> ID = ID ;  
ID -> ID = ID -> ID ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
 
} 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ( ID * ) ID ( sizeof ( ID ) , INTEGER ) ;  
ID -> ID = ID ;  
ID -> ID = ID -> ID ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
 
} 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
break ;  
} 
}  
} 
if ( ! ID ( ID , & ID , ID ) ) break ; 
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID == INTEGER ) {  
ID = ( ID * ) ID ( ID ) ;  
} 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ( ID , ID , ID ) ;  
} 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ( ID , ID , ID ) ;  
} 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ( ID , ID , ID ) ;  
} 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ( ID , ID , ID ) ;  
} 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ( ID , ID , ID ) ;  
} 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ( ID , ID , ID ) ;  
} 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ( ID , ID , ID ) ;  
} 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
ID ( ID , STRING ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
ID ( ID , STRING ) ; 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
ID ( ID , STRING ) ; 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID == INTEGER ) {  
ID ( ID , STRING , ID ) ;  
} 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID ( ID , STRING ) ;  
} 
} 
else 
if ( ID ( ID , ID , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID ( ID , STRING ) ;  
} 
} 
else 
ID ( ID , & ID , & ID ) ; 
ID ( ID , & ID , & ID ) ; 
} 
return ID ; 
} 

static ID * ID ( ID * ID ) 
{ 
ID * ID ; 
ID * ID ; 
{ 
ID * ID ; if ( ID == INTEGER ) {  
ID = ID = ( ID * ) ID ( sizeof ( ID ) , INTEGER ) ;  
} 
{  
while ( INTEGER ) 
{ 
ID ( ID , & ID , & ID ) ; 
{ 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID == INTEGER ) {  
ID -> ID = ( ID * ) ID ( sizeof ( ID ) , INTEGER ) ;  
ID = ID -> ID ;  
ID -> ID = ID ( ID ( STRING , ID , ID ++ ) , ID , ID ) ;  
ID -> ID -> ID ++ ;  
ID -> ID -> ID = ID ;  
 
} 
} 
if ( ID -> ID != ID  ) break ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ) ; 
} 
}  
if ( ID == INTEGER ) {  
ID = ID -> ID ;  
} 
ID ( ID , & ID , & ID ) ; 
} 
return ID ; 
} 

static ID * ID ( ID * ID ) 
{ 
ID * ID ; 
char * ID ; 
char * ID ; 
ID * ID ; 
{ 
unsigned ID ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
ID = ID ; ID = INTEGER ;  
ID ++ ;  
ID = ID ( ID , ID , ID == INTEGER ? ID : ID ) ;  
if ( ID == ID )  
{  
ID = ID ;  
ID -> ID ++ ;  
}  

if ( ID ( ID , ID  , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID -> ID = INTEGER ; 
if ( ID ( ID , ID , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
ID * ID ; ID = STRING ; ID = INTEGER ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
if ( ID ( ID , ID  , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
if ( ID ( ID , ID  , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ++ ; 
} 
if ( ! ID ( ID , ID  , ID ) ) break ; 
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
if ( ID == INTEGER ) {  
ID = ( ID * ) ID ( sizeof ( ID ) , INTEGER ) ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
ID -> ID = ID -> ID ;  
ID -> ID = ID ;  
 
} 
} 
if ( ! ID ( ID , ID , ID ) ) break ; 
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
ID = STRING ; ID = INTEGER ; 
if ( ID ( ID , ID  , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
if ( ID ( ID , ID  , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ++ ; 
} 
if ( ! ID ( ID , ID  , ID ) ) break ; 
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
if ( ID == INTEGER ) {  
ID -> ID = ID ;  
} 
if ( ID ( ID , & ID , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID -> ID = ID ;  
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID -> ID = ID ;  
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID -> ID = ID ;  
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID -> ID = ID ;  
} 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
ID = INTEGER ;  
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID == INTEGER ) {  
ID ++ ;  
ID -> ID = ID ;  
ID -> ID = INTEGER ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
 
} 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
ID ( ID , & ID , & ID ) ; 
} 
return ID ; 
} 

static ID * ID ( ID * ID ) 
{ 
ID * ID ; 
ID * ID ; 
char * ID ; 
char * ID ; 
{ 
ID * ID ; int ID ; int ID ; if ( ID == INTEGER ) {  
ID = ID = ( ID * ) ID ( sizeof ( ID ) , INTEGER ) ;  
} 
{  
while ( INTEGER ) 
{ 
ID ( ID , & ID , & ID ) ; 
{ 
if ( ID == INTEGER ) {  
ID = ID ; ID = ID ; ID = ID ;  
} 
{  
while ( INTEGER ) 
{ 
ID ( ID , & ID , & ID ) ; 
{ 
if ( ID ( ID , & ID , ID ) ) 
{ 
{  
while ( INTEGER ) 
{ 
ID ( ID , & ID , & ID ) ; 
{ 
if ( ID ( ID , & ID , ID ) ) 
{ 
ID = ID ( ID ( STRING , ID ) ) ; 
ID = INTEGER ; 
} 
else 
if ( ID ( ID , & ID , ID ) ) 
{ 
ID = ID ( ID ( STRING , ID ) ) ; 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
break ;  
} 
}  
if ( ID ( ID , ID  , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
if ( ID ( ID , & ID , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ;  
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ;  
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ;  
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ;  
} 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
} 
else 
if ( ID ( ID , & ID , ID ) ) 
{ 
ID = ID ( ID ( STRING , ID ) ) ; 
ID = INTEGER ; 
if ( ID == INTEGER ) {  
ID = ID -> ID ; ID = ID ;  
} 
if ( ID ( ID , ID  , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID ( ID , ID , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID ( ID , STRING ) ;  
} 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
if ( ID ( ID , & ID , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ( ID , ID  , ID ) ) 
{ 
ID = ID ( ID ( STRING , ID ) ) ; 
if ( ID ( ID , & ID , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ;  
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ;  
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ;  
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ;  
} 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
} 
else 
if ( ID ( ID , & ID , ID ) ) 
{ 
{  
while ( INTEGER ) 
{ 
ID ( ID , & ID , & ID ) ; 
{ 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ;  
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ;  
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ;  
} 
} 
else 
if ( ID ( ID , ID  , ID ) ) 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID ( ) ; 
if ( ID == INTEGER ) {  
ID = ID ;  
} 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
break ;  
} 
}  
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
} 
break ;  
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
break ;  
} 
}  
if ( ID == INTEGER ) {  
ID -> ID = ( ID * ) ID ( sizeof ( ID ) , INTEGER ) ;  
ID = ID -> ID ;  
ID -> ID = ID ;  
ID -> ID = ID -> ID ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
ID -> ID = ID ;  
 
} 
} 
if ( ! ID ( ID , & ID , ID ) ) break ; 
} 
}  
if ( ID == INTEGER ) {  
ID = ID -> ID ;  
} 
ID ( ID , & ID , & ID ) ; 
} 
return ID ; 
} 

static char * ID ( ID * ID ) 
{ 
char * ID ; 
{ 
if ( ID ) ID ( ID , ID ) ; 
ID ( ID , ID  , & ID ) ; 
ID = ID -> ID ; 
ID ( ) ; 
ID ( ID , & ID , & ID ) ; 
} 
return ID ; 
} 

void ID ( ID * ID ) 
{ 
{ 
if ( ID ( ID , & ID , ID ) ) 
{  
while ( INTEGER ) 
{ 
{ 
if ( ID ( ID , ID , ID ) ) 
{ 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
if ( ID ( ID , & ID , ID ) ) 
{ 
ID ( ID ( STRING , ID ) ) ; 
} 
else 
ID ( ID , & ID , & ID ) ; 
} 
if ( ! ID ( ID , & ID , ID ) ) break ; 
} 
}  
else 
{ 
 
if ( ID ) { ID * ID = ID ( ID , ID ) ; ID -> ID = ID ; ID -> ID = ID ; } 
} 
if ( ID == INTEGER ) ID ( ID , STRING ) ; 
ID ( ID , & ID , & ID ) ; 
} 
} 

int ID ( int ID , char * ID [ ] ) 
{ 
ID ID , ID = ID ( ) ; 
int 
ID = INTEGER ,  
ID = INTEGER ,  
ID = INTEGER ,  
ID = INTEGER ,  

ID = INTEGER ;  

unsigned long ID = INTEGER ;  

unsigned long ID = INTEGER ;  

char * ID = ID ;  

ID * ID = ( ID * ) ID ( STRING ) ;  
ID * ID ; 

ID ( STRING STRING STRING STRING ) ; 

ID ( STRING ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING , STRING , & ID ) ; 
ID ( STRING ) ; 
ID ( STRING ) ; 
ID ( STRING ) ; 
ID ( STRING ) ; 
ID ( STRING ) ; 

ID = ID ( ID , ID ) ; 

 
for ( ID = INTEGER ; ID [ ID ] != ID ; ID ++ ) 
ID [ ID ] = ID ( ID [ ID ] , STRING ) ; 

if ( ID ) 
{ 
ID [ INTEGER ] = STRING ; 
ID = STRING ; 
ID [ INTEGER ] = ID ;  

} 
if ( ( ID = ID [ INTEGER ] ) == ID ) 
ID ( STRING ) ; 

if ( ID [ INTEGER ] != ID ) 
ID ( ID , STRING ) ; 
ID ( ID , INTEGER , INTEGER , ( int ) ID ) ; 
ID ( INTEGER , INTEGER , INTEGER , ID , ID ) ; 
if ( ID ) 
ID ( ) ; 
ID = ID ( STRING , INTEGER , INTEGER , ID , ID , ID ) ; 
ID = ID ( STRING , INTEGER , INTEGER , ID , ID , ID ) ; 
ID = ID ( STRING , INTEGER , INTEGER , ID , ID , ID ) ; 
ID = ID ( STRING , INTEGER , INTEGER , ID , ID , ID ) ; 
ID ( ) ; 
ID ( ) ; 
ID ( ) ; 
if ( ID ) 
ID ( STRING STRING STRING ) ; 
for ( ID = INTEGER ; ID <= ID ; ID ++ ) 
{ 
ID = ID == ID ; 
ID ( ID || ( ID && ID == ID ) ) ; 

for ( ID = INTEGER ; ( ID = ID [ ID ] ) != ID ; ID ++ ) 
{ 
if ( ID ( ID ) == ID ) 
ID ( STRING ) ; 

ID ( ) ; 
ID ( ) ; 

ID ( ID = ID ( STRING , ID ) ) ;  
if ( ID ( ) != INTEGER ) 
ID ( ID , STRING , ID ( ) == INTEGER ? STRING : STRING , ID ) ;  
ID ( ID , sizeof ( ID ) ) ; 
} 
} 

ID = ID [ INTEGER ] ;  

ID ( ID , ID ) ; 
if ( ID != ID ) 
{ 
ID * ID ; 

if ( * ID == STRING )  
ID = STRING ; 
ID = ID ( ( ID = ID ( ID , STRING ) ) , STRING ) ; 

if ( ID == ID ) 
ID ( ID , STRING , ID ) ; 

if ( ID ) 
ID ( ID , STRING , ID ) ; 

ID ( ID ) ; 
ID ( ID , ID , ID , ID ) ; 
ID ( ID ) ; 
ID ( ID ) ; 
} 

ID ( ID , ID ) ; 
if ( ID ) 
{ 
ID ( INTEGER ) ; 
ID ( ) ; 

} 
ID ( ) ; 
if ( ID ) 
{ 
ID = ID ( ) ; 
ID ( ID , STRING , ( ( double ) ( ID - ID ) ) / ID ) ; 
} 
return ID ; 
} 

 

 

extern void * ID , * ID , * ID ; 

void * ID ;  
extern char * ID ;  


int 
ID = INTEGER ,  
ID = INTEGER ,  
ID = INTEGER ,  
ID = INTEGER ,  
ID = INTEGER ,  
ID ,  
ID = INTEGER ,  
ID = INTEGER ;  

char 
* ID ;  

unsigned ID ;  
unsigned ID = ID ;  

ID * ID ; 

char 
* ID = STRING ,  
* ID = STRING ,  
* ID = ID ,  
* ID = ID ,  
* ID = ID ,  
* ID = ID ,  
* ID = STRING ,  
* ID = STRING ;  

unsigned 
ID = INTEGER ,  
ID = INTEGER ,  
ID = INTEGER ,  
ID = INTEGER ,  
ID = INTEGER ,  
ID = INTEGER ,  
ID = INTEGER ,  
ID = INTEGER ,  
ID = INTEGER ,  
ID = INTEGER ,  
ID = INTEGER ,  
ID ,  
ID = INTEGER ,  
ID = INTEGER ;  

unsigned long ID = INTEGER ;  
unsigned long ID = INTEGER ;  

ID 
* ID = ID ;  

ID 
* ID = ID ;  

ID 
* ID = ID ;  

ID 
* ID = ID ;  

ID 
ID ; 

void ID ( enum ID ID , char * ID , char * ID , char * ID ) 
{ 
ID * ID = ( ID * ) ID ( sizeof ( ID ) ) ; 

ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID = ID ; 
} 

ID * ID ( char * ID , ID ID , ID ID ) 
{ 
ID * ID ; 
void * ID ; 

 
if ( ID == ID ) 
ID = ID ; 
else if ( ID == ID || ID == ID ) 
ID = ID ; 
else ID = ID ; 

if ( ( ID = ( ID * ) ID ( ID , & ID , ID ) ) == ID ) 
{ 
if ( ID == ID && ID ) 
{ 
ID ( ID , STRING , ID ) ; 
ID ( ID ) ; 
} 
else 
{ 
if ( ID == ID ) 
ID ( ID , STRING , ID ) ; 
ID = ( ID * ) ID ( sizeof ( ID ) ) ; 
ID -> ID = ID ; 
ID ( ID , ID ) ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID -> ID = INTEGER ;  
ID -> ID = INTEGER ; 
ID ( & ID -> ID , ID ) ; 
ID -> ID = INTEGER ; 
ID -> ID = INTEGER ; 
switch ( ID ) 
{ 
case ID : 
ID -> ID = STRING ; 
break ; 
case ID : 
ID -> ID = STRING ; 
break ; 
case ID : 
case ID : 
ID -> ID = STRING ; 
ID -> ID = INTEGER ; 
break ; 
default : 
ID -> ID = STRING ; 
break ; 
} 
} 
} 
else 
if ( ID == ID ) 
ID ( ID , STRING , ID ) ; 

return ID ; 
} 

ID * ID ( char * ID , char * ID , int ID ) 
{ 
ID * ID ; 

ID ( ID ) ; 
ID ( ID ) ; 
ID = ID ( ID , ID , ID ) ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = STRING ; 
ID -> ID = INTEGER ; 
return ID ; 
} 


void ID ( void ) 
{ 
ID = ID ( ID , STRING ) ; 
ID = ID ( ID , STRING ) ; 
ID ( & ID , ID , ID , ID , ID ) ; 

ID ( ID , ID , ID , STRING ) ; 
ID ( ID , STRING , STRING , STRING ) ; 
ID ( ID , STRING , STRING , STRING ) ; 
ID ( ID , STRING , STRING , STRING ) ; 
ID ( ID , STRING , STRING , STRING ) ; 
ID ( ID , STRING , STRING , STRING ) ; 
ID ( ID , STRING , STRING , STRING ) ; 
ID ( ID , STRING , STRING , STRING ) ; 
ID ( ID , STRING , STRING , STRING ) ; 
ID ( ID , STRING , STRING , STRING ) ; 
ID ( ID , STRING , STRING , STRING ) ; 

ID ( STRING , ID , ID ) -> ID = ID ;  
ID ( STRING , ID , ID ) -> ID = ID ; 
ID ( STRING , ID , ID ) -> ID = ID ; 
ID ( ID , ID , ID ) -> ID = ID ; 
} 

static void ID ( void * ID ) 
{ 
ID * ID = ( ID * ) ID ( ID ) ; 

while ( ID != ID ) 
{ 
if ( ID -> ID == ID || ID -> ID == ID ) 
{ 
ID -> ID = ID -> ID ; 
ID -> ID = ID ++ ; 
} 
ID = ( ID * ) ID ( ID ) ; 
} 

 
ID = ( ID * ) ID ( ID ) ; 
while ( ID != ID ) 
{ 
if ( ID -> ID == ID || ID -> ID == ID || 
ID -> ID == ID || ID -> ID == ID || 
ID -> ID == ID ) 
{ 
ID ( & ID -> ID , ID -> ID ) ; 
ID -> ID = ID ( & ID -> ID ) ; 
ID ( & ID -> ID , ID ) ; 
ID -> ID = ID ( & ID -> ID ) ; 

ID -> ID = INTEGER ; 
} 
else if ( ID -> ID == ID && ID -> ID != ID ) 
{ 
ID ( & ID -> ID , ID -> ID -> ID ) ; 
ID -> ID = ID ( & ID -> ID ) ; 
} 
ID = ( ID * ) ID ( ID ) ; 
} 
} 

static void ID ( void * ID ) 
{ 
ID * ID = ( ID * ) ID ( ID ) ; 
char * ID = STRING ;  
int ID = INTEGER ; 

if ( ID ) 
ID ( ID , STRING ) ; 

while ( ID != ID )  
{ 
if ( ID -> ID == ID || ID -> ID == ID ) 
{ 
char * ID = ID , 
* ID = ID -> ID ; 

if ( ! ID ( ID ) )  
{ 
 
while ( * ID == * ID && * ID != INTEGER )  
{ 
ID ++ ; 
ID ++ ; 
} 

ID ++ ;  

 
 
while ( * ( ID ) != INTEGER )  
{ 
 
char * ID = ID -> ID , 
* ID = ID ;  

while ( ID != ID ) 
ID ( * ID ++ ) ;  
ID ( INTEGER ) ;  

if ( ID ) 
ID ( ID , STRING , ID ) ; 

ID = INTEGER ; 

ID ( ID , ID , ID ) ; 

ID ++ ; 
} 
} 

ID = ID -> ID ; 
} 
ID = ( ID * ) ID ( ID ) ; 
} 
if ( ID && ! ID ) 
ID ( ID , STRING ) ; 

} 

void ID ( char * ID , int ID ) 
{ 
void 
* ID = ID ( ID ) , 
* ID = ID ( ID ) ; 

ID * ID = ( ID * ) ID ( sizeof ( ID ) ) ; 

ID -> ID = STRING ; 
ID ( ID , ID ) ; 

ID ( ID , ID ) ;  
ID ( ID ) ;  
ID ( ID , ID ) ;  
ID ( ID ) ;  
ID ( ID ) ;  
ID ( ID ) ;  

ID ( ID , ID ) ;  
ID ( ID ) ;  

if ( ID )  
ID ( ID ) ; 

if ( ID ( ) > INTEGER ) 
{ 
if ( ID ) 
ID ( ID , STRING ) ; 
else 
ID ( ID , STRING ) ; 
} 

ID ( ID ( ID , STRING ) ) ;  

ID ( ID ( ID , STRING ) , ID ) ;  

if ( ID )  
ID ( ) ; 
} 

void * ID ( char * ID ) 
{ 
ID * ID ; 

ID ( ID ) ; 
ID = ID ( ID , ID , ID ) ; 
ID -> ID ++ ;  

return ID ; 
} 

 
 
 
 
 
 
 
 
 
 
 
 
 

static int ID ;  

void ID ( char * ID ) 
{ 
if ( ID ( ID , ID ) == INTEGER ) 
ID = INTEGER ;  
} 

void ID ( char * ID ) 
{ 
if ( ID == ID ) 
return ; 

if ( * ID == INTEGER ) 
ID ( ID , STRING ) ; 
 
{ 
int ID = INTEGER ; 

while ( * ID != INTEGER ) 
{ 
ID |= ! ID ( * ID ) ; 
ID ++ ; 
} 

if ( ID ) 
ID ( ID , STRING ) ; 
} 
} 

void ID ( char * ID ) 
{ 
ID ( ID ) ;  
if ( * ( ID + INTEGER ) != INTEGER ) 
ID ( ID , STRING ) ; 
} 

void ID ( char * ID ) 
{ 
ID ( ID ) ;  
if ( ! ( * ( ID + INTEGER ) == INTEGER || * ( ID + INTEGER ) == INTEGER ) ) 
ID ( ID , STRING ) ; 
} 

void ID ( char * ID ) 
{ 
if ( ( ID ( STRING , ID , INTEGER ) == INTEGER ) || 
( ID ( STRING , ID , INTEGER ) == INTEGER ) || 
( ID ( STRING , ID , INTEGER ) == INTEGER ) || 
( ID ( STRING , ID , INTEGER ) == INTEGER ) || 
( ID ( STRING , ID , INTEGER ) == INTEGER ) || 
( ID ( STRING , ID , INTEGER ) == INTEGER ) || 
( ID ( STRING , ID , INTEGER ) == INTEGER ) || 
( ID ( STRING , ID , INTEGER ) == INTEGER ) || 
( ID ( STRING , ID , INTEGER ) == INTEGER ) ) 
ID ( ID , STRING , ID ) ; 
} 

static void ID ( void * ID ) 
{ 
unsigned ID = INTEGER , 
ID = INTEGER , 
ID = INTEGER ; 

ID * ID = ( ID * ) ID ( ID ) ; 

while ( ID != ID ) 
{ 
if ( ID -> ID == ID ) 
ID ++ ; 
else if ( ID -> ID == ID ) 
ID ++ ; 
else 
ID ++ ; 

ID = ( ID * ) ID ( ID ) ; 
} 

if ( ID ) 
ID ( ID , STRING , 
ID , ID - ID + INTEGER , ID , ID ) ; 
} 

static void ID ( ID * ID ) 
{ 
if ( ID -> ID )  
{ 
ID ( ID , STRING , ID -> ID ) ;  
ID -> ID = INTEGER ; 
return ; 
} 

if ( ! ID -> ID )  
{ 
ID * ID = ID -> ID ;  

ID -> ID = INTEGER ;  

if ( ID -> ID == ID )  
{ 
ID -> ID = INTEGER ;  
while ( ID != ID && ID -> ID )  
{ 
if ( ! ID -> ID -> ID )  
ID ( ID -> ID ) ; 

ID ( & ID -> ID , & ID -> ID -> ID ) ;  
ID -> ID = ID -> ID -> ID ;  

ID = ID -> ID ; 
} 
} 
else 
while ( ID != ID )  
{ 
if ( ! ID -> ID -> ID )  
ID ( ID -> ID ) ; 

ID ( & ID -> ID , & ID -> ID -> ID ) ;  
ID -> ID |= ID -> ID -> ID ;  
ID = ID -> ID ; 
} 
ID -> ID = INTEGER ;  
ID -> ID = INTEGER ;  
 
ID -> ID = ID ( & ID -> ID ) ; 
} 
} 

 
static void ID ( ID * ID ) 
{ 
ID * ID = ID -> ID ;  

while ( ID != ID )  
{ 
ID * ID = ID ;  
unsigned ID = ID -> ID -> ID ; 

do  
{ 
ID = ID -> ID ; 
if ( ID == ID )  
ID ( & ID -> ID -> ID , & ID -> ID ) ; 
else 
ID ( & ID -> ID -> ID , & ID -> ID -> ID ) ; 
} 
while ( ID != ID && ID -> ID -> ID ) ; 

 
ID |= ( ( ID -> ID -> ID = 
ID ( & ID -> ID -> ID ) 
) != ID ) ; 

ID = ID -> ID ;  
} 
} 

 
static void ID ( ID * ID ) 
{ 
ID * ID = ID -> ID ;  

while ( ID != ID ) 
{ 
unsigned ID = ID -> ID -> ID ; 

ID ( & ID -> ID -> ID , & ID -> ID ) ; 

ID |= ( ( ID -> ID -> ID = 
ID ( & ID -> ID -> ID ) 
) != ID ) ; 
ID = ID -> ID ; 
} 
} 

static void ID ( void * ID ) 
{ 
ID * ID ; 
unsigned ID = INTEGER ; 

do 
{ 
ID ++ ; 
ID = INTEGER ; 
ID = ( ID * ) ID ( ID ) ; 
while ( ID != ID ) 
{ 
if ( ID -> ID == ID )  
ID ( ID ) ; 
else 
ID ( ID ) ; 
ID = ( ID * ) ID ( ID ) ; 
} 
} 
while ( ID ) ; 

if ( ID ) 
ID ( ID , STRING , ID , ID == INTEGER ? STRING : STRING ) ; 

} 

static int ID ( char * ID ) 
{ 
ID * ID = ( ID * ) ID ( ID , & ID , ID ) ; 

if ( ID != ID ) 
{ 
if ( ID -> ID == ID ) 
{ 
ID ( ID , STRING , ID ) ; 
return INTEGER ; 
} 
} 
return INTEGER ; 
} 

static int ID ( void ) 
{ 
int ID = INTEGER , 
ID = INTEGER ; 
char * ID [ ] = { ID , ID } ; 

while ( ID [ ID ] != ID ) 
ID |= ID ( ID [ ID ++ ] ) ; 

return ID ; 
} 

 
static int ID ( void * ID ) 
{ 
int ID = INTEGER ; 
ID * ID = ( ID * ) ID ( ID ) ; 

while ( ID != ID ) 
{ 
ID * ID = ID -> ID ; 
int ID = ID -> ID , 
ID = INTEGER ; 

if ( ID == ID && ID -> ID == INTEGER && ! ID -> ID ) 
ID ( ID , STRING , ID -> ID ) ; 

if ( ID == ID && ID == ID ) 
{ 
ID ( ID , STRING , ID -> ID ) ; 
ID = INTEGER ; 
} 

if ( ID == ID )  
{ 
while ( ID != ID ) 
{ 
if ( ID -> ID -> ID == ID )  
if ( ID -> ID == ID )  
ID -> ID -> ID = INTEGER ; 
else if ( ID -> ID -> ID -> ID == ID )  
ID -> ID -> ID -> ID = INTEGER ;  
else 
ID -> ID -> ID = INTEGER ;  

if ( ID -> ID -> ID != ID ) 
ID = INTEGER ; 
ID = ID -> ID ; 
} 
} 
else 
ID = INTEGER ; 

if ( ID ) 
{ 
if ( ID -> ID == ID ) 
{ 
ID ( ID , STRING , ID -> ID ) ; 
ID -> ID = INTEGER ; 
} 
else 
{ 
ID -> ID = INTEGER ; 
} 
ID = INTEGER ; 
} 
ID = ( ID * ) ID ( ID ) ; 
} 

 
ID = ( ID * ) ID ( ID ) ; 

while ( ID != ID ) 
{ 
if ( ID -> ID == ID && ID -> ID != ID ) 
if ( ID -> ID -> ID == ID && ID -> ID -> ID -> ID ) 
ID -> ID = INTEGER ; 
ID = ( ID * ) ID ( ID ) ; 
} 
return ID ; 
} 

static void ID ( void * ID ) 
{ 
ID * ID = ( ID * ) ID ( ID ) ; 

while ( ID != ID ) 
{ 
ID ( ID ) ; 
ID = ( ID * ) ID ( ID ) ; 
} 
} 

 
static int ID ( void * ID ) 
{ 
int ID = INTEGER ; 
ID * ID = ( ID * ) ID ( ID ) ; 

while ( ID != ID ) 
{ 
if ( ID ( & ID , ID -> ID ) && ID -> ID != ID ) 
{ 
ID * ID = ID -> ID ; 

while ( ID != ID ) 
{ 

if ( ID -> ID == INTEGER && ID -> ID -> ID ) 
{ 
ID ( ID , STRING , ID -> ID ) ; 
ID ( STRING , ID -> ID -> ID ) ; 
ID ( ID -> ID , INTEGER ) ; 
ID ( STRING ) ; 
ID = INTEGER ; 
ID -> ID = INTEGER ; 
ID -> ID -> ID = INTEGER ; 
} 
ID = ID -> ID ; 
} 
} 
ID = ( ID * ) ID ( ID ) ; 
} 
return ID ; 
} 
static int ID ( void * ID ) 
{ 
int ID = INTEGER ; 
ID ID = ID ; 

ID * ID = ( ID * ) ID ( ID ) ; 

while ( ID != ID ) 
{ 
if ( ID ( & ID , ID -> ID ) && ID -> ID != ID ) 
{ 
ID * ID = ID -> ID ; 

while ( ID != ID ) 
{ 
ID * ID = ID -> ID ; 

while ( ID != ID ) 
{ 
 
if ( ID -> ID -> ID && ID -> ID -> ID ) 
{ 
ID ( ID , STRING , ID -> ID ) ; 
ID ( STRING , ID -> ID -> ID ) ; 
ID ( ID -> ID , INTEGER ) ; 
ID ( STRING , ID -> ID -> ID ) ; 
ID ( ID -> ID , INTEGER ) ; 
ID ( STRING ) ; 
ID -> ID -> ID = INTEGER ; 
ID -> ID -> ID = INTEGER ; 
ID = INTEGER ; 
} 

ID ( & ID , & ID -> ID -> ID ) ; 
ID ( & ID , & ID -> ID -> ID ) ; 

if ( ID ( & ID ) != INTEGER ) 
{ 
ID ( ID , STRING , ID -> ID ) ; 
ID ( STRING , ID -> ID -> ID ) ; 
ID ( ID -> ID , INTEGER ) ; 
ID ( STRING , ID -> ID -> ID ) ; 
ID ( ID -> ID , INTEGER ) ; 
ID ( STRING ) ; 
ID ( & ID , ID , INTEGER ) ; 
ID ( STRING ) ; 
ID -> ID -> ID = INTEGER ; 
ID -> ID -> ID = INTEGER ; 
ID = INTEGER ; 
} 
ID = ID -> ID ; 
} 
ID = ID -> ID ; 
} 
} 
ID = ( ID * ) ID ( ID ) ; 
} 
return ID ; 
} 

static int ID ( void * ID ) 
{ 
int ID = INTEGER ; 
ID * ID = ( ID * ) ID ( ID ) ; 
ID ID = ID ; 

while ( ID != ID ) 
{ 
if ( ID -> ID && ( ID -> ID != ID ) ) 
{ 
ID ( & ID , & ID -> ID ) ; 
ID ( & ID , & ID -> ID ) ; 

if ( ID ( & ID ) != INTEGER ) 
{ 
ID ( ID , STRING , ID -> ID ) ; 
ID ( ID , INTEGER ) ; 
ID ( STRING ) ; 

ID ( & ID , ID , INTEGER ) ; 
ID ( STRING ) ; 
ID -> ID = INTEGER ; 
ID = INTEGER ; 
} 
} 
ID = ( ID * ) ID ( ID ) ; 
} 
return ID ; 
} 

static void ID ( void * ID ) 
{ 
ID * ID = ( ID * ) ID ( ID ) ; 

while ( ID != ID ) 
{ 
if ( ID -> ID == ID && ID -> ID != INTEGER && ID -> ID == ID ) 
{ 
ID ( & ID -> ID , & ID -> ID ) ; 
ID -> ID = ID ( & ID -> ID ) ; 
} 
ID = ( ID * ) ID ( ID ) ; 
} 
} 

int ID ( void * ID ) 
{ 
int ID = INTEGER ; 

 
if ( ID ) 
ID ( ID , STRING ) ; 
ID |= ID ( ID ) ; 

 
ID ( ID ) ; 

 
if ( ID -> ID != ID ) 
ID ( ID , STRING , 
ID -> ID == ID ? STRING : 
ID -> ID == ID ? STRING : STRING , 
ID -> ID ) ; 

 
if ( ID ) 
ID ( ID , STRING ) ; 
ID ( ID ) ; 

 
if ( ID ) 
ID ( ID , STRING ) ; 
ID ( ID ) ; 

 
if ( ID ) 
ID ( ID , STRING ) ; 
ID |= ID ( ) ; 

 
if ( ID ) 
ID ( ID , STRING ) ; 
ID |= ID ( ID ) ; 

 
if ( ID ) 
ID ( ID , STRING ) ; 
ID |= ID ( ID ) ; 

 
if ( ID ) 
ID ( ID , STRING ) ; 
ID |= ID ( ID ) ; 

 
if ( ID ) 
ID ( ID , STRING ) ; 
ID ( ID ) ; 
 
ID ( ID ) ; 

return ID ; 
} 


extern void * ID ; 
extern char * ID ;  

char * ID = ID ; 
char * ID = ID ; 

static unsigned ID = INTEGER ;  

static void ID ( ID * ID ) 
{ 
if ( ID -> ID != ID ) 
ID ( ID -> ID ) ; 
ID ( STRING , ID -> ID ) ; 
} 

static void ID ( void ) 
{ 
unsigned ID ; 

for ( ID = INTEGER ; ID < ID ; ID ++ ) 
ID ( STRING ) ; 
} 

 

static void ID ( char * ID , ID * ID , char * ID ) 
{ 
ID ( STRING ) ; 

if ( ID ( ID ) > INTEGER ) 
ID ( STRING , 
ID == INTEGER ? STRING : STRING , 
ID == INTEGER ? STRING : ID , 
ID == INTEGER ? STRING : STRING , 
ID 
) ; 
else 
{ 
ID ( STRING , 
ID == INTEGER ? STRING : STRING , 
ID == INTEGER ? STRING : ID , 
ID == INTEGER ? STRING : STRING ) ; 
ID ( ID , ID , INTEGER ) ; 
} 

if ( ID == ID ) 
ID ( STRING ) ; 
else 
ID ( STRING , ID ) ; 
} 

static void ID ( char * ID ) 
{ 
while ( * ID != INTEGER ) 
{ 
if ( * ID == STRING || * ID == STRING || * ID == STRING ) 
ID ( STRING ) ; 
ID ( STRING , * ID ++ ) ; 
} 
} 

static void ID ( ID * ID ) 
{ 
if ( ID -> ID != ID ) 
ID ( ID -> ID ) ; 
switch ( ID -> ID ) 
{ 
case ID : 
ID ( STRING , ID -> ID , ID -> ID , ID -> ID ) ; 
break ; 
case ID : 
ID ( STRING , ID -> ID , ID -> ID , ID -> ID ) ; 
break ; 
case ID : 
ID ( STRING , ID -> ID , ID -> ID , ID -> ID ) ; 
break ; 
case ID : 
ID ( STRING , ID -> ID ) ; 
break ; 
} 
} 

void ID ( void * ID ) 
{ 
char * ID , 
* ID , 
* ID , 
* ID , 
* ID , 
* ID , 
* ID , 
* ID , 
* ID , 
* ID , 
* ID ; 

ID * ID = ( ID * ) ID ( ID ) ; 

ID = ID ( STRING ) ; 
ID ( STRING ) ; 
ID ( STRING ) ; 
ID ( STRING ) ; 
ID ( STRING ) ; 
ID ( STRING ) ; 
ID ( STRING ) ; 
ID ( STRING ) ; 
ID ( STRING ) ; 
ID ( STRING ) ; 
ID ( STRING ) ; 
ID ( STRING ) ; 
ID ( STRING ) ; 
ID ( STRING ) ; 
ID ( 
) ; 
ID ( 
) ; 

while ( ID != ID ) 
{ 
if ( ID -> ID == ID || ID -> ID == ID ) 
{ 
char * ID = ID -> ID ; 

ID -> ID = ID ( STRING ) ;  
while ( * ID != INTEGER )  
{ 
if ( * ID == STRING || * ID == STRING || * ID == STRING ) 
ID ( STRING ) ; 
ID ( * ID ++ ) ; 
} 
ID ( STRING ) ;  
} 
ID = ( ID * ) ID ( ID ) ; 
} 

ID = ( ID * ) ID ( ID ) ; 

ID = ID = ID ( STRING ) ; 
ID ( STRING ) ; 
ID ( STRING ) ; 
ID ( STRING ) ; 
ID = ID ( STRING ) ; 
ID = ID ( STRING ) ; 
ID = ID ( STRING ) ; 
ID = ID ( STRING ) ; 
ID = ID ( STRING ) ; 
ID = ID ( STRING ) ; 
ID = ID ( STRING ) ; 
ID = ID ( STRING ) ; 
ID = ID ( STRING ) ; 
ID = ID ( STRING ) ; 
ID ( STRING ) ; 
ID ( STRING ) ; 

while ( ID != ID ) 
{ 
if ( ID -> ID == ID || ID -> ID == ID ) 
{ 
ID -> ID = ID ( STRING ) ; 

if ( ID ( ID -> ID ) ) 
ID ( ID -> ID ) ; 
else 
{ 
char * ID = ID -> ID ; 

while ( * ID != INTEGER ) 
ID ( * ID ++ ) ; 

ID = ID -> ID ; 

ID ( STRING ) ; 
if ( ID ( ID , STRING ) == INTEGER )  
{ 
ID ( STRING ) ; 
ID ( STRING ) ; 
ID ( STRING ) ; 
} 
else if ( ID ( ID , STRING ) == INTEGER )  
{ 
ID ( STRING ) ; 
ID ( STRING ) ; 
ID ( STRING ) ; 
} 
else while ( * ID != INTEGER ) 
ID ( * ID ++ ) ; 

ID ( STRING ) ; 
} 
if ( ID -> ID == ID ) 
{ 
switch ( ID -> ID ) 
{ 
case ID : 
ID -> ID = ID ; 
break ; 
case ID : 
ID -> ID = ID ; 
break ; 
case ID : 
ID -> ID = ID ; 
break ; 
case ID : 
ID -> ID = ID ; 
break ; 
case ID : 
ID -> ID = ID ; 
break ; 
case ID : 
ID -> ID = ID ; 
break ; 
case ID : 
ID -> ID = ID ; 
break ; 
case ID : 
ID -> ID = ID ; 
break ; 
case ID : 
ID -> ID = ID ; 
break ; 
case ID : 
ID -> ID = ID ; 
break ; 
} 
} 
else 
ID -> ID = ID ; 
} 
ID = ( ID * ) ID ( ID ) ; 
} 
} 

static void ID ( ID * ID , int ID , int ID ) 
{ 
if ( ID != ID ) 
{ 
unsigned ID ; 

ID ( ID -> ID , INTEGER , ID ) ; 
ID ( STRING , ID ? ID -> ID : STRING ) ; 

if ( ID ) 
for ( ID = INTEGER ; ID < ID -> ID ; ID ++ ) 
ID ( STRING ) ; 

ID ( STRING , ID ? STRING : STRING ) ; 
switch ( ID -> ID ) 
{ 
case ID : 
ID ( STRING , ID -> ID ) ; 
break ; 
case ID : 
ID ( STRING , ID -> ID ) ; 
break ; 
case ID : 
ID ( STRING , ID -> ID ) ; 
break ; 
case ID : 
ID ( STRING , ID -> ID ) ; 
break ; 
} 
ID ( STRING , ID ? STRING : STRING ) ; 
} 
} 

static void ID ( char * ID , ID * ID , int ID , int ID ) 
{ 
ID ( STRING ) ; 

 
if ( ID ) 
{ 
if ( ID ) 
ID ( STRING ) ; 
else 
{ 
if ( ID == ID ) 
ID ( STRING ) ; 
else 
ID ( STRING , ID ? STRING : STRING , ID ? STRING : STRING , ID ) ; 
} 

if ( ID != ID ) 
ID ( STRING ) ;  
} 

if ( ID == ID && ID && ! ID ) 
ID ( STRING ) ; 
else 
ID ( ID , INTEGER , ID ) ; 

ID ( STRING ) ; 
} 

static void ID ( ID * ID ) 
{ 
switch ( ID -> ID ) 
{ 
case ID : 
ID ( STRING , ID -> ID ) ; 
break ; 
case ID : 
case ID : 
ID ( STRING , ID -> ID ) ; 
break ; 
case ID : 
case ID : 
case ID : 
ID ( STRING , ID -> ID ) ; 
break ; 
default : 
ID ( STRING , ID -> ID ) ; 
break ; 
} 
} 

 
static void ID ( ID * ID , int ID ) ; 
static void ID ( ID * ID , int ID ) ; 

void ID ( ID * ID , int ID ) 
{ 
switch ( ID -> ID ) 
{ 
case ID : 
case ID : 
case ID : 
case ID : 
ID ( STRING , ID -> ID ) ; 
break ; 
case ID : 
ID ( STRING , ID -> ID ) ; 
break ; 
case ID : 
 
break ; 
case ID : 
ID ( STRING , ID -> ID ) ; 
break ; 
case ID : 
ID ( ID , ID ) ; 
break ; 
case ID : 
if ( ID ) 
{ 
 
if ( ID -> ID == ID )  
{ 
if ( ID -> ID == INTEGER && ID -> ID == INTEGER ) 
{ 
ID ( STRING ) ; 
ID ( ID , ID ) ; 
ID ( STRING ) ; 
} 
else if ( ID -> ID == INTEGER && ID -> ID == INTEGER ) 
{ 
ID ( STRING ) ; 
ID ( ID , ID ) ; 
ID ( STRING ) ; 
} 
else if ( ID -> ID == INTEGER && ID -> ID == INTEGER ) 
{ 
ID ( STRING ) ; 
ID ( ID , ID ) ; 
ID ( STRING ) ; 
} 
else if ( ID -> ID == INTEGER && ID -> ID == INTEGER ) 
{ 
ID ( STRING ) ; 
ID ( ID , ID ) ; 
ID ( STRING ) ; 
} 
} 
else 
{  
ID ( STRING ) ; 
ID ( ID , ID ) ; 
ID ( STRING , ID -> ID , ID -> ID ) ; 
if ( ID -> ID != ID ) 
ID ( STRING , ID -> ID -> ID ) ; 
else 
ID ( STRING ) ; 
} 
} 
else 
ID ( STRING , ID -> ID ) ; 
break ; 
default : 
ID ( ID , STRING ) ; 
} 
} 

static void ID ( ID * ID , int ID ) 
{ 
ID * ID = ID -> ID ; 

while ( ID != ID ) 
{ 
ID ( ID -> ID , ID ) ; 
ID = ID -> ID ; 
} 
} 

static void ID ( ID * ID , int ID ) 
{ 
ID * ID = ID -> ID ; 

while ( ID != ID ) 
{ 
ID ( ID -> ID , ID ) ; 

if ( ( ID = ID -> ID ) != ID ) 
ID ( STRING ) ; 
} 
} 

void ID ( char * ID ) 
{ 
ID * ID ; 

ID * ID = ID ; 
ID * ID = ( ID * ) ID ( ID ( ID ) ) ; 
unsigned ID = INTEGER ; 
int ID = INTEGER ; 
char * ID = ID ( ID ( ID ) ) ; 

if ( ID ) 
ID ( ID , STRING , ID ) ; 

if ( * ID == STRING ) 
ID = ID ; 
else if ( ( ID = ID ( ID , STRING ) ) == ID ) 
ID ( ID , STRING , ID ) ; 

ID ( ID ) ; 

ID ( 
STRING 
STRING 
STRING ) ; 

ID ( ) ; 

ID ( 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING , 
ID ( ID , STRING ) , 
ID , ID 
) ; 

ID ( STRING , ID ) ; 

ID ( STRING ) ; 
ID ( ) ; 
ID ( STRING ) ; 

 
ID ( STRING ) ; 
while ( ID != ID ) 
{ 
if ( ID -> ID == ID || ID -> ID == ID ) 
{ 
ID ( STRING ) ; 
if ( ID ++ % INTEGER == INTEGER ) 
ID ( STRING ) ; 
ID ( ID ) ; 
if ( ID ) 
{ 
ID ( STRING ) ; 
ID = INTEGER ; 
} 
} 
ID = ( ID * ) ID ( ID ) ; 
} 
ID ( STRING ) ; 

 
ID ( STRING 
STRING 
STRING , 
ID , 
ID 
) ; 

 
ID ( STRING ) ; 
while ( ID != ID ) 
{ 
ID ( STRING , 
ID -> ID , ID -> ID , ID -> ID ) ; 
ID ( STRING , ID -> ID ) ; 
ID ( STRING , ID -> ID , ID -> ID ) ; 
ID ( STRING , ID -> ID , ID -> ID ) ; 
ID = ID -> ID ; 
} 

 
ID ( STRING ) ; 
ID ( STRING , ID -> ID ) ; 
for ( ID = INTEGER ; ID < ID -> ID ; ID ++ ) 
ID ( STRING ) ; 
ID ( STRING , ID -> ID ) ; 

ID ( ID , ID -> ID , INTEGER , INTEGER ) ; 

ID ( STRING ) ; 

ID ( STRING , 
ID ( ID , STRING ) ) ; 

ID ( ID ) ; 
} 

static void ID ( ID * ID , ID * ID ) ; 
static void ID ( ID * ID , ID * ID ) ; 

static void ID ( ID * ID , ID * ID , int ID , char * ID ) 
{ 
if ( ID -> ID == INTEGER )  
{ 
ID ( STRING ) ; 
ID ( ID -> ID , & ID -> ID , ID ) ; 
ID ( STRING ) ; 
ID ( ) ; 
} 

ID ( STRING , ID -> ID ) ; 

if ( ID -> ID ) 
{ 
ID ( ) ; 
ID ( STRING ) ; 
} 

ID ++ ; 

 
if ( ! ( ( ID -> ID == INTEGER || ID -> ID == INTEGER ) && ( ID -> ID == INTEGER || ID -> ID == INTEGER ) ) ) 
{ 
ID ( ) ; 
ID ( STRING ) ; 
} 

ID ( ) ; 
ID ( STRING ) ; 

ID ( ) ; 
ID ( STRING ) ; 
ID ++ ; 

 
if ( ID -> ID != INTEGER && ! ID -> ID ) 
{ 
ID ( ) ; 
ID ( ID -> ID , & ID -> ID , ID -> ID ) ; 
ID ( STRING ) ; 
} 

ID ( ) ; 
ID ( STRING ) ; 
ID ++ ; 

ID ( ID , ID ) ; 

ID ( ) ; 
ID ( STRING ) ; 
ID -- ; 

if ( ! ( ( ID -> ID == INTEGER || ID -> ID == INTEGER ) && ( ID -> ID == INTEGER || ID -> ID == INTEGER ) ) ) 
{ 
ID ( ) ; 
ID ( STRING ) ; 
} 

if ( ID -> ID > INTEGER )  
{ 
ID ( ) ; 
ID ( STRING , ID -> ID ) ; 
} 

if ( ID -> ID != ID ) 
{ 
ID ( ) ; 
ID ( STRING , ID -> ID -> ID ) ; 

if ( ID ) 
{ 
if ( ID -> ID == ID ) 
{ 
 
ID ( STRING ) ; 
ID ( ) ; 
} 
else if ( ID -> ID == ID ) 
{ 
 
ID ( STRING ) ; 
ID ( ) ; 
} 
} 

ID ( ) ; 
ID ( STRING ) ;  
} 
else if ( ID -> ID != INTEGER ) 
{ 
ID ( ) ; 
ID ( STRING ) ; 
ID ( ID -> ID , & ID -> ID , ID ) ; 
ID ( STRING ) ; 
} 

if ( ID -> ID == INTEGER ) 
{ 
ID ( ) ; 
ID ( STRING ) ; 
} 

ID -- ; 
ID ( ) ; 
ID ( STRING ) ; 

if ( ID -> ID > INTEGER )  
{ 
ID ( ) ; 
ID ( STRING , ID -> ID ) ; 
ID ( STRING ) ; 
} 

ID -- ; 
ID ( ) ; 
ID ( STRING , ID -> ID ) ; 

if ( ID -> ID == INTEGER && ( ID || ID != ID ) ) 
{ 
ID ( ) ; 
ID ( STRING ) ; 
ID ( ) ; 
ID ( STRING ) ; 
ID ++ ; 
ID ( ) ; 
ID ( STRING , ID -> ID ) ; 
if ( ID ) 
{ 
 
if ( ID == ID ) 
{ 
 
ID ( ) ; 
if ( ID ) 
ID ( STRING , ID -> ID + INTEGER ) ; 
else 
ID ( STRING ) ; 
} 
else if ( ID == ID ) 
{ 
 
ID ( ) ; 
if ( ID ) 
ID ( STRING , ID -> ID + INTEGER ) ; 
else 
ID ( STRING ) ; 
} 
} 

 
if ( ! ID && ID != ID )  
{ 
while ( * ID != STRING ) 
{ 
if ( * ID == STRING ) 
ID ( STRING ) ; 
else 
ID ( STRING , * ID ) ; 
ID ++ ; 
} 

ID ( STRING ) ;  
} 

ID -- ; 
ID ( ) ; 
ID ( STRING ) ; 
} 
} 

static void ID ( ID * ID , ID * ID , char * ID , ID * ID , int ID , int ID , char * ID ) 
{ 
if ( ID == ID ) 
ID = ID -> ID ; 

if ( ! ( ID -> ID == ID && ID -> ID ) ) 
ID ( ) ;  

switch ( ID -> ID ) 
{ 
case ID : 
case ID : 
case ID : 
case ID : 
case ID : 
if ( ID ) 
{ 
if ( ID == ID ) 
{ 
 
ID ( STRING ) ; 
ID ( ) ; 
} 
else if ( ID == ID ) 
{ 
 
ID ( STRING ) ; 
ID ( ) ; 
} 
else if ( ID == ID ) 
{ 
 
ID ( STRING ) ; 
ID ( ) ; 
} 
} 
ID ( STRING , 
ID == INTEGER ? STRING : STRING , 
ID == INTEGER ? STRING : ID -> ID , 
ID == INTEGER ? STRING : STRING ) ; 

ID ( ID ) ; 
ID ( STRING , ID -> ID ) ; 
ID ( ) ; 
if ( ID != ID && ! ID )  
{ 
ID ( STRING , ID , 
ID -> ID == ID ? STRING : 
ID -> ID == ID ? STRING : STRING ) ; 
ID ( ) ; 
} 
ID ( STRING ) ; 
break ; 
case ID : 
if ( ! ID )  
{ 
char * ID = ID -> ID ; 

if ( ID -> ID != INTEGER ) 
ID ( STRING , ID -> ID ) ; 

while ( * ID != STRING ) 
{ 
if ( * ID == STRING ) 
ID ( STRING ) ; 
else 
if ( ID ( * ID ) ) 
ID ( STRING , * ID ) ; 
ID ++ ; 
} 

if ( ID -> ID != INTEGER ) 
ID ( STRING ) ; 

if ( ID -> ID == ID && ID -> ID ) 
ID ( STRING ) ;  
} 
break ; 
case ID : 
if ( ID && ID == ID ) 
ID ( STRING , ID -> ID ) ; 
if ( ID != ID && ! ID )  
ID ( STRING , ID ) ; 
ID ( STRING , ID -> ID ) ; 
if ( ! ( ID -> ID && ID == ID ) ) 
ID ( ID == ID ? ID -> ID : ( char * ) ID , ID , INTEGER , INTEGER ) ; 
ID ( STRING ) ; 
break ; 
case ID : 
ID ( ID , STRING ) ; 
break ; 
case ID : 
ID ( ID , ID , ID , ID ) ; 
break ; 
default : 
ID ( ID , STRING ) ; 
} 
} 

static void ID ( ID * ID , ID * ID ) 
{ 
ID * ID = ID -> ID ; 

while ( ID != ID ) 
{ 
ID ( ID -> ID , ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID ) ; 
ID = ID -> ID ; 
} 
} 

static void ID ( ID * ID , ID * ID ) 
{ 
ID * ID = ID -> ID ; 

if ( ID -> ID == ID )  
ID ( ID -> ID , ID ) ; 
else 
{ 
while ( ID != ID ) 
{ 
if ( ID -> ID -> ID != ID ) 
ID ( ID , STRING ) ; 

ID ( ) ; 

ID ( STRING ) ; 
ID ( ID -> ID -> ID , & ID -> ID -> ID , ID ) ; 
ID ( STRING ) ; 
ID ( ) ; 
ID ( STRING ) ; 
ID ++ ; 

ID ( ID -> ID , ID ) ; 

ID -- ; 
ID ( ) ; 

ID ( STRING ) ; 

if ( ( ID = ID -> ID ) != ID ) 
{ 
ID ( ) ; 
ID ( STRING ) ; 
} 
else 
 
if ( ! ( ID -> ID && ID -> ID != INTEGER ) ) 
{ 
ID ( ) ; 
ID ( STRING ) ; 
ID ++ ; 
ID ( ) ; 
ID ( ID -> ID , & ID -> ID , ID -> ID ) ; 
ID -- ; 
ID ( ) ; 
ID ( STRING ) ; 
} 
} 
} 
} 

static void ID ( void * ID ) 
{ 
ID * ID ; 
unsigned ID ; 

if ( ! ID ( & ID , ID ( ID ) -> ID ) ) 
return ; 

ID = ID ( ID ) -> ID ; 

while ( ID != ID ) 
{ 
if ( ID -> ID -> ID != ID ) 
ID ( ID -> ID ) ; 

if ( ID -> ID != ID ) 
if ( ID ( ID , & ( ID -> ID ) , ID ) == ID ) 
{ 
ID * ID = ( ID * ) ID ( sizeof ( ID ) ) ; 

ID -> ID = ID -> ID ; 
ID ( ID , ID ) ; 

ID ( STRING , ID -> ID -> ID ) ; 
for ( ID = INTEGER ; ID < ID -> ID -> ID ; ID ++ ) 
ID ( STRING ) ; 
ID ( STRING , ID -> ID ) ; 
} 

ID = ID -> ID ; 
} 
} 

static void ID ( void * ID ) 
{ 
ID * ID = ( ID * ) ID ( ID ) ; 
unsigned ID ; 

ID ( STRING ) ; 
while ( ID != ID ) 
{ 
if ( ID -> ID == ID && ( ID -> ID > INTEGER ) && ! ID -> ID ) 
{ 
unsigned ID , 
ID = ( ( ID ( ID -> ID , STRING ) == INTEGER ) && ID -> ID == INTEGER ) ; 

void * ID = ID ( ID , ID -> ID ) ; 

if ( ID != ID ) 
ID ( STRING ) ; 

ID ( STRING , ID -> ID ) ; 

for ( ID = INTEGER ; ID < ID -> ID ; ID ++ ) 
ID ( STRING ) ; 
ID ( STRING , ID -> ID ) ; 

ID ( ID , ID -> ID , INTEGER , INTEGER ) ; 

ID ( STRING ) ; 

if ( ID -> ID ) 
ID ( STRING ) ; 

 
if ( ! ID ) 
{ 
ID ( STRING , ID -> ID ) ; 
for ( ID = INTEGER ; ID < ID -> ID ; ID ++ ) 
ID ( STRING ) ; 
ID ( STRING ) ; 
} 

if ( ! ID )  
ID ( ID ) ; 

ID ( ID ) ; 

 
if ( ID ) 
ID ( STRING , ID -> ID ) ; 
 
ID ( STRING ) ; 
ID ( ID -> ID , & ID -> ID , ID -> ID ? ( char * ) ID : ID -> ID ) ; 
ID ( STRING ) ; 
 
ID ( STRING ) ; 
ID = INTEGER ; 

ID ( ID , ID ) ; 

 
 
ID ( STRING , 
ID == INTEGER ? STRING : STRING , 
ID == INTEGER ? STRING : ID -> ID , 
ID == INTEGER ? STRING : STRING , 
ID -> ID , ID -> ID ) ; 
 
ID ( STRING ) ; 
 
if ( ID ) 
ID ( STRING , ID -> ID ) ; 

ID ( STRING , ID ? STRING : STRING ) ; 
} 
ID = ( ID * ) ID ( ID ) ; 
} 
} 

void ID ( char * ID , void * ID ) 
{ 
ID * ID ; 
ID * ID ; 
ID * ID ; 
unsigned ID ; 
char * ID ; 

if ( ID ) 
ID ( ID , STRING , ID ) ; 

if ( * ID == STRING ) 
ID = ID ; 
else if ( ( ID = ID ( ID , STRING ) ) == ID ) 
ID ( ID , STRING , ID ) ; 

ID ( ID ) ; 

 
ID ( STRING 
STRING 
STRING ) ; 

ID ( ) ; 
ID ( STRING 
STRING 
STRING 
STRING , 

ID ( ID , STRING ) ) ; 

if ( ID != ID ) 
ID ( ID ) ; 

if ( * ID != STRING )  
ID ( STRING , ID ( ID , STRING ) ) ; 

ID ( STRING 
STRING 
STRING 
STRING 

STRING 
STRING 
STRING 
STRING 
STRING 
STRING , ID ) ; 

ID = ID ; 
for ( ID = INTEGER ; ID < ID ; ID ++ ) 
{ 
ID ( STRING , ID ) ; 
if ( ID % INTEGER == INTEGER ) 
ID ( STRING ) ; 
while ( * ID ++ != INTEGER ) 
; 
} 

ID ( STRING ) ; 

ID = ID ; 
while ( ID != ID ) 
{ 
ID ( STRING , ID -> ID , ID -> ID ) ; 
ID ( STRING , ID -> ID ) ; 
ID = ID -> ID ; 
} 

 
if ( ID ) 
ID ( STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 

STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
) ; 

 
ID ( STRING ) ; 
ID = ( ID * ) ID ( ID ( ID ) ) ; 
while ( ID != ID ) 
{ 
if ( ID -> ID == ID || ID -> ID == ID ) 
{ 
ID ( STRING ) ; 
ID ( ID -> ID ) ; 
ID ( STRING ) ; 

if ( ID -> ID != ID ) 
{ 
ID ( STRING ) ; 
ID ( ID -> ID ) ; 
ID ( STRING ) ; 
} 
else 
ID ( STRING ) ; 

ID ( STRING , ID -> ID ) ; 
ID ( STRING , ID -> ID ) ; 
ID ( STRING ) ; 
} 
ID = ( ID * ) ID ( ID ) ; 
} 
ID ( STRING ) ; 

 
ID ( STRING ) ; 
ID = ( ID * ) ID ( ID ) ; 
while ( ID != ID ) 
{ 
if ( ID ( & ID , ID -> ID ) && ! ID -> ID ) 
{ 
if ( ID -> ID > INTEGER ) 
ID ( STRING , ID -> ID ) ; 

if ( ID -> ID == ID ) 
ID ( STRING , ID -> ID ) ; 
} 
ID = ( ID * ) ID ( ID ) ; 
} 

ID ( STRING ) ; 
ID = ( ID * ) ID ( ID ) ; 
while ( ID != ID ) 
{ 
if ( ID ( & ID , ID -> ID ) && ! ID -> ID ) 
{ 
if ( ID -> ID > INTEGER ) 
{ 
ID ( STRING , ID -> ID ) ; 
ID ( & ID -> ID , ID , INTEGER ) ; 
ID ( STRING ) ; 
} 

if ( ID -> ID == ID ) 
{ 
ID ( STRING , ID -> ID ) ; 
ID ( & ID -> ID , ID , INTEGER ) ; 
ID ( STRING ) ; 
} 
} 
ID = ( ID * ) ID ( ID ) ; 
} 
ID ( STRING ) ; 

 
ID ( STRING ) ; 
ID = ( ID * ) ID ( ID ) ; 
while ( ID != ID ) 
{ 
if ( ID -> ID == ID && ( ID -> ID > INTEGER ) ) 
{ 
unsigned ID ; 

if ( ID -> ID ) 
{ 
ID ( STRING , ID -> ID ) ; 
if ( ID -> ID != ID ) 
ID ( ID , ID -> ID , INTEGER , INTEGER ) ; 
ID ( STRING ) ; 
ID ( ID , ID ) ; 
} 
else 
{ 
if ( ID != ID ) 
ID ( STRING ) ; 

ID ( STRING , ID -> ID ) ; 

for ( ID = INTEGER ; ID < ID -> ID ; ID ++ ) 
ID ( STRING ) ; 
ID ( STRING , ID -> ID ) ; 

ID ( ID , ID -> ID , INTEGER , INTEGER ) ; 

ID ( STRING ) ; 
} 
} 
ID = ( ID * ) ID ( ID ) ; 
} 

 
if ( ID != ID ) 
ID ( STRING , ID ) ; 

 
ID ( ID ) ; 

 
ID ( STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING , 
ID , ID ) ; 

ID ( STRING ) ; 

if ( ID ) 
ID ( STRING 
STRING 
) ; 

 
ID ( STRING , ID ) ; 
ID ( STRING , 
( int ) ID ( ID , STRING ) , ID ) ; 

if ( * ID != INTEGER )  
ID ( STRING , ID ) ; 
ID ( STRING ) ; 

if ( ID != ID ) 
ID ( ID ) ; 

ID ( STRING ) ; 

ID ( STRING 
STRING 
STRING , 
ID ) ; 

ID ( STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
) ; 

ID ( STRING 
STRING ) ; 

if ( ! ID ) 
ID ( STRING 
STRING 
) ; 

ID ( STRING 
STRING , 
ID , ID , 
ID , ID , ID ) ; 

if ( ID ) 
ID ( STRING ) ; 

 
ID = ID ; 
while ( ID != ID ) 
{ 
ID ( STRING , 
ID -> ID , 
ID -> ID , 
ID -> ID , 
ID -> ID , 
ID -> ID , 
ID -> ID , 
ID -> ID ) ; 

ID = ID -> ID ; 
} 

ID ( STRING 
STRING ) ; 

if ( ID != ID ) 
ID ( STRING , ID ) ; 

ID ( STRING 
STRING , ID ) ; 

ID ( STRING , ID == INTEGER ? STRING : STRING ) ; 

if ( ID ) 
ID ( STRING ) ; 

ID ( 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING ) ; 

ID ( STRING , ID -> ID ) ; 

ID ( ID -> ID , ID -> ID , INTEGER , INTEGER ) ; 

ID ( 
STRING 
STRING 
STRING ) ; 

if ( ID && ! ID ) 
ID ( STRING ) ; 

ID ( 
STRING 
STRING 
STRING 
) ; 


if ( ID ) 
{ 
ID ( STRING ) ; 

ID ( STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
) ; 
} 

if ( ID != ID ) 
ID ( STRING , ID ) ; 

ID ( 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING , 
( int ) ID ( ID , STRING ) , ID ) ; 

ID ( STRING ) ; 

ID ( STRING , 
ID ( ID , STRING ) ) ; 

ID ( ID ) ; 
} 

void ID ( void * ID ) 
{ 
ID * ID = ( ID * ) ID ( ID ) ; 

if ( ID ) 
ID ( STRING ) ; 
while ( ID != ID ) 
{ 
ID * ID = ID -> ID ; 
int ID = ID -> ID ; 
unsigned ID ; 

if ( ID != ID && ID != ID && ID != ID && ID != ID ) 
{ 
ID ( STRING ) ; 
ID ( ID ) ; 

ID ( ID , ID -> ID , INTEGER , INTEGER ) ; 

ID ( STRING , ID -> ID ) ; 
for ( ID = INTEGER ; ID < ID -> ID ; ID ++ ) 
ID ( STRING ) ; 
ID ( STRING ) ; 

if ( ID == ID ) 
ID ( STRING , ID -> ID ) ; 
else 
{ 
if ( ID == ID ) 
{ 
if ( ID -> ID == INTEGER && ID -> ID == INTEGER && ID -> ID == ID ) 
ID ( STRING ) ; 
else if ( ID -> ID == INTEGER && ID -> ID == INTEGER && ID -> ID == ID ) 
ID ( STRING ) ; 
else if ( ID -> ID == INTEGER && ID -> ID == INTEGER && ID -> ID == ID ) 
ID ( STRING ) ; 
else 
ID ( STRING ) ; 
} 
while ( ID != ID ) 
{ 
ID ( ID -> ID ) ; 
ID ( ID , ID -> ID , INTEGER , INTEGER ) ; 

if ( ID -> ID != ID ) 
ID ( STRING , ID -> ID ) ; 

ID ( STRING ) ; 
ID = ID -> ID ; 
if ( ID != ID && ID != ID ) 
ID ( STRING ) ; 
} 

if ( ID == ID ) 
{ 
if ( ID -> ID == INTEGER && ID -> ID == INTEGER && ID -> ID == ID ) 
ID ( STRING ) ; 
else if ( ID -> ID == INTEGER && ID -> ID == INTEGER && ID -> ID == ID ) 
ID ( STRING ) ; 
else if ( ID -> ID == INTEGER && ID -> ID == INTEGER && ID -> ID == ID ) 
ID ( STRING ) ; 
else if ( ID -> ID == INTEGER && ID -> ID == INTEGER && ID -> ID == ID ) 
ID ( STRING ) ; 
else 
{ 
ID ( STRING , ID -> ID , ID -> ID ) ; 
if ( ID -> ID != ID ) 
ID ( STRING , ID -> ID -> ID ) ; 
else 
ID ( STRING ) ; 
} 
} 
} 

ID ( STRING ) ; 

ID ( STRING , ID -> ID ? STRING : STRING ) ; 
ID ( & ID -> ID , ID , INTEGER ) ; 
ID ( STRING ) ; 

ID ( STRING ) ; 
ID ( & ID -> ID , ID , INTEGER ) ; 
ID ( STRING ) ; 

if ( ID -> ID == INTEGER ) 
ID ( STRING ) ; 
else 
ID ( STRING , ID -> ID ) ; 
} 

ID = ( ID * ) ID ( ID ) ; 
} 
}$


ansi_cpp_artsupport
$
translation_unit ::=
  declaration_seq? ;
// Generated by gramex V3.0 from 'ansi_cpp_prd97.raw' (this build Mar 25 2012 at 13:21:48)
// Command line: C:\csle\dev\gramex\gramex.exe ansi_cpp_prd97.raw

// M()(translation_unit)

// Start of provenance

// ansi_cpp_prd97.raw - a grammar for the 1998 ANSI C++ standard language

// 1. This is the grammar summary from the 1997 Public Review Document for
// ANSI C++, cut-and-pasted from http://www.open-std.org/jtc1/sc22/open/n2356/ 
// on 30 August 2006.

// 2. There may be differences between this grammar and the one in the final 
// published standard. 

// 3. You can process this file with the gramex tool to make something close
// to a Bison input file, and use the gramconv tool to convert EBNF
// constructs to pure BNF, and to translate to a variety of other formats.

// 4. For tool and grammar downloads, see the Royal Holloway Compilers Group
// homepage under http://www.cs.rhul.ac.uk, or contact us at
// A.Johnstone@rhul.ac.uk or E.Scott@rhul.ac.uk.

// 5. Please don't change this file.

//         Adrian Johnstone and Elizabeth Scott, 24 August 2006

// End of provenance
//   ______________________________________________________________________

//   Annex 0 (informative)

//   Grammar summary                                                 [gram]

//   ______________________________________________________________________

// 1 This summary of C++ syntax is intended to be an aid to  comprehension.
//   It  is  not  an  exact  statement of the language.  In particular, the
//   grammar described here accepts a superset  of  valid  C++  constructs.
//   Disambiguation rules (_stmt.ambig_, _dcl.spec_, _class.member.lookup_)
//   must be applied to distinguish expressions  from  declarations.   Fur-
//   ther,  access  control, ambiguity, and type rules must be used to weed
//   out syntactically valid but meaningless constructs.

//   1.1  Keywords                                               [gram.key]

// 1 New context-dependent keywords are introduced into a program by  type-
//   def  (_dcl.typedef_),  namespace  (_namespace.def_),  class (_class_),
//   enumeration (_dcl.enum_), and template (_temp_) declarations.
(* Comment out lexical material 

typedef_name ::=
  identifier ;
namespace_name ::=
  original_namespace_name |
  namespace_alias ;

original_namespace_name ::=
  identifier ;

namespace_alias ::=
  identifier ;
class_name ::=
  identifier |
  template_id ;
enum_name ::=
  identifier ;
template_name ::=
  identifier |
  'Note' 'that' 'a' typedef_name 'naming' 'a' 'class' 'is' 'also' 'a' class_name |
  '(_class.name_).' ;

//   1.2  Lexical conventions                                    [gram.lex]
hex_quad ::=
  hexadecimal_digit hexadecimal_digit hexadecimal_digit hexadecimal_digit ;

universal_character_name ::=
  '\\u' hex_quad |
  '\\U' hex_quad hex_quad ;

preprocessing_token ::=
  header_name |
  identifier |
  pp_number |
  character_literal |
  string_literal |
  preprocessing_op_or_punc |
  'each' 'non-white-space' 'character' 'that' 'cannot' 'be' 'one' 'of' 'the' 'above' ;
token ::=
  identifier |
  'keyword' |
  literal |
  operator |
  'punctuator' ;
header_name ::=
  '<h-char-sequence>' |
  '\"q-char-sequence\"' ;
h_char_sequence ::=
  h_char |
  h_char_sequence h_char ;
h_char ::=
  'any' 'member' 'of' 'the' 'source' 'character' 'set' 'except' |
  new_line 'and' '>' ;
q_char_sequence ::=
  q_char |
  q_char_sequence q_char ;
q_char ::=
  'any' 'member' 'of' 'the' 'source' 'character' 'set' 'except' |
  new_line 'and' '\"' ;
pp_number ::=
  digit |
  '.' digit |
  pp_number digit |
  pp_number nondigit |
  pp_number 'e' sign |
  pp_number 'E' sign |
  pp_number '.' ;
identifier ::=
  nondigit |
  identifier nondigit |
  identifier digit ;
nondigit ::=
  universal_character_name |
  '_' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' |
  'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' |
  'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' |
  'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' ;
digit ::=
  '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' ;

preprocessing_op_or_punc ::=
  '{' | '}' | '[' | ']' | '#' | '##' | '(' | ')' |
  '<:' | ':>' | '<%' | '%>' | '%:' | '%:%:' | ';' | ':' | '...' |
  'new' | 'delete' | '?' | '::' | '.' | '.*' |
  '+' | '-' | '*' | '/' | '%' | '^' | '&' | '|' | '~' |
  '!' | '=' | '<' | '>' | '+=' | '-=' | '*=' | '/=' | '%=' |
  '^=' | '&=' | '|=' | '<<' | '>>' | '>>=' | '<<=' | '==' | '!=' |
  '<=' | '>=' | '&&' | '||' | '++' | '--' | ',' | '->*' | '->' |
  'and' | 'and_eq' | 'bitand' | 'bitor' | 'compl' | 'not' | 'not_eq' | 'or' | 'or_eq' |
  'xor' | 'xor_eq' ;

literal ::=
  integer_literal |
  character_literal |
  floating_literal |
  string_literal |
  boolean_literal ;
integer_literal ::=
  decimal_literal integer_suffix? |
  octal_literal integer_suffix? |
  hexadecimal_literal integer_suffix? ;
decimal_literal ::=
  nonzero_digit |
  decimal_literal digit ;
octal_literal ::=
  '0' |
  octal_literal octal_digit ;
hexadecimal_literal ::=
  '0x' hexadecimal_digit |
  '0X' hexadecimal_digit |
  hexadecimal_literal hexadecimal_digit ;
nonzero_digit ::=
  '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' ;
octal_digit ::=
  '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' ;
hexadecimal_digit ::=
  '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' |
  'a' | 'b' | 'c' | 'd' | 'e' | 'f' |
  'A' | 'B' | 'C' | 'D' | 'E' | 'F' ;
integer_suffix ::=
  unsigned_suffix long_suffix? |
  long_suffix unsigned_suffix? ;
unsigned_suffix ::=
  'u' | 'U' ;
long_suffix ::=
  'l' | 'L' ;
character_literal ::=
  '\'c-char-sequence\'' |
  'L\'c-char-sequence\'' ;
c_char_sequence ::=
  c_char |
  c_char_sequence c_char ;

c_char ::=
  'any' 'member' 'of' 'the' 'source' 'character' 'set' 'except' |
  'the' 'single-quote' '\',' 'backslash' '\\,' 'or' new_line 'character' |
  escape_sequence |
  universal_character_name ;
escape_sequence ::=
  simple_escape_sequence |
  octal_escape_sequence |
  hexadecimal_escape_sequence ;
simple_escape_sequence ::=
  '\\\'' | '\\\"' | '\\?' | '\\\\' |
  '\\a' | '\\b' | '\\f' | '\\n' | '\\r' | '\\t' | '\\v' ;
octal_escape_sequence ::=
  '\\' octal_digit |
  '\\' octal_digit octal_digit |
  '\\' octal_digit octal_digit octal_digit ;
hexadecimal_escape_sequence ::=
  '\\x' hexadecimal_digit |
  hexadecimal_escape_sequence hexadecimal_digit ;
floating_literal ::=
  fractional_constant exponent_part? floating_suffix? |
  digit_sequence exponent_part floating_suffix? ;
fractional_constant ::=
  digit_sequence? '.' digit_sequence |
  digit_sequence '.' ;
exponent_part ::=
  'e' sign? digit_sequence |
  'E' sign? digit_sequence ;
sign ::=
  '+' | '-' ;
digit_sequence ::=
  digit |
  digit_sequence digit ;
floating_suffix ::=
  'f' | 'l' | 'F' | 'L' ;
string_literal ::=
  '\"s-char-sequenceopt\"' |
  'L\"s-char-sequenceopt\"' ;
s_char_sequence ::=
  s_char |
  s_char_sequence s_char ;
s_char ::=
  'any' 'member' 'of' 'the' 'source' 'character' 'set' 'except' |
  'the' 'double-quote' '\",' 'backslash' '\\,' 'or' new_line 'character' |
  escape_sequence |
  universal_character_name ;
boolean_literal ::=
  'false' |
  'true' ;
*)
literal ::=
  integer_literal |
  character_literal |
  floating_literal |
  string_literal |
  boolean_literal ;

string_literal ::= 'STRING' | string_literal 'STRING' ; (* Allow C-style String catenation *)
character_literal ::= 'CHARACTER' ;
integer_literal ::= 'INTEGER' ;
floating_literal ::= 'REAL' ;
boolean_literal ::= 'true' | 'false' ;

identifier ::= 'ID' ;

//   1.3  Basic concepts                                       [gram.basic]
//translation_unit ::=
//  declaration_seq? ;

//   1.4  Expressions                                           [gram.expr]
primary_expression ::=
  literal |
  'this' |
  '::' identifier |
  '::' operator_function_id |
  '::' qualified_id |
  '(' expression ')' |
  id_expression ;

(* Comment out unexpected duplicate production
id_expression ::=
  unqualified_id |
  qualified_id ;
*)

id_expression ::=
  unqualified_id |
  qualified_id ;

unqualified_id ::=
  identifier |
  operator_function_id |
  conversion_function_id |
  '~' class_name |
  template_id ;
qualified_id ::=
  nested_name_specifier 'template'? unqualified_id ;
nested_name_specifier ::=
  class_or_namespace_name '::' nested_name_specifier? ;

class_or_namespace_name ::=
  class_name |
  namespace_name ;
postfix_expression ::=
  primary_expression |
  postfix_expression '[' expression ']' |
  postfix_expression '(' expression_list? ')' |
  simple_type_specifier '(' expression_list? ')' |
  postfix_expression '.' 'template'? '::'? id_expression |
  postfix_expression '->' 'template'? '::'? id_expression |
  postfix_expression '.' pseudo_destructor_name |
  postfix_expression '->' pseudo_destructor_name |
  postfix_expression '++' |
  postfix_expression '--' |
  'dynamic_cast' '<' type_id '>' '(' expression ')' |
  'static_cast' '<' type_id '>' '(' expression ')' |
  'reinterpret_cast' '<' type_id '>' '(' expression ')' |
  'const_cast' '<' type_id '>' '(' expression ')' |
  'typeid' '(' expression ')' |
  'typeid' '(' type_id ')' ;

expression_list ::=
  assignment_expression |
  expression_list ',' assignment_expression ;
pseudo_destructor_name ::=
  '::'? nested_name_specifier? type_name '::' '~' type_name |
  '::'? nested_name_specifier? '~' type_name ;
unary_expression ::=
  postfix_expression |
  '++' cast_expression |
  '--' cast_expression |
  unary_operator cast_expression |
  'sizeof' unary_expression |
  'sizeof' '(' type_id ')' |
  new_expression |
  delete_expression ;
unary_operator ::=
  '*' | '&' | '+' | '-' | '!' | '~' ;
new_expression ::=
  '::'? 'new' new_placement? new_type_id new_initializer? |
  '::'? 'new' new_placement? '(' type_id ')' new_initializer? ;
new_placement ::=
  '(' expression_list ')' ;
new_type_id ::=
  type_specifier_seq new_declarator? ;
new_declarator ::=
  ptr_operator new_declarator? |
  direct_new_declarator ;
direct_new_declarator ::=
  '[' expression ']' |
  direct_new_declarator '[' constant_expression ']' ;
new_initializer ::=
  '(' expression_list? ')' ;
delete_expression ::=
  '::'? 'delete' cast_expression |
  '::'? 'delete' '[' ']' cast_expression ;
cast_expression ::=
  unary_expression |
  '(' type_id ')' cast_expression ;
pm_expression ::=
  cast_expression |
  pm_expression '.*' cast_expression |
  pm_expression '->*' cast_expression ;
multiplicative_expression ::=
  pm_expression |
  multiplicative_expression '*' pm_expression |
  multiplicative_expression '/' pm_expression |
  multiplicative_expression '%' pm_expression ;
additive_expression ::=
  multiplicative_expression |
  additive_expression '+' multiplicative_expression |
  additive_expression '-' multiplicative_expression ;

shift_expression ::=
  additive_expression |
  shift_expression '<<' additive_expression |
  shift_expression '>>' additive_expression ;
relational_expression ::=
  shift_expression |
  relational_expression '<' shift_expression |
  relational_expression '>' shift_expression |
  relational_expression '<=' shift_expression |
  relational_expression '>=' shift_expression ;
equality_expression ::=
  relational_expression |
  equality_expression '==' relational_expression |
  equality_expression '!=' relational_expression ;
and_expression ::=
  equality_expression |
  and_expression '&' equality_expression ;
exclusive_or_expression ::=
  and_expression |
  exclusive_or_expression '^' and_expression ;
inclusive_or_expression ::=
  exclusive_or_expression |
  inclusive_or_expression '|' exclusive_or_expression ;
logical_and_expression ::=
  inclusive_or_expression |
  logical_and_expression '&&' inclusive_or_expression ;
logical_or_expression ::=
  logical_and_expression |
  logical_or_expression '||' logical_and_expression ;
conditional_expression ::=
  logical_or_expression |
  logical_or_expression '?' expression ':' assignment_expression ;
assignment_expression ::=
  conditional_expression |
  logical_or_expression assignment_operator assignment_expression |
  throw_expression ;
assignment_operator ::=
  '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '>>=' | '<<=' | '&=' | '^=' | '|=' ;
expression ::=
  assignment_expression |
  expression ',' assignment_expression ;
constant_expression ::=
  conditional_expression ;

//   1.5  Statements                                       [gram.stmt.stmt]
statement ::=
  labeled_statement |
  expression_statement |
  compound_statement |
  selection_statement |
  iteration_statement |
  jump_statement |
  declaration_statement |
  try_block ;

labeled_statement ::=
  identifier ':' statement |
  'case' constant_expression ':' statement |
  'default' ':' statement ;
expression_statement ::=
  expression? ';' ;
compound_statement ::=
  '{' statement_seq? '}' ;
statement_seq ::=
  statement |
  statement_seq statement ;
selection_statement ::=
  'if' '(' condition ')' statement |
  'if' '(' condition ')' statement 'else' statement |
  'switch' '(' condition ')' statement ;
condition ::=
  expression |
  type_specifier_seq declarator '=' assignment_expression ;
iteration_statement ::=
  'while' '(' condition ')' statement |
  'do' statement 'while' '(' expression ')' ';' |
  'for' '(' for_init_statement condition? ';' expression? ')' statement ;
for_init_statement ::=
  expression_statement |
  simple_declaration ;
jump_statement ::=
  'break' ';' |
  'continue' ';' |
  'return' expression? ';' |
  'goto' identifier ';' ;
declaration_statement ::=
  block_declaration ;

//   1.6  Declarations                                       [gram.dcl.dcl]
declaration_seq ::=
  declaration |
  declaration_seq declaration ;
declaration ::=
  block_declaration |
  function_definition |
  template_declaration |
  explicit_instantiation |
  explicit_specialization |
  linkage_specification |
  namespace_definition ;
block_declaration ::=
  simple_declaration |
  asm_definition |
  namespace_alias_definition |
  using_declaration |
  using_directive ;
simple_declaration ::=
  decl_specifier_seq? init_declarator_list? ';' ;

decl_specifier ::=
  storage_class_specifier |
  type_specifier |
  function_specifier |
  'friend' |
  'typedef' ;
decl_specifier_seq ::=
  decl_specifier_seq? decl_specifier ;
storage_class_specifier ::=
  'auto' |
  'register' |
  'static' |
  'extern' |
  'mutable' ;
function_specifier ::=
  'inline' |
  'virtual' |
  'explicit' ;
typedef_name ::=
  identifier ;
type_specifier ::=
  simple_type_specifier |
  class_specifier |
  enum_specifier |
  elaborated_type_specifier |
  cv_qualifier ;
simple_type_specifier ::=
  '::'? nested_name_specifier? type_name |
  'char' |
  'wchar_t' |
  'bool' |
  'short' |
  'int' |
  'long' |
  'signed' |
  'unsigned' |
  'float' |
  'double' |
  'void' ;
type_name ::=
  class_name |
  enum_name |
  typedef_name ;
elaborated_type_specifier ::=
  class_key '::'? nested_name_specifier? identifier |
  'enum' '::'? nested_name_specifier? identifier |
  'typename' '::'? nested_name_specifier identifier |
  'typename' '::'? nested_name_specifier identifier '<' template_argument_list '>' ;
enum_name ::=
  identifier ;
enum_specifier ::=
  'enum' identifier? '{' enumerator_list? '}' ;

enumerator_list ::=
  enumerator_definition |
  enumerator_list ',' enumerator_definition ;
enumerator_definition ::=
  enumerator |
  enumerator '=' constant_expression ;
enumerator ::=
  identifier ;
namespace_name ::=
  original_namespace_name |
  namespace_alias ;
original_namespace_name ::=
  identifier ;

namespace_definition ::=
  named_namespace_definition |
  unnamed_namespace_definition ;

named_namespace_definition ::=
  original_namespace_definition |
  extension_namespace_definition ;

original_namespace_definition ::=
  'namespace' identifier '{' namespace_body '}' ;

extension_namespace_definition ::=
  'namespace' original_namespace_name '{' namespace_body '}' ;

unnamed_namespace_definition ::=
  'namespace' '{' namespace_body '}' ;

namespace_body ::=
  declaration_seq? ;
namespace_alias ::=
  identifier ;

namespace_alias_definition ::=
  'namespace' identifier '=' qualified_namespace_specifier ';' ;

qualified_namespace_specifier ::=
  '::'? nested_name_specifier? namespace_name ;
using_declaration ::=
  'using' 'typename'? '::'? nested_name_specifier unqualified_id ';' |
  'using' '::' unqualified_id ';' ;
using_directive ::=
  'using' 'namespace' '::'? nested_name_specifier? namespace_name ';' ;
asm_definition ::=
  'asm' '(' string_literal ')' ';' ;
linkage_specification ::=
  'extern' string_literal '{' declaration_seq? '}' |
  'extern' string_literal declaration ;

//   1.7  Declarators                                       [gram.dcl.decl]
init_declarator_list ::=
  init_declarator |
  init_declarator_list ',' init_declarator ;
init_declarator ::=
  declarator initializer? ;
declarator ::=
  direct_declarator |
  ptr_operator declarator ;
direct_declarator ::=
  declarator_id |
  direct_declarator '(' parameter_declaration_clause ')' cv_qualifier_seq? exception_specification? |
  direct_declarator '[' constant_expression? ']' |
  '(' declarator ')' ;
ptr_operator ::=
  '*' cv_qualifier_seq? |
  '&' |
  '::'? nested_name_specifier '*' cv_qualifier_seq? ;
cv_qualifier_seq ::=
  cv_qualifier cv_qualifier_seq? ;
cv_qualifier ::=
  'const' |
  'volatile' ;
declarator_id ::=
  '::'? id_expression |
  '::'? nested_name_specifier? type_name ;
type_id ::=
  type_specifier_seq abstract_declarator? ;
type_specifier_seq ::=
  type_specifier type_specifier_seq? ;
abstract_declarator ::=
  ptr_operator abstract_declarator? |
  direct_abstract_declarator ;
direct_abstract_declarator ::=
  direct_abstract_declarator? '(' parameter_declaration_clause ')' cv_qualifier_seq? exception_specification? |
  direct_abstract_declarator? '[' constant_expression? ']' |
  '(' abstract_declarator ')' ;
parameter_declaration_clause ::=
  parameter_declaration_list? '...'? |
  parameter_declaration_list ',' '...' ;
parameter_declaration_list ::=
  parameter_declaration |
  parameter_declaration_list ',' parameter_declaration ;
parameter_declaration ::=
  decl_specifier_seq declarator |
  decl_specifier_seq declarator '=' assignment_expression |
  decl_specifier_seq abstract_declarator? |
  decl_specifier_seq abstract_declarator? '=' assignment_expression ;
function_definition ::=
  decl_specifier_seq? declarator ctor_initializer? function_body |
  decl_specifier_seq? declarator function_try_block ;

function_body ::=
  compound_statement ;

initializer ::=
  '=' initializer_clause |
  '(' expression_list ')' ;
initializer_clause ::=
  assignment_expression |
  '{' initializer_list ','? '}' |
  '{' '}' ;
initializer_list ::=
  initializer_clause |
  initializer_list ',' initializer_clause ;

//   1.8  Classes                                              [gram.class]
class_name ::=
  identifier |
  template_id ;
class_specifier ::=
  class_head '{' member_specification? '}' ;
class_head ::=
  class_key identifier? base_clause? |
  class_key nested_name_specifier identifier base_clause? ;
class_key ::=
  'class' |
  'struct' |
  'union' ;
member_specification ::=
  member_declaration member_specification? |
  access_specifier ':' member_specification? ;
member_declaration ::=
  decl_specifier_seq? member_declarator_list? ';' |
  function_definition ';'? |
  qualified_id ';' |
  using_declaration |
  template_declaration ;
member_declarator_list ::=
  member_declarator |
  member_declarator_list ',' member_declarator ;
member_declarator ::=
  declarator pure_specifier? |
  declarator constant_initializer? |
  identifier? ':' constant_expression ;
pure_specifier ::=
  '=' '0' ;
constant_initializer ::=
  '=' constant_expression ;

//   1.9  Derived classes                              [gram.class.derived]
base_clause ::=
  ':' base_specifier_list ;
base_specifier_list ::=
  base_specifier |
  base_specifier_list ',' base_specifier ;

base_specifier ::=
  '::'? nested_name_specifier? class_name |
  'virtual' access_specifier? '::'? nested_name_specifier? class_name |
  access_specifier 'virtual'? '::'? nested_name_specifier? class_name ;
access_specifier ::=
  'private' |
  'protected' |
  'public' ;

//   1.10  Special member functions                          [gram.special]
conversion_function_id ::=
  operator conversion_type_id ;
conversion_type_id ::=
  type_specifier_seq conversion_declarator? ;
conversion_declarator ::=
  ptr_operator conversion_declarator? ;
ctor_initializer ::=
  ':' mem_initializer_list ;
mem_initializer_list ::=
  mem_initializer |
  mem_initializer ',' mem_initializer_list ;
mem_initializer ::=
  mem_initializer_id '(' expression_list? ')' ;
mem_initializer_id ::=
  '::'? nested_name_specifier? class_name |
  identifier ;

//   1.11  Overloading                                          [gram.over]
operator_function_id ::=
  operator operator ;
operator ::=
  'new' | 'delete' | 'new[]' | 'delete[]' |
  '+' | '-' | '*' | '/' | '%' | '^' | '&' | '|' | '~' |
  '!' | '=' | '<' | '>' | '+=' | '-=' | '*=' | '/=' | '%=' |
  '^=' | '&=' | '|=' | '<<' | '>>' | '>>=' | '<<=' | '==' | '!=' |
  '<=' | '>=' | '&&' | '||' | '++' | '--' | ',' | '->*' | '->' |
  '()' | '[]' ;

//   1.12  Templates                                            [gram.temp]
template_declaration ::=
  'export'? 'template' '<' template_parameter_list '>' declaration ;
template_parameter_list ::=
  template_parameter |
  template_parameter_list ',' template_parameter ;
template_parameter ::=
  type_parameter |
  parameter_declaration ;
type_parameter ::=
  'class' identifier? |
  'class' identifier? '=' type_id |
  'typename' identifier? |
  'typename' identifier? '=' type_id |
  'template' '<' template_parameter_list '>' 'class' identifier? |
  'template' '<' template_parameter_list '>' 'class' identifier? '=' template_name ;

template_id ::=
  template_name '<' template_argument_list '>' ;
template_name ::=
  identifier ;
template_argument_list ::=
  template_argument |
  template_argument_list ',' template_argument ;
template_argument ::=
  assignment_expression |
  type_id |
  template_name ;
explicit_instantiation ::=
  'template' declaration ;
explicit_specialization ::=
  'template' '<' '>' declaration ;

//   1.13  Exception handling                                 [gram.except]
try_block ::=
  'try' compound_statement handler_seq ;
function_try_block ::=
  'try' ctor_initializer? function_body handler_seq ;
handler_seq ::=
  handler handler_seq? ;
handler ::=
  'catch' '(' exception_declaration ')' compound_statement ;
exception_declaration ::=
  type_specifier_seq declarator |
  type_specifier_seq abstract_declarator |
  type_specifier_seq |
  '...' ;
throw_expression ::=
  'throw' assignment_expression? ;
exception_specification ::=
  'throw' '(' type_id_list? ')' ;
type_id_list ::=
  type_id |
  type_id_list ',' type_id ;

(* Comment out preprocessor stuff 
//   1.14  Preprocessing directives                              [gram.cpp]
preprocessing_file ::=
  group? ;
group ::=
  group_part |
  group group_part ;
group_part ::=
  pp_tokens? new_line |
  if_section |
  control_line ;
if_section ::=
  if_group elif_groups? else_group? endif_line ;
if_group ::=
  '#' 'if' constant_expression new_line group? |
  '#' 'ifdef' identifier new_line group? |
  '#' 'ifndef' identifier new_line group? ;

elif_groups ::=
  elif_group |
  elif_groups elif_group ;
elif_group ::=
  '#' 'elif' constant_expression new_line group? ;
else_group ::=
  '#' 'else' new_line group? ;
endif_line ::=
  '#' 'endif' new_line ;
control_line ::=
  '#' 'include' pp_tokens new_line |
  '#' 'define' identifier replacement_list new_line |
  '#' 'define' identifier lparen 'identifier-list'? ')' replacement_list new_line |
  '#' 'undef' identifier new_line |
  '#' 'line' pp_tokens new_line |
  '#' 'error' pp_tokens? new_line |
  '#' 'pragma' pp_tokens? new_line |
  '#' new_line ;
lparen ::=
  'the' 'left-parenthesis' 'character' 'without' 'preceding' 'white-space' ;
replacement_list ::=
  pp_tokens? ;
pp_tokens ::=
  preprocessing_token |
  pp_tokens preprocessing_token ;
new_line ::=
  'the' new_line 'character' ;
*)

// End of ansi_cpp_prd97.raw
$
accept
$class ID { 
public : 
static ID ID ; 
static int ID ; 
ID ID ; 
enum ID ID ; 
ID * ID ; 
ID * ID ; 
ID ( ID ID ) { 
this -> ID = ID ; ID = ID = ID ; 
} ; 
ID ( ID ID , ID * ID ) { 
this -> ID = ID ; ID = ID ; 
ID * ID = ID -> ID ; 
if ( ID == ID ) 
ID -> ID = this ; 
else { 
while ( ID -> ID != ID ) 
ID = ID -> ID ; 
ID -> ID = this ; 
} 
ID = ID ; 
} ; 
void ID ( ) { 
ID << ID << STRING ; 
if ( ID != ID ) 
ID -> ID ( ) ; 
ID << STRING ; 
if ( ID != ID ) 
ID -> ID ( ) ; 
} ; 
void ID ( int ID , const char * * ID ) ; 
void ID ( const char * ID , const char * * ID ) { 
ID . ID ( ID ) ; 
ID << 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING ; 
ID = INTEGER ; 
this -> ID ( INTEGER , ID ) ; 
ID << STRING ; 
ID . ID ( ) ; 
} ; 
void ID ( ID * ID , const char * * ID ) { 
if ( ID == ID ) 
return ; 
if ( ID -> ID == ID ) 
ID << ID [ ID -> ID ] << STRING ; 
else { 
ID << STRING ; 
ID ( ID -> ID , ID ) ; 
ID << STRING ; 
} 
if ( ID -> ID != ID ) 
ID ( ID -> ID , ID ) ; 
} 
void ID ( const char * ID , ID * ID , const char * * ID ) { 
ID . ID ( ID ) ; 
ID ( ID , ID ) ; 
ID . ID ( ) ; 
} 
} ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID * ID ; int ID : INTEGER ; int ID : INTEGER ; ID ID ; ID ( ) { ID . ID = ID . ID = ID ; } ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID * ID ; ID ID ; ID * ID ; ID ID ; ID ID ; int ID : INTEGER ; } ; 
class ID { public : ID ID ; struct ID * ID ; struct ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID ID ; ID ID ; ID ( ) { ID . ID = ID . ID = ID . ID = ID . ID = ID ; } ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { 
public : 
ID ID ; 
bool ID ; 
ID ID ; 
ID ID ; 
const char * ID ; 
const char * ID ; 
const char * ID ; 
const char * ID ; 
ID * ID ; 
int ID ; 
const char * * ID ; 
const char * * ID ; 
ID * ID ; 
ID * ID ; 
ID ID ; 
const char * * ID ; 
const char * * ID ; 
bool * ID ; 
bool * ID ; 
int ID ; 
enum ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
bool * ID ; 
bool * ID ; 
bool * ID ; 
bool * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
ID * ID ( ID * ID ) ; 
ID * ID ( ID ID , ID * ID ) ; 
ID * ID ( ID ID , ID * ID , ID * ID ) ; 
ID * ID ( ID ID , ID ID , ID * ID ) ; 
ID * ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
void ID ( ID * ID , ID * ID , ID * ID ) ; 
void ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
bool ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
ID * ID ( ID * ID , ID * ID , bool ID ) ; 
void ID ( ID * ID , int ID ) ; 
void ID ( ID * ID , ID * ID ) ; 
void ID ( ) ; 
void ID ( ID * ID ) ; 
void ID ( const char * ID , ID * ID , int * ID ) ; 
const char * ID ( const char * ID ) ; 
const char * ID ( const char * ID , const char * ID ) { 
const char * ID = ID ; 
while ( * ID != INTEGER && * ID == * ID ) { 
ID ++ ; 
ID ++ ; 
} 
if ( * ID == INTEGER ) 
return ID ; 
else 
return ID ; 
} 
const char ID ( const char ID ) { return ( ID >= ( const char ) STRING && ID <= ( const char ) STRING ) ? ( const char ) ( ID + INTEGER ) : ID ; } 
const char * ID ( const char * ID , const char * ID ) { 
const char * ID = ID ; 
while ( * ID != INTEGER && ID ( * ID ) == ID ( * ID ) ) { 
ID ++ ; 
ID ++ ; 
} 
if ( * ID == INTEGER ) 
return ID ; 
else 
return ID ; 
} 
bool ID ( const char * ID ) { 
ID = new ID [ ID ( ID ) + INTEGER ] ; 
ID = new const char * [ ID ( ID ) + INTEGER ] ; 
ID = new const char * [ ID ( ID ) + INTEGER ] ; 
const char * ID = ID ; 
ID = ID ; 
ID ID ; 
ID = ID ( ID ) ; 
while ( INTEGER ) { 
if ( * ID == INTEGER ) { 
* ID = ID ; 
ID = ID ; 
ID = ID - ID ; 
return true ; 
} 
int ID = INTEGER ; 
const char * ID ; 
for ( ID ID = ( ID ) INTEGER ; ID != ID ; ID = ( ID ) ( ( int ) ID + INTEGER ) ) { 
if ( ID [ ID ] ) 
ID = ID ( ID [ ID ] , ID ) ; 
else 
ID = ID ( ID [ ID ] , ID ) ; 
int ID = ID - ID ; 
if ( ID > ID ) { 
ID = ID ; 
ID = ID ; 
} 
} 
ID ( ID , & ID , & ID ) ; 
if ( ID == INTEGER ) { 
ID << STRING << ( ID - ID ) << STRING << ( int ) * ID << STRING << * ID << STRING ; 
* ID = ID ; 
ID = ID ; 
return false ; 
} 
ID [ ID - ID ] = ID ; 
ID += ID ; 
ID [ ID - ID ] = ID ; 
* ID ++ = ID ; 
if ( ID [ ID ] ) { 
ID = ID ( ID ) ; 
} 
} 
} 
const char * ID ( const char * ID ) { 
if ( ID ( * ID ) || * ID == STRING ) 
while ( ID ( * ID ) || * ID == STRING || * ID == STRING || * ID == STRING ) 
ID ++ ; 
return ID ; 
} 
bool ID ( const char * ID ) { 
return 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING ; 
} 
bool ID ( const char * ID ) { 
return 
* ID == STRING || * ID == STRING || * ID == STRING ; 
} 
bool ID ( const char * ID ) { 
return 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ID ( ID ) ) 
return ID ; 
ID ++ ; 
while ( ID ( ID ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ID ( ID ) ) 
return ID ; 
ID ++ ; 
while ( ID ( ID ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ID ( * ID ) || * ID == STRING ) 
while ( ID ( * ID ) || * ID == STRING ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
bool ID = ( * ID == STRING && ( * ( ID + INTEGER ) == STRING || * ( ID + INTEGER ) == STRING ) ) ; 
if ( ID ) ID += INTEGER ; 
while ( ( ID ? ID ( * ID ) : ID ( * ID ) ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ID ( * ID ) ) 
return ID ; 
while ( ID ( * ID ) ) 
ID ++ ; 
if ( * ID != STRING ) 
return ID ; 
ID ++ ; 
while ( ID ( * ID ) ) 
ID ++ ; 
if ( * ID == STRING || * ID == STRING ) { 
ID ++ ; 
while ( ID ( * ID ) ) 
ID ++ ; 
} 
return ID ; 
} 
const char * ID ( const char * ID ) { 
const char * ID = ID ; 
if ( * ID != STRING ) 
return ID ; 
ID ++ ; 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
if ( * ID != STRING ) 
return ID ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( * ID != STRING ) ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( * ID != STRING ) ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( * ID != STRING ) ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ( ( * ID == STRING ) && ( * ( ID + INTEGER ) == STRING ) ) ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( ! ( ( * ID == STRING ) && ( * ( ID + INTEGER ) == STRING ) ) ) ; 
ID ++ ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
if ( * ID != STRING ) { 
if ( * ( ID + INTEGER ) == STRING && ( * ( ID + INTEGER ) == STRING || * ( ID + INTEGER ) == STRING ) ) 
ID += INTEGER ; 
} 
else 
ID += INTEGER ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
while ( * ID != INTEGER && ( ID ( * ID ) ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
int ID = INTEGER ; 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
while ( ID > INTEGER ) { 
if ( * ID == INTEGER ) 
break ; 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
ID ++ ; 
} 
else if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
ID -- ; 
} 
else 
ID ++ ; 
} 
} 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
while ( INTEGER ) { 
if ( * ID == INTEGER ) 
break ; 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
break ; 
} 
ID ++ ; 
} 
} 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) 
while ( * ID != INTEGER && * ID != STRING ) 
ID ++ ; 
if ( * ID == STRING ) 
ID ++ ; 
return ID ; 
} 
void ID ( const char * const ID ) ; 
void ID ( ID ID ) ; 
void ID ( ) { 
ID = new ID ( INTEGER , ID , ID - ID ) ; 
ID = new ID ; 
ID = new ID ; 
ID = new ID ; 
ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID -> ID = ID ; 
} 
void ID ( ) { 
ID = ID -> ID ( ) ; 
ID = ID -> ID ; 
ID = ID -> ID ; 
ID = ID -> ID ; 
ID = ID -> ID ; 
} 
void ID ( ) { 
ID = ID ( ) ; 
} 
void ID ( ) { 
ID = ID ( ) ; 
} 
void ID ( ) { 
if ( ID -> ID ( ID , ID , ID , ID , ID , ID , ID , ID , INTEGER , ID , ID ) < INTEGER ) 
ID ( ID , ID ) ; 
ID << STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID ; 
ID << STRING ; 
} 
void ID ( const char * ID ) { ID = ID ( ID ) ; } 
ID ( ) ; 
} ; 
class ID { 
class ID { 
public : 
unsigned long ID ; 
unsigned long ID ; 
ID * ID ; 
} ; 
ID * ID ; 
public : 
ID ( ) 
{ 
ID = new ID ; 
ID -> ID = ID -> ID = INTEGER ; 
ID -> ID = new ID ; 
ID -> ID -> ID = ID ; 
ID -> ID -> ID = INTEGER ; 
ID -> ID -> ID = ID ; 
} 
void ID ( unsigned long ID ) 
{ 
ID * ID = ID ; 
ID * ID ; 
ID * ID ; 
do 
{ 
if ( ID -> ID == ID ) 
{ 
ID -> ID ++ ; 
return ; 
} 
ID = ID ; 
ID = ID -> ID ; 
} 
while ( ID -> ID <= ID ) ; 
ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = INTEGER ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
} 
void ID ( ) 
{ 
unsigned long ID = ID ( ) ; 
ID * ID = ID ; 
while ( ID -> ID != ID ) 
{ 
if ( ID -> ID != INTEGER ) 
ID << ID -> ID << STRING << ID -> ID << STRING << ( INTEGER * ID -> ID ) / ID << STRING ; 
ID = ID -> ID ; 
} 
} 
unsigned long ID ( unsigned long ID ) 
{ 
ID * ID = ID ; 
while ( ID -> ID != ID && ID -> ID != ID ) 
ID = ID -> ID ; 
return ID -> ID == ID ? ID -> ID : INTEGER ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
if ( ID -> ID != INTEGER ) 
ID ++ ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
ID ++ ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
ID += ID -> ID ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
ID += ID -> ID * ID -> ID ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
} ; 
enum ID { ID , ID , ID , ID , ID , ID } ; 
enum ID { ID , ID , ID , ID , ID , ID } ; 
void ID ( struct ID * * ID , int ID , const char * * ID , enum ID * ID ) ; 
enum ID { ID , ID , ID , ID , ID , ID , ID } ; 
struct ID { ID ID ; struct ID * ID ; } ; 
struct ID { ID * ID ; ID * ID ; } ; 
class ID { 
public : 
ID ( ) { ID = ID = ID ; } ; 
static ID * ID ; 
static unsigned ID ; 
static unsigned ID ; 
static unsigned ID ; 
static struct ID * * ID ; 
struct ID * ID ; 
struct ID * ID ; 
ID ( unsigned ID , ID * ID , int ID ) { 
ID = ID ; 
ID = ID ; 
ID = INTEGER ; 
for ( int ID = INTEGER ; ID < ID ; ID ++ ) 
ID *= INTEGER ; 
ID = new ID * [ ID ] ; 
ID = ID - INTEGER ; 
ID ( ID , INTEGER , ID * sizeof ( ID * ) ) ; 
ID = ID = ID ; 
} 
unsigned ID ( ID ID , ID ID , ID ID , ID ID , ID * ID , ID * ID , ID * ID , ID * ID ) { 
return ( ID * ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID + 
( ID - ID ) * ID * ID * ID + 
( ID - ID ) * ID * ID + 
( ID - ID ) * ID + 
( ID - ID ) ) & ID ; 
} 
unsigned ID ( ID ID , ID ID , ID ID , ID * ID , ID * ID , ID * ID ) { 
return ( ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID + 
ID * ID * ID * ID + 
( ID - ID ) * ID * ID + 
( ID - ID ) * ID + 
( ID - ID ) ) & ID ; 
} 
unsigned ID ( ID ID , ID ID , ID * ID , ID * ID ) { 
return ( ID * ID * ID * ID + 
ID * ID * ID + 
( ID - ID ) * ID + 
( ID - ID ) ) & ID ; 
} 
unsigned ID ( ID ID , ID ID , ID * ID ) { 
return ( ID * ID * ID + 
ID * ID + 
( ID - ID ) ) & ID ; 
} 
bool ID ( ) ; 
void ID ( struct ID * ID ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ID ID , struct ID * ID , ID * ID , struct ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID ID , struct ID * ID , ID * ID , struct ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID * ID ) ; 
void ID ( ID * ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID ID , ID * ID ) ; 
void ID ( struct ID * ID ) ; 
struct ID * ID ( ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
void ID ( ) ; 
void ID ( ) ; 
int ID ( const char * ID , const char * ID , const char * ID , const char * ID , ID * ID , int ID , ID * ID , bool ID , double ID , const char * * ID , enum ID * ID ) ; 
void ID ( ) ; 
} ; 
class ID { 
public : 
static ID ID ; 
static int ID ; 
ID ID ; 
enum ID ID ; 
ID * ID ; 
ID * ID ; 
ID ( ID ID ) { 
this -> ID = ID ; ID = ID = ID ; 
} ; 
ID ( ID ID , ID * ID ) { 
this -> ID = ID ; ID = ID ; 
ID * ID = ID -> ID ; 
if ( ID == ID ) 
ID -> ID = this ; 
else { 
while ( ID -> ID != ID ) 
ID = ID -> ID ; 
ID -> ID = this ; 
} 
ID = ID ; 
} ; 
void ID ( ) { 
ID << ID << STRING ; 
if ( ID != ID ) 
ID -> ID ( ) ; 
ID << STRING ; 
if ( ID != ID ) 
ID -> ID ( ) ; 
} ; 
void ID ( int ID , const char * * ID ) ; 
void ID ( const char * ID , const char * * ID ) { 
ID . ID ( ID ) ; 
ID << 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING ; 
ID = INTEGER ; 
this -> ID ( INTEGER , ID ) ; 
ID << STRING ; 
ID . ID ( ) ; 
} ; 
void ID ( ID * ID , const char * * ID ) { 
if ( ID == ID ) 
return ; 
if ( ID -> ID == ID ) 
ID << ID [ ID -> ID ] << STRING ; 
else { 
ID << STRING ; 
ID ( ID -> ID , ID ) ; 
ID << STRING ; 
} 
if ( ID -> ID != ID ) 
ID ( ID -> ID , ID ) ; 
} 
void ID ( const char * ID , ID * ID , const char * * ID ) { 
ID . ID ( ID ) ; 
ID ( ID , ID ) ; 
ID . ID ( ) ; 
} 
} ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID * ID ; int ID : INTEGER ; int ID : INTEGER ; ID ID ; ID ( ) { ID . ID = ID . ID = ID ; } ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID * ID ; ID ID ; ID * ID ; ID ID ; ID ID ; int ID : INTEGER ; } ; 
class ID { public : ID ID ; struct ID * ID ; struct ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID ID ; ID ID ; ID ( ) { ID . ID = ID . ID = ID . ID = ID . ID = ID ; } ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { 
public : 
ID ID ; 
bool ID ; 
ID ID ; 
ID ID ; 
const char * ID ; 
const char * ID ; 
const char * ID ; 
const char * ID ; 
ID * ID ; 
int ID ; 
const char * * ID ; 
const char * * ID ; 
ID * ID ; 
ID * ID ; 
ID ID ; 
const char * * ID ; 
const char * * ID ; 
bool * ID ; 
bool * ID ; 
int ID ; 
enum ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
bool * ID ; 
bool * ID ; 
bool * ID ; 
bool * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
ID * ID ( ID * ID ) ; 
ID * ID ( ID ID , ID * ID ) ; 
ID * ID ( ID ID , ID * ID , ID * ID ) ; 
ID * ID ( ID ID , ID ID , ID * ID ) ; 
ID * ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
void ID ( ID * ID , ID * ID , ID * ID ) ; 
void ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
bool ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
ID * ID ( ID * ID , ID * ID , bool ID ) ; 
void ID ( ID * ID , int ID ) ; 
void ID ( ID * ID , ID * ID ) ; 
void ID ( ) ; 
void ID ( ID * ID ) ; 
void ID ( const char * ID , ID * ID , int * ID ) ; 
const char * ID ( const char * ID ) ; 
const char * ID ( const char * ID , const char * ID ) { 
const char * ID = ID ; 
while ( * ID != INTEGER && * ID == * ID ) { 
ID ++ ; 
ID ++ ; 
} 
if ( * ID == INTEGER ) 
return ID ; 
else 
return ID ; 
} 
const char ID ( const char ID ) { return ( ID >= ( const char ) STRING && ID <= ( const char ) STRING ) ? ( const char ) ( ID + INTEGER ) : ID ; } 
const char * ID ( const char * ID , const char * ID ) { 
const char * ID = ID ; 
while ( * ID != INTEGER && ID ( * ID ) == ID ( * ID ) ) { 
ID ++ ; 
ID ++ ; 
} 
if ( * ID == INTEGER ) 
return ID ; 
else 
return ID ; 
} 
bool ID ( const char * ID ) { 
ID = new ID [ ID ( ID ) + INTEGER ] ; 
ID = new const char * [ ID ( ID ) + INTEGER ] ; 
ID = new const char * [ ID ( ID ) + INTEGER ] ; 
const char * ID = ID ; 
ID = ID ; 
ID ID ; 
ID = ID ( ID ) ; 
while ( INTEGER ) { 
if ( * ID == INTEGER ) { 
* ID = ID ; 
ID = ID ; 
ID = ID - ID ; 
return true ; 
} 
int ID = INTEGER ; 
const char * ID ; 
for ( ID ID = ( ID ) INTEGER ; ID != ID ; ID = ( ID ) ( ( int ) ID + INTEGER ) ) { 
if ( ID [ ID ] ) 
ID = ID ( ID [ ID ] , ID ) ; 
else 
ID = ID ( ID [ ID ] , ID ) ; 
int ID = ID - ID ; 
if ( ID > ID ) { 
ID = ID ; 
ID = ID ; 
} 
} 
ID ( ID , & ID , & ID ) ; 
if ( ID == INTEGER ) { 
ID << STRING << ( ID - ID ) << STRING << ( int ) * ID << STRING << * ID << STRING ; 
* ID = ID ; 
ID = ID ; 
return false ; 
} 
ID [ ID - ID ] = ID ; 
ID += ID ; 
ID [ ID - ID ] = ID ; 
* ID ++ = ID ; 
if ( ID [ ID ] ) { 
ID = ID ( ID ) ; 
} 
} 
} 
const char * ID ( const char * ID ) { 
if ( ID ( * ID ) || * ID == STRING ) 
while ( ID ( * ID ) || * ID == STRING || * ID == STRING || * ID == STRING ) 
ID ++ ; 
return ID ; 
} 
bool ID ( const char * ID ) { 
return 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING ; 
} 
bool ID ( const char * ID ) { 
return 
* ID == STRING || * ID == STRING || * ID == STRING ; 
} 
bool ID ( const char * ID ) { 
return 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ID ( ID ) ) 
return ID ; 
ID ++ ; 
while ( ID ( ID ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ID ( ID ) ) 
return ID ; 
ID ++ ; 
while ( ID ( ID ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ID ( * ID ) || * ID == STRING ) 
while ( ID ( * ID ) || * ID == STRING ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
bool ID = ( * ID == STRING && ( * ( ID + INTEGER ) == STRING || * ( ID + INTEGER ) == STRING ) ) ; 
if ( ID ) ID += INTEGER ; 
while ( ( ID ? ID ( * ID ) : ID ( * ID ) ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ID ( * ID ) ) 
return ID ; 
while ( ID ( * ID ) ) 
ID ++ ; 
if ( * ID != STRING ) 
return ID ; 
ID ++ ; 
while ( ID ( * ID ) ) 
ID ++ ; 
if ( * ID == STRING || * ID == STRING ) { 
ID ++ ; 
while ( ID ( * ID ) ) 
ID ++ ; 
} 
return ID ; 
} 
const char * ID ( const char * ID ) { 
const char * ID = ID ; 
if ( * ID != STRING ) 
return ID ; 
ID ++ ; 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
if ( * ID != STRING ) 
return ID ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( * ID != STRING ) ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( * ID != STRING ) ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( * ID != STRING ) ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ( ( * ID == STRING ) && ( * ( ID + INTEGER ) == STRING ) ) ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( ! ( ( * ID == STRING ) && ( * ( ID + INTEGER ) == STRING ) ) ) ; 
ID ++ ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
if ( * ID != STRING ) { 
if ( * ( ID + INTEGER ) == STRING && ( * ( ID + INTEGER ) == STRING || * ( ID + INTEGER ) == STRING ) ) 
ID += INTEGER ; 
} 
else 
ID += INTEGER ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
while ( * ID != INTEGER && ( ID ( * ID ) ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
int ID = INTEGER ; 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
while ( ID > INTEGER ) { 
if ( * ID == INTEGER ) 
break ; 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
ID ++ ; 
} 
else if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
ID -- ; 
} 
else 
ID ++ ; 
} 
} 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
while ( INTEGER ) { 
if ( * ID == INTEGER ) 
break ; 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
break ; 
} 
ID ++ ; 
} 
} 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) 
while ( * ID != INTEGER && * ID != STRING ) 
ID ++ ; 
if ( * ID == STRING ) 
ID ++ ; 
return ID ; 
} 
void ID ( const char * const ID ) ; 
void ID ( ID ID ) ; 
void ID ( ) { 
ID = new ID ( INTEGER , ID , ID - ID ) ; 
ID = new ID ; 
ID = new ID ; 
ID = new ID ; 
ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID -> ID = ID ; 
} 
void ID ( ) { 
ID = ID -> ID ( ) ; 
ID = ID -> ID ; 
ID = ID -> ID ; 
ID = ID -> ID ; 
ID = ID -> ID ; 
} 
void ID ( ) { 
ID = ID ( ) ; 
} 
void ID ( ) { 
ID = ID ( ) ; 
} 
void ID ( ) { 
if ( ID -> ID ( ID , ID , ID , ID , ID , ID , ID , ID , INTEGER , ID , ID ) < INTEGER ) 
ID ( ID , ID ) ; 
ID << STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID ; 
ID << STRING ; 
} 
void ID ( const char * ID ) { ID = ID ( ID ) ; } 
ID ( ) ; 
} ; 
class ID { 
class ID { 
public : 
unsigned long ID ; 
unsigned long ID ; 
ID * ID ; 
} ; 
ID * ID ; 
public : 
ID ( ) 
{ 
ID = new ID ; 
ID -> ID = ID -> ID = INTEGER ; 
ID -> ID = new ID ; 
ID -> ID -> ID = ID ; 
ID -> ID -> ID = INTEGER ; 
ID -> ID -> ID = ID ; 
} 
void ID ( unsigned long ID ) 
{ 
ID * ID = ID ; 
ID * ID ; 
ID * ID ; 
do 
{ 
if ( ID -> ID == ID ) 
{ 
ID -> ID ++ ; 
return ; 
} 
ID = ID ; 
ID = ID -> ID ; 
} 
while ( ID -> ID <= ID ) ; 
ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = INTEGER ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
} 
void ID ( ) 
{ 
unsigned long ID = ID ( ) ; 
ID * ID = ID ; 
while ( ID -> ID != ID ) 
{ 
if ( ID -> ID != INTEGER ) 
ID << ID -> ID << STRING << ID -> ID << STRING << ( INTEGER * ID -> ID ) / ID << STRING ; 
ID = ID -> ID ; 
} 
} 
unsigned long ID ( unsigned long ID ) 
{ 
ID * ID = ID ; 
while ( ID -> ID != ID && ID -> ID != ID ) 
ID = ID -> ID ; 
return ID -> ID == ID ? ID -> ID : INTEGER ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
if ( ID -> ID != INTEGER ) 
ID ++ ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
ID ++ ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
ID += ID -> ID ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
ID += ID -> ID * ID -> ID ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
} ; 
unsigned ID :: ID ; 
unsigned ID :: ID ; 
ID * ID :: ID ; 
unsigned ID :: ID ; 
ID * * ID :: ID ; 
void ID :: ID ( ) { 
} 
int ID :: ID ( const char * ID , const char * ID , const char * ID , const char * ID , ID * ID , int ID , ID * ID , bool ID , double ID , const char * * ID , enum ID * ID ) { 
ID = STRING ; 
int ID = INTEGER ; 
int ID = INTEGER ; 
int ID = INTEGER ; 
int ID = INTEGER ; 
int ID = INTEGER ; 
int ID = INTEGER ; 
int ID = INTEGER ; 
int ID = INTEGER ; 
int ID = INTEGER ; 
int ID = INTEGER ; 
ID * ID = new ID ( ) ; 
int * ID = new int [ ID - ID + INTEGER ] ; 
for ( int ID = INTEGER ; ID < ID - ID + INTEGER ; ID ++ ) 
ID [ ID ] = INTEGER ; 
for ( int ID = INTEGER ; ID < ID :: ID ; ID ++ ) { 
unsigned long ID = INTEGER ; 
for ( ID * ID = ID :: ID [ ID ] ; ID != ID ; ID = ID -> ID ) { 
ID ++ ; 
ID * ID ; 
switch ( ID -> ID ) { 
case ID : ID ++ ; break ; 
case ID : 
ID ++ ; 
if ( ID < ( ( ID * ) ID ) -> ID - ID ) 
ID = ( ( ID * ) ID ) -> ID - ID ; 
for ( ID = ( ( ID * ) ID ) -> ID . ID ( ) ; ID != ID ; ID = ( ( ID * ) ID ) -> ID . ID ( ) ) { 
ID ++ ; 
if ( ID -> ID != ID ) 
ID ++ ; 
if ( ID -> ID != ID ) 
ID ++ ; 
} 
break ; 
case ID : ID ++ ; break ; 
case ID : ID ++ ; break ; 
case ID : ID ++ ; break ; 
case ID : ID ++ ; ID [ ( ( ID * ) ID ) -> ID - ID ] ++ ; break ; 
case ID : ID ++ ; break ; 
default : ID << STRING << ID -> ID << STRING ; 
} 
} 
} 
for ( int ID = INTEGER ; ID < ( ID - ID + INTEGER ) ; ID ++ ) { 
if ( ID [ ID ] > ID ) 
ID = ID [ ID ] ; 
} 
if ( ID < INTEGER ) { 
ID << STRING ; 
ID ID ; 
ID . ID ( STRING ) ; 
ID << 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING << 
STRING << 
STRING ; 
for ( int ID = INTEGER ; ID < ID :: ID ; ID ++ ) { 
for ( ID * ID = ID :: ID [ ID ] ; ID != ID ; ID = ID -> ID ) { 
ID * ID = ( ID * ) ID ; 
ID * ID = ( ID * ) ID ; 
switch ( ID -> ID ) { 
case ID : ID << STRING << 
ID [ ID -> ID -> ID ] << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
ID [ ID -> ID -> ID ] << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
ID [ ID -> ID -> ID ] << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING ; 
break ; 
case ID : ID << STRING << 
ID [ ID -> ID ] << 
STRING << 
( ID -> ID - ID ) << 
STRING << 
( ID -> ID - ID ) << 
STRING << 
( int ) ( ID -> ID ) << 
STRING ; 
break ; 
} 
} 
} 
ID << STRING ; 
ID . ID ( ) ; 
} 
if ( ! ID ) { 
for ( int ID = INTEGER ; ID < ( ID - ID ) ; ID ++ ) 
ID << ID << STRING << ID [ ID ] << STRING << ID [ ID [ ID ] ] << STRING ; 
ID << STRING << ID << STRING << ( ID == INTEGER ? STRING : STRING ) ; 
} 
double ID = ID > REAL ? ( ( double ) ( ID - ID ) ) / ID : INTEGER ; 
ID << ( ID ? STRING : STRING ) << STRING << ID << STRING << ID << STRING << 
ID << STRING << ID << STRING << ( ID - ID ) << STRING << 
ID 
<< STRING << ID << 
STRING << ID << 
STRING << ID << STRING << ID << STRING << ID << STRING << ID << 
STRING << ID << STRING << ID << STRING << ID << 
STRING << ID << 
STRING << ID 
; 
return ID ; 
} 
bool ID :: ID ( ) { 
return ID == ID ; 
} 
void ID :: ID ( struct ID * ID ) { 
ID * ID = new ID ; 
ID -> ID = ( ID * ) ID ; 
ID -> ID = ID ; 
ID = ID ; 
} 
void ID :: ID ( struct ID * ID ) { 
ID * ID = new ID ; 
ID -> ID = ( ID * ) ID ; 
ID -> ID = ID ; 
ID = ID ; 
} 
ID * ID :: ID ( ) { 
ID * ID = ID ; 
ID = ID -> ID ; 
return ( ID * ) ID -> ID ; 
} 
ID * ID :: ID ( ID ID , ID * ID , ID * ID , ID * ID ) { 
int ID = ID ( ID , ID , ID -> ID , ID -> ID , ID -> ID , ID , ID -> ID , ID -> ID ) ; 
for ( ID * ID = ( ID * ) ID :: ID [ ID ] ; 
ID != ID ; 
ID = ( ID * ) ID -> ID ) 
if ( ID -> ID == ID && ID -> ID == ID && ID -> ID == ID && ID -> ID == ID && ID -> ID == ID ) 
return ID ; 
return ID ; 
} 
ID * ID :: ID ( ID ID , ID * ID , ID * ID , ID * ID ) { 
int ID = ID ( ID , ID , ID -> ID , ID -> ID , ID -> ID , ID , ID -> ID , ID -> ID ) ; 
ID * ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = ID :: ID [ ID ] ; 
ID :: ID [ ID ] = ( ID * ) ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
return ID ; 
} 
ID * ID :: ID ( ID ID , ID * ID , ID * ID , ID * ID ) { 
int ID = ID ( ID , ID , ID -> ID , ID -> ID , ID -> ID , ID , ID -> ID , ID -> ID ) ; 
for ( ID * ID = ( ID * ) ID :: ID [ ID ] ; 
ID != ID ; 
ID = ( ID * ) ID -> ID ) 
if ( ID -> ID == ID && ID -> ID == ID && ID -> ID == ID && ID -> ID == ID && ID -> ID == ID ) 
return ID ; 
return ID ; 
} 
ID * ID :: ID ( ID ID , ID * ID , ID * ID , ID * ID ) { 
int ID = ID ( ID , ID , ID -> ID , ID -> ID , ID -> ID , ID , ID -> ID , ID -> ID ) ; 
ID * ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = ID :: ID [ ID ] ; 
ID :: ID [ ID ] = ( ID * ) ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
return ID ; 
} 
ID * ID :: ID ( ID * ID , ID * ID ) { 
int ID = ID ( ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID ) ; 
for ( ID * ID = ( ID * ) ID :: ID [ ID ] ; 
ID != ID ; 
ID = ( ID * ) ID -> ID ) 
if ( ID -> ID == ID && 
ID -> ID -> ID == ID -> ID && ID -> ID -> ID == ID -> ID && 
ID -> ID -> ID == ID -> ID && ID -> ID -> ID == ID -> ID && ID -> ID -> ID == ID -> ID ) 
return ID ; 
return ID ; 
} 
void ID :: ID ( ID * ID , ID * ID ) { 
int ID = ID ( ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID ) ; 
ID * ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = ID :: ID [ ID ] ; 
ID :: ID [ ID ] = ( ID * ) ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID * ID = new ID ; 
ID -> ID = ( ID * ) ID ; 
ID -> ID = ID ; 
ID = ID ; 
} 
ID * ID :: ID ( ID ID , ID * ID ) { 
int ID = ID ( ID , ID , ID ) ; 
for ( ID * ID = ( ID * ) ID :: ID [ ID ] ; 
ID != ID ; 
ID = ( ID * ) ID -> ID ) 
if ( ID -> ID == ID && ID -> ID == ID && ID -> ID == ID ) 
return ID ; 
return ID ; 
} 
ID * ID :: ID ( ID ID , ID * ID ) { 
int ID = ID ( ID , ID , ID ) ; 
ID * ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = ID :: ID [ ID ] ; 
ID :: ID [ ID ] = ( ID * ) ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
return ID ; 
} 
ID * ID :: ID ( ID ID , ID * ID , ID * ID ) { 
int ID = ID ( ID , ID , ID , ID ) ; 
for ( ID * ID = ( ID * ) ID :: ID [ ID ] ; 
ID != ID ; 
ID = ( ID * ) ID -> ID ) 
if ( ID -> ID == ID && ID -> ID == ID && ID -> ID == ID && ID -> ID == ID ) { 
return ID ; 
} 
return ID ; 
} 
ID * ID :: ID ( ID ID , ID * ID , ID * ID ) { 
int ID = ID ( ID , ID , ID , ID ) ; 
ID * ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = ID :: ID [ ID ] ; 
ID :: ID [ ID ] = ( ID * ) ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
return ID ; 
} 
ID * ID :: ID ( ID * ID , ID ID , ID * ID ) { 
int ID = ID ( ID , ID -> ID , ID , ID -> ID , ID -> ID , ID ) ; 
for ( ID * ID = ( ID * ) ID :: ID [ ID ] ; 
ID != ID ; 
ID = ( ID * ) ID -> ID ) 
if ( ID -> ID == ID && ID -> ID == ID && ID -> ID == ID && ID -> ID == ID ) 
return ID ; 
return ID ; 
} 
ID * ID :: ID ( ID * ID , ID ID , ID * ID ) { 
int ID = ID ( ID , ID -> ID , ID , ID -> ID , ID -> ID , ID ) ; 
ID * ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = ID :: ID [ ID ] ; 
ID :: ID [ ID ] = ( ID * ) ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID . ID ( ID ) ; 
return ID ; 
} 
ID * ID :: ID ( ID * ID , ID * ID , ID * ID ) { 
int ID = ID ( ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID ) ; 
for ( ID * ID = ( ID * ) ID :: ID [ ID ] ; 
ID != ID ; 
ID = ( ID * ) ID -> ID ) 
if ( ID -> ID == ID && ID -> ID == ID && ID -> ID == ID && ID -> ID == ID ) 
return ID ; 
return ID ; 
} 
ID * ID :: ID ( ID * ID , ID * ID , ID * ID ) { 
int ID = ID ( ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID ) ; 
ID * ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = ID :: ID [ ID ] ; 
ID :: ID [ ID ] = ( ID * ) ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID * ID = new ID ; 
ID -> ID = ( ID * ) ID ; 
ID -> ID = ID ; 
ID = ID ; 
return ID ; 
} 
ID * ID :: ID ( ) { 
ID = ID ; 
return ID == ID ? ID : ( ID * ) ID -> ID ; 
} 
ID * ID :: ID ( ) { 
if ( ID != ID ) 
ID = ID -> ID ; 
return ID == ID ? ID : ( ID * ) ID -> ID ; 
} 
ID * ID :: ID ( ) { 
ID = ID ; 
return ID == ID ? ID : ( ID * ) ID -> ID ; 
} 
ID * ID :: ID ( ) { 
if ( ID != ID ) 
ID = ID -> ID ; 
return ID == ID ? ID : ( ID * ) ID -> ID ; 
} 
ID * ID :: ID ( ) { 
ID = ID ; 
return ID == ID ? ID : ( ID * ) ID -> ID ; 
} 
ID * ID :: ID ( ) { 
if ( ID != ID ) 
ID = ID -> ID ; 
return ID == ID ? ID : ( ID * ) ID -> ID ; 
} 
ID ID :: ID ; 
int ID :: ID ; 
void ID ( ID * ID , const char * ID ) { 
if ( ID == ID ) 
* ID << STRING ; 
else 
while ( * ID != INTEGER ) { 
if ( * ID == STRING ) 
* ID << STRING ; 
* ID << * ID ++ ; 
} 
} 
void ID :: ID ( int ID , const char * * ID ) { 
int ID = ID ; 
if ( ID != INTEGER ) 
ID << 
STRING << ID << STRING << ID << STRING ; 
ID << STRING << ID << STRING ; 
ID ( & ID , ID [ ID ] ) ; 
ID << ( this -> ID == ID ? STRING : this -> ID == ID ? STRING : this -> ID == ID ? STRING : STRING ) << 
STRING << ID << STRING ; 
if ( ID != ID ) { 
ID ++ ; 
ID -> ID ( ID , ID ) ; 
} 
if ( ID != ID ) { 
ID ++ ; 
ID -> ID ( ID , ID ) ; 
} 
} 
void ID :: ID ( ) { 
for ( int ID = INTEGER ; ID < ID :: ID ; ID ++ ) { 
for ( ID * ID = ID :: ID [ ID ] ; ID != ID ; ID = ID -> ID ) 
switch ( ID -> ID ) { 
case ID : ( ( ID * ) ID ) -> ID = false ; break ; 
case ID : ( ( ID * ) ID ) -> ID = false ; break ; 
case ID : break ; 
case ID : break ; 
case ID : break ; 
case ID : break ; 
case ID : break ; 
default : ID << STRING << ID -> ID << STRING ; 
} 
} 
} 
void ID :: ID ( ) { 
for ( int ID = INTEGER ; ID < ID :: ID ; ID ++ ) { 
for ( ID * ID = ID :: ID [ ID ] ; ID != ID ; ID = ID -> ID ) 
if ( ID -> ID == ID ) { 
ID * ID = ( ID * ) ID ; 
if ( ! ID -> ID ) { 
} 
} 
} 
} 
enum ID { ID , ID , ID , ID , ID , ID } ; 
void ID ( struct ID * * ID , int ID , const char * * ID , enum ID * ID ) ; 
enum ID { ID , ID , ID , ID , ID , ID , ID } ; 
struct ID { ID ID ; struct ID * ID ; } ; 
struct ID { ID * ID ; ID * ID ; } ; 
class ID { 
public : 
ID ( ) { ID = ID = ID ; } ; 
static ID * ID ; 
static unsigned ID ; 
static unsigned ID ; 
static unsigned ID ; 
static struct ID * * ID ; 
struct ID * ID ; 
struct ID * ID ; 
ID ( unsigned ID , ID * ID , int ID ) { 
ID = ID ; 
ID = ID ; 
ID = INTEGER ; 
for ( int ID = INTEGER ; ID < ID ; ID ++ ) 
ID *= INTEGER ; 
ID = new ID * [ ID ] ; 
ID = ID - INTEGER ; 
ID ( ID , INTEGER , ID * sizeof ( ID * ) ) ; 
ID = ID = ID ; 
} 
unsigned ID ( ID ID , ID ID , ID ID , ID ID , ID * ID , ID * ID , ID * ID , ID * ID ) { 
return ( ID * ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID + 
( ID - ID ) * ID * ID * ID + 
( ID - ID ) * ID * ID + 
( ID - ID ) * ID + 
( ID - ID ) ) & ID ; 
} 
unsigned ID ( ID ID , ID ID , ID ID , ID * ID , ID * ID , ID * ID ) { 
return ( ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID + 
ID * ID * ID * ID + 
( ID - ID ) * ID * ID + 
( ID - ID ) * ID + 
( ID - ID ) ) & ID ; 
} 
unsigned ID ( ID ID , ID ID , ID * ID , ID * ID ) { 
return ( ID * ID * ID * ID + 
ID * ID * ID + 
( ID - ID ) * ID + 
( ID - ID ) ) & ID ; 
} 
unsigned ID ( ID ID , ID ID , ID * ID ) { 
return ( ID * ID * ID + 
ID * ID + 
( ID - ID ) ) & ID ; 
} 
bool ID ( ) ; 
void ID ( struct ID * ID ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ID ID , struct ID * ID , ID * ID , struct ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID ID , struct ID * ID , ID * ID , struct ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID * ID ) ; 
void ID ( ID * ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID ID , ID * ID ) ; 
void ID ( struct ID * ID ) ; 
struct ID * ID ( ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
void ID ( ) ; 
void ID ( ) ; 
int ID ( const char * ID , const char * ID , const char * ID , const char * ID , ID * ID , int ID , ID * ID , bool ID , double ID , const char * * ID , enum ID * ID ) ; 
void ID ( ) ; 
} ; 
enum ID { ID , ID , ID , ID , ID , ID } ; 
void ID ( struct ID * * ID , int ID , const char * * ID , enum ID * ID ) ; 
enum ID { ID , ID , ID , ID , ID , ID , ID } ; 
struct ID { ID ID ; struct ID * ID ; } ; 
struct ID { ID * ID ; ID * ID ; } ; 
class ID { 
public : 
ID ( ) { ID = ID = ID ; } ; 
static ID * ID ; 
static unsigned ID ; 
static unsigned ID ; 
static unsigned ID ; 
static struct ID * * ID ; 
struct ID * ID ; 
struct ID * ID ; 
ID ( unsigned ID , ID * ID , int ID ) { 
ID = ID ; 
ID = ID ; 
ID = INTEGER ; 
for ( int ID = INTEGER ; ID < ID ; ID ++ ) 
ID *= INTEGER ; 
ID = new ID * [ ID ] ; 
ID = ID - INTEGER ; 
ID ( ID , INTEGER , ID * sizeof ( ID * ) ) ; 
ID = ID = ID ; 
} 
unsigned ID ( ID ID , ID ID , ID ID , ID ID , ID * ID , ID * ID , ID * ID , ID * ID ) { 
return ( ID * ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID + 
( ID - ID ) * ID * ID * ID + 
( ID - ID ) * ID * ID + 
( ID - ID ) * ID + 
( ID - ID ) ) & ID ; 
} 
unsigned ID ( ID ID , ID ID , ID ID , ID * ID , ID * ID , ID * ID ) { 
return ( ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID + 
ID * ID * ID * ID + 
( ID - ID ) * ID * ID + 
( ID - ID ) * ID + 
( ID - ID ) ) & ID ; 
} 
unsigned ID ( ID ID , ID ID , ID * ID , ID * ID ) { 
return ( ID * ID * ID * ID + 
ID * ID * ID + 
( ID - ID ) * ID + 
( ID - ID ) ) & ID ; 
} 
unsigned ID ( ID ID , ID ID , ID * ID ) { 
return ( ID * ID * ID + 
ID * ID + 
( ID - ID ) ) & ID ; 
} 
bool ID ( ) ; 
void ID ( struct ID * ID ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ID ID , struct ID * ID , ID * ID , struct ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID ID , struct ID * ID , ID * ID , struct ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID * ID ) ; 
void ID ( ID * ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID ID , ID * ID ) ; 
void ID ( struct ID * ID ) ; 
struct ID * ID ( ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
void ID ( ) ; 
void ID ( ) ; 
int ID ( const char * ID , const char * ID , const char * ID , const char * ID , ID * ID , int ID , ID * ID , bool ID , double ID , const char * * ID , enum ID * ID ) ; 
void ID ( ) ; 
} ; 
class ID { 
public : 
static ID ID ; 
static int ID ; 
ID ID ; 
enum ID ID ; 
ID * ID ; 
ID * ID ; 
ID ( ID ID ) { 
this -> ID = ID ; ID = ID = ID ; 
} ; 
ID ( ID ID , ID * ID ) { 
this -> ID = ID ; ID = ID ; 
ID * ID = ID -> ID ; 
if ( ID == ID ) 
ID -> ID = this ; 
else { 
while ( ID -> ID != ID ) 
ID = ID -> ID ; 
ID -> ID = this ; 
} 
ID = ID ; 
} ; 
void ID ( ) { 
ID << ID << STRING ; 
if ( ID != ID ) 
ID -> ID ( ) ; 
ID << STRING ; 
if ( ID != ID ) 
ID -> ID ( ) ; 
} ; 
void ID ( int ID , const char * * ID ) ; 
void ID ( const char * ID , const char * * ID ) { 
ID . ID ( ID ) ; 
ID << 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING ; 
ID = INTEGER ; 
this -> ID ( INTEGER , ID ) ; 
ID << STRING ; 
ID . ID ( ) ; 
} ; 
void ID ( ID * ID , const char * * ID ) { 
if ( ID == ID ) 
return ; 
if ( ID -> ID == ID ) 
ID << ID [ ID -> ID ] << STRING ; 
else { 
ID << STRING ; 
ID ( ID -> ID , ID ) ; 
ID << STRING ; 
} 
if ( ID -> ID != ID ) 
ID ( ID -> ID , ID ) ; 
} 
void ID ( const char * ID , ID * ID , const char * * ID ) { 
ID . ID ( ID ) ; 
ID ( ID , ID ) ; 
ID . ID ( ) ; 
} 
} ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID * ID ; int ID : INTEGER ; int ID : INTEGER ; ID ID ; ID ( ) { ID . ID = ID . ID = ID ; } ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID * ID ; ID ID ; ID * ID ; ID ID ; ID ID ; int ID : INTEGER ; } ; 
class ID { public : ID ID ; struct ID * ID ; struct ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID ID ; ID ID ; ID ( ) { ID . ID = ID . ID = ID . ID = ID . ID = ID ; } ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { 
public : 
ID ID ; 
bool ID ; 
ID ID ; 
ID ID ; 
const char * ID ; 
const char * ID ; 
const char * ID ; 
const char * ID ; 
ID * ID ; 
int ID ; 
const char * * ID ; 
const char * * ID ; 
ID * ID ; 
ID * ID ; 
ID ID ; 
const char * * ID ; 
const char * * ID ; 
bool * ID ; 
bool * ID ; 
int ID ; 
enum ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
bool * ID ; 
bool * ID ; 
bool * ID ; 
bool * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
ID * ID ( ID * ID ) ; 
ID * ID ( ID ID , ID * ID ) ; 
ID * ID ( ID ID , ID * ID , ID * ID ) ; 
ID * ID ( ID ID , ID ID , ID * ID ) ; 
ID * ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
void ID ( ID * ID , ID * ID , ID * ID ) ; 
void ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
bool ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
ID * ID ( ID * ID , ID * ID , bool ID ) ; 
void ID ( ID * ID , int ID ) ; 
void ID ( ID * ID , ID * ID ) ; 
void ID ( ) ; 
void ID ( ID * ID ) ; 
void ID ( const char * ID , ID * ID , int * ID ) ; 
const char * ID ( const char * ID ) ; 
const char * ID ( const char * ID , const char * ID ) { 
const char * ID = ID ; 
while ( * ID != INTEGER && * ID == * ID ) { 
ID ++ ; 
ID ++ ; 
} 
if ( * ID == INTEGER ) 
return ID ; 
else 
return ID ; 
} 
const char ID ( const char ID ) { return ( ID >= ( const char ) STRING && ID <= ( const char ) STRING ) ? ( const char ) ( ID + INTEGER ) : ID ; } 
const char * ID ( const char * ID , const char * ID ) { 
const char * ID = ID ; 
while ( * ID != INTEGER && ID ( * ID ) == ID ( * ID ) ) { 
ID ++ ; 
ID ++ ; 
} 
if ( * ID == INTEGER ) 
return ID ; 
else 
return ID ; 
} 
bool ID ( const char * ID ) { 
ID = new ID [ ID ( ID ) + INTEGER ] ; 
ID = new const char * [ ID ( ID ) + INTEGER ] ; 
ID = new const char * [ ID ( ID ) + INTEGER ] ; 
const char * ID = ID ; 
ID = ID ; 
ID ID ; 
ID = ID ( ID ) ; 
while ( INTEGER ) { 
if ( * ID == INTEGER ) { 
* ID = ID ; 
ID = ID ; 
ID = ID - ID ; 
return true ; 
} 
int ID = INTEGER ; 
const char * ID ; 
for ( ID ID = ( ID ) INTEGER ; ID != ID ; ID = ( ID ) ( ( int ) ID + INTEGER ) ) { 
if ( ID [ ID ] ) 
ID = ID ( ID [ ID ] , ID ) ; 
else 
ID = ID ( ID [ ID ] , ID ) ; 
int ID = ID - ID ; 
if ( ID > ID ) { 
ID = ID ; 
ID = ID ; 
} 
} 
ID ( ID , & ID , & ID ) ; 
if ( ID == INTEGER ) { 
ID << STRING << ( ID - ID ) << STRING << ( int ) * ID << STRING << * ID << STRING ; 
* ID = ID ; 
ID = ID ; 
return false ; 
} 
ID [ ID - ID ] = ID ; 
ID += ID ; 
ID [ ID - ID ] = ID ; 
* ID ++ = ID ; 
if ( ID [ ID ] ) { 
ID = ID ( ID ) ; 
} 
} 
} 
const char * ID ( const char * ID ) { 
if ( ID ( * ID ) || * ID == STRING ) 
while ( ID ( * ID ) || * ID == STRING || * ID == STRING || * ID == STRING ) 
ID ++ ; 
return ID ; 
} 
bool ID ( const char * ID ) { 
return 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING ; 
} 
bool ID ( const char * ID ) { 
return 
* ID == STRING || * ID == STRING || * ID == STRING ; 
} 
bool ID ( const char * ID ) { 
return 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ID ( ID ) ) 
return ID ; 
ID ++ ; 
while ( ID ( ID ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ID ( ID ) ) 
return ID ; 
ID ++ ; 
while ( ID ( ID ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ID ( * ID ) || * ID == STRING ) 
while ( ID ( * ID ) || * ID == STRING ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
bool ID = ( * ID == STRING && ( * ( ID + INTEGER ) == STRING || * ( ID + INTEGER ) == STRING ) ) ; 
if ( ID ) ID += INTEGER ; 
while ( ( ID ? ID ( * ID ) : ID ( * ID ) ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ID ( * ID ) ) 
return ID ; 
while ( ID ( * ID ) ) 
ID ++ ; 
if ( * ID != STRING ) 
return ID ; 
ID ++ ; 
while ( ID ( * ID ) ) 
ID ++ ; 
if ( * ID == STRING || * ID == STRING ) { 
ID ++ ; 
while ( ID ( * ID ) ) 
ID ++ ; 
} 
return ID ; 
} 
const char * ID ( const char * ID ) { 
const char * ID = ID ; 
if ( * ID != STRING ) 
return ID ; 
ID ++ ; 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
if ( * ID != STRING ) 
return ID ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( * ID != STRING ) ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( * ID != STRING ) ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( * ID != STRING ) ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ( ( * ID == STRING ) && ( * ( ID + INTEGER ) == STRING ) ) ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( ! ( ( * ID == STRING ) && ( * ( ID + INTEGER ) == STRING ) ) ) ; 
ID ++ ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
if ( * ID != STRING ) { 
if ( * ( ID + INTEGER ) == STRING && ( * ( ID + INTEGER ) == STRING || * ( ID + INTEGER ) == STRING ) ) 
ID += INTEGER ; 
} 
else 
ID += INTEGER ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
while ( * ID != INTEGER && ( ID ( * ID ) ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
int ID = INTEGER ; 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
while ( ID > INTEGER ) { 
if ( * ID == INTEGER ) 
break ; 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
ID ++ ; 
} 
else if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
ID -- ; 
} 
else 
ID ++ ; 
} 
} 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
while ( INTEGER ) { 
if ( * ID == INTEGER ) 
break ; 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
break ; 
} 
ID ++ ; 
} 
} 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) 
while ( * ID != INTEGER && * ID != STRING ) 
ID ++ ; 
if ( * ID == STRING ) 
ID ++ ; 
return ID ; 
} 
void ID ( const char * const ID ) ; 
void ID ( ID ID ) ; 
void ID ( ) { 
ID = new ID ( INTEGER , ID , ID - ID ) ; 
ID = new ID ; 
ID = new ID ; 
ID = new ID ; 
ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID -> ID = ID ; 
} 
void ID ( ) { 
ID = ID -> ID ( ) ; 
ID = ID -> ID ; 
ID = ID -> ID ; 
ID = ID -> ID ; 
ID = ID -> ID ; 
} 
void ID ( ) { 
ID = ID ( ) ; 
} 
void ID ( ) { 
ID = ID ( ) ; 
} 
void ID ( ) { 
if ( ID -> ID ( ID , ID , ID , ID , ID , ID , ID , ID , INTEGER , ID , ID ) < INTEGER ) 
ID ( ID , ID ) ; 
ID << STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID ; 
ID << STRING ; 
} 
void ID ( const char * ID ) { ID = ID ( ID ) ; } 
ID ( ) ; 
} ; 
class ID { 
class ID { 
public : 
unsigned long ID ; 
unsigned long ID ; 
ID * ID ; 
} ; 
ID * ID ; 
public : 
ID ( ) 
{ 
ID = new ID ; 
ID -> ID = ID -> ID = INTEGER ; 
ID -> ID = new ID ; 
ID -> ID -> ID = ID ; 
ID -> ID -> ID = INTEGER ; 
ID -> ID -> ID = ID ; 
} 
void ID ( unsigned long ID ) 
{ 
ID * ID = ID ; 
ID * ID ; 
ID * ID ; 
do 
{ 
if ( ID -> ID == ID ) 
{ 
ID -> ID ++ ; 
return ; 
} 
ID = ID ; 
ID = ID -> ID ; 
} 
while ( ID -> ID <= ID ) ; 
ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = INTEGER ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
} 
void ID ( ) 
{ 
unsigned long ID = ID ( ) ; 
ID * ID = ID ; 
while ( ID -> ID != ID ) 
{ 
if ( ID -> ID != INTEGER ) 
ID << ID -> ID << STRING << ID -> ID << STRING << ( INTEGER * ID -> ID ) / ID << STRING ; 
ID = ID -> ID ; 
} 
} 
unsigned long ID ( unsigned long ID ) 
{ 
ID * ID = ID ; 
while ( ID -> ID != ID && ID -> ID != ID ) 
ID = ID -> ID ; 
return ID -> ID == ID ? ID -> ID : INTEGER ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
if ( ID -> ID != INTEGER ) 
ID ++ ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
ID ++ ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
ID += ID -> ID ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
ID += ID -> ID * ID -> ID ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
} ; 
void ID :: ID ( ID ID ) { 
this -> ID = ID ; 
ID = ID -> ID ( ID , ID , ID ) ; 
ID = ID != ID ; 
} 
bool ID :: ID ( ID ID , ID * ID , ID * ID , ID * ID ) { 
ID ++ ; 
if ( ID -> ID ( ID , ID , ID , ID ) == ID ) { 
ID -> ID ( ID , ID , ID , ID ) ; 
return false ; 
} 
return true ; 
} 
void ID :: ID ( ID ID , ID * ID , ID * ID , ID * ID ) { 
ID ++ ; 
if ( ID -> ID ( ID , ID , ID , ID ) == ID ) { 
ID * ID = ID -> ID ( ID , ID , ID , ID ) ; 
ID -> ID ( ID ) ; 
} 
} 
void ID :: ID ( ID * ID , ID * ID , ID * ID ) { 
ID ++ ; 
if ( ID == ID ) { 
return ; 
} 
if ( ID -> ID . ID ( ID , ID ) == ID ) { 
ID -> ID . ID ( ID , ID ) ; 
} 
for ( ID * ID = ID -> ID . ID ( ) ; ID != ID ; ID = ID -> ID . ID ( ) ) { 
ID * ID = ID :: ID ( ID -> ID , ID -> ID , ID ) ; 
ID :: ID ( ID -> ID , ID -> ID , ID , ID ) ; 
} 
} 
ID * ID :: ID ( ID ID , ID * ID , ID * ID , ID * ID ) { 
ID ++ ; 
ID * ID ; 
if ( ( ID = ID -> ID ( ID , ID ) ) == ID ) { 
ID = ID -> ID ( ID , ID ) ; 
} 
if ( ID != ID && ID -> ID . ID ( ID , ID , ID ) == ID ) { 
ID -> ID . ID ( ID , ID , ID ) ; 
for ( ID * ID = ID -> ID . ID ( ) ; ID != ID ; ID = ID -> ID . ID ( ) ) { 
ID * ID = ID :: ID ( ID , ID , ID -> ID ) ; 
ID :: ID ( ID , ID , ID -> ID -> ID , ID ) ; 
} 
} 
return ID ; 
} 
ID * ID :: ID ( ID * ID ) { 
ID ++ ; 
ID * ID ; 
if ( ( ID = ID -> ID ( ID , ID , ID ) ) == ID ) { 
ID = ID -> ID ( ID , ID , ID ) ; 
} 
return ID ; 
} 
ID * ID :: ID ( ID ID , ID * ID ) { 
ID ++ ; 
ID * ID ; 
if ( ( ID = ID -> ID ( ID , ID , ID + INTEGER ) ) == ID ) { 
ID = ID -> ID ( ID , ID , ID + INTEGER ) ; 
} 
return ID ; 
} 
ID * ID :: ID ( ID ID , ID * ID , ID * ID ) { 
ID ++ ; 
if ( ID [ ID ] ) { 
return ID ; 
} 
ID * ID ; 
ID * ID = ( ID == ID ? ID -> ID : ID -> ID ) ; 
ID ID ; 
if ( ID [ ID ] ) 
ID = ID [ ID ] ? ID [ ID ] : ID [ ID ] ; 
else { 
ID = ID [ ID ] ? ID [ ID ] : ID [ ID ] ; 
} 
if ( ( ID = ID -> ID ( ID , ID , ID -> ID ) ) == ID ) { 
ID = ID -> ID ( ID , ID , ID -> ID ) ; 
} 
if ( ID -> ID . ID ( ID , ID , ID -> ID ) == ID ) { 
ID * ID = ID -> ID . ID ( ID , ID , ID -> ID ) ; 
ID -> ID = ID -> ID ; 
ID -> ID = ID -> ID ; 
} 
return ID ; 
} 
ID * ID :: ID ( ID ID , ID ID , ID * ID ) { 
ID ++ ; 
ID * ID ; 
if ( ( ID = ID -> ID ( ID , ID , ID ) ) == ID ) { 
ID = ID -> ID ( ID , ID , ID ) ; 
} 
if ( ID -> ID . ID ( ID , ID , ID ) == ID ) { 
ID * ID = ID -> ID . ID ( ID , ID , ID ) ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID ( ID ) ; 
} 
return ID ; 
} 
void ID :: ID ( ID * ID ) { 
int ID = INTEGER ; 
if ( ID == ID ) 
return ; 
if ( ID -> ID ) 
return ; 
ID -> ID = true ; 
for ( ID * ID = ID -> ID . ID ( ) ; ID != ID ; ID = ID -> ID . ID ( ) ) { 
ID -> ID = true ; 
ID ++ ; 
if ( ID -> ID != ID ) 
ID ( ID -> ID ( ID -> ID , ID -> ID , ID -> ID ) ) ; 
if ( ID -> ID != ID ) 
ID ( ID -> ID ( ID -> ID , ID -> ID , ID -> ID ) ) ; 
} 
if ( ID > INTEGER ) { 
ID -> ID = true ; 
ID ++ ; 
} 
} 
void ID :: ID ( ) { 
ID = INTEGER ; 
ID ( ID ) ; 
} 
ID ID ; 
int ID ; 
void ID :: ID ( ID * ID , int ID ) { 
if ( ID == ID ) 
return ; 
if ( ID -> ID ) 
return ; 
ID -> ID = true ; 
int ID = INTEGER ; 
for ( ID * ID = ID -> ID . ID ( ) ; ID != ID ; ID = ID -> ID . ID ( ) ) 
ID ++ ; 
ID << STRING << 
ID [ ID -> ID ] << STRING << 
ID [ ID -> ID ] << 
STRING << 
( ID -> ID - ID ) << 
STRING << 
( ID -> ID - ID ) << STRING << 
( ID [ ID -> ID ] == ID ? STRING : STRING ) << 
STRING << ID << STRING << ++ ID << ( ID > INTEGER ? STRING : STRING ) << STRING ; 
for ( ID * ID = ID -> ID . ID ( ) ; ID != ID ; ID = ID -> ID . ID ( ) ) { 
ID << STRING << 
ID [ ID -> ID -> ID ] << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
ID [ ID -> ID ] << 
STRING << 
( ID -> ID - ID ) << 
STRING << 
ID [ ID -> ID ] << 
( ID [ ID -> ID ] == ID ? STRING : ID [ ID -> ID ] == ID ? STRING : ID [ ID -> ID ] == ID ? STRING : STRING ) << 
STRING << 
( ID -> ID - ID ) << 
STRING << ( ID + INTEGER ) << STRING << ++ ID << ( ID > INTEGER ? STRING : STRING ) 
<< ( ID [ ID -> ID -> ID ] == ID ? STRING : STRING ) 
<< STRING << 
STRING << 
ID [ ID -> ID ] << STRING << 
ID [ ID -> ID -> ID ] << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
ID [ ID -> ID -> ID ] << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
ID [ ID -> ID ] << 
STRING << 
( ID -> ID - ID ) << 
STRING ; 
ID -> ID = true ; 
if ( ID -> ID != ID ) { 
ID << 
STRING << 
ID [ ID -> ID -> ID ] << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
ID [ ID -> ID ] << 
STRING << 
( ID -> ID - ID ) << 
STRING << 
ID [ ID -> ID ] << STRING << 
ID [ ID -> ID ] << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
( ID -> ID - ID ) << 
STRING ; 
ID ( ID -> ID ( ID -> ID , ID -> ID , ID -> ID ) , ID + INTEGER ) ; 
} 
if ( ID -> ID != ID ) { 
ID << 
STRING << 
ID [ ID -> ID -> ID ] << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
ID [ ID -> ID ] << 
STRING << 
( ID -> ID - ID ) << 
STRING << 
ID [ ID -> ID ] << STRING << 
ID [ ID -> ID ] << 
STRING << 
( ID -> ID - ID ) << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING ; 
ID ( ID -> ID ( ID -> ID , ID -> ID , ID -> ID ) , ID + INTEGER ) ; 
} 
} 
} 
void ID :: ID ( ID * ID , ID * ID ) { 
ID -> ID ( ) ; 
ID . ID ( STRING ) ; 
ID << 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING ; 
ID = INTEGER ; 
ID ( ID , INTEGER ) ; 
ID -> ID ( ) ; 
ID << STRING ; 
ID . ID ( ) ; 
} 
ID * ID :: ID ( ID * ID , ID * ID , bool ID ) { 
ID * ID ; 
ID * ID = ID ; 
ID * ID = ID ; 
if ( ID == ID ) 
return ID ; 
if ( ID -> ID ) 
return ID ; 
if ( ID == ID ) 
ID = new ID ( ID -> ID ) ; 
else 
ID = new ID ( ID -> ID , ID ) ; 
int ID = INTEGER ; 
ID -> ID = true ; 
for ( ID * ID = ID -> ID . ID ( ) ; ID != ID ; ID = ID -> ID . ID ( ) ) { 
ID ++ ; 
ID -> ID = ID > INTEGER ; 
if ( ( ID -> ID != ID && ID -> ID ( ID -> ID , ID -> ID , ID -> ID ) -> ID ) || 
( ID -> ID != ID && ID -> ID ( ID -> ID , ID -> ID , ID -> ID ) -> ID ) ) 
continue ; 
if ( ID -> ID >= ID ) { 
ID = ID ; 
ID = ID -> ID ; 
} 
} 
if ( ID != ID ) { 
ID -> ID = true ; 
if ( ID -> ID != ID ) 
ID ( ID -> ID ( ID -> ID , ID -> ID , ID -> ID ) , ID , ID ) ; 
if ( ID -> ID != ID ) 
ID ( ID -> ID ( ID -> ID , ID -> ID , ID -> ID ) , ID , ID ) ; 
} 
return ID ; 
}  
class ID { 
public : 
static ID ID ; 
static int ID ; 
ID ID ; 
enum ID ID ; 
ID * ID ; 
ID * ID ; 
ID ( ID ID ) { 
this -> ID = ID ; ID = ID = ID ; 
} ; 
ID ( ID ID , ID * ID ) { 
this -> ID = ID ; ID = ID ; 
ID * ID = ID -> ID ; 
if ( ID == ID ) 
ID -> ID = this ; 
else { 
while ( ID -> ID != ID ) 
ID = ID -> ID ; 
ID -> ID = this ; 
} 
ID = ID ; 
} ; 
void ID ( ) { 
ID << ID << STRING ; 
if ( ID != ID ) 
ID -> ID ( ) ; 
ID << STRING ; 
if ( ID != ID ) 
ID -> ID ( ) ; 
} ; 
void ID ( int ID , const char * * ID ) ; 
void ID ( const char * ID , const char * * ID ) { 
ID . ID ( ID ) ; 
ID << 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING ; 
ID = INTEGER ; 
this -> ID ( INTEGER , ID ) ; 
ID << STRING ; 
ID . ID ( ) ; 
} ; 
void ID ( ID * ID , const char * * ID ) { 
if ( ID == ID ) 
return ; 
if ( ID -> ID == ID ) 
ID << ID [ ID -> ID ] << STRING ; 
else { 
ID << STRING ; 
ID ( ID -> ID , ID ) ; 
ID << STRING ; 
} 
if ( ID -> ID != ID ) 
ID ( ID -> ID , ID ) ; 
} 
void ID ( const char * ID , ID * ID , const char * * ID ) { 
ID . ID ( ID ) ; 
ID ( ID , ID ) ; 
ID . ID ( ) ; 
} 
} ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID * ID ; int ID : INTEGER ; int ID : INTEGER ; ID ID ; ID ( ) { ID . ID = ID . ID = ID ; } ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID * ID ; ID ID ; ID * ID ; ID ID ; ID ID ; int ID : INTEGER ; } ; 
class ID { public : ID ID ; struct ID * ID ; struct ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID ID ; ID ID ; ID ( ) { ID . ID = ID . ID = ID . ID = ID . ID = ID ; } ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { 
public : 
ID ID ; 
bool ID ; 
ID ID ; 
ID ID ; 
const char * ID ; 
const char * ID ; 
const char * ID ; 
const char * ID ; 
ID * ID ; 
int ID ; 
const char * * ID ; 
const char * * ID ; 
ID * ID ; 
ID * ID ; 
ID ID ; 
const char * * ID ; 
const char * * ID ; 
bool * ID ; 
bool * ID ; 
int ID ; 
enum ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
bool * ID ; 
bool * ID ; 
bool * ID ; 
bool * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
ID * ID ( ID * ID ) ; 
ID * ID ( ID ID , ID * ID ) ; 
ID * ID ( ID ID , ID * ID , ID * ID ) ; 
ID * ID ( ID ID , ID ID , ID * ID ) ; 
ID * ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
void ID ( ID * ID , ID * ID , ID * ID ) ; 
void ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
bool ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
ID * ID ( ID * ID , ID * ID , bool ID ) ; 
void ID ( ID * ID , int ID ) ; 
void ID ( ID * ID , ID * ID ) ; 
void ID ( ) ; 
void ID ( ID * ID ) ; 
void ID ( const char * ID , ID * ID , int * ID ) ; 
const char * ID ( const char * ID ) ; 
const char * ID ( const char * ID , const char * ID ) { 
const char * ID = ID ; 
while ( * ID != INTEGER && * ID == * ID ) { 
ID ++ ; 
ID ++ ; 
} 
if ( * ID == INTEGER ) 
return ID ; 
else 
return ID ; 
} 
const char ID ( const char ID ) { return ( ID >= ( const char ) STRING && ID <= ( const char ) STRING ) ? ( const char ) ( ID + INTEGER ) : ID ; } 
const char * ID ( const char * ID , const char * ID ) { 
const char * ID = ID ; 
while ( * ID != INTEGER && ID ( * ID ) == ID ( * ID ) ) { 
ID ++ ; 
ID ++ ; 
} 
if ( * ID == INTEGER ) 
return ID ; 
else 
return ID ; 
} 
bool ID ( const char * ID ) { 
ID = new ID [ ID ( ID ) + INTEGER ] ; 
ID = new const char * [ ID ( ID ) + INTEGER ] ; 
ID = new const char * [ ID ( ID ) + INTEGER ] ; 
const char * ID = ID ; 
ID = ID ; 
ID ID ; 
ID = ID ( ID ) ; 
while ( INTEGER ) { 
if ( * ID == INTEGER ) { 
* ID = ID ; 
ID = ID ; 
ID = ID - ID ; 
return true ; 
} 
int ID = INTEGER ; 
const char * ID ; 
for ( ID ID = ( ID ) INTEGER ; ID != ID ; ID = ( ID ) ( ( int ) ID + INTEGER ) ) { 
if ( ID [ ID ] ) 
ID = ID ( ID [ ID ] , ID ) ; 
else 
ID = ID ( ID [ ID ] , ID ) ; 
int ID = ID - ID ; 
if ( ID > ID ) { 
ID = ID ; 
ID = ID ; 
} 
} 
ID ( ID , & ID , & ID ) ; 
if ( ID == INTEGER ) { 
ID << STRING << ( ID - ID ) << STRING << ( int ) * ID << STRING << * ID << STRING ; 
* ID = ID ; 
ID = ID ; 
return false ; 
} 
ID [ ID - ID ] = ID ; 
ID += ID ; 
ID [ ID - ID ] = ID ; 
* ID ++ = ID ; 
if ( ID [ ID ] ) { 
ID = ID ( ID ) ; 
} 
} 
} 
const char * ID ( const char * ID ) { 
if ( ID ( * ID ) || * ID == STRING ) 
while ( ID ( * ID ) || * ID == STRING || * ID == STRING || * ID == STRING ) 
ID ++ ; 
return ID ; 
} 
bool ID ( const char * ID ) { 
return 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING ; 
} 
bool ID ( const char * ID ) { 
return 
* ID == STRING || * ID == STRING || * ID == STRING ; 
} 
bool ID ( const char * ID ) { 
return 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ID ( ID ) ) 
return ID ; 
ID ++ ; 
while ( ID ( ID ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ID ( ID ) ) 
return ID ; 
ID ++ ; 
while ( ID ( ID ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ID ( * ID ) || * ID == STRING ) 
while ( ID ( * ID ) || * ID == STRING ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
bool ID = ( * ID == STRING && ( * ( ID + INTEGER ) == STRING || * ( ID + INTEGER ) == STRING ) ) ; 
if ( ID ) ID += INTEGER ; 
while ( ( ID ? ID ( * ID ) : ID ( * ID ) ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ID ( * ID ) ) 
return ID ; 
while ( ID ( * ID ) ) 
ID ++ ; 
if ( * ID != STRING ) 
return ID ; 
ID ++ ; 
while ( ID ( * ID ) ) 
ID ++ ; 
if ( * ID == STRING || * ID == STRING ) { 
ID ++ ; 
while ( ID ( * ID ) ) 
ID ++ ; 
} 
return ID ; 
} 
const char * ID ( const char * ID ) { 
const char * ID = ID ; 
if ( * ID != STRING ) 
return ID ; 
ID ++ ; 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
if ( * ID != STRING ) 
return ID ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( * ID != STRING ) ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( * ID != STRING ) ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( * ID != STRING ) ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ( ( * ID == STRING ) && ( * ( ID + INTEGER ) == STRING ) ) ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( ! ( ( * ID == STRING ) && ( * ( ID + INTEGER ) == STRING ) ) ) ; 
ID ++ ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
if ( * ID != STRING ) { 
if ( * ( ID + INTEGER ) == STRING && ( * ( ID + INTEGER ) == STRING || * ( ID + INTEGER ) == STRING ) ) 
ID += INTEGER ; 
} 
else 
ID += INTEGER ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
while ( * ID != INTEGER && ( ID ( * ID ) ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
int ID = INTEGER ; 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
while ( ID > INTEGER ) { 
if ( * ID == INTEGER ) 
break ; 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
ID ++ ; 
} 
else if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
ID -- ; 
} 
else 
ID ++ ; 
} 
} 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
while ( INTEGER ) { 
if ( * ID == INTEGER ) 
break ; 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
break ; 
} 
ID ++ ; 
} 
} 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) 
while ( * ID != INTEGER && * ID != STRING ) 
ID ++ ; 
if ( * ID == STRING ) 
ID ++ ; 
return ID ; 
} 
void ID ( const char * const ID ) ; 
void ID ( ID ID ) ; 
void ID ( ) { 
ID = new ID ( INTEGER , ID , ID - ID ) ; 
ID = new ID ; 
ID = new ID ; 
ID = new ID ; 
ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID -> ID = ID ; 
} 
void ID ( ) { 
ID = ID -> ID ( ) ; 
ID = ID -> ID ; 
ID = ID -> ID ; 
ID = ID -> ID ; 
ID = ID -> ID ; 
} 
void ID ( ) { 
ID = ID ( ) ; 
} 
void ID ( ) { 
ID = ID ( ) ; 
} 
void ID ( ) { 
if ( ID -> ID ( ID , ID , ID , ID , ID , ID , ID , ID , INTEGER , ID , ID ) < INTEGER ) 
ID ( ID , ID ) ; 
ID << STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID ; 
ID << STRING ; 
} 
void ID ( const char * ID ) { ID = ID ( ID ) ; } 
ID ( ) ; 
} ; 
class ID { 
class ID { 
public : 
unsigned long ID ; 
unsigned long ID ; 
ID * ID ; 
} ; 
ID * ID ; 
public : 
ID ( ) 
{ 
ID = new ID ; 
ID -> ID = ID -> ID = INTEGER ; 
ID -> ID = new ID ; 
ID -> ID -> ID = ID ; 
ID -> ID -> ID = INTEGER ; 
ID -> ID -> ID = ID ; 
} 
void ID ( unsigned long ID ) 
{ 
ID * ID = ID ; 
ID * ID ; 
ID * ID ; 
do 
{ 
if ( ID -> ID == ID ) 
{ 
ID -> ID ++ ; 
return ; 
} 
ID = ID ; 
ID = ID -> ID ; 
} 
while ( ID -> ID <= ID ) ; 
ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = INTEGER ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
} 
void ID ( ) 
{ 
unsigned long ID = ID ( ) ; 
ID * ID = ID ; 
while ( ID -> ID != ID ) 
{ 
if ( ID -> ID != INTEGER ) 
ID << ID -> ID << STRING << ID -> ID << STRING << ( INTEGER * ID -> ID ) / ID << STRING ; 
ID = ID -> ID ; 
} 
} 
unsigned long ID ( unsigned long ID ) 
{ 
ID * ID = ID ; 
while ( ID -> ID != ID && ID -> ID != ID ) 
ID = ID -> ID ; 
return ID -> ID == ID ? ID -> ID : INTEGER ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
if ( ID -> ID != INTEGER ) 
ID ++ ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
ID ++ ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
ID += ID -> ID ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
ID += ID -> ID * ID -> ID ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
} ; 
enum ID { ID , ID , ID , ID , ID , ID } ; 
enum ID { ID , ID , ID , ID , ID , ID } ; 
void ID ( struct ID * * ID , int ID , const char * * ID , enum ID * ID ) ; 
enum ID { ID , ID , ID , ID , ID , ID , ID } ; 
struct ID { ID ID ; struct ID * ID ; } ; 
struct ID { ID * ID ; ID * ID ; } ; 
class ID { 
public : 
ID ( ) { ID = ID = ID ; } ; 
static ID * ID ; 
static unsigned ID ; 
static unsigned ID ; 
static unsigned ID ; 
static struct ID * * ID ; 
struct ID * ID ; 
struct ID * ID ; 
ID ( unsigned ID , ID * ID , int ID ) { 
ID = ID ; 
ID = ID ; 
ID = INTEGER ; 
for ( int ID = INTEGER ; ID < ID ; ID ++ ) 
ID *= INTEGER ; 
ID = new ID * [ ID ] ; 
ID = ID - INTEGER ; 
ID ( ID , INTEGER , ID * sizeof ( ID * ) ) ; 
ID = ID = ID ; 
} 
unsigned ID ( ID ID , ID ID , ID ID , ID ID , ID * ID , ID * ID , ID * ID , ID * ID ) { 
return ( ID * ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID + 
( ID - ID ) * ID * ID * ID + 
( ID - ID ) * ID * ID + 
( ID - ID ) * ID + 
( ID - ID ) ) & ID ; 
} 
unsigned ID ( ID ID , ID ID , ID ID , ID * ID , ID * ID , ID * ID ) { 
return ( ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID + 
ID * ID * ID * ID + 
( ID - ID ) * ID * ID + 
( ID - ID ) * ID + 
( ID - ID ) ) & ID ; 
} 
unsigned ID ( ID ID , ID ID , ID * ID , ID * ID ) { 
return ( ID * ID * ID * ID + 
ID * ID * ID + 
( ID - ID ) * ID + 
( ID - ID ) ) & ID ; 
} 
unsigned ID ( ID ID , ID ID , ID * ID ) { 
return ( ID * ID * ID + 
ID * ID + 
( ID - ID ) ) & ID ; 
} 
bool ID ( ) ; 
void ID ( struct ID * ID ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ID ID , struct ID * ID , ID * ID , struct ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID ID , struct ID * ID , ID * ID , struct ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID * ID ) ; 
void ID ( ID * ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID ID , ID * ID ) ; 
void ID ( struct ID * ID ) ; 
struct ID * ID ( ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
void ID ( ) ; 
void ID ( ) ; 
int ID ( const char * ID , const char * ID , const char * ID , const char * ID , ID * ID , int ID , ID * ID , bool ID , double ID , const char * * ID , enum ID * ID ) ; 
void ID ( ) ; 
} ; 
class ID { 
public : 
static ID ID ; 
static int ID ; 
ID ID ; 
enum ID ID ; 
ID * ID ; 
ID * ID ; 
ID ( ID ID ) { 
this -> ID = ID ; ID = ID = ID ; 
} ; 
ID ( ID ID , ID * ID ) { 
this -> ID = ID ; ID = ID ; 
ID * ID = ID -> ID ; 
if ( ID == ID ) 
ID -> ID = this ; 
else { 
while ( ID -> ID != ID ) 
ID = ID -> ID ; 
ID -> ID = this ; 
} 
ID = ID ; 
} ; 
void ID ( ) { 
ID << ID << STRING ; 
if ( ID != ID ) 
ID -> ID ( ) ; 
ID << STRING ; 
if ( ID != ID ) 
ID -> ID ( ) ; 
} ; 
void ID ( int ID , const char * * ID ) ; 
void ID ( const char * ID , const char * * ID ) { 
ID . ID ( ID ) ; 
ID << 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING ; 
ID = INTEGER ; 
this -> ID ( INTEGER , ID ) ; 
ID << STRING ; 
ID . ID ( ) ; 
} ; 
void ID ( ID * ID , const char * * ID ) { 
if ( ID == ID ) 
return ; 
if ( ID -> ID == ID ) 
ID << ID [ ID -> ID ] << STRING ; 
else { 
ID << STRING ; 
ID ( ID -> ID , ID ) ; 
ID << STRING ; 
} 
if ( ID -> ID != ID ) 
ID ( ID -> ID , ID ) ; 
} 
void ID ( const char * ID , ID * ID , const char * * ID ) { 
ID . ID ( ID ) ; 
ID ( ID , ID ) ; 
ID . ID ( ) ; 
} 
} ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID * ID ; int ID : INTEGER ; int ID : INTEGER ; ID ID ; ID ( ) { ID . ID = ID . ID = ID ; } ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID * ID ; ID ID ; ID * ID ; ID ID ; ID ID ; int ID : INTEGER ; } ; 
class ID { public : ID ID ; struct ID * ID ; struct ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID ID ; ID ID ; ID ( ) { ID . ID = ID . ID = ID . ID = ID . ID = ID ; } ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { 
public : 
ID ID ; 
bool ID ; 
ID ID ; 
ID ID ; 
const char * ID ; 
const char * ID ; 
const char * ID ; 
const char * ID ; 
ID * ID ; 
int ID ; 
const char * * ID ; 
const char * * ID ; 
ID * ID ; 
ID * ID ; 
ID ID ; 
const char * * ID ; 
const char * * ID ; 
bool * ID ; 
bool * ID ; 
int ID ; 
enum ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
bool * ID ; 
bool * ID ; 
bool * ID ; 
bool * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
ID * ID ( ID * ID ) ; 
ID * ID ( ID ID , ID * ID ) ; 
ID * ID ( ID ID , ID * ID , ID * ID ) ; 
ID * ID ( ID ID , ID ID , ID * ID ) ; 
ID * ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
void ID ( ID * ID , ID * ID , ID * ID ) ; 
void ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
bool ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
ID * ID ( ID * ID , ID * ID , bool ID ) ; 
void ID ( ID * ID , int ID ) ; 
void ID ( ID * ID , ID * ID ) ; 
void ID ( ) ; 
void ID ( ID * ID ) ; 
void ID ( const char * ID , ID * ID , int * ID ) ; 
const char * ID ( const char * ID ) ; 
const char * ID ( const char * ID , const char * ID ) { 
const char * ID = ID ; 
while ( * ID != INTEGER && * ID == * ID ) { 
ID ++ ; 
ID ++ ; 
} 
if ( * ID == INTEGER ) 
return ID ; 
else 
return ID ; 
} 
const char ID ( const char ID ) { return ( ID >= ( const char ) STRING && ID <= ( const char ) STRING ) ? ( const char ) ( ID + INTEGER ) : ID ; } 
const char * ID ( const char * ID , const char * ID ) { 
const char * ID = ID ; 
while ( * ID != INTEGER && ID ( * ID ) == ID ( * ID ) ) { 
ID ++ ; 
ID ++ ; 
} 
if ( * ID == INTEGER ) 
return ID ; 
else 
return ID ; 
} 
bool ID ( const char * ID ) { 
ID = new ID [ ID ( ID ) + INTEGER ] ; 
ID = new const char * [ ID ( ID ) + INTEGER ] ; 
ID = new const char * [ ID ( ID ) + INTEGER ] ; 
const char * ID = ID ; 
ID = ID ; 
ID ID ; 
ID = ID ( ID ) ; 
while ( INTEGER ) { 
if ( * ID == INTEGER ) { 
* ID = ID ; 
ID = ID ; 
ID = ID - ID ; 
return true ; 
} 
int ID = INTEGER ; 
const char * ID ; 
for ( ID ID = ( ID ) INTEGER ; ID != ID ; ID = ( ID ) ( ( int ) ID + INTEGER ) ) { 
if ( ID [ ID ] ) 
ID = ID ( ID [ ID ] , ID ) ; 
else 
ID = ID ( ID [ ID ] , ID ) ; 
int ID = ID - ID ; 
if ( ID > ID ) { 
ID = ID ; 
ID = ID ; 
} 
} 
ID ( ID , & ID , & ID ) ; 
if ( ID == INTEGER ) { 
ID << STRING << ( ID - ID ) << STRING << ( int ) * ID << STRING << * ID << STRING ; 
* ID = ID ; 
ID = ID ; 
return false ; 
} 
ID [ ID - ID ] = ID ; 
ID += ID ; 
ID [ ID - ID ] = ID ; 
* ID ++ = ID ; 
if ( ID [ ID ] ) { 
ID = ID ( ID ) ; 
} 
} 
} 
const char * ID ( const char * ID ) { 
if ( ID ( * ID ) || * ID == STRING ) 
while ( ID ( * ID ) || * ID == STRING || * ID == STRING || * ID == STRING ) 
ID ++ ; 
return ID ; 
} 
bool ID ( const char * ID ) { 
return 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING ; 
} 
bool ID ( const char * ID ) { 
return 
* ID == STRING || * ID == STRING || * ID == STRING ; 
} 
bool ID ( const char * ID ) { 
return 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ID ( ID ) ) 
return ID ; 
ID ++ ; 
while ( ID ( ID ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ID ( ID ) ) 
return ID ; 
ID ++ ; 
while ( ID ( ID ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ID ( * ID ) || * ID == STRING ) 
while ( ID ( * ID ) || * ID == STRING ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
bool ID = ( * ID == STRING && ( * ( ID + INTEGER ) == STRING || * ( ID + INTEGER ) == STRING ) ) ; 
if ( ID ) ID += INTEGER ; 
while ( ( ID ? ID ( * ID ) : ID ( * ID ) ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ID ( * ID ) ) 
return ID ; 
while ( ID ( * ID ) ) 
ID ++ ; 
if ( * ID != STRING ) 
return ID ; 
ID ++ ; 
while ( ID ( * ID ) ) 
ID ++ ; 
if ( * ID == STRING || * ID == STRING ) { 
ID ++ ; 
while ( ID ( * ID ) ) 
ID ++ ; 
} 
return ID ; 
} 
const char * ID ( const char * ID ) { 
const char * ID = ID ; 
if ( * ID != STRING ) 
return ID ; 
ID ++ ; 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
if ( * ID != STRING ) 
return ID ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( * ID != STRING ) ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( * ID != STRING ) ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( * ID != STRING ) ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ( ( * ID == STRING ) && ( * ( ID + INTEGER ) == STRING ) ) ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( ! ( ( * ID == STRING ) && ( * ( ID + INTEGER ) == STRING ) ) ) ; 
ID ++ ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
if ( * ID != STRING ) { 
if ( * ( ID + INTEGER ) == STRING && ( * ( ID + INTEGER ) == STRING || * ( ID + INTEGER ) == STRING ) ) 
ID += INTEGER ; 
} 
else 
ID += INTEGER ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
while ( * ID != INTEGER && ( ID ( * ID ) ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
int ID = INTEGER ; 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
while ( ID > INTEGER ) { 
if ( * ID == INTEGER ) 
break ; 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
ID ++ ; 
} 
else if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
ID -- ; 
} 
else 
ID ++ ; 
} 
} 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
while ( INTEGER ) { 
if ( * ID == INTEGER ) 
break ; 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
break ; 
} 
ID ++ ; 
} 
} 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) 
while ( * ID != INTEGER && * ID != STRING ) 
ID ++ ; 
if ( * ID == STRING ) 
ID ++ ; 
return ID ; 
} 
void ID ( const char * const ID ) ; 
void ID ( ID ID ) ; 
void ID ( ) { 
ID = new ID ( INTEGER , ID , ID - ID ) ; 
ID = new ID ; 
ID = new ID ; 
ID = new ID ; 
ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID -> ID = ID ; 
} 
void ID ( ) { 
ID = ID -> ID ( ) ; 
ID = ID -> ID ; 
ID = ID -> ID ; 
ID = ID -> ID ; 
ID = ID -> ID ; 
} 
void ID ( ) { 
ID = ID ( ) ; 
} 
void ID ( ) { 
ID = ID ( ) ; 
} 
void ID ( ) { 
if ( ID -> ID ( ID , ID , ID , ID , ID , ID , ID , ID , INTEGER , ID , ID ) < INTEGER ) 
ID ( ID , ID ) ; 
ID << STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID ; 
ID << STRING ; 
} 
void ID ( const char * ID ) { ID = ID ( ID ) ; } 
ID ( ) ; 
} ; 
class ID { 
class ID { 
public : 
unsigned long ID ; 
unsigned long ID ; 
ID * ID ; 
} ; 
ID * ID ; 
public : 
ID ( ) 
{ 
ID = new ID ; 
ID -> ID = ID -> ID = INTEGER ; 
ID -> ID = new ID ; 
ID -> ID -> ID = ID ; 
ID -> ID -> ID = INTEGER ; 
ID -> ID -> ID = ID ; 
} 
void ID ( unsigned long ID ) 
{ 
ID * ID = ID ; 
ID * ID ; 
ID * ID ; 
do 
{ 
if ( ID -> ID == ID ) 
{ 
ID -> ID ++ ; 
return ; 
} 
ID = ID ; 
ID = ID -> ID ; 
} 
while ( ID -> ID <= ID ) ; 
ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = INTEGER ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
} 
void ID ( ) 
{ 
unsigned long ID = ID ( ) ; 
ID * ID = ID ; 
while ( ID -> ID != ID ) 
{ 
if ( ID -> ID != INTEGER ) 
ID << ID -> ID << STRING << ID -> ID << STRING << ( INTEGER * ID -> ID ) / ID << STRING ; 
ID = ID -> ID ; 
} 
} 
unsigned long ID ( unsigned long ID ) 
{ 
ID * ID = ID ; 
while ( ID -> ID != ID && ID -> ID != ID ) 
ID = ID -> ID ; 
return ID -> ID == ID ? ID -> ID : INTEGER ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
if ( ID -> ID != INTEGER ) 
ID ++ ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
ID ++ ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
ID += ID -> ID ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
ID += ID -> ID * ID -> ID ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
} ; 
unsigned ID :: ID ; 
unsigned ID :: ID ; 
ID * ID :: ID ; 
unsigned ID :: ID ; 
ID * * ID :: ID ; 
void ID :: ID ( ) { 
} 
int ID :: ID ( const char * ID , const char * ID , const char * ID , const char * ID , ID * ID , int ID , ID * ID , bool ID , double ID , const char * * ID , enum ID * ID ) { 
ID = STRING ; 
int ID = INTEGER ; 
int ID = INTEGER ; 
int ID = INTEGER ; 
int ID = INTEGER ; 
int ID = INTEGER ; 
int ID = INTEGER ; 
int ID = INTEGER ; 
int ID = INTEGER ; 
int ID = INTEGER ; 
int ID = INTEGER ; 
ID * ID = new ID ( ) ; 
int * ID = new int [ ID - ID + INTEGER ] ; 
for ( int ID = INTEGER ; ID < ID - ID + INTEGER ; ID ++ ) 
ID [ ID ] = INTEGER ; 
for ( int ID = INTEGER ; ID < ID :: ID ; ID ++ ) { 
unsigned long ID = INTEGER ; 
for ( ID * ID = ID :: ID [ ID ] ; ID != ID ; ID = ID -> ID ) { 
ID ++ ; 
ID * ID ; 
switch ( ID -> ID ) { 
case ID : ID ++ ; break ; 
case ID : 
ID ++ ; 
if ( ID < ( ( ID * ) ID ) -> ID - ID ) 
ID = ( ( ID * ) ID ) -> ID - ID ; 
for ( ID = ( ( ID * ) ID ) -> ID . ID ( ) ; ID != ID ; ID = ( ( ID * ) ID ) -> ID . ID ( ) ) { 
ID ++ ; 
if ( ID -> ID != ID ) 
ID ++ ; 
if ( ID -> ID != ID ) 
ID ++ ; 
} 
break ; 
case ID : ID ++ ; break ; 
case ID : ID ++ ; break ; 
case ID : ID ++ ; break ; 
case ID : ID ++ ; ID [ ( ( ID * ) ID ) -> ID - ID ] ++ ; break ; 
case ID : ID ++ ; break ; 
default : ID << STRING << ID -> ID << STRING ; 
} 
} 
} 
for ( int ID = INTEGER ; ID < ( ID - ID + INTEGER ) ; ID ++ ) { 
if ( ID [ ID ] > ID ) 
ID = ID [ ID ] ; 
} 
if ( ID < INTEGER ) { 
ID << STRING ; 
ID ID ; 
ID . ID ( STRING ) ; 
ID << 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING << 
STRING << 
STRING ; 
for ( int ID = INTEGER ; ID < ID :: ID ; ID ++ ) { 
for ( ID * ID = ID :: ID [ ID ] ; ID != ID ; ID = ID -> ID ) { 
ID * ID = ( ID * ) ID ; 
ID * ID = ( ID * ) ID ; 
switch ( ID -> ID ) { 
case ID : ID << STRING << 
ID [ ID -> ID -> ID ] << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
ID [ ID -> ID -> ID ] << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
ID [ ID -> ID -> ID ] << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING ; 
break ; 
case ID : ID << STRING << 
ID [ ID -> ID ] << 
STRING << 
( ID -> ID - ID ) << 
STRING << 
( ID -> ID - ID ) << 
STRING << 
( int ) ( ID -> ID ) << 
STRING ; 
break ; 
} 
} 
} 
ID << STRING ; 
ID . ID ( ) ; 
} 
if ( ! ID ) { 
for ( int ID = INTEGER ; ID < ( ID - ID ) ; ID ++ ) 
ID << ID << STRING << ID [ ID ] << STRING << ID [ ID [ ID ] ] << STRING ; 
ID << STRING << ID << STRING << ( ID == INTEGER ? STRING : STRING ) ; 
} 
double ID = ID > REAL ? ( ( double ) ( ID - ID ) ) / ID : INTEGER ; 
ID << ( ID ? STRING : STRING ) << STRING << ID << STRING << ID << STRING << 
ID << STRING << ID << STRING << ( ID - ID ) << STRING << 
ID 
<< STRING << ID << 
STRING << ID << 
STRING << ID << STRING << ID << STRING << ID << STRING << ID << 
STRING << ID << STRING << ID << STRING << ID << 
STRING << ID << 
STRING << ID 
; 
return ID ; 
} 
bool ID :: ID ( ) { 
return ID == ID ; 
} 
void ID :: ID ( struct ID * ID ) { 
ID * ID = new ID ; 
ID -> ID = ( ID * ) ID ; 
ID -> ID = ID ; 
ID = ID ; 
} 
void ID :: ID ( struct ID * ID ) { 
ID * ID = new ID ; 
ID -> ID = ( ID * ) ID ; 
ID -> ID = ID ; 
ID = ID ; 
} 
ID * ID :: ID ( ) { 
ID * ID = ID ; 
ID = ID -> ID ; 
return ( ID * ) ID -> ID ; 
} 
ID * ID :: ID ( ID ID , ID * ID , ID * ID , ID * ID ) { 
int ID = ID ( ID , ID , ID -> ID , ID -> ID , ID -> ID , ID , ID -> ID , ID -> ID ) ; 
for ( ID * ID = ( ID * ) ID :: ID [ ID ] ; 
ID != ID ; 
ID = ( ID * ) ID -> ID ) 
if ( ID -> ID == ID && ID -> ID == ID && ID -> ID == ID && ID -> ID == ID && ID -> ID == ID ) 
return ID ; 
return ID ; 
} 
ID * ID :: ID ( ID ID , ID * ID , ID * ID , ID * ID ) { 
int ID = ID ( ID , ID , ID -> ID , ID -> ID , ID -> ID , ID , ID -> ID , ID -> ID ) ; 
ID * ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = ID :: ID [ ID ] ; 
ID :: ID [ ID ] = ( ID * ) ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
return ID ; 
} 
ID * ID :: ID ( ID ID , ID * ID , ID * ID , ID * ID ) { 
int ID = ID ( ID , ID , ID -> ID , ID -> ID , ID -> ID , ID , ID -> ID , ID -> ID ) ; 
for ( ID * ID = ( ID * ) ID :: ID [ ID ] ; 
ID != ID ; 
ID = ( ID * ) ID -> ID ) 
if ( ID -> ID == ID && ID -> ID == ID && ID -> ID == ID && ID -> ID == ID && ID -> ID == ID ) 
return ID ; 
return ID ; 
} 
ID * ID :: ID ( ID ID , ID * ID , ID * ID , ID * ID ) { 
int ID = ID ( ID , ID , ID -> ID , ID -> ID , ID -> ID , ID , ID -> ID , ID -> ID ) ; 
ID * ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = ID :: ID [ ID ] ; 
ID :: ID [ ID ] = ( ID * ) ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
return ID ; 
} 
ID * ID :: ID ( ID * ID , ID * ID ) { 
int ID = ID ( ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID ) ; 
for ( ID * ID = ( ID * ) ID :: ID [ ID ] ; 
ID != ID ; 
ID = ( ID * ) ID -> ID ) 
if ( ID -> ID == ID && 
ID -> ID -> ID == ID -> ID && ID -> ID -> ID == ID -> ID && 
ID -> ID -> ID == ID -> ID && ID -> ID -> ID == ID -> ID && ID -> ID -> ID == ID -> ID ) 
return ID ; 
return ID ; 
} 
void ID :: ID ( ID * ID , ID * ID ) { 
int ID = ID ( ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID ) ; 
ID * ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = ID :: ID [ ID ] ; 
ID :: ID [ ID ] = ( ID * ) ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID * ID = new ID ; 
ID -> ID = ( ID * ) ID ; 
ID -> ID = ID ; 
ID = ID ; 
} 
ID * ID :: ID ( ID ID , ID * ID ) { 
int ID = ID ( ID , ID , ID ) ; 
for ( ID * ID = ( ID * ) ID :: ID [ ID ] ; 
ID != ID ; 
ID = ( ID * ) ID -> ID ) 
if ( ID -> ID == ID && ID -> ID == ID && ID -> ID == ID ) 
return ID ; 
return ID ; 
} 
ID * ID :: ID ( ID ID , ID * ID ) { 
int ID = ID ( ID , ID , ID ) ; 
ID * ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = ID :: ID [ ID ] ; 
ID :: ID [ ID ] = ( ID * ) ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
return ID ; 
} 
ID * ID :: ID ( ID ID , ID * ID , ID * ID ) { 
int ID = ID ( ID , ID , ID , ID ) ; 
for ( ID * ID = ( ID * ) ID :: ID [ ID ] ; 
ID != ID ; 
ID = ( ID * ) ID -> ID ) 
if ( ID -> ID == ID && ID -> ID == ID && ID -> ID == ID && ID -> ID == ID ) { 
return ID ; 
} 
return ID ; 
} 
ID * ID :: ID ( ID ID , ID * ID , ID * ID ) { 
int ID = ID ( ID , ID , ID , ID ) ; 
ID * ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = ID :: ID [ ID ] ; 
ID :: ID [ ID ] = ( ID * ) ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
return ID ; 
} 
ID * ID :: ID ( ID * ID , ID ID , ID * ID ) { 
int ID = ID ( ID , ID -> ID , ID , ID -> ID , ID -> ID , ID ) ; 
for ( ID * ID = ( ID * ) ID :: ID [ ID ] ; 
ID != ID ; 
ID = ( ID * ) ID -> ID ) 
if ( ID -> ID == ID && ID -> ID == ID && ID -> ID == ID && ID -> ID == ID ) 
return ID ; 
return ID ; 
} 
ID * ID :: ID ( ID * ID , ID ID , ID * ID ) { 
int ID = ID ( ID , ID -> ID , ID , ID -> ID , ID -> ID , ID ) ; 
ID * ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = ID :: ID [ ID ] ; 
ID :: ID [ ID ] = ( ID * ) ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID . ID ( ID ) ; 
return ID ; 
} 
ID * ID :: ID ( ID * ID , ID * ID , ID * ID ) { 
int ID = ID ( ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID ) ; 
for ( ID * ID = ( ID * ) ID :: ID [ ID ] ; 
ID != ID ; 
ID = ( ID * ) ID -> ID ) 
if ( ID -> ID == ID && ID -> ID == ID && ID -> ID == ID && ID -> ID == ID ) 
return ID ; 
return ID ; 
} 
ID * ID :: ID ( ID * ID , ID * ID , ID * ID ) { 
int ID = ID ( ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID ) ; 
ID * ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = ID :: ID [ ID ] ; 
ID :: ID [ ID ] = ( ID * ) ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID * ID = new ID ; 
ID -> ID = ( ID * ) ID ; 
ID -> ID = ID ; 
ID = ID ; 
return ID ; 
} 
ID * ID :: ID ( ) { 
ID = ID ; 
return ID == ID ? ID : ( ID * ) ID -> ID ; 
} 
ID * ID :: ID ( ) { 
if ( ID != ID ) 
ID = ID -> ID ; 
return ID == ID ? ID : ( ID * ) ID -> ID ; 
} 
ID * ID :: ID ( ) { 
ID = ID ; 
return ID == ID ? ID : ( ID * ) ID -> ID ; 
} 
ID * ID :: ID ( ) { 
if ( ID != ID ) 
ID = ID -> ID ; 
return ID == ID ? ID : ( ID * ) ID -> ID ; 
} 
ID * ID :: ID ( ) { 
ID = ID ; 
return ID == ID ? ID : ( ID * ) ID -> ID ; 
} 
ID * ID :: ID ( ) { 
if ( ID != ID ) 
ID = ID -> ID ; 
return ID == ID ? ID : ( ID * ) ID -> ID ; 
} 
ID ID :: ID ; 
int ID :: ID ; 
void ID ( ID * ID , const char * ID ) { 
if ( ID == ID ) 
* ID << STRING ; 
else 
while ( * ID != INTEGER ) { 
if ( * ID == STRING ) 
* ID << STRING ; 
* ID << * ID ++ ; 
} 
} 
void ID :: ID ( int ID , const char * * ID ) { 
int ID = ID ; 
if ( ID != INTEGER ) 
ID << 
STRING << ID << STRING << ID << STRING ; 
ID << STRING << ID << STRING ; 
ID ( & ID , ID [ ID ] ) ; 
ID << ( this -> ID == ID ? STRING : this -> ID == ID ? STRING : this -> ID == ID ? STRING : STRING ) << 
STRING << ID << STRING ; 
if ( ID != ID ) { 
ID ++ ; 
ID -> ID ( ID , ID ) ; 
} 
if ( ID != ID ) { 
ID ++ ; 
ID -> ID ( ID , ID ) ; 
} 
} 
void ID :: ID ( ) { 
for ( int ID = INTEGER ; ID < ID :: ID ; ID ++ ) { 
for ( ID * ID = ID :: ID [ ID ] ; ID != ID ; ID = ID -> ID ) 
switch ( ID -> ID ) { 
case ID : ( ( ID * ) ID ) -> ID = false ; break ; 
case ID : ( ( ID * ) ID ) -> ID = false ; break ; 
case ID : break ; 
case ID : break ; 
case ID : break ; 
case ID : break ; 
case ID : break ; 
default : ID << STRING << ID -> ID << STRING ; 
} 
} 
} 
void ID :: ID ( ) { 
for ( int ID = INTEGER ; ID < ID :: ID ; ID ++ ) { 
for ( ID * ID = ID :: ID [ ID ] ; ID != ID ; ID = ID -> ID ) 
if ( ID -> ID == ID ) { 
ID * ID = ( ID * ) ID ; 
if ( ! ID -> ID ) { 
} 
} 
} 
} 
enum ID { ID , ID , ID , ID , ID , ID } ; 
void ID ( struct ID * * ID , int ID , const char * * ID , enum ID * ID ) ; 
enum ID { ID , ID , ID , ID , ID , ID , ID } ; 
struct ID { ID ID ; struct ID * ID ; } ; 
struct ID { ID * ID ; ID * ID ; } ; 
class ID { 
public : 
ID ( ) { ID = ID = ID ; } ; 
static ID * ID ; 
static unsigned ID ; 
static unsigned ID ; 
static unsigned ID ; 
static struct ID * * ID ; 
struct ID * ID ; 
struct ID * ID ; 
ID ( unsigned ID , ID * ID , int ID ) { 
ID = ID ; 
ID = ID ; 
ID = INTEGER ; 
for ( int ID = INTEGER ; ID < ID ; ID ++ ) 
ID *= INTEGER ; 
ID = new ID * [ ID ] ; 
ID = ID - INTEGER ; 
ID ( ID , INTEGER , ID * sizeof ( ID * ) ) ; 
ID = ID = ID ; 
} 
unsigned ID ( ID ID , ID ID , ID ID , ID ID , ID * ID , ID * ID , ID * ID , ID * ID ) { 
return ( ID * ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID + 
( ID - ID ) * ID * ID * ID + 
( ID - ID ) * ID * ID + 
( ID - ID ) * ID + 
( ID - ID ) ) & ID ; 
} 
unsigned ID ( ID ID , ID ID , ID ID , ID * ID , ID * ID , ID * ID ) { 
return ( ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID + 
ID * ID * ID * ID + 
( ID - ID ) * ID * ID + 
( ID - ID ) * ID + 
( ID - ID ) ) & ID ; 
} 
unsigned ID ( ID ID , ID ID , ID * ID , ID * ID ) { 
return ( ID * ID * ID * ID + 
ID * ID * ID + 
( ID - ID ) * ID + 
( ID - ID ) ) & ID ; 
} 
unsigned ID ( ID ID , ID ID , ID * ID ) { 
return ( ID * ID * ID + 
ID * ID + 
( ID - ID ) ) & ID ; 
} 
bool ID ( ) ; 
void ID ( struct ID * ID ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ID ID , struct ID * ID , ID * ID , struct ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID ID , struct ID * ID , ID * ID , struct ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID * ID ) ; 
void ID ( ID * ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID ID , ID * ID ) ; 
void ID ( struct ID * ID ) ; 
struct ID * ID ( ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
void ID ( ) ; 
void ID ( ) ; 
int ID ( const char * ID , const char * ID , const char * ID , const char * ID , ID * ID , int ID , ID * ID , bool ID , double ID , const char * * ID , enum ID * ID ) ; 
void ID ( ) ; 
} ; 
enum ID { ID , ID , ID , ID , ID , ID } ; 
void ID ( struct ID * * ID , int ID , const char * * ID , enum ID * ID ) ; 
enum ID { ID , ID , ID , ID , ID , ID , ID } ; 
struct ID { ID ID ; struct ID * ID ; } ; 
struct ID { ID * ID ; ID * ID ; } ; 
class ID { 
public : 
ID ( ) { ID = ID = ID ; } ; 
static ID * ID ; 
static unsigned ID ; 
static unsigned ID ; 
static unsigned ID ; 
static struct ID * * ID ; 
struct ID * ID ; 
struct ID * ID ; 
ID ( unsigned ID , ID * ID , int ID ) { 
ID = ID ; 
ID = ID ; 
ID = INTEGER ; 
for ( int ID = INTEGER ; ID < ID ; ID ++ ) 
ID *= INTEGER ; 
ID = new ID * [ ID ] ; 
ID = ID - INTEGER ; 
ID ( ID , INTEGER , ID * sizeof ( ID * ) ) ; 
ID = ID = ID ; 
} 
unsigned ID ( ID ID , ID ID , ID ID , ID ID , ID * ID , ID * ID , ID * ID , ID * ID ) { 
return ( ID * ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID + 
( ID - ID ) * ID * ID * ID + 
( ID - ID ) * ID * ID + 
( ID - ID ) * ID + 
( ID - ID ) ) & ID ; 
} 
unsigned ID ( ID ID , ID ID , ID ID , ID * ID , ID * ID , ID * ID ) { 
return ( ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID + 
ID * ID * ID * ID + 
( ID - ID ) * ID * ID + 
( ID - ID ) * ID + 
( ID - ID ) ) & ID ; 
} 
unsigned ID ( ID ID , ID ID , ID * ID , ID * ID ) { 
return ( ID * ID * ID * ID + 
ID * ID * ID + 
( ID - ID ) * ID + 
( ID - ID ) ) & ID ; 
} 
unsigned ID ( ID ID , ID ID , ID * ID ) { 
return ( ID * ID * ID + 
ID * ID + 
( ID - ID ) ) & ID ; 
} 
bool ID ( ) ; 
void ID ( struct ID * ID ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ID ID , struct ID * ID , ID * ID , struct ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID ID , struct ID * ID , ID * ID , struct ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID * ID ) ; 
void ID ( ID * ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID ID , ID * ID ) ; 
void ID ( struct ID * ID ) ; 
struct ID * ID ( ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
void ID ( ) ; 
void ID ( ) ; 
int ID ( const char * ID , const char * ID , const char * ID , const char * ID , ID * ID , int ID , ID * ID , bool ID , double ID , const char * * ID , enum ID * ID ) ; 
void ID ( ) ; 
} ; 
class ID { 
public : 
static ID ID ; 
static int ID ; 
ID ID ; 
enum ID ID ; 
ID * ID ; 
ID * ID ; 
ID ( ID ID ) { 
this -> ID = ID ; ID = ID = ID ; 
} ; 
ID ( ID ID , ID * ID ) { 
this -> ID = ID ; ID = ID ; 
ID * ID = ID -> ID ; 
if ( ID == ID ) 
ID -> ID = this ; 
else { 
while ( ID -> ID != ID ) 
ID = ID -> ID ; 
ID -> ID = this ; 
} 
ID = ID ; 
} ; 
void ID ( ) { 
ID << ID << STRING ; 
if ( ID != ID ) 
ID -> ID ( ) ; 
ID << STRING ; 
if ( ID != ID ) 
ID -> ID ( ) ; 
} ; 
void ID ( int ID , const char * * ID ) ; 
void ID ( const char * ID , const char * * ID ) { 
ID . ID ( ID ) ; 
ID << 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING ; 
ID = INTEGER ; 
this -> ID ( INTEGER , ID ) ; 
ID << STRING ; 
ID . ID ( ) ; 
} ; 
void ID ( ID * ID , const char * * ID ) { 
if ( ID == ID ) 
return ; 
if ( ID -> ID == ID ) 
ID << ID [ ID -> ID ] << STRING ; 
else { 
ID << STRING ; 
ID ( ID -> ID , ID ) ; 
ID << STRING ; 
} 
if ( ID -> ID != ID ) 
ID ( ID -> ID , ID ) ; 
} 
void ID ( const char * ID , ID * ID , const char * * ID ) { 
ID . ID ( ID ) ; 
ID ( ID , ID ) ; 
ID . ID ( ) ; 
} 
} ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID * ID ; int ID : INTEGER ; int ID : INTEGER ; ID ID ; ID ( ) { ID . ID = ID . ID = ID ; } ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID * ID ; ID ID ; ID * ID ; ID ID ; ID ID ; int ID : INTEGER ; } ; 
class ID { public : ID ID ; struct ID * ID ; struct ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID ID ; ID ID ; ID ( ) { ID . ID = ID . ID = ID . ID = ID . ID = ID ; } ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { 
public : 
ID ID ; 
bool ID ; 
ID ID ; 
ID ID ; 
const char * ID ; 
const char * ID ; 
const char * ID ; 
const char * ID ; 
ID * ID ; 
int ID ; 
const char * * ID ; 
const char * * ID ; 
ID * ID ; 
ID * ID ; 
ID ID ; 
const char * * ID ; 
const char * * ID ; 
bool * ID ; 
bool * ID ; 
int ID ; 
enum ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
bool * ID ; 
bool * ID ; 
bool * ID ; 
bool * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
ID * ID ( ID * ID ) ; 
ID * ID ( ID ID , ID * ID ) ; 
ID * ID ( ID ID , ID * ID , ID * ID ) ; 
ID * ID ( ID ID , ID ID , ID * ID ) ; 
ID * ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
void ID ( ID * ID , ID * ID , ID * ID ) ; 
void ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
bool ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
ID * ID ( ID * ID , ID * ID , bool ID ) ; 
void ID ( ID * ID , int ID ) ; 
void ID ( ID * ID , ID * ID ) ; 
void ID ( ) ; 
void ID ( ID * ID ) ; 
void ID ( const char * ID , ID * ID , int * ID ) ; 
const char * ID ( const char * ID ) ; 
const char * ID ( const char * ID , const char * ID ) { 
const char * ID = ID ; 
while ( * ID != INTEGER && * ID == * ID ) { 
ID ++ ; 
ID ++ ; 
} 
if ( * ID == INTEGER ) 
return ID ; 
else 
return ID ; 
} 
const char ID ( const char ID ) { return ( ID >= ( const char ) STRING && ID <= ( const char ) STRING ) ? ( const char ) ( ID + INTEGER ) : ID ; } 
const char * ID ( const char * ID , const char * ID ) { 
const char * ID = ID ; 
while ( * ID != INTEGER && ID ( * ID ) == ID ( * ID ) ) { 
ID ++ ; 
ID ++ ; 
} 
if ( * ID == INTEGER ) 
return ID ; 
else 
return ID ; 
} 
bool ID ( const char * ID ) { 
ID = new ID [ ID ( ID ) + INTEGER ] ; 
ID = new const char * [ ID ( ID ) + INTEGER ] ; 
ID = new const char * [ ID ( ID ) + INTEGER ] ; 
const char * ID = ID ; 
ID = ID ; 
ID ID ; 
ID = ID ( ID ) ; 
while ( INTEGER ) { 
if ( * ID == INTEGER ) { 
* ID = ID ; 
ID = ID ; 
ID = ID - ID ; 
return true ; 
} 
int ID = INTEGER ; 
const char * ID ; 
for ( ID ID = ( ID ) INTEGER ; ID != ID ; ID = ( ID ) ( ( int ) ID + INTEGER ) ) { 
if ( ID [ ID ] ) 
ID = ID ( ID [ ID ] , ID ) ; 
else 
ID = ID ( ID [ ID ] , ID ) ; 
int ID = ID - ID ; 
if ( ID > ID ) { 
ID = ID ; 
ID = ID ; 
} 
} 
ID ( ID , & ID , & ID ) ; 
if ( ID == INTEGER ) { 
ID << STRING << ( ID - ID ) << STRING << ( int ) * ID << STRING << * ID << STRING ; 
* ID = ID ; 
ID = ID ; 
return false ; 
} 
ID [ ID - ID ] = ID ; 
ID += ID ; 
ID [ ID - ID ] = ID ; 
* ID ++ = ID ; 
if ( ID [ ID ] ) { 
ID = ID ( ID ) ; 
} 
} 
} 
const char * ID ( const char * ID ) { 
if ( ID ( * ID ) || * ID == STRING ) 
while ( ID ( * ID ) || * ID == STRING || * ID == STRING || * ID == STRING ) 
ID ++ ; 
return ID ; 
} 
bool ID ( const char * ID ) { 
return 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING ; 
} 
bool ID ( const char * ID ) { 
return 
* ID == STRING || * ID == STRING || * ID == STRING ; 
} 
bool ID ( const char * ID ) { 
return 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ID ( ID ) ) 
return ID ; 
ID ++ ; 
while ( ID ( ID ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ID ( ID ) ) 
return ID ; 
ID ++ ; 
while ( ID ( ID ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ID ( * ID ) || * ID == STRING ) 
while ( ID ( * ID ) || * ID == STRING ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
bool ID = ( * ID == STRING && ( * ( ID + INTEGER ) == STRING || * ( ID + INTEGER ) == STRING ) ) ; 
if ( ID ) ID += INTEGER ; 
while ( ( ID ? ID ( * ID ) : ID ( * ID ) ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ID ( * ID ) ) 
return ID ; 
while ( ID ( * ID ) ) 
ID ++ ; 
if ( * ID != STRING ) 
return ID ; 
ID ++ ; 
while ( ID ( * ID ) ) 
ID ++ ; 
if ( * ID == STRING || * ID == STRING ) { 
ID ++ ; 
while ( ID ( * ID ) ) 
ID ++ ; 
} 
return ID ; 
} 
const char * ID ( const char * ID ) { 
const char * ID = ID ; 
if ( * ID != STRING ) 
return ID ; 
ID ++ ; 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
if ( * ID != STRING ) 
return ID ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( * ID != STRING ) ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( * ID != STRING ) ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( * ID != STRING ) ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ( ( * ID == STRING ) && ( * ( ID + INTEGER ) == STRING ) ) ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( ! ( ( * ID == STRING ) && ( * ( ID + INTEGER ) == STRING ) ) ) ; 
ID ++ ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
if ( * ID != STRING ) { 
if ( * ( ID + INTEGER ) == STRING && ( * ( ID + INTEGER ) == STRING || * ( ID + INTEGER ) == STRING ) ) 
ID += INTEGER ; 
} 
else 
ID += INTEGER ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
while ( * ID != INTEGER && ( ID ( * ID ) ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
int ID = INTEGER ; 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
while ( ID > INTEGER ) { 
if ( * ID == INTEGER ) 
break ; 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
ID ++ ; 
} 
else if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
ID -- ; 
} 
else 
ID ++ ; 
} 
} 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
while ( INTEGER ) { 
if ( * ID == INTEGER ) 
break ; 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
break ; 
} 
ID ++ ; 
} 
} 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) 
while ( * ID != INTEGER && * ID != STRING ) 
ID ++ ; 
if ( * ID == STRING ) 
ID ++ ; 
return ID ; 
} 
void ID ( const char * const ID ) ; 
void ID ( ID ID ) ; 
void ID ( ) { 
ID = new ID ( INTEGER , ID , ID - ID ) ; 
ID = new ID ; 
ID = new ID ; 
ID = new ID ; 
ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID -> ID = ID ; 
} 
void ID ( ) { 
ID = ID -> ID ( ) ; 
ID = ID -> ID ; 
ID = ID -> ID ; 
ID = ID -> ID ; 
ID = ID -> ID ; 
} 
void ID ( ) { 
ID = ID ( ) ; 
} 
void ID ( ) { 
ID = ID ( ) ; 
} 
void ID ( ) { 
if ( ID -> ID ( ID , ID , ID , ID , ID , ID , ID , ID , INTEGER , ID , ID ) < INTEGER ) 
ID ( ID , ID ) ; 
ID << STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID ; 
ID << STRING ; 
} 
void ID ( const char * ID ) { ID = ID ( ID ) ; } 
ID ( ) ; 
} ; 
class ID { 
class ID { 
public : 
unsigned long ID ; 
unsigned long ID ; 
ID * ID ; 
} ; 
ID * ID ; 
public : 
ID ( ) 
{ 
ID = new ID ; 
ID -> ID = ID -> ID = INTEGER ; 
ID -> ID = new ID ; 
ID -> ID -> ID = ID ; 
ID -> ID -> ID = INTEGER ; 
ID -> ID -> ID = ID ; 
} 
void ID ( unsigned long ID ) 
{ 
ID * ID = ID ; 
ID * ID ; 
ID * ID ; 
do 
{ 
if ( ID -> ID == ID ) 
{ 
ID -> ID ++ ; 
return ; 
} 
ID = ID ; 
ID = ID -> ID ; 
} 
while ( ID -> ID <= ID ) ; 
ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = INTEGER ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
} 
void ID ( ) 
{ 
unsigned long ID = ID ( ) ; 
ID * ID = ID ; 
while ( ID -> ID != ID ) 
{ 
if ( ID -> ID != INTEGER ) 
ID << ID -> ID << STRING << ID -> ID << STRING << ( INTEGER * ID -> ID ) / ID << STRING ; 
ID = ID -> ID ; 
} 
} 
unsigned long ID ( unsigned long ID ) 
{ 
ID * ID = ID ; 
while ( ID -> ID != ID && ID -> ID != ID ) 
ID = ID -> ID ; 
return ID -> ID == ID ? ID -> ID : INTEGER ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
if ( ID -> ID != INTEGER ) 
ID ++ ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
ID ++ ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
ID += ID -> ID ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
ID += ID -> ID * ID -> ID ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
} ; 
void ID :: ID ( ID ID ) { 
this -> ID = ID ; 
ID = ID -> ID ( ID , ID , ID ) ; 
ID = ID != ID ; 
} 
bool ID :: ID ( ID ID , ID * ID , ID * ID , ID * ID ) { 
ID ++ ; 
if ( ID -> ID ( ID , ID , ID , ID ) == ID ) { 
ID -> ID ( ID , ID , ID , ID ) ; 
return false ; 
} 
return true ; 
} 
void ID :: ID ( ID ID , ID * ID , ID * ID , ID * ID ) { 
ID ++ ; 
if ( ID -> ID ( ID , ID , ID , ID ) == ID ) { 
ID * ID = ID -> ID ( ID , ID , ID , ID ) ; 
ID -> ID ( ID ) ; 
} 
} 
void ID :: ID ( ID * ID , ID * ID , ID * ID ) { 
ID ++ ; 
if ( ID == ID ) { 
return ; 
} 
if ( ID -> ID . ID ( ID , ID ) == ID ) { 
ID -> ID . ID ( ID , ID ) ; 
} 
for ( ID * ID = ID -> ID . ID ( ) ; ID != ID ; ID = ID -> ID . ID ( ) ) { 
ID * ID = ID :: ID ( ID -> ID , ID -> ID , ID ) ; 
ID :: ID ( ID -> ID , ID -> ID , ID , ID ) ; 
} 
} 
ID * ID :: ID ( ID ID , ID * ID , ID * ID , ID * ID ) { 
ID ++ ; 
ID * ID ; 
if ( ( ID = ID -> ID ( ID , ID ) ) == ID ) { 
ID = ID -> ID ( ID , ID ) ; 
} 
if ( ID != ID && ID -> ID . ID ( ID , ID , ID ) == ID ) { 
ID -> ID . ID ( ID , ID , ID ) ; 
for ( ID * ID = ID -> ID . ID ( ) ; ID != ID ; ID = ID -> ID . ID ( ) ) { 
ID * ID = ID :: ID ( ID , ID , ID -> ID ) ; 
ID :: ID ( ID , ID , ID -> ID -> ID , ID ) ; 
} 
} 
return ID ; 
} 
ID * ID :: ID ( ID * ID ) { 
ID ++ ; 
ID * ID ; 
if ( ( ID = ID -> ID ( ID , ID , ID ) ) == ID ) { 
ID = ID -> ID ( ID , ID , ID ) ; 
} 
return ID ; 
} 
ID * ID :: ID ( ID ID , ID * ID ) { 
ID ++ ; 
ID * ID ; 
if ( ( ID = ID -> ID ( ID , ID , ID + INTEGER ) ) == ID ) { 
ID = ID -> ID ( ID , ID , ID + INTEGER ) ; 
} 
return ID ; 
} 
ID * ID :: ID ( ID ID , ID * ID , ID * ID ) { 
ID ++ ; 
if ( ID [ ID ] ) { 
return ID ; 
} 
ID * ID ; 
ID * ID = ( ID == ID ? ID -> ID : ID -> ID ) ; 
ID ID ; 
if ( ID [ ID ] ) 
ID = ID [ ID ] ? ID [ ID ] : ID [ ID ] ; 
else { 
ID = ID [ ID ] ? ID [ ID ] : ID [ ID ] ; 
} 
if ( ( ID = ID -> ID ( ID , ID , ID -> ID ) ) == ID ) { 
ID = ID -> ID ( ID , ID , ID -> ID ) ; 
} 
if ( ID -> ID . ID ( ID , ID , ID -> ID ) == ID ) { 
ID * ID = ID -> ID . ID ( ID , ID , ID -> ID ) ; 
ID -> ID = ID -> ID ; 
ID -> ID = ID -> ID ; 
} 
return ID ; 
} 
ID * ID :: ID ( ID ID , ID ID , ID * ID ) { 
ID ++ ; 
ID * ID ; 
if ( ( ID = ID -> ID ( ID , ID , ID ) ) == ID ) { 
ID = ID -> ID ( ID , ID , ID ) ; 
} 
if ( ID -> ID . ID ( ID , ID , ID ) == ID ) { 
ID * ID = ID -> ID . ID ( ID , ID , ID ) ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID ( ID ) ; 
} 
return ID ; 
} 
void ID :: ID ( ID * ID ) { 
int ID = INTEGER ; 
if ( ID == ID ) 
return ; 
if ( ID -> ID ) 
return ; 
ID -> ID = true ; 
for ( ID * ID = ID -> ID . ID ( ) ; ID != ID ; ID = ID -> ID . ID ( ) ) { 
ID -> ID = true ; 
ID ++ ; 
if ( ID -> ID != ID ) 
ID ( ID -> ID ( ID -> ID , ID -> ID , ID -> ID ) ) ; 
if ( ID -> ID != ID ) 
ID ( ID -> ID ( ID -> ID , ID -> ID , ID -> ID ) ) ; 
} 
if ( ID > INTEGER ) { 
ID -> ID = true ; 
ID ++ ; 
} 
} 
void ID :: ID ( ) { 
ID = INTEGER ; 
ID ( ID ) ; 
} 
ID ID ; 
int ID ; 
void ID :: ID ( ID * ID , int ID ) { 
if ( ID == ID ) 
return ; 
if ( ID -> ID ) 
return ; 
ID -> ID = true ; 
int ID = INTEGER ; 
for ( ID * ID = ID -> ID . ID ( ) ; ID != ID ; ID = ID -> ID . ID ( ) ) 
ID ++ ; 
ID << STRING << 
ID [ ID -> ID ] << STRING << 
ID [ ID -> ID ] << 
STRING << 
( ID -> ID - ID ) << 
STRING << 
( ID -> ID - ID ) << STRING << 
( ID [ ID -> ID ] == ID ? STRING : STRING ) << 
STRING << ID << STRING << ++ ID << ( ID > INTEGER ? STRING : STRING ) << STRING ; 
for ( ID * ID = ID -> ID . ID ( ) ; ID != ID ; ID = ID -> ID . ID ( ) ) { 
ID << STRING << 
ID [ ID -> ID -> ID ] << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
ID [ ID -> ID ] << 
STRING << 
( ID -> ID - ID ) << 
STRING << 
ID [ ID -> ID ] << 
( ID [ ID -> ID ] == ID ? STRING : ID [ ID -> ID ] == ID ? STRING : ID [ ID -> ID ] == ID ? STRING : STRING ) << 
STRING << 
( ID -> ID - ID ) << 
STRING << ( ID + INTEGER ) << STRING << ++ ID << ( ID > INTEGER ? STRING : STRING ) 
<< ( ID [ ID -> ID -> ID ] == ID ? STRING : STRING ) 
<< STRING << 
STRING << 
ID [ ID -> ID ] << STRING << 
ID [ ID -> ID -> ID ] << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
ID [ ID -> ID -> ID ] << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
ID [ ID -> ID ] << 
STRING << 
( ID -> ID - ID ) << 
STRING ; 
ID -> ID = true ; 
if ( ID -> ID != ID ) { 
ID << 
STRING << 
ID [ ID -> ID -> ID ] << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
ID [ ID -> ID ] << 
STRING << 
( ID -> ID - ID ) << 
STRING << 
ID [ ID -> ID ] << STRING << 
ID [ ID -> ID ] << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
( ID -> ID - ID ) << 
STRING ; 
ID ( ID -> ID ( ID -> ID , ID -> ID , ID -> ID ) , ID + INTEGER ) ; 
} 
if ( ID -> ID != ID ) { 
ID << 
STRING << 
ID [ ID -> ID -> ID ] << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
ID [ ID -> ID ] << 
STRING << 
( ID -> ID - ID ) << 
STRING << 
ID [ ID -> ID ] << STRING << 
ID [ ID -> ID ] << 
STRING << 
( ID -> ID - ID ) << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING ; 
ID ( ID -> ID ( ID -> ID , ID -> ID , ID -> ID ) , ID + INTEGER ) ; 
} 
} 
} 
void ID :: ID ( ID * ID , ID * ID ) { 
ID -> ID ( ) ; 
ID . ID ( STRING ) ; 
ID << 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING ; 
ID = INTEGER ; 
ID ( ID , INTEGER ) ; 
ID -> ID ( ) ; 
ID << STRING ; 
ID . ID ( ) ; 
} 
ID * ID :: ID ( ID * ID , ID * ID , bool ID ) { 
ID * ID ; 
ID * ID = ID ; 
ID * ID = ID ; 
if ( ID == ID ) 
return ID ; 
if ( ID -> ID ) 
return ID ; 
if ( ID == ID ) 
ID = new ID ( ID -> ID ) ; 
else 
ID = new ID ( ID -> ID , ID ) ; 
int ID = INTEGER ; 
ID -> ID = true ; 
for ( ID * ID = ID -> ID . ID ( ) ; ID != ID ; ID = ID -> ID . ID ( ) ) { 
ID ++ ; 
ID -> ID = ID > INTEGER ; 
if ( ( ID -> ID != ID && ID -> ID ( ID -> ID , ID -> ID , ID -> ID ) -> ID ) || 
( ID -> ID != ID && ID -> ID ( ID -> ID , ID -> ID , ID -> ID ) -> ID ) ) 
continue ; 
if ( ID -> ID >= ID ) { 
ID = ID ; 
ID = ID -> ID ; 
} 
} 
if ( ID != ID ) { 
ID -> ID = true ; 
if ( ID -> ID != ID ) 
ID ( ID -> ID ( ID -> ID , ID -> ID , ID -> ID ) , ID , ID ) ; 
if ( ID -> ID != ID ) 
ID ( ID -> ID ( ID -> ID , ID -> ID , ID -> ID ) , ID , ID ) ; 
} 
return ID ; 
}  
$


(*!!!!!*)
ansi_cpp_mult_artsupport
$
(* ART3 grammar generated by ART from 'v2\ansi_cppV2.art' on Jun 10 2018 08:39:42 - AJ multiply out! *)

translation_unit ::=
   # |
   declaration_seq 



abstract_declarator ::=
   direct_abstract_declarator |
   ptr_operator |
   ptr_operator abstract_declarator 

access_specifier ::=
   'private' |
   'protected' |
   'public' 

additive_expression ::=
   multiplicative_expression |
   additive_expression '+' multiplicative_expression |
   additive_expression '-' multiplicative_expression 

and_expression ::=
   equality_expression |
   and_expression '&' equality_expression 

asm_definition ::=
   'asm' '(' string_literal ')' ';' 

assignment_expression ::=
   conditional_expression |
   logical_or_expression assignment_operator assignment_expression |
   throw_expression 

assignment_operator ::=
   '=' |
   '*=' |
   '/=' |
   '%=' |
   '+=' |
   '-=' |
   '>>=' |
   '<<=' |
   '&=' |
   '^=' |
   '|=' 

base_clause ::=
   ':' base_specifier_list 

base_specifier ::=
   class_name |
   nested_name_specifier class_name |
   '::' class_name |
   '::' nested_name_specifier class_name |
   'virtual' class_name |
   'virtual' nested_name_specifier class_name |
   'virtual' '::' class_name |
   'virtual' '::' nested_name_specifier class_name |
   'virtual' access_specifier class_name |
   'virtual' access_specifier nested_name_specifier class_name |
   'virtual' access_specifier '::' class_name |
   'virtual' access_specifier '::' nested_name_specifier class_name |
   access_specifier class_name |
   access_specifier nested_name_specifier class_name |
   access_specifier '::' class_name |
   access_specifier '::' nested_name_specifier class_name |
   access_specifier 'virtual' class_name |
   access_specifier 'virtual' nested_name_specifier class_name |
   access_specifier 'virtual' '::' class_name |
   access_specifier 'virtual' '::' nested_name_specifier class_name 

base_specifier_list ::=
   base_specifier |
   base_specifier_list ',' base_specifier 

block_declaration ::=
   simple_declaration |
   asm_definition |
   namespace_alias_definition |
   using_declaration |
   using_directive 

boolean_literal ::=
   'true' |
   'false' 

cast_expression ::=
   unary_expression |
   '(' type_id ')' cast_expression 

character_literal ::=
   'CHARACTER' 

class_head ::=
   class_key nested_name_specifier identifier |
   class_key nested_name_specifier identifier base_clause |
   class_key |
   class_key base_clause |
   class_key identifier |
   class_key identifier base_clause 

class_key ::=
   'class' |
   'struct' |
   'union' 

class_name ::=
   identifier |
   template_id 

class_or_namespace_name ::=
   class_name |
   namespace_name 

class_specifier ::=
   class_head '{' '}' |
   class_head '{' member_specification '}' 

compound_statement ::=
   '{' '}' |
   '{' statement_seq '}' 

condition ::=
   expression |
   type_specifier_seq declarator '=' assignment_expression 

conditional_expression ::=
   logical_or_expression |
   logical_or_expression '?' expression ':' assignment_expression 

constant_expression ::=
   conditional_expression 

constant_initializer ::=
   '=' constant_expression 

conversion_declarator ::=
   ptr_operator |
   ptr_operator conversion_declarator 

conversion_function_id ::=
   operator conversion_type_id 

conversion_type_id ::=
   type_specifier_seq |
   type_specifier_seq conversion_declarator 

ctor_initializer ::=
   ':' mem_initializer_list 

cv_qualifier ::=
   'const' |
   'volatile' 

cv_qualifier_seq ::=
   cv_qualifier |
   cv_qualifier cv_qualifier_seq 

decl_specifier ::=
   storage_class_specifier |
   type_specifier |
   function_specifier |
   'friend' |
   'typedef' 

decl_specifier_seq ::=
   decl_specifier |
   decl_specifier_seq decl_specifier 

declaration ::=
   block_declaration |
   function_definition |
   template_declaration |
   explicit_instantiation |
   explicit_specialization |
   linkage_specification |
   namespace_definition 

declaration_seq ::=
   declaration |
   declaration_seq declaration 

declaration_statement ::=
   block_declaration 

declarator ::=
   direct_declarator |
   ptr_operator declarator 

declarator_id ::=
   id_expression |
   '::' id_expression |
   type_name |
   nested_name_specifier type_name |
   '::' type_name |
   '::' nested_name_specifier type_name 

delete_expression ::=
   'delete' cast_expression |
   '::' 'delete' cast_expression |
   'delete' '[' ']' cast_expression |
   '::' 'delete' '[' ']' cast_expression 

direct_abstract_declarator ::=
   '(' abstract_declarator ')' |
   '[' ']' |
   '[' constant_expression ']' |
   direct_abstract_declarator '[' ']' |
   direct_abstract_declarator '[' constant_expression ']' |
   '(' parameter_declaration_clause ')' |
   '(' parameter_declaration_clause ')' exception_specification |
   '(' parameter_declaration_clause ')' cv_qualifier_seq |
   '(' parameter_declaration_clause ')' cv_qualifier_seq exception_specification |
   direct_abstract_declarator '(' parameter_declaration_clause ')' |
   direct_abstract_declarator '(' parameter_declaration_clause ')' exception_specification |
   direct_abstract_declarator '(' parameter_declaration_clause ')' cv_qualifier_seq |
   direct_abstract_declarator '(' parameter_declaration_clause ')' cv_qualifier_seq exception_specification 

direct_declarator ::=
   declarator_id |
   '(' declarator ')' |
   direct_declarator '[' ']' |
   direct_declarator '[' constant_expression ']' |
   direct_declarator '(' parameter_declaration_clause ')' |
   direct_declarator '(' parameter_declaration_clause ')' exception_specification |
   direct_declarator '(' parameter_declaration_clause ')' cv_qualifier_seq |
   direct_declarator '(' parameter_declaration_clause ')' cv_qualifier_seq exception_specification 

direct_new_declarator ::=
   '[' expression ']' |
   direct_new_declarator '[' constant_expression ']' 

elaborated_type_specifier ::=
   'typename' nested_name_specifier identifier |
   'typename' '::' nested_name_specifier identifier |
   'typename' nested_name_specifier identifier '<' template_argument_list '>' |
   'typename' '::' nested_name_specifier identifier '<' template_argument_list '>' |
   class_key identifier |
   class_key nested_name_specifier identifier |
   class_key '::' identifier |
   class_key '::' nested_name_specifier identifier |
   'enum' identifier |
   'enum' nested_name_specifier identifier |
   'enum' '::' identifier |
   'enum' '::' nested_name_specifier identifier 

enum_name ::=
   identifier 

enum_specifier ::=
   'enum' '{' '}' |
   'enum' '{' enumerator_list '}' |
   'enum' identifier '{' '}' |
   'enum' identifier '{' enumerator_list '}' 

enumerator ::=
   identifier 

enumerator_definition ::=
   enumerator |
   enumerator '=' constant_expression 

enumerator_list ::=
   enumerator_definition |
   enumerator_list ',' enumerator_definition 

equality_expression ::=
   relational_expression |
   equality_expression '==' relational_expression |
   equality_expression '!=' relational_expression 

exception_declaration ::=
   type_specifier_seq declarator |
   type_specifier_seq abstract_declarator |
   type_specifier_seq |
   '...' 

exception_specification ::=
   'throw' '(' ')' |
   'throw' '(' type_id_list ')' 

exclusive_or_expression ::=
   and_expression |
   exclusive_or_expression '^' and_expression 

explicit_instantiation ::=
   'template' declaration 

explicit_specialization ::=
   'template' '<' '>' declaration 

expression ::=
   assignment_expression |
   expression ',' assignment_expression 

expression_list ::=
   assignment_expression |
   expression_list ',' assignment_expression 

expression_statement ::=
   ';' |
   expression ';' 

extension_namespace_definition ::=
   'namespace' original_namespace_name '{' namespace_body '}' 

floating_literal ::=
   'REAL' 

for_init_statement ::=
   expression_statement |
   simple_declaration 

function_body ::=
   compound_statement 

function_definition ::=
   declarator function_try_block |
   decl_specifier_seq declarator function_try_block |
   declarator function_body |
   declarator ctor_initializer function_body |
   decl_specifier_seq declarator function_body |
   decl_specifier_seq declarator ctor_initializer function_body 

function_specifier ::=
   'inline' |
   'virtual' |
   'explicit' 

function_try_block ::=
   'try' function_body handler_seq |
   'try' ctor_initializer function_body handler_seq 

handler ::=
   'catch' '(' exception_declaration ')' compound_statement 

handler_seq ::=
   handler |
   handler handler_seq 

id_expression ::=
   unqualified_id |
   qualified_id 

identifier ::=
   'ID' 

inclusive_or_expression ::=
   exclusive_or_expression |
   inclusive_or_expression '|' exclusive_or_expression 

init_declarator ::=
   declarator |
   declarator initializer 

init_declarator_list ::=
   init_declarator |
   init_declarator_list ',' init_declarator 

initializer ::=
   '=' initializer_clause |
   '(' expression_list ')' 

initializer_clause ::=
   assignment_expression |
   '{' '}' |
   '{' initializer_list '}' |
   '{' initializer_list ',' '}' 

initializer_list ::=
   initializer_clause |
   initializer_list ',' initializer_clause 

integer_literal ::=
   'INTEGER' 

iteration_statement ::=
   'while' '(' condition ')' statement |
   'do' statement 'while' '(' expression ')' ';' |
   'for' '(' for_init_statement ';' ')' statement |
   'for' '(' for_init_statement ';' expression ')' statement |
   'for' '(' for_init_statement condition ';' ')' statement |
   'for' '(' for_init_statement condition ';' expression ')' statement 

jump_statement ::=
   'break' ';' |
   'continue' ';' |
   'goto' identifier ';' |
   'return' ';' |
   'return' expression ';' 

labeled_statement ::=
   identifier ':' statement |
   'case' constant_expression ':' statement |
   'default' ':' statement 

linkage_specification ::=
   'extern' string_literal declaration |
   'extern' string_literal '{' '}' |
   'extern' string_literal '{' declaration_seq '}' 

literal ::=
   integer_literal |
   character_literal |
   floating_literal |
   string_literal |
   boolean_literal 

logical_and_expression ::=
   inclusive_or_expression |
   logical_and_expression '&&' inclusive_or_expression 

logical_or_expression ::=
   logical_and_expression |
   logical_or_expression '||' logical_and_expression 

mem_initializer ::=
   mem_initializer_id '(' ')' |
   mem_initializer_id '(' expression_list ')' 

mem_initializer_id ::=
   identifier |
   class_name |
   nested_name_specifier class_name |
   '::' class_name |
   '::' nested_name_specifier class_name 

mem_initializer_list ::=
   mem_initializer |
   mem_initializer ',' mem_initializer_list 

member_declaration ::=
   qualified_id ';' |
   using_declaration |
   template_declaration |
   function_definition |
   function_definition ';' |
   ';' |
   member_declarator_list ';' |
   decl_specifier_seq ';' |
   decl_specifier_seq member_declarator_list ';' 

member_declarator ::=
   declarator |
   declarator pure_specifier |
   declarator |
   declarator constant_initializer |
   ':' constant_expression |
   identifier ':' constant_expression 

member_declarator_list ::=
   member_declarator |
   member_declarator_list ',' member_declarator 

member_specification ::=
   member_declaration |
   member_declaration member_specification |
   access_specifier ':' |
   access_specifier ':' member_specification 

multiplicative_expression ::=
   pm_expression |
   multiplicative_expression '*' pm_expression |
   multiplicative_expression '/' pm_expression |
   multiplicative_expression '%' pm_expression 

named_namespace_definition ::=
   original_namespace_definition |
   extension_namespace_definition 

namespace_alias ::=
   identifier 

namespace_alias_definition ::=
   'namespace' identifier '=' qualified_namespace_specifier ';' 

namespace_body ::=
   # |
   declaration_seq 

namespace_definition ::=
   named_namespace_definition |
   unnamed_namespace_definition 

namespace_name ::=
   original_namespace_name |
   namespace_alias 

nested_name_specifier ::=
   class_or_namespace_name '::' |
   class_or_namespace_name '::' nested_name_specifier 

new_declarator ::=
   direct_new_declarator |
   ptr_operator |
   ptr_operator new_declarator 

new_expression ::=
   'new' new_type_id |
   'new' new_type_id new_initializer |
   'new' new_placement new_type_id |
   'new' new_placement new_type_id new_initializer |
   '::' 'new' new_type_id |
   '::' 'new' new_type_id new_initializer |
   '::' 'new' new_placement new_type_id |
   '::' 'new' new_placement new_type_id new_initializer |
   'new' '(' type_id ')' |
   'new' '(' type_id ')' new_initializer |
   'new' new_placement '(' type_id ')' |
   'new' new_placement '(' type_id ')' new_initializer |
   '::' 'new' '(' type_id ')' |
   '::' 'new' '(' type_id ')' new_initializer |
   '::' 'new' new_placement '(' type_id ')' |
   '::' 'new' new_placement '(' type_id ')' new_initializer 

new_initializer ::=
   '(' ')' |
   '(' expression_list ')' 

new_placement ::=
   '(' expression_list ')' 

new_type_id ::=
   type_specifier_seq |
   type_specifier_seq new_declarator 

operator ::=
   'new' |
   'delete' |
   'new[]' |
   'delete[]' |
   '+' |
   '-' |
   '*' |
   '/' |
   '%' |
   '^' |
   '&' |
   '|' |
   '~' |
   '!' |
   '=' |
   '<' |
   '>' |
   '+=' |
   '-=' |
   '*=' |
   '/=' |
   '%=' |
   '^=' |
   '&=' |
   '|=' |
   '<<' |
   '>>' |
   '>>=' |
   '<<=' |
   '==' |
   '!=' |
   '<=' |
   '>=' |
   '&&' |
   '||' |
   '++' |
   '--' |
   ',' |
   '->*' |
   '->' |
   '()' |
   '[]' 

operator_function_id ::=
   operator operator 

original_namespace_definition ::=
   'namespace' identifier '{' namespace_body '}' 

original_namespace_name ::=
   identifier 

parameter_declaration ::=
   decl_specifier_seq declarator |
   decl_specifier_seq declarator '=' assignment_expression |
   decl_specifier_seq |
   decl_specifier_seq abstract_declarator |
   decl_specifier_seq '=' assignment_expression |
   decl_specifier_seq abstract_declarator '=' assignment_expression 

parameter_declaration_clause ::=
   parameter_declaration_list ',' '...' |
   # |
   '...' |
   parameter_declaration_list |
   parameter_declaration_list '...' 

parameter_declaration_list ::=
   parameter_declaration |
   parameter_declaration_list ',' parameter_declaration 

pm_expression ::=
   cast_expression |
   pm_expression '.*' cast_expression |
   pm_expression '->*' cast_expression 

postfix_expression ::=
   primary_expression |
   postfix_expression '[' expression ']' |
   postfix_expression '.' pseudo_destructor_name |
   postfix_expression '->' pseudo_destructor_name |
   postfix_expression '++' |
   postfix_expression '--' |
   'dynamic_cast' '<' type_id '>' '(' expression ')' |
   'static_cast' '<' type_id '>' '(' expression ')' |
   'reinterpret_cast' '<' type_id '>' '(' expression ')' |
   'const_cast' '<' type_id '>' '(' expression ')' |
   'typeid' '(' expression ')' |
   'typeid' '(' type_id ')' |
   postfix_expression '(' ')' |
   postfix_expression '(' expression_list ')' |
   simple_type_specifier '(' ')' |
   simple_type_specifier '(' expression_list ')' |
   postfix_expression '.' id_expression |
   postfix_expression '.' '::' id_expression |
   postfix_expression '.' 'template' id_expression |
   postfix_expression '.' 'template' '::' id_expression |
   postfix_expression '->' id_expression |
   postfix_expression '->' '::' id_expression |
   postfix_expression '->' 'template' id_expression |
   postfix_expression '->' 'template' '::' id_expression 

primary_expression ::=
   literal |
   'this' |
   '::' identifier |
   '::' operator_function_id |
   '::' qualified_id |
   '(' expression ')' |
   id_expression 

pseudo_destructor_name ::=
   type_name '::' '~' type_name |
   nested_name_specifier type_name '::' '~' type_name |
   '::' type_name '::' '~' type_name |
   '::' nested_name_specifier type_name '::' '~' type_name |
   '~' type_name |
   nested_name_specifier '~' type_name |
   '::' '~' type_name |
   '::' nested_name_specifier '~' type_name 

ptr_operator ::=
   '&' |
   '*' |
   '*' cv_qualifier_seq |
   nested_name_specifier '*' |
   nested_name_specifier '*' cv_qualifier_seq |
   '::' nested_name_specifier '*' |
   '::' nested_name_specifier '*' cv_qualifier_seq 

pure_specifier ::=
   '=' '0' 

qualified_id ::=
   nested_name_specifier unqualified_id |
   nested_name_specifier 'template' unqualified_id 

qualified_namespace_specifier ::=
   namespace_name |
   nested_name_specifier namespace_name |
   '::' namespace_name |
   '::' nested_name_specifier namespace_name 

relational_expression ::=
   shift_expression |
   relational_expression '<' shift_expression |
   relational_expression '>' shift_expression |
   relational_expression '<=' shift_expression |
   relational_expression '>=' shift_expression 

selection_statement ::=
   'if' '(' condition ')' statement |
   'if' '(' condition ')' statement 'else' statement |
   'switch' '(' condition ')' statement 

shift_expression ::=
   additive_expression |
   shift_expression '<<' additive_expression |
   shift_expression '>>' additive_expression 

simple_declaration ::=
   ';' |
   init_declarator_list ';' |
   decl_specifier_seq ';' |
   decl_specifier_seq init_declarator_list ';' 

simple_type_specifier ::=
   'char' |
   'wchar_t' |
   'bool' |
   'short' |
   'int' |
   'long' |
   'signed' |
   'unsigned' |
   'float' |
   'double' |
   'void' |
   type_name |
   nested_name_specifier type_name |
   '::' type_name |
   '::' nested_name_specifier type_name 

statement ::=
   labeled_statement |
   expression_statement |
   compound_statement |
   selection_statement |
   iteration_statement |
   jump_statement |
   declaration_statement |
   try_block 

statement_seq ::=
   statement |
   statement_seq statement 

storage_class_specifier ::=
   'auto' |
   'register' |
   'static' |
   'extern' |
   'mutable' 

string_literal ::=
   'STRING' |
   string_literal 'STRING' 

template_argument ::=
   assignment_expression |
   type_id |
   template_name 

template_argument_list ::=
   template_argument |
   template_argument_list ',' template_argument 

template_declaration ::=
   'template' '<' template_parameter_list '>' declaration |
   'export' 'template' '<' template_parameter_list '>' declaration 

template_id ::=
   template_name '<' template_argument_list '>' 

template_name ::=
   identifier 

template_parameter ::=
   type_parameter |
   parameter_declaration 

template_parameter_list ::=
   template_parameter |
   template_parameter_list ',' template_parameter 

throw_expression ::=
   'throw' |
   'throw' assignment_expression 

try_block ::=
   'try' compound_statement handler_seq 

type_id ::=
   type_specifier_seq |
   type_specifier_seq abstract_declarator 

type_id_list ::=
   type_id |
   type_id_list ',' type_id 

type_name ::=
   class_name |
   enum_name |
   typedef_name 

type_parameter ::=
   'class' |
   'class' identifier |
   'class' '=' type_id |
   'class' identifier '=' type_id |
   'typename' |
   'typename' identifier |
   'typename' '=' type_id |
   'typename' identifier '=' type_id |
   'template' '<' template_parameter_list '>' 'class' |
   'template' '<' template_parameter_list '>' 'class' identifier |
   'template' '<' template_parameter_list '>' 'class' '=' template_name |
   'template' '<' template_parameter_list '>' 'class' identifier '=' template_name 

type_specifier ::=
   simple_type_specifier |
   class_specifier |
   enum_specifier |
   elaborated_type_specifier |
   cv_qualifier 

type_specifier_seq ::=
   type_specifier |
   type_specifier type_specifier_seq 

typedef_name ::=
   identifier 

unary_expression ::=
   postfix_expression |
   '++' cast_expression |
   '--' cast_expression |
   unary_operator cast_expression |
   'sizeof' unary_expression |
   'sizeof' '(' type_id ')' |
   new_expression |
   delete_expression 

unary_operator ::=
   '*' |
   '&' |
   '+' |
   '-' |
   '!' |
   '~' 

unnamed_namespace_definition ::=
   'namespace' '{' namespace_body '}' 

unqualified_id ::=
   identifier |
   operator_function_id |
   conversion_function_id |
   '~' class_name |
   template_id 

using_declaration ::=
   'using' '::' unqualified_id ';' |
   'using' nested_name_specifier unqualified_id ';' |
   'using' '::' nested_name_specifier unqualified_id ';' |
   'using' 'typename' nested_name_specifier unqualified_id ';' |
   'using' 'typename' '::' nested_name_specifier unqualified_id ';' 

using_directive ::=
   'using' 'namespace' namespace_name ';' |
   'using' 'namespace' nested_name_specifier namespace_name ';' |
   'using' 'namespace' '::' namespace_name ';' |
   'using' 'namespace' '::' nested_name_specifier namespace_name ';' 

$
accept
$class ID { 
public : 
static ID ID ; 
static int ID ; 
ID ID ; 
enum ID ID ; 
ID * ID ; 
ID * ID ; 
ID ( ID ID ) { 
this -> ID = ID ; ID = ID = ID ; 
} ; 
ID ( ID ID , ID * ID ) { 
this -> ID = ID ; ID = ID ; 
ID * ID = ID -> ID ; 
if ( ID == ID ) 
ID -> ID = this ; 
else { 
while ( ID -> ID != ID ) 
ID = ID -> ID ; 
ID -> ID = this ; 
} 
ID = ID ; 
} ; 
void ID ( ) { 
ID << ID << STRING ; 
if ( ID != ID ) 
ID -> ID ( ) ; 
ID << STRING ; 
if ( ID != ID ) 
ID -> ID ( ) ; 
} ; 
void ID ( int ID , const char * * ID ) ; 
void ID ( const char * ID , const char * * ID ) { 
ID . ID ( ID ) ; 
ID << 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING ; 
ID = INTEGER ; 
this -> ID ( INTEGER , ID ) ; 
ID << STRING ; 
ID . ID ( ) ; 
} ; 
void ID ( ID * ID , const char * * ID ) { 
if ( ID == ID ) 
return ; 
if ( ID -> ID == ID ) 
ID << ID [ ID -> ID ] << STRING ; 
else { 
ID << STRING ; 
ID ( ID -> ID , ID ) ; 
ID << STRING ; 
} 
if ( ID -> ID != ID ) 
ID ( ID -> ID , ID ) ; 
} 
void ID ( const char * ID , ID * ID , const char * * ID ) { 
ID . ID ( ID ) ; 
ID ( ID , ID ) ; 
ID . ID ( ) ; 
} 
} ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID * ID ; int ID : INTEGER ; int ID : INTEGER ; ID ID ; ID ( ) { ID . ID = ID . ID = ID ; } ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID * ID ; ID ID ; ID * ID ; ID ID ; ID ID ; int ID : INTEGER ; } ; 
class ID { public : ID ID ; struct ID * ID ; struct ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID ID ; ID ID ; ID ( ) { ID . ID = ID . ID = ID . ID = ID . ID = ID ; } ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { 
public : 
ID ID ; 
bool ID ; 
ID ID ; 
ID ID ; 
const char * ID ; 
const char * ID ; 
const char * ID ; 
const char * ID ; 
ID * ID ; 
int ID ; 
const char * * ID ; 
const char * * ID ; 
ID * ID ; 
ID * ID ; 
ID ID ; 
const char * * ID ; 
const char * * ID ; 
bool * ID ; 
bool * ID ; 
int ID ; 
enum ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
bool * ID ; 
bool * ID ; 
bool * ID ; 
bool * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
ID * ID ( ID * ID ) ; 
ID * ID ( ID ID , ID * ID ) ; 
ID * ID ( ID ID , ID * ID , ID * ID ) ; 
ID * ID ( ID ID , ID ID , ID * ID ) ; 
ID * ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
void ID ( ID * ID , ID * ID , ID * ID ) ; 
void ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
bool ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
ID * ID ( ID * ID , ID * ID , bool ID ) ; 
void ID ( ID * ID , int ID ) ; 
void ID ( ID * ID , ID * ID ) ; 
void ID ( ) ; 
void ID ( ID * ID ) ; 
void ID ( const char * ID , ID * ID , int * ID ) ; 
const char * ID ( const char * ID ) ; 
const char * ID ( const char * ID , const char * ID ) { 
const char * ID = ID ; 
while ( * ID != INTEGER && * ID == * ID ) { 
ID ++ ; 
ID ++ ; 
} 
if ( * ID == INTEGER ) 
return ID ; 
else 
return ID ; 
} 
const char ID ( const char ID ) { return ( ID >= ( const char ) STRING && ID <= ( const char ) STRING ) ? ( const char ) ( ID + INTEGER ) : ID ; } 
const char * ID ( const char * ID , const char * ID ) { 
const char * ID = ID ; 
while ( * ID != INTEGER && ID ( * ID ) == ID ( * ID ) ) { 
ID ++ ; 
ID ++ ; 
} 
if ( * ID == INTEGER ) 
return ID ; 
else 
return ID ; 
} 
bool ID ( const char * ID ) { 
ID = new ID [ ID ( ID ) + INTEGER ] ; 
ID = new const char * [ ID ( ID ) + INTEGER ] ; 
ID = new const char * [ ID ( ID ) + INTEGER ] ; 
const char * ID = ID ; 
ID = ID ; 
ID ID ; 
ID = ID ( ID ) ; 
while ( INTEGER ) { 
if ( * ID == INTEGER ) { 
* ID = ID ; 
ID = ID ; 
ID = ID - ID ; 
return true ; 
} 
int ID = INTEGER ; 
const char * ID ; 
for ( ID ID = ( ID ) INTEGER ; ID != ID ; ID = ( ID ) ( ( int ) ID + INTEGER ) ) { 
if ( ID [ ID ] ) 
ID = ID ( ID [ ID ] , ID ) ; 
else 
ID = ID ( ID [ ID ] , ID ) ; 
int ID = ID - ID ; 
if ( ID > ID ) { 
ID = ID ; 
ID = ID ; 
} 
} 
ID ( ID , & ID , & ID ) ; 
if ( ID == INTEGER ) { 
ID << STRING << ( ID - ID ) << STRING << ( int ) * ID << STRING << * ID << STRING ; 
* ID = ID ; 
ID = ID ; 
return false ; 
} 
ID [ ID - ID ] = ID ; 
ID += ID ; 
ID [ ID - ID ] = ID ; 
* ID ++ = ID ; 
if ( ID [ ID ] ) { 
ID = ID ( ID ) ; 
} 
} 
} 
const char * ID ( const char * ID ) { 
if ( ID ( * ID ) || * ID == STRING ) 
while ( ID ( * ID ) || * ID == STRING || * ID == STRING || * ID == STRING ) 
ID ++ ; 
return ID ; 
} 
bool ID ( const char * ID ) { 
return 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING ; 
} 
bool ID ( const char * ID ) { 
return 
* ID == STRING || * ID == STRING || * ID == STRING ; 
} 
bool ID ( const char * ID ) { 
return 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ID ( ID ) ) 
return ID ; 
ID ++ ; 
while ( ID ( ID ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ID ( ID ) ) 
return ID ; 
ID ++ ; 
while ( ID ( ID ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ID ( * ID ) || * ID == STRING ) 
while ( ID ( * ID ) || * ID == STRING ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
bool ID = ( * ID == STRING && ( * ( ID + INTEGER ) == STRING || * ( ID + INTEGER ) == STRING ) ) ; 
if ( ID ) ID += INTEGER ; 
while ( ( ID ? ID ( * ID ) : ID ( * ID ) ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ID ( * ID ) ) 
return ID ; 
while ( ID ( * ID ) ) 
ID ++ ; 
if ( * ID != STRING ) 
return ID ; 
ID ++ ; 
while ( ID ( * ID ) ) 
ID ++ ; 
if ( * ID == STRING || * ID == STRING ) { 
ID ++ ; 
while ( ID ( * ID ) ) 
ID ++ ; 
} 
return ID ; 
} 
const char * ID ( const char * ID ) { 
const char * ID = ID ; 
if ( * ID != STRING ) 
return ID ; 
ID ++ ; 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
if ( * ID != STRING ) 
return ID ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( * ID != STRING ) ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( * ID != STRING ) ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( * ID != STRING ) ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ( ( * ID == STRING ) && ( * ( ID + INTEGER ) == STRING ) ) ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( ! ( ( * ID == STRING ) && ( * ( ID + INTEGER ) == STRING ) ) ) ; 
ID ++ ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
if ( * ID != STRING ) { 
if ( * ( ID + INTEGER ) == STRING && ( * ( ID + INTEGER ) == STRING || * ( ID + INTEGER ) == STRING ) ) 
ID += INTEGER ; 
} 
else 
ID += INTEGER ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
while ( * ID != INTEGER && ( ID ( * ID ) ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
int ID = INTEGER ; 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
while ( ID > INTEGER ) { 
if ( * ID == INTEGER ) 
break ; 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
ID ++ ; 
} 
else if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
ID -- ; 
} 
else 
ID ++ ; 
} 
} 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
while ( INTEGER ) { 
if ( * ID == INTEGER ) 
break ; 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
break ; 
} 
ID ++ ; 
} 
} 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) 
while ( * ID != INTEGER && * ID != STRING ) 
ID ++ ; 
if ( * ID == STRING ) 
ID ++ ; 
return ID ; 
} 
void ID ( const char * const ID ) ; 
void ID ( ID ID ) ; 
void ID ( ) { 
ID = new ID ( INTEGER , ID , ID - ID ) ; 
ID = new ID ; 
ID = new ID ; 
ID = new ID ; 
ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID -> ID = ID ; 
} 
void ID ( ) { 
ID = ID -> ID ( ) ; 
ID = ID -> ID ; 
ID = ID -> ID ; 
ID = ID -> ID ; 
ID = ID -> ID ; 
} 
void ID ( ) { 
ID = ID ( ) ; 
} 
void ID ( ) { 
ID = ID ( ) ; 
} 
void ID ( ) { 
if ( ID -> ID ( ID , ID , ID , ID , ID , ID , ID , ID , INTEGER , ID , ID ) < INTEGER ) 
ID ( ID , ID ) ; 
ID << STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID ; 
ID << STRING ; 
} 
void ID ( const char * ID ) { ID = ID ( ID ) ; } 
ID ( ) ; 
} ; 
class ID { 
class ID { 
public : 
unsigned long ID ; 
unsigned long ID ; 
ID * ID ; 
} ; 
ID * ID ; 
public : 
ID ( ) 
{ 
ID = new ID ; 
ID -> ID = ID -> ID = INTEGER ; 
ID -> ID = new ID ; 
ID -> ID -> ID = ID ; 
ID -> ID -> ID = INTEGER ; 
ID -> ID -> ID = ID ; 
} 
void ID ( unsigned long ID ) 
{ 
ID * ID = ID ; 
ID * ID ; 
ID * ID ; 
do 
{ 
if ( ID -> ID == ID ) 
{ 
ID -> ID ++ ; 
return ; 
} 
ID = ID ; 
ID = ID -> ID ; 
} 
while ( ID -> ID <= ID ) ; 
ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = INTEGER ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
} 
void ID ( ) 
{ 
unsigned long ID = ID ( ) ; 
ID * ID = ID ; 
while ( ID -> ID != ID ) 
{ 
if ( ID -> ID != INTEGER ) 
ID << ID -> ID << STRING << ID -> ID << STRING << ( INTEGER * ID -> ID ) / ID << STRING ; 
ID = ID -> ID ; 
} 
} 
unsigned long ID ( unsigned long ID ) 
{ 
ID * ID = ID ; 
while ( ID -> ID != ID && ID -> ID != ID ) 
ID = ID -> ID ; 
return ID -> ID == ID ? ID -> ID : INTEGER ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
if ( ID -> ID != INTEGER ) 
ID ++ ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
ID ++ ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
ID += ID -> ID ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
ID += ID -> ID * ID -> ID ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
} ; 
enum ID { ID , ID , ID , ID , ID , ID } ; 
enum ID { ID , ID , ID , ID , ID , ID } ; 
void ID ( struct ID * * ID , int ID , const char * * ID , enum ID * ID ) ; 
enum ID { ID , ID , ID , ID , ID , ID , ID } ; 
struct ID { ID ID ; struct ID * ID ; } ; 
struct ID { ID * ID ; ID * ID ; } ; 
class ID { 
public : 
ID ( ) { ID = ID = ID ; } ; 
static ID * ID ; 
static unsigned ID ; 
static unsigned ID ; 
static unsigned ID ; 
static struct ID * * ID ; 
struct ID * ID ; 
struct ID * ID ; 
ID ( unsigned ID , ID * ID , int ID ) { 
ID = ID ; 
ID = ID ; 
ID = INTEGER ; 
for ( int ID = INTEGER ; ID < ID ; ID ++ ) 
ID *= INTEGER ; 
ID = new ID * [ ID ] ; 
ID = ID - INTEGER ; 
ID ( ID , INTEGER , ID * sizeof ( ID * ) ) ; 
ID = ID = ID ; 
} 
unsigned ID ( ID ID , ID ID , ID ID , ID ID , ID * ID , ID * ID , ID * ID , ID * ID ) { 
return ( ID * ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID + 
( ID - ID ) * ID * ID * ID + 
( ID - ID ) * ID * ID + 
( ID - ID ) * ID + 
( ID - ID ) ) & ID ; 
} 
unsigned ID ( ID ID , ID ID , ID ID , ID * ID , ID * ID , ID * ID ) { 
return ( ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID + 
ID * ID * ID * ID + 
( ID - ID ) * ID * ID + 
( ID - ID ) * ID + 
( ID - ID ) ) & ID ; 
} 
unsigned ID ( ID ID , ID ID , ID * ID , ID * ID ) { 
return ( ID * ID * ID * ID + 
ID * ID * ID + 
( ID - ID ) * ID + 
( ID - ID ) ) & ID ; 
} 
unsigned ID ( ID ID , ID ID , ID * ID ) { 
return ( ID * ID * ID + 
ID * ID + 
( ID - ID ) ) & ID ; 
} 
bool ID ( ) ; 
void ID ( struct ID * ID ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ID ID , struct ID * ID , ID * ID , struct ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID ID , struct ID * ID , ID * ID , struct ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID * ID ) ; 
void ID ( ID * ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID ID , ID * ID ) ; 
void ID ( struct ID * ID ) ; 
struct ID * ID ( ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
void ID ( ) ; 
void ID ( ) ; 
int ID ( const char * ID , const char * ID , const char * ID , const char * ID , ID * ID , int ID , ID * ID , bool ID , double ID , const char * * ID , enum ID * ID ) ; 
void ID ( ) ; 
} ; 
class ID { 
public : 
static ID ID ; 
static int ID ; 
ID ID ; 
enum ID ID ; 
ID * ID ; 
ID * ID ; 
ID ( ID ID ) { 
this -> ID = ID ; ID = ID = ID ; 
} ; 
ID ( ID ID , ID * ID ) { 
this -> ID = ID ; ID = ID ; 
ID * ID = ID -> ID ; 
if ( ID == ID ) 
ID -> ID = this ; 
else { 
while ( ID -> ID != ID ) 
ID = ID -> ID ; 
ID -> ID = this ; 
} 
ID = ID ; 
} ; 
void ID ( ) { 
ID << ID << STRING ; 
if ( ID != ID ) 
ID -> ID ( ) ; 
ID << STRING ; 
if ( ID != ID ) 
ID -> ID ( ) ; 
} ; 
void ID ( int ID , const char * * ID ) ; 
void ID ( const char * ID , const char * * ID ) { 
ID . ID ( ID ) ; 
ID << 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING ; 
ID = INTEGER ; 
this -> ID ( INTEGER , ID ) ; 
ID << STRING ; 
ID . ID ( ) ; 
} ; 
void ID ( ID * ID , const char * * ID ) { 
if ( ID == ID ) 
return ; 
if ( ID -> ID == ID ) 
ID << ID [ ID -> ID ] << STRING ; 
else { 
ID << STRING ; 
ID ( ID -> ID , ID ) ; 
ID << STRING ; 
} 
if ( ID -> ID != ID ) 
ID ( ID -> ID , ID ) ; 
} 
void ID ( const char * ID , ID * ID , const char * * ID ) { 
ID . ID ( ID ) ; 
ID ( ID , ID ) ; 
ID . ID ( ) ; 
} 
} ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID * ID ; int ID : INTEGER ; int ID : INTEGER ; ID ID ; ID ( ) { ID . ID = ID . ID = ID ; } ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID * ID ; ID ID ; ID * ID ; ID ID ; ID ID ; int ID : INTEGER ; } ; 
class ID { public : ID ID ; struct ID * ID ; struct ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID ID ; ID ID ; ID ( ) { ID . ID = ID . ID = ID . ID = ID . ID = ID ; } ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { 
public : 
ID ID ; 
bool ID ; 
ID ID ; 
ID ID ; 
const char * ID ; 
const char * ID ; 
const char * ID ; 
const char * ID ; 
ID * ID ; 
int ID ; 
const char * * ID ; 
const char * * ID ; 
ID * ID ; 
ID * ID ; 
ID ID ; 
const char * * ID ; 
const char * * ID ; 
bool * ID ; 
bool * ID ; 
int ID ; 
enum ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
bool * ID ; 
bool * ID ; 
bool * ID ; 
bool * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
ID * ID ( ID * ID ) ; 
ID * ID ( ID ID , ID * ID ) ; 
ID * ID ( ID ID , ID * ID , ID * ID ) ; 
ID * ID ( ID ID , ID ID , ID * ID ) ; 
ID * ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
void ID ( ID * ID , ID * ID , ID * ID ) ; 
void ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
bool ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
ID * ID ( ID * ID , ID * ID , bool ID ) ; 
void ID ( ID * ID , int ID ) ; 
void ID ( ID * ID , ID * ID ) ; 
void ID ( ) ; 
void ID ( ID * ID ) ; 
void ID ( const char * ID , ID * ID , int * ID ) ; 
const char * ID ( const char * ID ) ; 
const char * ID ( const char * ID , const char * ID ) { 
const char * ID = ID ; 
while ( * ID != INTEGER && * ID == * ID ) { 
ID ++ ; 
ID ++ ; 
} 
if ( * ID == INTEGER ) 
return ID ; 
else 
return ID ; 
} 
const char ID ( const char ID ) { return ( ID >= ( const char ) STRING && ID <= ( const char ) STRING ) ? ( const char ) ( ID + INTEGER ) : ID ; } 
const char * ID ( const char * ID , const char * ID ) { 
const char * ID = ID ; 
while ( * ID != INTEGER && ID ( * ID ) == ID ( * ID ) ) { 
ID ++ ; 
ID ++ ; 
} 
if ( * ID == INTEGER ) 
return ID ; 
else 
return ID ; 
} 
bool ID ( const char * ID ) { 
ID = new ID [ ID ( ID ) + INTEGER ] ; 
ID = new const char * [ ID ( ID ) + INTEGER ] ; 
ID = new const char * [ ID ( ID ) + INTEGER ] ; 
const char * ID = ID ; 
ID = ID ; 
ID ID ; 
ID = ID ( ID ) ; 
while ( INTEGER ) { 
if ( * ID == INTEGER ) { 
* ID = ID ; 
ID = ID ; 
ID = ID - ID ; 
return true ; 
} 
int ID = INTEGER ; 
const char * ID ; 
for ( ID ID = ( ID ) INTEGER ; ID != ID ; ID = ( ID ) ( ( int ) ID + INTEGER ) ) { 
if ( ID [ ID ] ) 
ID = ID ( ID [ ID ] , ID ) ; 
else 
ID = ID ( ID [ ID ] , ID ) ; 
int ID = ID - ID ; 
if ( ID > ID ) { 
ID = ID ; 
ID = ID ; 
} 
} 
ID ( ID , & ID , & ID ) ; 
if ( ID == INTEGER ) { 
ID << STRING << ( ID - ID ) << STRING << ( int ) * ID << STRING << * ID << STRING ; 
* ID = ID ; 
ID = ID ; 
return false ; 
} 
ID [ ID - ID ] = ID ; 
ID += ID ; 
ID [ ID - ID ] = ID ; 
* ID ++ = ID ; 
if ( ID [ ID ] ) { 
ID = ID ( ID ) ; 
} 
} 
} 
const char * ID ( const char * ID ) { 
if ( ID ( * ID ) || * ID == STRING ) 
while ( ID ( * ID ) || * ID == STRING || * ID == STRING || * ID == STRING ) 
ID ++ ; 
return ID ; 
} 
bool ID ( const char * ID ) { 
return 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING ; 
} 
bool ID ( const char * ID ) { 
return 
* ID == STRING || * ID == STRING || * ID == STRING ; 
} 
bool ID ( const char * ID ) { 
return 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ID ( ID ) ) 
return ID ; 
ID ++ ; 
while ( ID ( ID ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ID ( ID ) ) 
return ID ; 
ID ++ ; 
while ( ID ( ID ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ID ( * ID ) || * ID == STRING ) 
while ( ID ( * ID ) || * ID == STRING ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
bool ID = ( * ID == STRING && ( * ( ID + INTEGER ) == STRING || * ( ID + INTEGER ) == STRING ) ) ; 
if ( ID ) ID += INTEGER ; 
while ( ( ID ? ID ( * ID ) : ID ( * ID ) ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ID ( * ID ) ) 
return ID ; 
while ( ID ( * ID ) ) 
ID ++ ; 
if ( * ID != STRING ) 
return ID ; 
ID ++ ; 
while ( ID ( * ID ) ) 
ID ++ ; 
if ( * ID == STRING || * ID == STRING ) { 
ID ++ ; 
while ( ID ( * ID ) ) 
ID ++ ; 
} 
return ID ; 
} 
const char * ID ( const char * ID ) { 
const char * ID = ID ; 
if ( * ID != STRING ) 
return ID ; 
ID ++ ; 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
if ( * ID != STRING ) 
return ID ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( * ID != STRING ) ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( * ID != STRING ) ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( * ID != STRING ) ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ( ( * ID == STRING ) && ( * ( ID + INTEGER ) == STRING ) ) ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( ! ( ( * ID == STRING ) && ( * ( ID + INTEGER ) == STRING ) ) ) ; 
ID ++ ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
if ( * ID != STRING ) { 
if ( * ( ID + INTEGER ) == STRING && ( * ( ID + INTEGER ) == STRING || * ( ID + INTEGER ) == STRING ) ) 
ID += INTEGER ; 
} 
else 
ID += INTEGER ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
while ( * ID != INTEGER && ( ID ( * ID ) ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
int ID = INTEGER ; 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
while ( ID > INTEGER ) { 
if ( * ID == INTEGER ) 
break ; 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
ID ++ ; 
} 
else if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
ID -- ; 
} 
else 
ID ++ ; 
} 
} 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
while ( INTEGER ) { 
if ( * ID == INTEGER ) 
break ; 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
break ; 
} 
ID ++ ; 
} 
} 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) 
while ( * ID != INTEGER && * ID != STRING ) 
ID ++ ; 
if ( * ID == STRING ) 
ID ++ ; 
return ID ; 
} 
void ID ( const char * const ID ) ; 
void ID ( ID ID ) ; 
void ID ( ) { 
ID = new ID ( INTEGER , ID , ID - ID ) ; 
ID = new ID ; 
ID = new ID ; 
ID = new ID ; 
ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID -> ID = ID ; 
} 
void ID ( ) { 
ID = ID -> ID ( ) ; 
ID = ID -> ID ; 
ID = ID -> ID ; 
ID = ID -> ID ; 
ID = ID -> ID ; 
} 
void ID ( ) { 
ID = ID ( ) ; 
} 
void ID ( ) { 
ID = ID ( ) ; 
} 
void ID ( ) { 
if ( ID -> ID ( ID , ID , ID , ID , ID , ID , ID , ID , INTEGER , ID , ID ) < INTEGER ) 
ID ( ID , ID ) ; 
ID << STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID ; 
ID << STRING ; 
} 
void ID ( const char * ID ) { ID = ID ( ID ) ; } 
ID ( ) ; 
} ; 
class ID { 
class ID { 
public : 
unsigned long ID ; 
unsigned long ID ; 
ID * ID ; 
} ; 
ID * ID ; 
public : 
ID ( ) 
{ 
ID = new ID ; 
ID -> ID = ID -> ID = INTEGER ; 
ID -> ID = new ID ; 
ID -> ID -> ID = ID ; 
ID -> ID -> ID = INTEGER ; 
ID -> ID -> ID = ID ; 
} 
void ID ( unsigned long ID ) 
{ 
ID * ID = ID ; 
ID * ID ; 
ID * ID ; 
do 
{ 
if ( ID -> ID == ID ) 
{ 
ID -> ID ++ ; 
return ; 
} 
ID = ID ; 
ID = ID -> ID ; 
} 
while ( ID -> ID <= ID ) ; 
ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = INTEGER ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
} 
void ID ( ) 
{ 
unsigned long ID = ID ( ) ; 
ID * ID = ID ; 
while ( ID -> ID != ID ) 
{ 
if ( ID -> ID != INTEGER ) 
ID << ID -> ID << STRING << ID -> ID << STRING << ( INTEGER * ID -> ID ) / ID << STRING ; 
ID = ID -> ID ; 
} 
} 
unsigned long ID ( unsigned long ID ) 
{ 
ID * ID = ID ; 
while ( ID -> ID != ID && ID -> ID != ID ) 
ID = ID -> ID ; 
return ID -> ID == ID ? ID -> ID : INTEGER ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
if ( ID -> ID != INTEGER ) 
ID ++ ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
ID ++ ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
ID += ID -> ID ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
ID += ID -> ID * ID -> ID ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
} ; 
unsigned ID :: ID ; 
unsigned ID :: ID ; 
ID * ID :: ID ; 
unsigned ID :: ID ; 
ID * * ID :: ID ; 
void ID :: ID ( ) { 
} 
int ID :: ID ( const char * ID , const char * ID , const char * ID , const char * ID , ID * ID , int ID , ID * ID , bool ID , double ID , const char * * ID , enum ID * ID ) { 
ID = STRING ; 
int ID = INTEGER ; 
int ID = INTEGER ; 
int ID = INTEGER ; 
int ID = INTEGER ; 
int ID = INTEGER ; 
int ID = INTEGER ; 
int ID = INTEGER ; 
int ID = INTEGER ; 
int ID = INTEGER ; 
int ID = INTEGER ; 
ID * ID = new ID ( ) ; 
int * ID = new int [ ID - ID + INTEGER ] ; 
for ( int ID = INTEGER ; ID < ID - ID + INTEGER ; ID ++ ) 
ID [ ID ] = INTEGER ; 
for ( int ID = INTEGER ; ID < ID :: ID ; ID ++ ) { 
unsigned long ID = INTEGER ; 
for ( ID * ID = ID :: ID [ ID ] ; ID != ID ; ID = ID -> ID ) { 
ID ++ ; 
ID * ID ; 
switch ( ID -> ID ) { 
case ID : ID ++ ; break ; 
case ID : 
ID ++ ; 
if ( ID < ( ( ID * ) ID ) -> ID - ID ) 
ID = ( ( ID * ) ID ) -> ID - ID ; 
for ( ID = ( ( ID * ) ID ) -> ID . ID ( ) ; ID != ID ; ID = ( ( ID * ) ID ) -> ID . ID ( ) ) { 
ID ++ ; 
if ( ID -> ID != ID ) 
ID ++ ; 
if ( ID -> ID != ID ) 
ID ++ ; 
} 
break ; 
case ID : ID ++ ; break ; 
case ID : ID ++ ; break ; 
case ID : ID ++ ; break ; 
case ID : ID ++ ; ID [ ( ( ID * ) ID ) -> ID - ID ] ++ ; break ; 
case ID : ID ++ ; break ; 
default : ID << STRING << ID -> ID << STRING ; 
} 
} 
} 
for ( int ID = INTEGER ; ID < ( ID - ID + INTEGER ) ; ID ++ ) { 
if ( ID [ ID ] > ID ) 
ID = ID [ ID ] ; 
} 
if ( ID < INTEGER ) { 
ID << STRING ; 
ID ID ; 
ID . ID ( STRING ) ; 
ID << 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING << 
STRING << 
STRING ; 
for ( int ID = INTEGER ; ID < ID :: ID ; ID ++ ) { 
for ( ID * ID = ID :: ID [ ID ] ; ID != ID ; ID = ID -> ID ) { 
ID * ID = ( ID * ) ID ; 
ID * ID = ( ID * ) ID ; 
switch ( ID -> ID ) { 
case ID : ID << STRING << 
ID [ ID -> ID -> ID ] << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
ID [ ID -> ID -> ID ] << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
ID [ ID -> ID -> ID ] << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING ; 
break ; 
case ID : ID << STRING << 
ID [ ID -> ID ] << 
STRING << 
( ID -> ID - ID ) << 
STRING << 
( ID -> ID - ID ) << 
STRING << 
( int ) ( ID -> ID ) << 
STRING ; 
break ; 
} 
} 
} 
ID << STRING ; 
ID . ID ( ) ; 
} 
if ( ! ID ) { 
for ( int ID = INTEGER ; ID < ( ID - ID ) ; ID ++ ) 
ID << ID << STRING << ID [ ID ] << STRING << ID [ ID [ ID ] ] << STRING ; 
ID << STRING << ID << STRING << ( ID == INTEGER ? STRING : STRING ) ; 
} 
double ID = ID > REAL ? ( ( double ) ( ID - ID ) ) / ID : INTEGER ; 
ID << ( ID ? STRING : STRING ) << STRING << ID << STRING << ID << STRING << 
ID << STRING << ID << STRING << ( ID - ID ) << STRING << 
ID 
<< STRING << ID << 
STRING << ID << 
STRING << ID << STRING << ID << STRING << ID << STRING << ID << 
STRING << ID << STRING << ID << STRING << ID << 
STRING << ID << 
STRING << ID 
; 
return ID ; 
} 
bool ID :: ID ( ) { 
return ID == ID ; 
} 
void ID :: ID ( struct ID * ID ) { 
ID * ID = new ID ; 
ID -> ID = ( ID * ) ID ; 
ID -> ID = ID ; 
ID = ID ; 
} 
void ID :: ID ( struct ID * ID ) { 
ID * ID = new ID ; 
ID -> ID = ( ID * ) ID ; 
ID -> ID = ID ; 
ID = ID ; 
} 
ID * ID :: ID ( ) { 
ID * ID = ID ; 
ID = ID -> ID ; 
return ( ID * ) ID -> ID ; 
} 
ID * ID :: ID ( ID ID , ID * ID , ID * ID , ID * ID ) { 
int ID = ID ( ID , ID , ID -> ID , ID -> ID , ID -> ID , ID , ID -> ID , ID -> ID ) ; 
for ( ID * ID = ( ID * ) ID :: ID [ ID ] ; 
ID != ID ; 
ID = ( ID * ) ID -> ID ) 
if ( ID -> ID == ID && ID -> ID == ID && ID -> ID == ID && ID -> ID == ID && ID -> ID == ID ) 
return ID ; 
return ID ; 
} 
ID * ID :: ID ( ID ID , ID * ID , ID * ID , ID * ID ) { 
int ID = ID ( ID , ID , ID -> ID , ID -> ID , ID -> ID , ID , ID -> ID , ID -> ID ) ; 
ID * ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = ID :: ID [ ID ] ; 
ID :: ID [ ID ] = ( ID * ) ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
return ID ; 
} 
ID * ID :: ID ( ID ID , ID * ID , ID * ID , ID * ID ) { 
int ID = ID ( ID , ID , ID -> ID , ID -> ID , ID -> ID , ID , ID -> ID , ID -> ID ) ; 
for ( ID * ID = ( ID * ) ID :: ID [ ID ] ; 
ID != ID ; 
ID = ( ID * ) ID -> ID ) 
if ( ID -> ID == ID && ID -> ID == ID && ID -> ID == ID && ID -> ID == ID && ID -> ID == ID ) 
return ID ; 
return ID ; 
} 
ID * ID :: ID ( ID ID , ID * ID , ID * ID , ID * ID ) { 
int ID = ID ( ID , ID , ID -> ID , ID -> ID , ID -> ID , ID , ID -> ID , ID -> ID ) ; 
ID * ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = ID :: ID [ ID ] ; 
ID :: ID [ ID ] = ( ID * ) ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
return ID ; 
} 
ID * ID :: ID ( ID * ID , ID * ID ) { 
int ID = ID ( ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID ) ; 
for ( ID * ID = ( ID * ) ID :: ID [ ID ] ; 
ID != ID ; 
ID = ( ID * ) ID -> ID ) 
if ( ID -> ID == ID && 
ID -> ID -> ID == ID -> ID && ID -> ID -> ID == ID -> ID && 
ID -> ID -> ID == ID -> ID && ID -> ID -> ID == ID -> ID && ID -> ID -> ID == ID -> ID ) 
return ID ; 
return ID ; 
} 
void ID :: ID ( ID * ID , ID * ID ) { 
int ID = ID ( ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID ) ; 
ID * ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = ID :: ID [ ID ] ; 
ID :: ID [ ID ] = ( ID * ) ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID * ID = new ID ; 
ID -> ID = ( ID * ) ID ; 
ID -> ID = ID ; 
ID = ID ; 
} 
ID * ID :: ID ( ID ID , ID * ID ) { 
int ID = ID ( ID , ID , ID ) ; 
for ( ID * ID = ( ID * ) ID :: ID [ ID ] ; 
ID != ID ; 
ID = ( ID * ) ID -> ID ) 
if ( ID -> ID == ID && ID -> ID == ID && ID -> ID == ID ) 
return ID ; 
return ID ; 
} 
ID * ID :: ID ( ID ID , ID * ID ) { 
int ID = ID ( ID , ID , ID ) ; 
ID * ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = ID :: ID [ ID ] ; 
ID :: ID [ ID ] = ( ID * ) ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
return ID ; 
} 
ID * ID :: ID ( ID ID , ID * ID , ID * ID ) { 
int ID = ID ( ID , ID , ID , ID ) ; 
for ( ID * ID = ( ID * ) ID :: ID [ ID ] ; 
ID != ID ; 
ID = ( ID * ) ID -> ID ) 
if ( ID -> ID == ID && ID -> ID == ID && ID -> ID == ID && ID -> ID == ID ) { 
return ID ; 
} 
return ID ; 
} 
ID * ID :: ID ( ID ID , ID * ID , ID * ID ) { 
int ID = ID ( ID , ID , ID , ID ) ; 
ID * ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = ID :: ID [ ID ] ; 
ID :: ID [ ID ] = ( ID * ) ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
return ID ; 
} 
ID * ID :: ID ( ID * ID , ID ID , ID * ID ) { 
int ID = ID ( ID , ID -> ID , ID , ID -> ID , ID -> ID , ID ) ; 
for ( ID * ID = ( ID * ) ID :: ID [ ID ] ; 
ID != ID ; 
ID = ( ID * ) ID -> ID ) 
if ( ID -> ID == ID && ID -> ID == ID && ID -> ID == ID && ID -> ID == ID ) 
return ID ; 
return ID ; 
} 
ID * ID :: ID ( ID * ID , ID ID , ID * ID ) { 
int ID = ID ( ID , ID -> ID , ID , ID -> ID , ID -> ID , ID ) ; 
ID * ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = ID :: ID [ ID ] ; 
ID :: ID [ ID ] = ( ID * ) ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID . ID ( ID ) ; 
return ID ; 
} 
ID * ID :: ID ( ID * ID , ID * ID , ID * ID ) { 
int ID = ID ( ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID ) ; 
for ( ID * ID = ( ID * ) ID :: ID [ ID ] ; 
ID != ID ; 
ID = ( ID * ) ID -> ID ) 
if ( ID -> ID == ID && ID -> ID == ID && ID -> ID == ID && ID -> ID == ID ) 
return ID ; 
return ID ; 
} 
ID * ID :: ID ( ID * ID , ID * ID , ID * ID ) { 
int ID = ID ( ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID ) ; 
ID * ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = ID :: ID [ ID ] ; 
ID :: ID [ ID ] = ( ID * ) ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID * ID = new ID ; 
ID -> ID = ( ID * ) ID ; 
ID -> ID = ID ; 
ID = ID ; 
return ID ; 
} 
ID * ID :: ID ( ) { 
ID = ID ; 
return ID == ID ? ID : ( ID * ) ID -> ID ; 
} 
ID * ID :: ID ( ) { 
if ( ID != ID ) 
ID = ID -> ID ; 
return ID == ID ? ID : ( ID * ) ID -> ID ; 
} 
ID * ID :: ID ( ) { 
ID = ID ; 
return ID == ID ? ID : ( ID * ) ID -> ID ; 
} 
ID * ID :: ID ( ) { 
if ( ID != ID ) 
ID = ID -> ID ; 
return ID == ID ? ID : ( ID * ) ID -> ID ; 
} 
ID * ID :: ID ( ) { 
ID = ID ; 
return ID == ID ? ID : ( ID * ) ID -> ID ; 
} 
ID * ID :: ID ( ) { 
if ( ID != ID ) 
ID = ID -> ID ; 
return ID == ID ? ID : ( ID * ) ID -> ID ; 
} 
ID ID :: ID ; 
int ID :: ID ; 
void ID ( ID * ID , const char * ID ) { 
if ( ID == ID ) 
* ID << STRING ; 
else 
while ( * ID != INTEGER ) { 
if ( * ID == STRING ) 
* ID << STRING ; 
* ID << * ID ++ ; 
} 
} 
void ID :: ID ( int ID , const char * * ID ) { 
int ID = ID ; 
if ( ID != INTEGER ) 
ID << 
STRING << ID << STRING << ID << STRING ; 
ID << STRING << ID << STRING ; 
ID ( & ID , ID [ ID ] ) ; 
ID << ( this -> ID == ID ? STRING : this -> ID == ID ? STRING : this -> ID == ID ? STRING : STRING ) << 
STRING << ID << STRING ; 
if ( ID != ID ) { 
ID ++ ; 
ID -> ID ( ID , ID ) ; 
} 
if ( ID != ID ) { 
ID ++ ; 
ID -> ID ( ID , ID ) ; 
} 
} 
void ID :: ID ( ) { 
for ( int ID = INTEGER ; ID < ID :: ID ; ID ++ ) { 
for ( ID * ID = ID :: ID [ ID ] ; ID != ID ; ID = ID -> ID ) 
switch ( ID -> ID ) { 
case ID : ( ( ID * ) ID ) -> ID = false ; break ; 
case ID : ( ( ID * ) ID ) -> ID = false ; break ; 
case ID : break ; 
case ID : break ; 
case ID : break ; 
case ID : break ; 
case ID : break ; 
default : ID << STRING << ID -> ID << STRING ; 
} 
} 
} 
void ID :: ID ( ) { 
for ( int ID = INTEGER ; ID < ID :: ID ; ID ++ ) { 
for ( ID * ID = ID :: ID [ ID ] ; ID != ID ; ID = ID -> ID ) 
if ( ID -> ID == ID ) { 
ID * ID = ( ID * ) ID ; 
if ( ! ID -> ID ) { 
} 
} 
} 
} 
enum ID { ID , ID , ID , ID , ID , ID } ; 
void ID ( struct ID * * ID , int ID , const char * * ID , enum ID * ID ) ; 
enum ID { ID , ID , ID , ID , ID , ID , ID } ; 
struct ID { ID ID ; struct ID * ID ; } ; 
struct ID { ID * ID ; ID * ID ; } ; 
class ID { 
public : 
ID ( ) { ID = ID = ID ; } ; 
static ID * ID ; 
static unsigned ID ; 
static unsigned ID ; 
static unsigned ID ; 
static struct ID * * ID ; 
struct ID * ID ; 
struct ID * ID ; 
ID ( unsigned ID , ID * ID , int ID ) { 
ID = ID ; 
ID = ID ; 
ID = INTEGER ; 
for ( int ID = INTEGER ; ID < ID ; ID ++ ) 
ID *= INTEGER ; 
ID = new ID * [ ID ] ; 
ID = ID - INTEGER ; 
ID ( ID , INTEGER , ID * sizeof ( ID * ) ) ; 
ID = ID = ID ; 
} 
unsigned ID ( ID ID , ID ID , ID ID , ID ID , ID * ID , ID * ID , ID * ID , ID * ID ) { 
return ( ID * ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID + 
( ID - ID ) * ID * ID * ID + 
( ID - ID ) * ID * ID + 
( ID - ID ) * ID + 
( ID - ID ) ) & ID ; 
} 
unsigned ID ( ID ID , ID ID , ID ID , ID * ID , ID * ID , ID * ID ) { 
return ( ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID + 
ID * ID * ID * ID + 
( ID - ID ) * ID * ID + 
( ID - ID ) * ID + 
( ID - ID ) ) & ID ; 
} 
unsigned ID ( ID ID , ID ID , ID * ID , ID * ID ) { 
return ( ID * ID * ID * ID + 
ID * ID * ID + 
( ID - ID ) * ID + 
( ID - ID ) ) & ID ; 
} 
unsigned ID ( ID ID , ID ID , ID * ID ) { 
return ( ID * ID * ID + 
ID * ID + 
( ID - ID ) ) & ID ; 
} 
bool ID ( ) ; 
void ID ( struct ID * ID ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ID ID , struct ID * ID , ID * ID , struct ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID ID , struct ID * ID , ID * ID , struct ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID * ID ) ; 
void ID ( ID * ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID ID , ID * ID ) ; 
void ID ( struct ID * ID ) ; 
struct ID * ID ( ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
void ID ( ) ; 
void ID ( ) ; 
int ID ( const char * ID , const char * ID , const char * ID , const char * ID , ID * ID , int ID , ID * ID , bool ID , double ID , const char * * ID , enum ID * ID ) ; 
void ID ( ) ; 
} ; 
enum ID { ID , ID , ID , ID , ID , ID } ; 
void ID ( struct ID * * ID , int ID , const char * * ID , enum ID * ID ) ; 
enum ID { ID , ID , ID , ID , ID , ID , ID } ; 
struct ID { ID ID ; struct ID * ID ; } ; 
struct ID { ID * ID ; ID * ID ; } ; 
class ID { 
public : 
ID ( ) { ID = ID = ID ; } ; 
static ID * ID ; 
static unsigned ID ; 
static unsigned ID ; 
static unsigned ID ; 
static struct ID * * ID ; 
struct ID * ID ; 
struct ID * ID ; 
ID ( unsigned ID , ID * ID , int ID ) { 
ID = ID ; 
ID = ID ; 
ID = INTEGER ; 
for ( int ID = INTEGER ; ID < ID ; ID ++ ) 
ID *= INTEGER ; 
ID = new ID * [ ID ] ; 
ID = ID - INTEGER ; 
ID ( ID , INTEGER , ID * sizeof ( ID * ) ) ; 
ID = ID = ID ; 
} 
unsigned ID ( ID ID , ID ID , ID ID , ID ID , ID * ID , ID * ID , ID * ID , ID * ID ) { 
return ( ID * ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID + 
( ID - ID ) * ID * ID * ID + 
( ID - ID ) * ID * ID + 
( ID - ID ) * ID + 
( ID - ID ) ) & ID ; 
} 
unsigned ID ( ID ID , ID ID , ID ID , ID * ID , ID * ID , ID * ID ) { 
return ( ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID + 
ID * ID * ID * ID + 
( ID - ID ) * ID * ID + 
( ID - ID ) * ID + 
( ID - ID ) ) & ID ; 
} 
unsigned ID ( ID ID , ID ID , ID * ID , ID * ID ) { 
return ( ID * ID * ID * ID + 
ID * ID * ID + 
( ID - ID ) * ID + 
( ID - ID ) ) & ID ; 
} 
unsigned ID ( ID ID , ID ID , ID * ID ) { 
return ( ID * ID * ID + 
ID * ID + 
( ID - ID ) ) & ID ; 
} 
bool ID ( ) ; 
void ID ( struct ID * ID ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ID ID , struct ID * ID , ID * ID , struct ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID ID , struct ID * ID , ID * ID , struct ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID * ID ) ; 
void ID ( ID * ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID ID , ID * ID ) ; 
void ID ( struct ID * ID ) ; 
struct ID * ID ( ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
void ID ( ) ; 
void ID ( ) ; 
int ID ( const char * ID , const char * ID , const char * ID , const char * ID , ID * ID , int ID , ID * ID , bool ID , double ID , const char * * ID , enum ID * ID ) ; 
void ID ( ) ; 
} ; 
class ID { 
public : 
static ID ID ; 
static int ID ; 
ID ID ; 
enum ID ID ; 
ID * ID ; 
ID * ID ; 
ID ( ID ID ) { 
this -> ID = ID ; ID = ID = ID ; 
} ; 
ID ( ID ID , ID * ID ) { 
this -> ID = ID ; ID = ID ; 
ID * ID = ID -> ID ; 
if ( ID == ID ) 
ID -> ID = this ; 
else { 
while ( ID -> ID != ID ) 
ID = ID -> ID ; 
ID -> ID = this ; 
} 
ID = ID ; 
} ; 
void ID ( ) { 
ID << ID << STRING ; 
if ( ID != ID ) 
ID -> ID ( ) ; 
ID << STRING ; 
if ( ID != ID ) 
ID -> ID ( ) ; 
} ; 
void ID ( int ID , const char * * ID ) ; 
void ID ( const char * ID , const char * * ID ) { 
ID . ID ( ID ) ; 
ID << 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING ; 
ID = INTEGER ; 
this -> ID ( INTEGER , ID ) ; 
ID << STRING ; 
ID . ID ( ) ; 
} ; 
void ID ( ID * ID , const char * * ID ) { 
if ( ID == ID ) 
return ; 
if ( ID -> ID == ID ) 
ID << ID [ ID -> ID ] << STRING ; 
else { 
ID << STRING ; 
ID ( ID -> ID , ID ) ; 
ID << STRING ; 
} 
if ( ID -> ID != ID ) 
ID ( ID -> ID , ID ) ; 
} 
void ID ( const char * ID , ID * ID , const char * * ID ) { 
ID . ID ( ID ) ; 
ID ( ID , ID ) ; 
ID . ID ( ) ; 
} 
} ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID * ID ; int ID : INTEGER ; int ID : INTEGER ; ID ID ; ID ( ) { ID . ID = ID . ID = ID ; } ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID * ID ; ID ID ; ID * ID ; ID ID ; ID ID ; int ID : INTEGER ; } ; 
class ID { public : ID ID ; struct ID * ID ; struct ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID ID ; ID ID ; ID ( ) { ID . ID = ID . ID = ID . ID = ID . ID = ID ; } ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { 
public : 
ID ID ; 
bool ID ; 
ID ID ; 
ID ID ; 
const char * ID ; 
const char * ID ; 
const char * ID ; 
const char * ID ; 
ID * ID ; 
int ID ; 
const char * * ID ; 
const char * * ID ; 
ID * ID ; 
ID * ID ; 
ID ID ; 
const char * * ID ; 
const char * * ID ; 
bool * ID ; 
bool * ID ; 
int ID ; 
enum ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
bool * ID ; 
bool * ID ; 
bool * ID ; 
bool * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
ID * ID ( ID * ID ) ; 
ID * ID ( ID ID , ID * ID ) ; 
ID * ID ( ID ID , ID * ID , ID * ID ) ; 
ID * ID ( ID ID , ID ID , ID * ID ) ; 
ID * ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
void ID ( ID * ID , ID * ID , ID * ID ) ; 
void ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
bool ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
ID * ID ( ID * ID , ID * ID , bool ID ) ; 
void ID ( ID * ID , int ID ) ; 
void ID ( ID * ID , ID * ID ) ; 
void ID ( ) ; 
void ID ( ID * ID ) ; 
void ID ( const char * ID , ID * ID , int * ID ) ; 
const char * ID ( const char * ID ) ; 
const char * ID ( const char * ID , const char * ID ) { 
const char * ID = ID ; 
while ( * ID != INTEGER && * ID == * ID ) { 
ID ++ ; 
ID ++ ; 
} 
if ( * ID == INTEGER ) 
return ID ; 
else 
return ID ; 
} 
const char ID ( const char ID ) { return ( ID >= ( const char ) STRING && ID <= ( const char ) STRING ) ? ( const char ) ( ID + INTEGER ) : ID ; } 
const char * ID ( const char * ID , const char * ID ) { 
const char * ID = ID ; 
while ( * ID != INTEGER && ID ( * ID ) == ID ( * ID ) ) { 
ID ++ ; 
ID ++ ; 
} 
if ( * ID == INTEGER ) 
return ID ; 
else 
return ID ; 
} 
bool ID ( const char * ID ) { 
ID = new ID [ ID ( ID ) + INTEGER ] ; 
ID = new const char * [ ID ( ID ) + INTEGER ] ; 
ID = new const char * [ ID ( ID ) + INTEGER ] ; 
const char * ID = ID ; 
ID = ID ; 
ID ID ; 
ID = ID ( ID ) ; 
while ( INTEGER ) { 
if ( * ID == INTEGER ) { 
* ID = ID ; 
ID = ID ; 
ID = ID - ID ; 
return true ; 
} 
int ID = INTEGER ; 
const char * ID ; 
for ( ID ID = ( ID ) INTEGER ; ID != ID ; ID = ( ID ) ( ( int ) ID + INTEGER ) ) { 
if ( ID [ ID ] ) 
ID = ID ( ID [ ID ] , ID ) ; 
else 
ID = ID ( ID [ ID ] , ID ) ; 
int ID = ID - ID ; 
if ( ID > ID ) { 
ID = ID ; 
ID = ID ; 
} 
} 
ID ( ID , & ID , & ID ) ; 
if ( ID == INTEGER ) { 
ID << STRING << ( ID - ID ) << STRING << ( int ) * ID << STRING << * ID << STRING ; 
* ID = ID ; 
ID = ID ; 
return false ; 
} 
ID [ ID - ID ] = ID ; 
ID += ID ; 
ID [ ID - ID ] = ID ; 
* ID ++ = ID ; 
if ( ID [ ID ] ) { 
ID = ID ( ID ) ; 
} 
} 
} 
const char * ID ( const char * ID ) { 
if ( ID ( * ID ) || * ID == STRING ) 
while ( ID ( * ID ) || * ID == STRING || * ID == STRING || * ID == STRING ) 
ID ++ ; 
return ID ; 
} 
bool ID ( const char * ID ) { 
return 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING ; 
} 
bool ID ( const char * ID ) { 
return 
* ID == STRING || * ID == STRING || * ID == STRING ; 
} 
bool ID ( const char * ID ) { 
return 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ID ( ID ) ) 
return ID ; 
ID ++ ; 
while ( ID ( ID ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ID ( ID ) ) 
return ID ; 
ID ++ ; 
while ( ID ( ID ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ID ( * ID ) || * ID == STRING ) 
while ( ID ( * ID ) || * ID == STRING ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
bool ID = ( * ID == STRING && ( * ( ID + INTEGER ) == STRING || * ( ID + INTEGER ) == STRING ) ) ; 
if ( ID ) ID += INTEGER ; 
while ( ( ID ? ID ( * ID ) : ID ( * ID ) ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ID ( * ID ) ) 
return ID ; 
while ( ID ( * ID ) ) 
ID ++ ; 
if ( * ID != STRING ) 
return ID ; 
ID ++ ; 
while ( ID ( * ID ) ) 
ID ++ ; 
if ( * ID == STRING || * ID == STRING ) { 
ID ++ ; 
while ( ID ( * ID ) ) 
ID ++ ; 
} 
return ID ; 
} 
const char * ID ( const char * ID ) { 
const char * ID = ID ; 
if ( * ID != STRING ) 
return ID ; 
ID ++ ; 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
if ( * ID != STRING ) 
return ID ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( * ID != STRING ) ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( * ID != STRING ) ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( * ID != STRING ) ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ( ( * ID == STRING ) && ( * ( ID + INTEGER ) == STRING ) ) ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( ! ( ( * ID == STRING ) && ( * ( ID + INTEGER ) == STRING ) ) ) ; 
ID ++ ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
if ( * ID != STRING ) { 
if ( * ( ID + INTEGER ) == STRING && ( * ( ID + INTEGER ) == STRING || * ( ID + INTEGER ) == STRING ) ) 
ID += INTEGER ; 
} 
else 
ID += INTEGER ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
while ( * ID != INTEGER && ( ID ( * ID ) ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
int ID = INTEGER ; 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
while ( ID > INTEGER ) { 
if ( * ID == INTEGER ) 
break ; 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
ID ++ ; 
} 
else if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
ID -- ; 
} 
else 
ID ++ ; 
} 
} 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
while ( INTEGER ) { 
if ( * ID == INTEGER ) 
break ; 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
break ; 
} 
ID ++ ; 
} 
} 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) 
while ( * ID != INTEGER && * ID != STRING ) 
ID ++ ; 
if ( * ID == STRING ) 
ID ++ ; 
return ID ; 
} 
void ID ( const char * const ID ) ; 
void ID ( ID ID ) ; 
void ID ( ) { 
ID = new ID ( INTEGER , ID , ID - ID ) ; 
ID = new ID ; 
ID = new ID ; 
ID = new ID ; 
ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID -> ID = ID ; 
} 
void ID ( ) { 
ID = ID -> ID ( ) ; 
ID = ID -> ID ; 
ID = ID -> ID ; 
ID = ID -> ID ; 
ID = ID -> ID ; 
} 
void ID ( ) { 
ID = ID ( ) ; 
} 
void ID ( ) { 
ID = ID ( ) ; 
} 
void ID ( ) { 
if ( ID -> ID ( ID , ID , ID , ID , ID , ID , ID , ID , INTEGER , ID , ID ) < INTEGER ) 
ID ( ID , ID ) ; 
ID << STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID ; 
ID << STRING ; 
} 
void ID ( const char * ID ) { ID = ID ( ID ) ; } 
ID ( ) ; 
} ; 
class ID { 
class ID { 
public : 
unsigned long ID ; 
unsigned long ID ; 
ID * ID ; 
} ; 
ID * ID ; 
public : 
ID ( ) 
{ 
ID = new ID ; 
ID -> ID = ID -> ID = INTEGER ; 
ID -> ID = new ID ; 
ID -> ID -> ID = ID ; 
ID -> ID -> ID = INTEGER ; 
ID -> ID -> ID = ID ; 
} 
void ID ( unsigned long ID ) 
{ 
ID * ID = ID ; 
ID * ID ; 
ID * ID ; 
do 
{ 
if ( ID -> ID == ID ) 
{ 
ID -> ID ++ ; 
return ; 
} 
ID = ID ; 
ID = ID -> ID ; 
} 
while ( ID -> ID <= ID ) ; 
ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = INTEGER ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
} 
void ID ( ) 
{ 
unsigned long ID = ID ( ) ; 
ID * ID = ID ; 
while ( ID -> ID != ID ) 
{ 
if ( ID -> ID != INTEGER ) 
ID << ID -> ID << STRING << ID -> ID << STRING << ( INTEGER * ID -> ID ) / ID << STRING ; 
ID = ID -> ID ; 
} 
} 
unsigned long ID ( unsigned long ID ) 
{ 
ID * ID = ID ; 
while ( ID -> ID != ID && ID -> ID != ID ) 
ID = ID -> ID ; 
return ID -> ID == ID ? ID -> ID : INTEGER ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
if ( ID -> ID != INTEGER ) 
ID ++ ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
ID ++ ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
ID += ID -> ID ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
ID += ID -> ID * ID -> ID ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
} ; 
void ID :: ID ( ID ID ) { 
this -> ID = ID ; 
ID = ID -> ID ( ID , ID , ID ) ; 
ID = ID != ID ; 
} 
bool ID :: ID ( ID ID , ID * ID , ID * ID , ID * ID ) { 
ID ++ ; 
if ( ID -> ID ( ID , ID , ID , ID ) == ID ) { 
ID -> ID ( ID , ID , ID , ID ) ; 
return false ; 
} 
return true ; 
} 
void ID :: ID ( ID ID , ID * ID , ID * ID , ID * ID ) { 
ID ++ ; 
if ( ID -> ID ( ID , ID , ID , ID ) == ID ) { 
ID * ID = ID -> ID ( ID , ID , ID , ID ) ; 
ID -> ID ( ID ) ; 
} 
} 
void ID :: ID ( ID * ID , ID * ID , ID * ID ) { 
ID ++ ; 
if ( ID == ID ) { 
return ; 
} 
if ( ID -> ID . ID ( ID , ID ) == ID ) { 
ID -> ID . ID ( ID , ID ) ; 
} 
for ( ID * ID = ID -> ID . ID ( ) ; ID != ID ; ID = ID -> ID . ID ( ) ) { 
ID * ID = ID :: ID ( ID -> ID , ID -> ID , ID ) ; 
ID :: ID ( ID -> ID , ID -> ID , ID , ID ) ; 
} 
} 
ID * ID :: ID ( ID ID , ID * ID , ID * ID , ID * ID ) { 
ID ++ ; 
ID * ID ; 
if ( ( ID = ID -> ID ( ID , ID ) ) == ID ) { 
ID = ID -> ID ( ID , ID ) ; 
} 
if ( ID != ID && ID -> ID . ID ( ID , ID , ID ) == ID ) { 
ID -> ID . ID ( ID , ID , ID ) ; 
for ( ID * ID = ID -> ID . ID ( ) ; ID != ID ; ID = ID -> ID . ID ( ) ) { 
ID * ID = ID :: ID ( ID , ID , ID -> ID ) ; 
ID :: ID ( ID , ID , ID -> ID -> ID , ID ) ; 
} 
} 
return ID ; 
} 
ID * ID :: ID ( ID * ID ) { 
ID ++ ; 
ID * ID ; 
if ( ( ID = ID -> ID ( ID , ID , ID ) ) == ID ) { 
ID = ID -> ID ( ID , ID , ID ) ; 
} 
return ID ; 
} 
ID * ID :: ID ( ID ID , ID * ID ) { 
ID ++ ; 
ID * ID ; 
if ( ( ID = ID -> ID ( ID , ID , ID + INTEGER ) ) == ID ) { 
ID = ID -> ID ( ID , ID , ID + INTEGER ) ; 
} 
return ID ; 
} 
ID * ID :: ID ( ID ID , ID * ID , ID * ID ) { 
ID ++ ; 
if ( ID [ ID ] ) { 
return ID ; 
} 
ID * ID ; 
ID * ID = ( ID == ID ? ID -> ID : ID -> ID ) ; 
ID ID ; 
if ( ID [ ID ] ) 
ID = ID [ ID ] ? ID [ ID ] : ID [ ID ] ; 
else { 
ID = ID [ ID ] ? ID [ ID ] : ID [ ID ] ; 
} 
if ( ( ID = ID -> ID ( ID , ID , ID -> ID ) ) == ID ) { 
ID = ID -> ID ( ID , ID , ID -> ID ) ; 
} 
if ( ID -> ID . ID ( ID , ID , ID -> ID ) == ID ) { 
ID * ID = ID -> ID . ID ( ID , ID , ID -> ID ) ; 
ID -> ID = ID -> ID ; 
ID -> ID = ID -> ID ; 
} 
return ID ; 
} 
ID * ID :: ID ( ID ID , ID ID , ID * ID ) { 
ID ++ ; 
ID * ID ; 
if ( ( ID = ID -> ID ( ID , ID , ID ) ) == ID ) { 
ID = ID -> ID ( ID , ID , ID ) ; 
} 
if ( ID -> ID . ID ( ID , ID , ID ) == ID ) { 
ID * ID = ID -> ID . ID ( ID , ID , ID ) ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID ( ID ) ; 
} 
return ID ; 
} 
void ID :: ID ( ID * ID ) { 
int ID = INTEGER ; 
if ( ID == ID ) 
return ; 
if ( ID -> ID ) 
return ; 
ID -> ID = true ; 
for ( ID * ID = ID -> ID . ID ( ) ; ID != ID ; ID = ID -> ID . ID ( ) ) { 
ID -> ID = true ; 
ID ++ ; 
if ( ID -> ID != ID ) 
ID ( ID -> ID ( ID -> ID , ID -> ID , ID -> ID ) ) ; 
if ( ID -> ID != ID ) 
ID ( ID -> ID ( ID -> ID , ID -> ID , ID -> ID ) ) ; 
} 
if ( ID > INTEGER ) { 
ID -> ID = true ; 
ID ++ ; 
} 
} 
void ID :: ID ( ) { 
ID = INTEGER ; 
ID ( ID ) ; 
} 
ID ID ; 
int ID ; 
void ID :: ID ( ID * ID , int ID ) { 
if ( ID == ID ) 
return ; 
if ( ID -> ID ) 
return ; 
ID -> ID = true ; 
int ID = INTEGER ; 
for ( ID * ID = ID -> ID . ID ( ) ; ID != ID ; ID = ID -> ID . ID ( ) ) 
ID ++ ; 
ID << STRING << 
ID [ ID -> ID ] << STRING << 
ID [ ID -> ID ] << 
STRING << 
( ID -> ID - ID ) << 
STRING << 
( ID -> ID - ID ) << STRING << 
( ID [ ID -> ID ] == ID ? STRING : STRING ) << 
STRING << ID << STRING << ++ ID << ( ID > INTEGER ? STRING : STRING ) << STRING ; 
for ( ID * ID = ID -> ID . ID ( ) ; ID != ID ; ID = ID -> ID . ID ( ) ) { 
ID << STRING << 
ID [ ID -> ID -> ID ] << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
ID [ ID -> ID ] << 
STRING << 
( ID -> ID - ID ) << 
STRING << 
ID [ ID -> ID ] << 
( ID [ ID -> ID ] == ID ? STRING : ID [ ID -> ID ] == ID ? STRING : ID [ ID -> ID ] == ID ? STRING : STRING ) << 
STRING << 
( ID -> ID - ID ) << 
STRING << ( ID + INTEGER ) << STRING << ++ ID << ( ID > INTEGER ? STRING : STRING ) 
<< ( ID [ ID -> ID -> ID ] == ID ? STRING : STRING ) 
<< STRING << 
STRING << 
ID [ ID -> ID ] << STRING << 
ID [ ID -> ID -> ID ] << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
ID [ ID -> ID -> ID ] << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
ID [ ID -> ID ] << 
STRING << 
( ID -> ID - ID ) << 
STRING ; 
ID -> ID = true ; 
if ( ID -> ID != ID ) { 
ID << 
STRING << 
ID [ ID -> ID -> ID ] << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
ID [ ID -> ID ] << 
STRING << 
( ID -> ID - ID ) << 
STRING << 
ID [ ID -> ID ] << STRING << 
ID [ ID -> ID ] << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
( ID -> ID - ID ) << 
STRING ; 
ID ( ID -> ID ( ID -> ID , ID -> ID , ID -> ID ) , ID + INTEGER ) ; 
} 
if ( ID -> ID != ID ) { 
ID << 
STRING << 
ID [ ID -> ID -> ID ] << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
ID [ ID -> ID ] << 
STRING << 
( ID -> ID - ID ) << 
STRING << 
ID [ ID -> ID ] << STRING << 
ID [ ID -> ID ] << 
STRING << 
( ID -> ID - ID ) << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING ; 
ID ( ID -> ID ( ID -> ID , ID -> ID , ID -> ID ) , ID + INTEGER ) ; 
} 
} 
} 
void ID :: ID ( ID * ID , ID * ID ) { 
ID -> ID ( ) ; 
ID . ID ( STRING ) ; 
ID << 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING ; 
ID = INTEGER ; 
ID ( ID , INTEGER ) ; 
ID -> ID ( ) ; 
ID << STRING ; 
ID . ID ( ) ; 
} 
ID * ID :: ID ( ID * ID , ID * ID , bool ID ) { 
ID * ID ; 
ID * ID = ID ; 
ID * ID = ID ; 
if ( ID == ID ) 
return ID ; 
if ( ID -> ID ) 
return ID ; 
if ( ID == ID ) 
ID = new ID ( ID -> ID ) ; 
else 
ID = new ID ( ID -> ID , ID ) ; 
int ID = INTEGER ; 
ID -> ID = true ; 
for ( ID * ID = ID -> ID . ID ( ) ; ID != ID ; ID = ID -> ID . ID ( ) ) { 
ID ++ ; 
ID -> ID = ID > INTEGER ; 
if ( ( ID -> ID != ID && ID -> ID ( ID -> ID , ID -> ID , ID -> ID ) -> ID ) || 
( ID -> ID != ID && ID -> ID ( ID -> ID , ID -> ID , ID -> ID ) -> ID ) ) 
continue ; 
if ( ID -> ID >= ID ) { 
ID = ID ; 
ID = ID -> ID ; 
} 
} 
if ( ID != ID ) { 
ID -> ID = true ; 
if ( ID -> ID != ID ) 
ID ( ID -> ID ( ID -> ID , ID -> ID , ID -> ID ) , ID , ID ) ; 
if ( ID -> ID != ID ) 
ID ( ID -> ID ( ID -> ID , ID -> ID , ID -> ID ) , ID , ID ) ; 
} 
return ID ; 
}  
class ID { 
public : 
static ID ID ; 
static int ID ; 
ID ID ; 
enum ID ID ; 
ID * ID ; 
ID * ID ; 
ID ( ID ID ) { 
this -> ID = ID ; ID = ID = ID ; 
} ; 
ID ( ID ID , ID * ID ) { 
this -> ID = ID ; ID = ID ; 
ID * ID = ID -> ID ; 
if ( ID == ID ) 
ID -> ID = this ; 
else { 
while ( ID -> ID != ID ) 
ID = ID -> ID ; 
ID -> ID = this ; 
} 
ID = ID ; 
} ; 
void ID ( ) { 
ID << ID << STRING ; 
if ( ID != ID ) 
ID -> ID ( ) ; 
ID << STRING ; 
if ( ID != ID ) 
ID -> ID ( ) ; 
} ; 
void ID ( int ID , const char * * ID ) ; 
void ID ( const char * ID , const char * * ID ) { 
ID . ID ( ID ) ; 
ID << 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING ; 
ID = INTEGER ; 
this -> ID ( INTEGER , ID ) ; 
ID << STRING ; 
ID . ID ( ) ; 
} ; 
void ID ( ID * ID , const char * * ID ) { 
if ( ID == ID ) 
return ; 
if ( ID -> ID == ID ) 
ID << ID [ ID -> ID ] << STRING ; 
else { 
ID << STRING ; 
ID ( ID -> ID , ID ) ; 
ID << STRING ; 
} 
if ( ID -> ID != ID ) 
ID ( ID -> ID , ID ) ; 
} 
void ID ( const char * ID , ID * ID , const char * * ID ) { 
ID . ID ( ID ) ; 
ID ( ID , ID ) ; 
ID . ID ( ) ; 
} 
} ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID * ID ; int ID : INTEGER ; int ID : INTEGER ; ID ID ; ID ( ) { ID . ID = ID . ID = ID ; } ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID * ID ; ID ID ; ID * ID ; ID ID ; ID ID ; int ID : INTEGER ; } ; 
class ID { public : ID ID ; struct ID * ID ; struct ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID ID ; ID ID ; ID ( ) { ID . ID = ID . ID = ID . ID = ID . ID = ID ; } ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { 
public : 
ID ID ; 
bool ID ; 
ID ID ; 
ID ID ; 
const char * ID ; 
const char * ID ; 
const char * ID ; 
const char * ID ; 
ID * ID ; 
int ID ; 
const char * * ID ; 
const char * * ID ; 
ID * ID ; 
ID * ID ; 
ID ID ; 
const char * * ID ; 
const char * * ID ; 
bool * ID ; 
bool * ID ; 
int ID ; 
enum ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
bool * ID ; 
bool * ID ; 
bool * ID ; 
bool * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
ID * ID ( ID * ID ) ; 
ID * ID ( ID ID , ID * ID ) ; 
ID * ID ( ID ID , ID * ID , ID * ID ) ; 
ID * ID ( ID ID , ID ID , ID * ID ) ; 
ID * ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
void ID ( ID * ID , ID * ID , ID * ID ) ; 
void ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
bool ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
ID * ID ( ID * ID , ID * ID , bool ID ) ; 
void ID ( ID * ID , int ID ) ; 
void ID ( ID * ID , ID * ID ) ; 
void ID ( ) ; 
void ID ( ID * ID ) ; 
void ID ( const char * ID , ID * ID , int * ID ) ; 
const char * ID ( const char * ID ) ; 
const char * ID ( const char * ID , const char * ID ) { 
const char * ID = ID ; 
while ( * ID != INTEGER && * ID == * ID ) { 
ID ++ ; 
ID ++ ; 
} 
if ( * ID == INTEGER ) 
return ID ; 
else 
return ID ; 
} 
const char ID ( const char ID ) { return ( ID >= ( const char ) STRING && ID <= ( const char ) STRING ) ? ( const char ) ( ID + INTEGER ) : ID ; } 
const char * ID ( const char * ID , const char * ID ) { 
const char * ID = ID ; 
while ( * ID != INTEGER && ID ( * ID ) == ID ( * ID ) ) { 
ID ++ ; 
ID ++ ; 
} 
if ( * ID == INTEGER ) 
return ID ; 
else 
return ID ; 
} 
bool ID ( const char * ID ) { 
ID = new ID [ ID ( ID ) + INTEGER ] ; 
ID = new const char * [ ID ( ID ) + INTEGER ] ; 
ID = new const char * [ ID ( ID ) + INTEGER ] ; 
const char * ID = ID ; 
ID = ID ; 
ID ID ; 
ID = ID ( ID ) ; 
while ( INTEGER ) { 
if ( * ID == INTEGER ) { 
* ID = ID ; 
ID = ID ; 
ID = ID - ID ; 
return true ; 
} 
int ID = INTEGER ; 
const char * ID ; 
for ( ID ID = ( ID ) INTEGER ; ID != ID ; ID = ( ID ) ( ( int ) ID + INTEGER ) ) { 
if ( ID [ ID ] ) 
ID = ID ( ID [ ID ] , ID ) ; 
else 
ID = ID ( ID [ ID ] , ID ) ; 
int ID = ID - ID ; 
if ( ID > ID ) { 
ID = ID ; 
ID = ID ; 
} 
} 
ID ( ID , & ID , & ID ) ; 
if ( ID == INTEGER ) { 
ID << STRING << ( ID - ID ) << STRING << ( int ) * ID << STRING << * ID << STRING ; 
* ID = ID ; 
ID = ID ; 
return false ; 
} 
ID [ ID - ID ] = ID ; 
ID += ID ; 
ID [ ID - ID ] = ID ; 
* ID ++ = ID ; 
if ( ID [ ID ] ) { 
ID = ID ( ID ) ; 
} 
} 
} 
const char * ID ( const char * ID ) { 
if ( ID ( * ID ) || * ID == STRING ) 
while ( ID ( * ID ) || * ID == STRING || * ID == STRING || * ID == STRING ) 
ID ++ ; 
return ID ; 
} 
bool ID ( const char * ID ) { 
return 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING ; 
} 
bool ID ( const char * ID ) { 
return 
* ID == STRING || * ID == STRING || * ID == STRING ; 
} 
bool ID ( const char * ID ) { 
return 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ID ( ID ) ) 
return ID ; 
ID ++ ; 
while ( ID ( ID ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ID ( ID ) ) 
return ID ; 
ID ++ ; 
while ( ID ( ID ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ID ( * ID ) || * ID == STRING ) 
while ( ID ( * ID ) || * ID == STRING ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
bool ID = ( * ID == STRING && ( * ( ID + INTEGER ) == STRING || * ( ID + INTEGER ) == STRING ) ) ; 
if ( ID ) ID += INTEGER ; 
while ( ( ID ? ID ( * ID ) : ID ( * ID ) ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ID ( * ID ) ) 
return ID ; 
while ( ID ( * ID ) ) 
ID ++ ; 
if ( * ID != STRING ) 
return ID ; 
ID ++ ; 
while ( ID ( * ID ) ) 
ID ++ ; 
if ( * ID == STRING || * ID == STRING ) { 
ID ++ ; 
while ( ID ( * ID ) ) 
ID ++ ; 
} 
return ID ; 
} 
const char * ID ( const char * ID ) { 
const char * ID = ID ; 
if ( * ID != STRING ) 
return ID ; 
ID ++ ; 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
if ( * ID != STRING ) 
return ID ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( * ID != STRING ) ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( * ID != STRING ) ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( * ID != STRING ) ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ( ( * ID == STRING ) && ( * ( ID + INTEGER ) == STRING ) ) ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( ! ( ( * ID == STRING ) && ( * ( ID + INTEGER ) == STRING ) ) ) ; 
ID ++ ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
if ( * ID != STRING ) { 
if ( * ( ID + INTEGER ) == STRING && ( * ( ID + INTEGER ) == STRING || * ( ID + INTEGER ) == STRING ) ) 
ID += INTEGER ; 
} 
else 
ID += INTEGER ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
while ( * ID != INTEGER && ( ID ( * ID ) ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
int ID = INTEGER ; 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
while ( ID > INTEGER ) { 
if ( * ID == INTEGER ) 
break ; 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
ID ++ ; 
} 
else if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
ID -- ; 
} 
else 
ID ++ ; 
} 
} 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
while ( INTEGER ) { 
if ( * ID == INTEGER ) 
break ; 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
break ; 
} 
ID ++ ; 
} 
} 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) 
while ( * ID != INTEGER && * ID != STRING ) 
ID ++ ; 
if ( * ID == STRING ) 
ID ++ ; 
return ID ; 
} 
void ID ( const char * const ID ) ; 
void ID ( ID ID ) ; 
void ID ( ) { 
ID = new ID ( INTEGER , ID , ID - ID ) ; 
ID = new ID ; 
ID = new ID ; 
ID = new ID ; 
ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID -> ID = ID ; 
} 
void ID ( ) { 
ID = ID -> ID ( ) ; 
ID = ID -> ID ; 
ID = ID -> ID ; 
ID = ID -> ID ; 
ID = ID -> ID ; 
} 
void ID ( ) { 
ID = ID ( ) ; 
} 
void ID ( ) { 
ID = ID ( ) ; 
} 
void ID ( ) { 
if ( ID -> ID ( ID , ID , ID , ID , ID , ID , ID , ID , INTEGER , ID , ID ) < INTEGER ) 
ID ( ID , ID ) ; 
ID << STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID ; 
ID << STRING ; 
} 
void ID ( const char * ID ) { ID = ID ( ID ) ; } 
ID ( ) ; 
} ; 
class ID { 
class ID { 
public : 
unsigned long ID ; 
unsigned long ID ; 
ID * ID ; 
} ; 
ID * ID ; 
public : 
ID ( ) 
{ 
ID = new ID ; 
ID -> ID = ID -> ID = INTEGER ; 
ID -> ID = new ID ; 
ID -> ID -> ID = ID ; 
ID -> ID -> ID = INTEGER ; 
ID -> ID -> ID = ID ; 
} 
void ID ( unsigned long ID ) 
{ 
ID * ID = ID ; 
ID * ID ; 
ID * ID ; 
do 
{ 
if ( ID -> ID == ID ) 
{ 
ID -> ID ++ ; 
return ; 
} 
ID = ID ; 
ID = ID -> ID ; 
} 
while ( ID -> ID <= ID ) ; 
ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = INTEGER ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
} 
void ID ( ) 
{ 
unsigned long ID = ID ( ) ; 
ID * ID = ID ; 
while ( ID -> ID != ID ) 
{ 
if ( ID -> ID != INTEGER ) 
ID << ID -> ID << STRING << ID -> ID << STRING << ( INTEGER * ID -> ID ) / ID << STRING ; 
ID = ID -> ID ; 
} 
} 
unsigned long ID ( unsigned long ID ) 
{ 
ID * ID = ID ; 
while ( ID -> ID != ID && ID -> ID != ID ) 
ID = ID -> ID ; 
return ID -> ID == ID ? ID -> ID : INTEGER ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
if ( ID -> ID != INTEGER ) 
ID ++ ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
ID ++ ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
ID += ID -> ID ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
ID += ID -> ID * ID -> ID ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
} ; 
enum ID { ID , ID , ID , ID , ID , ID } ; 
enum ID { ID , ID , ID , ID , ID , ID } ; 
void ID ( struct ID * * ID , int ID , const char * * ID , enum ID * ID ) ; 
enum ID { ID , ID , ID , ID , ID , ID , ID } ; 
struct ID { ID ID ; struct ID * ID ; } ; 
struct ID { ID * ID ; ID * ID ; } ; 
class ID { 
public : 
ID ( ) { ID = ID = ID ; } ; 
static ID * ID ; 
static unsigned ID ; 
static unsigned ID ; 
static unsigned ID ; 
static struct ID * * ID ; 
struct ID * ID ; 
struct ID * ID ; 
ID ( unsigned ID , ID * ID , int ID ) { 
ID = ID ; 
ID = ID ; 
ID = INTEGER ; 
for ( int ID = INTEGER ; ID < ID ; ID ++ ) 
ID *= INTEGER ; 
ID = new ID * [ ID ] ; 
ID = ID - INTEGER ; 
ID ( ID , INTEGER , ID * sizeof ( ID * ) ) ; 
ID = ID = ID ; 
} 
unsigned ID ( ID ID , ID ID , ID ID , ID ID , ID * ID , ID * ID , ID * ID , ID * ID ) { 
return ( ID * ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID + 
( ID - ID ) * ID * ID * ID + 
( ID - ID ) * ID * ID + 
( ID - ID ) * ID + 
( ID - ID ) ) & ID ; 
} 
unsigned ID ( ID ID , ID ID , ID ID , ID * ID , ID * ID , ID * ID ) { 
return ( ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID + 
ID * ID * ID * ID + 
( ID - ID ) * ID * ID + 
( ID - ID ) * ID + 
( ID - ID ) ) & ID ; 
} 
unsigned ID ( ID ID , ID ID , ID * ID , ID * ID ) { 
return ( ID * ID * ID * ID + 
ID * ID * ID + 
( ID - ID ) * ID + 
( ID - ID ) ) & ID ; 
} 
unsigned ID ( ID ID , ID ID , ID * ID ) { 
return ( ID * ID * ID + 
ID * ID + 
( ID - ID ) ) & ID ; 
} 
bool ID ( ) ; 
void ID ( struct ID * ID ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ID ID , struct ID * ID , ID * ID , struct ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID ID , struct ID * ID , ID * ID , struct ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID * ID ) ; 
void ID ( ID * ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID ID , ID * ID ) ; 
void ID ( struct ID * ID ) ; 
struct ID * ID ( ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
void ID ( ) ; 
void ID ( ) ; 
int ID ( const char * ID , const char * ID , const char * ID , const char * ID , ID * ID , int ID , ID * ID , bool ID , double ID , const char * * ID , enum ID * ID ) ; 
void ID ( ) ; 
} ; 
class ID { 
public : 
static ID ID ; 
static int ID ; 
ID ID ; 
enum ID ID ; 
ID * ID ; 
ID * ID ; 
ID ( ID ID ) { 
this -> ID = ID ; ID = ID = ID ; 
} ; 
ID ( ID ID , ID * ID ) { 
this -> ID = ID ; ID = ID ; 
ID * ID = ID -> ID ; 
if ( ID == ID ) 
ID -> ID = this ; 
else { 
while ( ID -> ID != ID ) 
ID = ID -> ID ; 
ID -> ID = this ; 
} 
ID = ID ; 
} ; 
void ID ( ) { 
ID << ID << STRING ; 
if ( ID != ID ) 
ID -> ID ( ) ; 
ID << STRING ; 
if ( ID != ID ) 
ID -> ID ( ) ; 
} ; 
void ID ( int ID , const char * * ID ) ; 
void ID ( const char * ID , const char * * ID ) { 
ID . ID ( ID ) ; 
ID << 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING ; 
ID = INTEGER ; 
this -> ID ( INTEGER , ID ) ; 
ID << STRING ; 
ID . ID ( ) ; 
} ; 
void ID ( ID * ID , const char * * ID ) { 
if ( ID == ID ) 
return ; 
if ( ID -> ID == ID ) 
ID << ID [ ID -> ID ] << STRING ; 
else { 
ID << STRING ; 
ID ( ID -> ID , ID ) ; 
ID << STRING ; 
} 
if ( ID -> ID != ID ) 
ID ( ID -> ID , ID ) ; 
} 
void ID ( const char * ID , ID * ID , const char * * ID ) { 
ID . ID ( ID ) ; 
ID ( ID , ID ) ; 
ID . ID ( ) ; 
} 
} ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID * ID ; int ID : INTEGER ; int ID : INTEGER ; ID ID ; ID ( ) { ID . ID = ID . ID = ID ; } ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID * ID ; ID ID ; ID * ID ; ID ID ; ID ID ; int ID : INTEGER ; } ; 
class ID { public : ID ID ; struct ID * ID ; struct ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID ID ; ID ID ; ID ( ) { ID . ID = ID . ID = ID . ID = ID . ID = ID ; } ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { 
public : 
ID ID ; 
bool ID ; 
ID ID ; 
ID ID ; 
const char * ID ; 
const char * ID ; 
const char * ID ; 
const char * ID ; 
ID * ID ; 
int ID ; 
const char * * ID ; 
const char * * ID ; 
ID * ID ; 
ID * ID ; 
ID ID ; 
const char * * ID ; 
const char * * ID ; 
bool * ID ; 
bool * ID ; 
int ID ; 
enum ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
bool * ID ; 
bool * ID ; 
bool * ID ; 
bool * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
ID * ID ( ID * ID ) ; 
ID * ID ( ID ID , ID * ID ) ; 
ID * ID ( ID ID , ID * ID , ID * ID ) ; 
ID * ID ( ID ID , ID ID , ID * ID ) ; 
ID * ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
void ID ( ID * ID , ID * ID , ID * ID ) ; 
void ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
bool ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
ID * ID ( ID * ID , ID * ID , bool ID ) ; 
void ID ( ID * ID , int ID ) ; 
void ID ( ID * ID , ID * ID ) ; 
void ID ( ) ; 
void ID ( ID * ID ) ; 
void ID ( const char * ID , ID * ID , int * ID ) ; 
const char * ID ( const char * ID ) ; 
const char * ID ( const char * ID , const char * ID ) { 
const char * ID = ID ; 
while ( * ID != INTEGER && * ID == * ID ) { 
ID ++ ; 
ID ++ ; 
} 
if ( * ID == INTEGER ) 
return ID ; 
else 
return ID ; 
} 
const char ID ( const char ID ) { return ( ID >= ( const char ) STRING && ID <= ( const char ) STRING ) ? ( const char ) ( ID + INTEGER ) : ID ; } 
const char * ID ( const char * ID , const char * ID ) { 
const char * ID = ID ; 
while ( * ID != INTEGER && ID ( * ID ) == ID ( * ID ) ) { 
ID ++ ; 
ID ++ ; 
} 
if ( * ID == INTEGER ) 
return ID ; 
else 
return ID ; 
} 
bool ID ( const char * ID ) { 
ID = new ID [ ID ( ID ) + INTEGER ] ; 
ID = new const char * [ ID ( ID ) + INTEGER ] ; 
ID = new const char * [ ID ( ID ) + INTEGER ] ; 
const char * ID = ID ; 
ID = ID ; 
ID ID ; 
ID = ID ( ID ) ; 
while ( INTEGER ) { 
if ( * ID == INTEGER ) { 
* ID = ID ; 
ID = ID ; 
ID = ID - ID ; 
return true ; 
} 
int ID = INTEGER ; 
const char * ID ; 
for ( ID ID = ( ID ) INTEGER ; ID != ID ; ID = ( ID ) ( ( int ) ID + INTEGER ) ) { 
if ( ID [ ID ] ) 
ID = ID ( ID [ ID ] , ID ) ; 
else 
ID = ID ( ID [ ID ] , ID ) ; 
int ID = ID - ID ; 
if ( ID > ID ) { 
ID = ID ; 
ID = ID ; 
} 
} 
ID ( ID , & ID , & ID ) ; 
if ( ID == INTEGER ) { 
ID << STRING << ( ID - ID ) << STRING << ( int ) * ID << STRING << * ID << STRING ; 
* ID = ID ; 
ID = ID ; 
return false ; 
} 
ID [ ID - ID ] = ID ; 
ID += ID ; 
ID [ ID - ID ] = ID ; 
* ID ++ = ID ; 
if ( ID [ ID ] ) { 
ID = ID ( ID ) ; 
} 
} 
} 
const char * ID ( const char * ID ) { 
if ( ID ( * ID ) || * ID == STRING ) 
while ( ID ( * ID ) || * ID == STRING || * ID == STRING || * ID == STRING ) 
ID ++ ; 
return ID ; 
} 
bool ID ( const char * ID ) { 
return 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING ; 
} 
bool ID ( const char * ID ) { 
return 
* ID == STRING || * ID == STRING || * ID == STRING ; 
} 
bool ID ( const char * ID ) { 
return 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ID ( ID ) ) 
return ID ; 
ID ++ ; 
while ( ID ( ID ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ID ( ID ) ) 
return ID ; 
ID ++ ; 
while ( ID ( ID ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ID ( * ID ) || * ID == STRING ) 
while ( ID ( * ID ) || * ID == STRING ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
bool ID = ( * ID == STRING && ( * ( ID + INTEGER ) == STRING || * ( ID + INTEGER ) == STRING ) ) ; 
if ( ID ) ID += INTEGER ; 
while ( ( ID ? ID ( * ID ) : ID ( * ID ) ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ID ( * ID ) ) 
return ID ; 
while ( ID ( * ID ) ) 
ID ++ ; 
if ( * ID != STRING ) 
return ID ; 
ID ++ ; 
while ( ID ( * ID ) ) 
ID ++ ; 
if ( * ID == STRING || * ID == STRING ) { 
ID ++ ; 
while ( ID ( * ID ) ) 
ID ++ ; 
} 
return ID ; 
} 
const char * ID ( const char * ID ) { 
const char * ID = ID ; 
if ( * ID != STRING ) 
return ID ; 
ID ++ ; 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
if ( * ID != STRING ) 
return ID ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( * ID != STRING ) ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( * ID != STRING ) ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( * ID != STRING ) ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ( ( * ID == STRING ) && ( * ( ID + INTEGER ) == STRING ) ) ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( ! ( ( * ID == STRING ) && ( * ( ID + INTEGER ) == STRING ) ) ) ; 
ID ++ ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
if ( * ID != STRING ) { 
if ( * ( ID + INTEGER ) == STRING && ( * ( ID + INTEGER ) == STRING || * ( ID + INTEGER ) == STRING ) ) 
ID += INTEGER ; 
} 
else 
ID += INTEGER ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
while ( * ID != INTEGER && ( ID ( * ID ) ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
int ID = INTEGER ; 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
while ( ID > INTEGER ) { 
if ( * ID == INTEGER ) 
break ; 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
ID ++ ; 
} 
else if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
ID -- ; 
} 
else 
ID ++ ; 
} 
} 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
while ( INTEGER ) { 
if ( * ID == INTEGER ) 
break ; 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
break ; 
} 
ID ++ ; 
} 
} 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) 
while ( * ID != INTEGER && * ID != STRING ) 
ID ++ ; 
if ( * ID == STRING ) 
ID ++ ; 
return ID ; 
} 
void ID ( const char * const ID ) ; 
void ID ( ID ID ) ; 
void ID ( ) { 
ID = new ID ( INTEGER , ID , ID - ID ) ; 
ID = new ID ; 
ID = new ID ; 
ID = new ID ; 
ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID -> ID = ID ; 
} 
void ID ( ) { 
ID = ID -> ID ( ) ; 
ID = ID -> ID ; 
ID = ID -> ID ; 
ID = ID -> ID ; 
ID = ID -> ID ; 
} 
void ID ( ) { 
ID = ID ( ) ; 
} 
void ID ( ) { 
ID = ID ( ) ; 
} 
void ID ( ) { 
if ( ID -> ID ( ID , ID , ID , ID , ID , ID , ID , ID , INTEGER , ID , ID ) < INTEGER ) 
ID ( ID , ID ) ; 
ID << STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID ; 
ID << STRING ; 
} 
void ID ( const char * ID ) { ID = ID ( ID ) ; } 
ID ( ) ; 
} ; 
class ID { 
class ID { 
public : 
unsigned long ID ; 
unsigned long ID ; 
ID * ID ; 
} ; 
ID * ID ; 
public : 
ID ( ) 
{ 
ID = new ID ; 
ID -> ID = ID -> ID = INTEGER ; 
ID -> ID = new ID ; 
ID -> ID -> ID = ID ; 
ID -> ID -> ID = INTEGER ; 
ID -> ID -> ID = ID ; 
} 
void ID ( unsigned long ID ) 
{ 
ID * ID = ID ; 
ID * ID ; 
ID * ID ; 
do 
{ 
if ( ID -> ID == ID ) 
{ 
ID -> ID ++ ; 
return ; 
} 
ID = ID ; 
ID = ID -> ID ; 
} 
while ( ID -> ID <= ID ) ; 
ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = INTEGER ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
} 
void ID ( ) 
{ 
unsigned long ID = ID ( ) ; 
ID * ID = ID ; 
while ( ID -> ID != ID ) 
{ 
if ( ID -> ID != INTEGER ) 
ID << ID -> ID << STRING << ID -> ID << STRING << ( INTEGER * ID -> ID ) / ID << STRING ; 
ID = ID -> ID ; 
} 
} 
unsigned long ID ( unsigned long ID ) 
{ 
ID * ID = ID ; 
while ( ID -> ID != ID && ID -> ID != ID ) 
ID = ID -> ID ; 
return ID -> ID == ID ? ID -> ID : INTEGER ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
if ( ID -> ID != INTEGER ) 
ID ++ ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
ID ++ ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
ID += ID -> ID ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
ID += ID -> ID * ID -> ID ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
} ; 
unsigned ID :: ID ; 
unsigned ID :: ID ; 
ID * ID :: ID ; 
unsigned ID :: ID ; 
ID * * ID :: ID ; 
void ID :: ID ( ) { 
} 
int ID :: ID ( const char * ID , const char * ID , const char * ID , const char * ID , ID * ID , int ID , ID * ID , bool ID , double ID , const char * * ID , enum ID * ID ) { 
ID = STRING ; 
int ID = INTEGER ; 
int ID = INTEGER ; 
int ID = INTEGER ; 
int ID = INTEGER ; 
int ID = INTEGER ; 
int ID = INTEGER ; 
int ID = INTEGER ; 
int ID = INTEGER ; 
int ID = INTEGER ; 
int ID = INTEGER ; 
ID * ID = new ID ( ) ; 
int * ID = new int [ ID - ID + INTEGER ] ; 
for ( int ID = INTEGER ; ID < ID - ID + INTEGER ; ID ++ ) 
ID [ ID ] = INTEGER ; 
for ( int ID = INTEGER ; ID < ID :: ID ; ID ++ ) { 
unsigned long ID = INTEGER ; 
for ( ID * ID = ID :: ID [ ID ] ; ID != ID ; ID = ID -> ID ) { 
ID ++ ; 
ID * ID ; 
switch ( ID -> ID ) { 
case ID : ID ++ ; break ; 
case ID : 
ID ++ ; 
if ( ID < ( ( ID * ) ID ) -> ID - ID ) 
ID = ( ( ID * ) ID ) -> ID - ID ; 
for ( ID = ( ( ID * ) ID ) -> ID . ID ( ) ; ID != ID ; ID = ( ( ID * ) ID ) -> ID . ID ( ) ) { 
ID ++ ; 
if ( ID -> ID != ID ) 
ID ++ ; 
if ( ID -> ID != ID ) 
ID ++ ; 
} 
break ; 
case ID : ID ++ ; break ; 
case ID : ID ++ ; break ; 
case ID : ID ++ ; break ; 
case ID : ID ++ ; ID [ ( ( ID * ) ID ) -> ID - ID ] ++ ; break ; 
case ID : ID ++ ; break ; 
default : ID << STRING << ID -> ID << STRING ; 
} 
} 
} 
for ( int ID = INTEGER ; ID < ( ID - ID + INTEGER ) ; ID ++ ) { 
if ( ID [ ID ] > ID ) 
ID = ID [ ID ] ; 
} 
if ( ID < INTEGER ) { 
ID << STRING ; 
ID ID ; 
ID . ID ( STRING ) ; 
ID << 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING << 
STRING << 
STRING ; 
for ( int ID = INTEGER ; ID < ID :: ID ; ID ++ ) { 
for ( ID * ID = ID :: ID [ ID ] ; ID != ID ; ID = ID -> ID ) { 
ID * ID = ( ID * ) ID ; 
ID * ID = ( ID * ) ID ; 
switch ( ID -> ID ) { 
case ID : ID << STRING << 
ID [ ID -> ID -> ID ] << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
ID [ ID -> ID -> ID ] << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
ID [ ID -> ID -> ID ] << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING ; 
break ; 
case ID : ID << STRING << 
ID [ ID -> ID ] << 
STRING << 
( ID -> ID - ID ) << 
STRING << 
( ID -> ID - ID ) << 
STRING << 
( int ) ( ID -> ID ) << 
STRING ; 
break ; 
} 
} 
} 
ID << STRING ; 
ID . ID ( ) ; 
} 
if ( ! ID ) { 
for ( int ID = INTEGER ; ID < ( ID - ID ) ; ID ++ ) 
ID << ID << STRING << ID [ ID ] << STRING << ID [ ID [ ID ] ] << STRING ; 
ID << STRING << ID << STRING << ( ID == INTEGER ? STRING : STRING ) ; 
} 
double ID = ID > REAL ? ( ( double ) ( ID - ID ) ) / ID : INTEGER ; 
ID << ( ID ? STRING : STRING ) << STRING << ID << STRING << ID << STRING << 
ID << STRING << ID << STRING << ( ID - ID ) << STRING << 
ID 
<< STRING << ID << 
STRING << ID << 
STRING << ID << STRING << ID << STRING << ID << STRING << ID << 
STRING << ID << STRING << ID << STRING << ID << 
STRING << ID << 
STRING << ID 
; 
return ID ; 
} 
bool ID :: ID ( ) { 
return ID == ID ; 
} 
void ID :: ID ( struct ID * ID ) { 
ID * ID = new ID ; 
ID -> ID = ( ID * ) ID ; 
ID -> ID = ID ; 
ID = ID ; 
} 
void ID :: ID ( struct ID * ID ) { 
ID * ID = new ID ; 
ID -> ID = ( ID * ) ID ; 
ID -> ID = ID ; 
ID = ID ; 
} 
ID * ID :: ID ( ) { 
ID * ID = ID ; 
ID = ID -> ID ; 
return ( ID * ) ID -> ID ; 
} 
ID * ID :: ID ( ID ID , ID * ID , ID * ID , ID * ID ) { 
int ID = ID ( ID , ID , ID -> ID , ID -> ID , ID -> ID , ID , ID -> ID , ID -> ID ) ; 
for ( ID * ID = ( ID * ) ID :: ID [ ID ] ; 
ID != ID ; 
ID = ( ID * ) ID -> ID ) 
if ( ID -> ID == ID && ID -> ID == ID && ID -> ID == ID && ID -> ID == ID && ID -> ID == ID ) 
return ID ; 
return ID ; 
} 
ID * ID :: ID ( ID ID , ID * ID , ID * ID , ID * ID ) { 
int ID = ID ( ID , ID , ID -> ID , ID -> ID , ID -> ID , ID , ID -> ID , ID -> ID ) ; 
ID * ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = ID :: ID [ ID ] ; 
ID :: ID [ ID ] = ( ID * ) ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
return ID ; 
} 
ID * ID :: ID ( ID ID , ID * ID , ID * ID , ID * ID ) { 
int ID = ID ( ID , ID , ID -> ID , ID -> ID , ID -> ID , ID , ID -> ID , ID -> ID ) ; 
for ( ID * ID = ( ID * ) ID :: ID [ ID ] ; 
ID != ID ; 
ID = ( ID * ) ID -> ID ) 
if ( ID -> ID == ID && ID -> ID == ID && ID -> ID == ID && ID -> ID == ID && ID -> ID == ID ) 
return ID ; 
return ID ; 
} 
ID * ID :: ID ( ID ID , ID * ID , ID * ID , ID * ID ) { 
int ID = ID ( ID , ID , ID -> ID , ID -> ID , ID -> ID , ID , ID -> ID , ID -> ID ) ; 
ID * ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = ID :: ID [ ID ] ; 
ID :: ID [ ID ] = ( ID * ) ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
return ID ; 
} 
ID * ID :: ID ( ID * ID , ID * ID ) { 
int ID = ID ( ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID ) ; 
for ( ID * ID = ( ID * ) ID :: ID [ ID ] ; 
ID != ID ; 
ID = ( ID * ) ID -> ID ) 
if ( ID -> ID == ID && 
ID -> ID -> ID == ID -> ID && ID -> ID -> ID == ID -> ID && 
ID -> ID -> ID == ID -> ID && ID -> ID -> ID == ID -> ID && ID -> ID -> ID == ID -> ID ) 
return ID ; 
return ID ; 
} 
void ID :: ID ( ID * ID , ID * ID ) { 
int ID = ID ( ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID ) ; 
ID * ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = ID :: ID [ ID ] ; 
ID :: ID [ ID ] = ( ID * ) ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID * ID = new ID ; 
ID -> ID = ( ID * ) ID ; 
ID -> ID = ID ; 
ID = ID ; 
} 
ID * ID :: ID ( ID ID , ID * ID ) { 
int ID = ID ( ID , ID , ID ) ; 
for ( ID * ID = ( ID * ) ID :: ID [ ID ] ; 
ID != ID ; 
ID = ( ID * ) ID -> ID ) 
if ( ID -> ID == ID && ID -> ID == ID && ID -> ID == ID ) 
return ID ; 
return ID ; 
} 
ID * ID :: ID ( ID ID , ID * ID ) { 
int ID = ID ( ID , ID , ID ) ; 
ID * ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = ID :: ID [ ID ] ; 
ID :: ID [ ID ] = ( ID * ) ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
return ID ; 
} 
ID * ID :: ID ( ID ID , ID * ID , ID * ID ) { 
int ID = ID ( ID , ID , ID , ID ) ; 
for ( ID * ID = ( ID * ) ID :: ID [ ID ] ; 
ID != ID ; 
ID = ( ID * ) ID -> ID ) 
if ( ID -> ID == ID && ID -> ID == ID && ID -> ID == ID && ID -> ID == ID ) { 
return ID ; 
} 
return ID ; 
} 
ID * ID :: ID ( ID ID , ID * ID , ID * ID ) { 
int ID = ID ( ID , ID , ID , ID ) ; 
ID * ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = ID :: ID [ ID ] ; 
ID :: ID [ ID ] = ( ID * ) ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
return ID ; 
} 
ID * ID :: ID ( ID * ID , ID ID , ID * ID ) { 
int ID = ID ( ID , ID -> ID , ID , ID -> ID , ID -> ID , ID ) ; 
for ( ID * ID = ( ID * ) ID :: ID [ ID ] ; 
ID != ID ; 
ID = ( ID * ) ID -> ID ) 
if ( ID -> ID == ID && ID -> ID == ID && ID -> ID == ID && ID -> ID == ID ) 
return ID ; 
return ID ; 
} 
ID * ID :: ID ( ID * ID , ID ID , ID * ID ) { 
int ID = ID ( ID , ID -> ID , ID , ID -> ID , ID -> ID , ID ) ; 
ID * ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = ID :: ID [ ID ] ; 
ID :: ID [ ID ] = ( ID * ) ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID . ID ( ID ) ; 
return ID ; 
} 
ID * ID :: ID ( ID * ID , ID * ID , ID * ID ) { 
int ID = ID ( ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID ) ; 
for ( ID * ID = ( ID * ) ID :: ID [ ID ] ; 
ID != ID ; 
ID = ( ID * ) ID -> ID ) 
if ( ID -> ID == ID && ID -> ID == ID && ID -> ID == ID && ID -> ID == ID ) 
return ID ; 
return ID ; 
} 
ID * ID :: ID ( ID * ID , ID * ID , ID * ID ) { 
int ID = ID ( ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID , ID -> ID ) ; 
ID * ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = ID :: ID [ ID ] ; 
ID :: ID [ ID ] = ( ID * ) ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID * ID = new ID ; 
ID -> ID = ( ID * ) ID ; 
ID -> ID = ID ; 
ID = ID ; 
return ID ; 
} 
ID * ID :: ID ( ) { 
ID = ID ; 
return ID == ID ? ID : ( ID * ) ID -> ID ; 
} 
ID * ID :: ID ( ) { 
if ( ID != ID ) 
ID = ID -> ID ; 
return ID == ID ? ID : ( ID * ) ID -> ID ; 
} 
ID * ID :: ID ( ) { 
ID = ID ; 
return ID == ID ? ID : ( ID * ) ID -> ID ; 
} 
ID * ID :: ID ( ) { 
if ( ID != ID ) 
ID = ID -> ID ; 
return ID == ID ? ID : ( ID * ) ID -> ID ; 
} 
ID * ID :: ID ( ) { 
ID = ID ; 
return ID == ID ? ID : ( ID * ) ID -> ID ; 
} 
ID * ID :: ID ( ) { 
if ( ID != ID ) 
ID = ID -> ID ; 
return ID == ID ? ID : ( ID * ) ID -> ID ; 
} 
ID ID :: ID ; 
int ID :: ID ; 
void ID ( ID * ID , const char * ID ) { 
if ( ID == ID ) 
* ID << STRING ; 
else 
while ( * ID != INTEGER ) { 
if ( * ID == STRING ) 
* ID << STRING ; 
* ID << * ID ++ ; 
} 
} 
void ID :: ID ( int ID , const char * * ID ) { 
int ID = ID ; 
if ( ID != INTEGER ) 
ID << 
STRING << ID << STRING << ID << STRING ; 
ID << STRING << ID << STRING ; 
ID ( & ID , ID [ ID ] ) ; 
ID << ( this -> ID == ID ? STRING : this -> ID == ID ? STRING : this -> ID == ID ? STRING : STRING ) << 
STRING << ID << STRING ; 
if ( ID != ID ) { 
ID ++ ; 
ID -> ID ( ID , ID ) ; 
} 
if ( ID != ID ) { 
ID ++ ; 
ID -> ID ( ID , ID ) ; 
} 
} 
void ID :: ID ( ) { 
for ( int ID = INTEGER ; ID < ID :: ID ; ID ++ ) { 
for ( ID * ID = ID :: ID [ ID ] ; ID != ID ; ID = ID -> ID ) 
switch ( ID -> ID ) { 
case ID : ( ( ID * ) ID ) -> ID = false ; break ; 
case ID : ( ( ID * ) ID ) -> ID = false ; break ; 
case ID : break ; 
case ID : break ; 
case ID : break ; 
case ID : break ; 
case ID : break ; 
default : ID << STRING << ID -> ID << STRING ; 
} 
} 
} 
void ID :: ID ( ) { 
for ( int ID = INTEGER ; ID < ID :: ID ; ID ++ ) { 
for ( ID * ID = ID :: ID [ ID ] ; ID != ID ; ID = ID -> ID ) 
if ( ID -> ID == ID ) { 
ID * ID = ( ID * ) ID ; 
if ( ! ID -> ID ) { 
} 
} 
} 
} 
enum ID { ID , ID , ID , ID , ID , ID } ; 
void ID ( struct ID * * ID , int ID , const char * * ID , enum ID * ID ) ; 
enum ID { ID , ID , ID , ID , ID , ID , ID } ; 
struct ID { ID ID ; struct ID * ID ; } ; 
struct ID { ID * ID ; ID * ID ; } ; 
class ID { 
public : 
ID ( ) { ID = ID = ID ; } ; 
static ID * ID ; 
static unsigned ID ; 
static unsigned ID ; 
static unsigned ID ; 
static struct ID * * ID ; 
struct ID * ID ; 
struct ID * ID ; 
ID ( unsigned ID , ID * ID , int ID ) { 
ID = ID ; 
ID = ID ; 
ID = INTEGER ; 
for ( int ID = INTEGER ; ID < ID ; ID ++ ) 
ID *= INTEGER ; 
ID = new ID * [ ID ] ; 
ID = ID - INTEGER ; 
ID ( ID , INTEGER , ID * sizeof ( ID * ) ) ; 
ID = ID = ID ; 
} 
unsigned ID ( ID ID , ID ID , ID ID , ID ID , ID * ID , ID * ID , ID * ID , ID * ID ) { 
return ( ID * ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID + 
( ID - ID ) * ID * ID * ID + 
( ID - ID ) * ID * ID + 
( ID - ID ) * ID + 
( ID - ID ) ) & ID ; 
} 
unsigned ID ( ID ID , ID ID , ID ID , ID * ID , ID * ID , ID * ID ) { 
return ( ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID + 
ID * ID * ID * ID + 
( ID - ID ) * ID * ID + 
( ID - ID ) * ID + 
( ID - ID ) ) & ID ; 
} 
unsigned ID ( ID ID , ID ID , ID * ID , ID * ID ) { 
return ( ID * ID * ID * ID + 
ID * ID * ID + 
( ID - ID ) * ID + 
( ID - ID ) ) & ID ; 
} 
unsigned ID ( ID ID , ID ID , ID * ID ) { 
return ( ID * ID * ID + 
ID * ID + 
( ID - ID ) ) & ID ; 
} 
bool ID ( ) ; 
void ID ( struct ID * ID ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ID ID , struct ID * ID , ID * ID , struct ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID ID , struct ID * ID , ID * ID , struct ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID * ID ) ; 
void ID ( ID * ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID ID , ID * ID ) ; 
void ID ( struct ID * ID ) ; 
struct ID * ID ( ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
void ID ( ) ; 
void ID ( ) ; 
int ID ( const char * ID , const char * ID , const char * ID , const char * ID , ID * ID , int ID , ID * ID , bool ID , double ID , const char * * ID , enum ID * ID ) ; 
void ID ( ) ; 
} ; 
enum ID { ID , ID , ID , ID , ID , ID } ; 
void ID ( struct ID * * ID , int ID , const char * * ID , enum ID * ID ) ; 
enum ID { ID , ID , ID , ID , ID , ID , ID } ; 
struct ID { ID ID ; struct ID * ID ; } ; 
struct ID { ID * ID ; ID * ID ; } ; 
class ID { 
public : 
ID ( ) { ID = ID = ID ; } ; 
static ID * ID ; 
static unsigned ID ; 
static unsigned ID ; 
static unsigned ID ; 
static struct ID * * ID ; 
struct ID * ID ; 
struct ID * ID ; 
ID ( unsigned ID , ID * ID , int ID ) { 
ID = ID ; 
ID = ID ; 
ID = INTEGER ; 
for ( int ID = INTEGER ; ID < ID ; ID ++ ) 
ID *= INTEGER ; 
ID = new ID * [ ID ] ; 
ID = ID - INTEGER ; 
ID ( ID , INTEGER , ID * sizeof ( ID * ) ) ; 
ID = ID = ID ; 
} 
unsigned ID ( ID ID , ID ID , ID ID , ID ID , ID * ID , ID * ID , ID * ID , ID * ID ) { 
return ( ID * ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID + 
( ID - ID ) * ID * ID * ID + 
( ID - ID ) * ID * ID + 
( ID - ID ) * ID + 
( ID - ID ) ) & ID ; 
} 
unsigned ID ( ID ID , ID ID , ID ID , ID * ID , ID * ID , ID * ID ) { 
return ( ID * ID * ID * ID * ID * ID + 
ID * ID * ID * ID * ID + 
ID * ID * ID * ID + 
( ID - ID ) * ID * ID + 
( ID - ID ) * ID + 
( ID - ID ) ) & ID ; 
} 
unsigned ID ( ID ID , ID ID , ID * ID , ID * ID ) { 
return ( ID * ID * ID * ID + 
ID * ID * ID + 
( ID - ID ) * ID + 
( ID - ID ) ) & ID ; 
} 
unsigned ID ( ID ID , ID ID , ID * ID ) { 
return ( ID * ID * ID + 
ID * ID + 
( ID - ID ) ) & ID ; 
} 
bool ID ( ) ; 
void ID ( struct ID * ID ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ID ID , struct ID * ID , ID * ID , struct ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID ID , struct ID * ID , ID * ID , struct ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID * ID ) ; 
void ID ( ID * ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID ID , ID * ID ) ; 
void ID ( struct ID * ID ) ; 
struct ID * ID ( ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ID * ID , ID * ID , ID * ID ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
struct ID * ID ( ) ; 
void ID ( ) ; 
void ID ( ) ; 
int ID ( const char * ID , const char * ID , const char * ID , const char * ID , ID * ID , int ID , ID * ID , bool ID , double ID , const char * * ID , enum ID * ID ) ; 
void ID ( ) ; 
} ; 
class ID { 
public : 
static ID ID ; 
static int ID ; 
ID ID ; 
enum ID ID ; 
ID * ID ; 
ID * ID ; 
ID ( ID ID ) { 
this -> ID = ID ; ID = ID = ID ; 
} ; 
ID ( ID ID , ID * ID ) { 
this -> ID = ID ; ID = ID ; 
ID * ID = ID -> ID ; 
if ( ID == ID ) 
ID -> ID = this ; 
else { 
while ( ID -> ID != ID ) 
ID = ID -> ID ; 
ID -> ID = this ; 
} 
ID = ID ; 
} ; 
void ID ( ) { 
ID << ID << STRING ; 
if ( ID != ID ) 
ID -> ID ( ) ; 
ID << STRING ; 
if ( ID != ID ) 
ID -> ID ( ) ; 
} ; 
void ID ( int ID , const char * * ID ) ; 
void ID ( const char * ID , const char * * ID ) { 
ID . ID ( ID ) ; 
ID << 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING ; 
ID = INTEGER ; 
this -> ID ( INTEGER , ID ) ; 
ID << STRING ; 
ID . ID ( ) ; 
} ; 
void ID ( ID * ID , const char * * ID ) { 
if ( ID == ID ) 
return ; 
if ( ID -> ID == ID ) 
ID << ID [ ID -> ID ] << STRING ; 
else { 
ID << STRING ; 
ID ( ID -> ID , ID ) ; 
ID << STRING ; 
} 
if ( ID -> ID != ID ) 
ID ( ID -> ID , ID ) ; 
} 
void ID ( const char * ID , ID * ID , const char * * ID ) { 
ID . ID ( ID ) ; 
ID ( ID , ID ) ; 
ID . ID ( ) ; 
} 
} ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID * ID ; int ID : INTEGER ; int ID : INTEGER ; ID ID ; ID ( ) { ID . ID = ID . ID = ID ; } ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID * ID ; ID ID ; ID * ID ; ID ID ; ID ID ; int ID : INTEGER ; } ; 
class ID { public : ID ID ; struct ID * ID ; struct ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID ID ; ID ID ; ID ( ) { ID . ID = ID . ID = ID . ID = ID . ID = ID ; } ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { public : ID ID ; struct ID * ID ; ID ID ; ID * ID ; ID * ID ; ID * ID ; } ; 
class ID { 
public : 
ID ID ; 
bool ID ; 
ID ID ; 
ID ID ; 
const char * ID ; 
const char * ID ; 
const char * ID ; 
const char * ID ; 
ID * ID ; 
int ID ; 
const char * * ID ; 
const char * * ID ; 
ID * ID ; 
ID * ID ; 
ID ID ; 
const char * * ID ; 
const char * * ID ; 
bool * ID ; 
bool * ID ; 
int ID ; 
enum ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
bool * ID ; 
bool * ID ; 
bool * ID ; 
bool * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
ID * ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
int ID ; 
ID * ID ( ID * ID ) ; 
ID * ID ( ID ID , ID * ID ) ; 
ID * ID ( ID ID , ID * ID , ID * ID ) ; 
ID * ID ( ID ID , ID ID , ID * ID ) ; 
ID * ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
void ID ( ID * ID , ID * ID , ID * ID ) ; 
void ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
bool ID ( ID ID , ID * ID , ID * ID , ID * ID ) ; 
ID * ID ( ID * ID , ID * ID , bool ID ) ; 
void ID ( ID * ID , int ID ) ; 
void ID ( ID * ID , ID * ID ) ; 
void ID ( ) ; 
void ID ( ID * ID ) ; 
void ID ( const char * ID , ID * ID , int * ID ) ; 
const char * ID ( const char * ID ) ; 
const char * ID ( const char * ID , const char * ID ) { 
const char * ID = ID ; 
while ( * ID != INTEGER && * ID == * ID ) { 
ID ++ ; 
ID ++ ; 
} 
if ( * ID == INTEGER ) 
return ID ; 
else 
return ID ; 
} 
const char ID ( const char ID ) { return ( ID >= ( const char ) STRING && ID <= ( const char ) STRING ) ? ( const char ) ( ID + INTEGER ) : ID ; } 
const char * ID ( const char * ID , const char * ID ) { 
const char * ID = ID ; 
while ( * ID != INTEGER && ID ( * ID ) == ID ( * ID ) ) { 
ID ++ ; 
ID ++ ; 
} 
if ( * ID == INTEGER ) 
return ID ; 
else 
return ID ; 
} 
bool ID ( const char * ID ) { 
ID = new ID [ ID ( ID ) + INTEGER ] ; 
ID = new const char * [ ID ( ID ) + INTEGER ] ; 
ID = new const char * [ ID ( ID ) + INTEGER ] ; 
const char * ID = ID ; 
ID = ID ; 
ID ID ; 
ID = ID ( ID ) ; 
while ( INTEGER ) { 
if ( * ID == INTEGER ) { 
* ID = ID ; 
ID = ID ; 
ID = ID - ID ; 
return true ; 
} 
int ID = INTEGER ; 
const char * ID ; 
for ( ID ID = ( ID ) INTEGER ; ID != ID ; ID = ( ID ) ( ( int ) ID + INTEGER ) ) { 
if ( ID [ ID ] ) 
ID = ID ( ID [ ID ] , ID ) ; 
else 
ID = ID ( ID [ ID ] , ID ) ; 
int ID = ID - ID ; 
if ( ID > ID ) { 
ID = ID ; 
ID = ID ; 
} 
} 
ID ( ID , & ID , & ID ) ; 
if ( ID == INTEGER ) { 
ID << STRING << ( ID - ID ) << STRING << ( int ) * ID << STRING << * ID << STRING ; 
* ID = ID ; 
ID = ID ; 
return false ; 
} 
ID [ ID - ID ] = ID ; 
ID += ID ; 
ID [ ID - ID ] = ID ; 
* ID ++ = ID ; 
if ( ID [ ID ] ) { 
ID = ID ( ID ) ; 
} 
} 
} 
const char * ID ( const char * ID ) { 
if ( ID ( * ID ) || * ID == STRING ) 
while ( ID ( * ID ) || * ID == STRING || * ID == STRING || * ID == STRING ) 
ID ++ ; 
return ID ; 
} 
bool ID ( const char * ID ) { 
return 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING ; 
} 
bool ID ( const char * ID ) { 
return 
* ID == STRING || * ID == STRING || * ID == STRING ; 
} 
bool ID ( const char * ID ) { 
return 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || * ID == STRING || 
* ID == STRING || * ID == STRING || * ID == STRING ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ID ( ID ) ) 
return ID ; 
ID ++ ; 
while ( ID ( ID ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ID ( ID ) ) 
return ID ; 
ID ++ ; 
while ( ID ( ID ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ID ( * ID ) || * ID == STRING ) 
while ( ID ( * ID ) || * ID == STRING ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
bool ID = ( * ID == STRING && ( * ( ID + INTEGER ) == STRING || * ( ID + INTEGER ) == STRING ) ) ; 
if ( ID ) ID += INTEGER ; 
while ( ( ID ? ID ( * ID ) : ID ( * ID ) ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ID ( * ID ) ) 
return ID ; 
while ( ID ( * ID ) ) 
ID ++ ; 
if ( * ID != STRING ) 
return ID ; 
ID ++ ; 
while ( ID ( * ID ) ) 
ID ++ ; 
if ( * ID == STRING || * ID == STRING ) { 
ID ++ ; 
while ( ID ( * ID ) ) 
ID ++ ; 
} 
return ID ; 
} 
const char * ID ( const char * ID ) { 
const char * ID = ID ; 
if ( * ID != STRING ) 
return ID ; 
ID ++ ; 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
if ( * ID != STRING ) 
return ID ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( * ID != STRING ) ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( * ID != STRING ) ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( * ID != STRING ) ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( ! ( ( * ID == STRING ) && ( * ( ID + INTEGER ) == STRING ) ) ) 
return ID ; 
do { 
if ( * ID == STRING ) 
ID ++ ; 
ID ++ ; 
} 
while ( ! ( ( * ID == STRING ) && ( * ( ID + INTEGER ) == STRING ) ) ) ; 
ID ++ ; 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID != STRING ) 
return ID ; 
if ( * ID != STRING ) { 
if ( * ( ID + INTEGER ) == STRING && ( * ( ID + INTEGER ) == STRING || * ( ID + INTEGER ) == STRING ) ) 
ID += INTEGER ; 
} 
else 
ID += INTEGER ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
while ( * ID != INTEGER && ( ID ( * ID ) ) ) 
ID ++ ; 
return ID ; 
} 
const char * ID ( const char * ID ) { 
int ID = INTEGER ; 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
while ( ID > INTEGER ) { 
if ( * ID == INTEGER ) 
break ; 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
ID ++ ; 
} 
else if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
ID -- ; 
} 
else 
ID ++ ; 
} 
} 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
while ( INTEGER ) { 
if ( * ID == INTEGER ) 
break ; 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) { 
ID += INTEGER ; 
break ; 
} 
ID ++ ; 
} 
} 
return ID ; 
} 
const char * ID ( const char * ID ) { 
if ( * ID == STRING && * ( ID + INTEGER ) == STRING ) 
while ( * ID != INTEGER && * ID != STRING ) 
ID ++ ; 
if ( * ID == STRING ) 
ID ++ ; 
return ID ; 
} 
void ID ( const char * const ID ) ; 
void ID ( ID ID ) ; 
void ID ( ) { 
ID = new ID ( INTEGER , ID , ID - ID ) ; 
ID = new ID ; 
ID = new ID ; 
ID = new ID ; 
ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID -> ID = ID -> ID = ID ; 
} 
void ID ( ) { 
ID = ID -> ID ( ) ; 
ID = ID -> ID ; 
ID = ID -> ID ; 
ID = ID -> ID ; 
ID = ID -> ID ; 
} 
void ID ( ) { 
ID = ID ( ) ; 
} 
void ID ( ) { 
ID = ID ( ) ; 
} 
void ID ( ) { 
if ( ID -> ID ( ID , ID , ID , ID , ID , ID , ID , ID , INTEGER , ID , ID ) < INTEGER ) 
ID ( ID , ID ) ; 
ID << STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID 
<< STRING << ID ; 
ID << STRING ; 
} 
void ID ( const char * ID ) { ID = ID ( ID ) ; } 
ID ( ) ; 
} ; 
class ID { 
class ID { 
public : 
unsigned long ID ; 
unsigned long ID ; 
ID * ID ; 
} ; 
ID * ID ; 
public : 
ID ( ) 
{ 
ID = new ID ; 
ID -> ID = ID -> ID = INTEGER ; 
ID -> ID = new ID ; 
ID -> ID -> ID = ID ; 
ID -> ID -> ID = INTEGER ; 
ID -> ID -> ID = ID ; 
} 
void ID ( unsigned long ID ) 
{ 
ID * ID = ID ; 
ID * ID ; 
ID * ID ; 
do 
{ 
if ( ID -> ID == ID ) 
{ 
ID -> ID ++ ; 
return ; 
} 
ID = ID ; 
ID = ID -> ID ; 
} 
while ( ID -> ID <= ID ) ; 
ID = new ID ; 
ID -> ID = ID ; 
ID -> ID = INTEGER ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
} 
void ID ( ) 
{ 
unsigned long ID = ID ( ) ; 
ID * ID = ID ; 
while ( ID -> ID != ID ) 
{ 
if ( ID -> ID != INTEGER ) 
ID << ID -> ID << STRING << ID -> ID << STRING << ( INTEGER * ID -> ID ) / ID << STRING ; 
ID = ID -> ID ; 
} 
} 
unsigned long ID ( unsigned long ID ) 
{ 
ID * ID = ID ; 
while ( ID -> ID != ID && ID -> ID != ID ) 
ID = ID -> ID ; 
return ID -> ID == ID ? ID -> ID : INTEGER ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
if ( ID -> ID != INTEGER ) 
ID ++ ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
ID ++ ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
ID += ID -> ID ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
unsigned long ID ( ) 
{ 
ID * ID = ID ; 
unsigned long ID = INTEGER ; 
while ( ID -> ID != ID ) 
{ 
ID += ID -> ID * ID -> ID ; 
ID = ID -> ID ; 
} 
return ID ; 
} 
} ; 
void ID :: ID ( ID ID ) { 
this -> ID = ID ; 
ID = ID -> ID ( ID , ID , ID ) ; 
ID = ID != ID ; 
} 
bool ID :: ID ( ID ID , ID * ID , ID * ID , ID * ID ) { 
ID ++ ; 
if ( ID -> ID ( ID , ID , ID , ID ) == ID ) { 
ID -> ID ( ID , ID , ID , ID ) ; 
return false ; 
} 
return true ; 
} 
void ID :: ID ( ID ID , ID * ID , ID * ID , ID * ID ) { 
ID ++ ; 
if ( ID -> ID ( ID , ID , ID , ID ) == ID ) { 
ID * ID = ID -> ID ( ID , ID , ID , ID ) ; 
ID -> ID ( ID ) ; 
} 
} 
void ID :: ID ( ID * ID , ID * ID , ID * ID ) { 
ID ++ ; 
if ( ID == ID ) { 
return ; 
} 
if ( ID -> ID . ID ( ID , ID ) == ID ) { 
ID -> ID . ID ( ID , ID ) ; 
} 
for ( ID * ID = ID -> ID . ID ( ) ; ID != ID ; ID = ID -> ID . ID ( ) ) { 
ID * ID = ID :: ID ( ID -> ID , ID -> ID , ID ) ; 
ID :: ID ( ID -> ID , ID -> ID , ID , ID ) ; 
} 
} 
ID * ID :: ID ( ID ID , ID * ID , ID * ID , ID * ID ) { 
ID ++ ; 
ID * ID ; 
if ( ( ID = ID -> ID ( ID , ID ) ) == ID ) { 
ID = ID -> ID ( ID , ID ) ; 
} 
if ( ID != ID && ID -> ID . ID ( ID , ID , ID ) == ID ) { 
ID -> ID . ID ( ID , ID , ID ) ; 
for ( ID * ID = ID -> ID . ID ( ) ; ID != ID ; ID = ID -> ID . ID ( ) ) { 
ID * ID = ID :: ID ( ID , ID , ID -> ID ) ; 
ID :: ID ( ID , ID , ID -> ID -> ID , ID ) ; 
} 
} 
return ID ; 
} 
ID * ID :: ID ( ID * ID ) { 
ID ++ ; 
ID * ID ; 
if ( ( ID = ID -> ID ( ID , ID , ID ) ) == ID ) { 
ID = ID -> ID ( ID , ID , ID ) ; 
} 
return ID ; 
} 
ID * ID :: ID ( ID ID , ID * ID ) { 
ID ++ ; 
ID * ID ; 
if ( ( ID = ID -> ID ( ID , ID , ID + INTEGER ) ) == ID ) { 
ID = ID -> ID ( ID , ID , ID + INTEGER ) ; 
} 
return ID ; 
} 
ID * ID :: ID ( ID ID , ID * ID , ID * ID ) { 
ID ++ ; 
if ( ID [ ID ] ) { 
return ID ; 
} 
ID * ID ; 
ID * ID = ( ID == ID ? ID -> ID : ID -> ID ) ; 
ID ID ; 
if ( ID [ ID ] ) 
ID = ID [ ID ] ? ID [ ID ] : ID [ ID ] ; 
else { 
ID = ID [ ID ] ? ID [ ID ] : ID [ ID ] ; 
} 
if ( ( ID = ID -> ID ( ID , ID , ID -> ID ) ) == ID ) { 
ID = ID -> ID ( ID , ID , ID -> ID ) ; 
} 
if ( ID -> ID . ID ( ID , ID , ID -> ID ) == ID ) { 
ID * ID = ID -> ID . ID ( ID , ID , ID -> ID ) ; 
ID -> ID = ID -> ID ; 
ID -> ID = ID -> ID ; 
} 
return ID ; 
} 
ID * ID :: ID ( ID ID , ID ID , ID * ID ) { 
ID ++ ; 
ID * ID ; 
if ( ( ID = ID -> ID ( ID , ID , ID ) ) == ID ) { 
ID = ID -> ID ( ID , ID , ID ) ; 
} 
if ( ID -> ID . ID ( ID , ID , ID ) == ID ) { 
ID * ID = ID -> ID . ID ( ID , ID , ID ) ; 
ID -> ID = ID ; 
ID -> ID = ID ; 
ID ( ID ) ; 
} 
return ID ; 
} 
void ID :: ID ( ID * ID ) { 
int ID = INTEGER ; 
if ( ID == ID ) 
return ; 
if ( ID -> ID ) 
return ; 
ID -> ID = true ; 
for ( ID * ID = ID -> ID . ID ( ) ; ID != ID ; ID = ID -> ID . ID ( ) ) { 
ID -> ID = true ; 
ID ++ ; 
if ( ID -> ID != ID ) 
ID ( ID -> ID ( ID -> ID , ID -> ID , ID -> ID ) ) ; 
if ( ID -> ID != ID ) 
ID ( ID -> ID ( ID -> ID , ID -> ID , ID -> ID ) ) ; 
} 
if ( ID > INTEGER ) { 
ID -> ID = true ; 
ID ++ ; 
} 
} 
void ID :: ID ( ) { 
ID = INTEGER ; 
ID ( ID ) ; 
} 
ID ID ; 
int ID ; 
void ID :: ID ( ID * ID , int ID ) { 
if ( ID == ID ) 
return ; 
if ( ID -> ID ) 
return ; 
ID -> ID = true ; 
int ID = INTEGER ; 
for ( ID * ID = ID -> ID . ID ( ) ; ID != ID ; ID = ID -> ID . ID ( ) ) 
ID ++ ; 
ID << STRING << 
ID [ ID -> ID ] << STRING << 
ID [ ID -> ID ] << 
STRING << 
( ID -> ID - ID ) << 
STRING << 
( ID -> ID - ID ) << STRING << 
( ID [ ID -> ID ] == ID ? STRING : STRING ) << 
STRING << ID << STRING << ++ ID << ( ID > INTEGER ? STRING : STRING ) << STRING ; 
for ( ID * ID = ID -> ID . ID ( ) ; ID != ID ; ID = ID -> ID . ID ( ) ) { 
ID << STRING << 
ID [ ID -> ID -> ID ] << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
ID [ ID -> ID ] << 
STRING << 
( ID -> ID - ID ) << 
STRING << 
ID [ ID -> ID ] << 
( ID [ ID -> ID ] == ID ? STRING : ID [ ID -> ID ] == ID ? STRING : ID [ ID -> ID ] == ID ? STRING : STRING ) << 
STRING << 
( ID -> ID - ID ) << 
STRING << ( ID + INTEGER ) << STRING << ++ ID << ( ID > INTEGER ? STRING : STRING ) 
<< ( ID [ ID -> ID -> ID ] == ID ? STRING : STRING ) 
<< STRING << 
STRING << 
ID [ ID -> ID ] << STRING << 
ID [ ID -> ID -> ID ] << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
ID [ ID -> ID -> ID ] << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
ID [ ID -> ID ] << 
STRING << 
( ID -> ID - ID ) << 
STRING ; 
ID -> ID = true ; 
if ( ID -> ID != ID ) { 
ID << 
STRING << 
ID [ ID -> ID -> ID ] << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
ID [ ID -> ID ] << 
STRING << 
( ID -> ID - ID ) << 
STRING << 
ID [ ID -> ID ] << STRING << 
ID [ ID -> ID ] << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
( ID -> ID - ID ) << 
STRING ; 
ID ( ID -> ID ( ID -> ID , ID -> ID , ID -> ID ) , ID + INTEGER ) ; 
} 
if ( ID -> ID != ID ) { 
ID << 
STRING << 
ID [ ID -> ID -> ID ] << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING << 
ID [ ID -> ID ] << 
STRING << 
( ID -> ID - ID ) << 
STRING << 
ID [ ID -> ID ] << STRING << 
ID [ ID -> ID ] << 
STRING << 
( ID -> ID - ID ) << 
STRING << 
( ID -> ID -> ID - ID ) << 
STRING ; 
ID ( ID -> ID ( ID -> ID , ID -> ID , ID -> ID ) , ID + INTEGER ) ; 
} 
} 
} 
void ID :: ID ( ID * ID , ID * ID ) { 
ID -> ID ( ) ; 
ID . ID ( STRING ) ; 
ID << 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING 
STRING ; 
ID = INTEGER ; 
ID ( ID , INTEGER ) ; 
ID -> ID ( ) ; 
ID << STRING ; 
ID . ID ( ) ; 
} 
ID * ID :: ID ( ID * ID , ID * ID , bool ID ) { 
ID * ID ; 
ID * ID = ID ; 
ID * ID = ID ; 
if ( ID == ID ) 
return ID ; 
if ( ID -> ID ) 
return ID ; 
if ( ID == ID ) 
ID = new ID ( ID -> ID ) ; 
else 
ID = new ID ( ID -> ID , ID ) ; 
int ID = INTEGER ; 
ID -> ID = true ; 
for ( ID * ID = ID -> ID . ID ( ) ; ID != ID ; ID = ID -> ID . ID ( ) ) { 
ID ++ ; 
ID -> ID = ID > INTEGER ; 
if ( ( ID -> ID != ID && ID -> ID ( ID -> ID , ID -> ID , ID -> ID ) -> ID ) || 
( ID -> ID != ID && ID -> ID ( ID -> ID , ID -> ID , ID -> ID ) -> ID ) ) 
continue ; 
if ( ID -> ID >= ID ) { 
ID = ID ; 
ID = ID -> ID ; 
} 
} 
if ( ID != ID ) { 
ID -> ID = true ; 
if ( ID -> ID != ID ) 
ID ( ID -> ID ( ID -> ID , ID -> ID , ID -> ID ) , ID , ID ) ; 
if ( ID -> ID != ID ) 
ID ( ID -> ID ( ID -> ID , ID -> ID , ID -> ID ) , ID , ID ) ; 
} 
return ID ; 
}  
$


